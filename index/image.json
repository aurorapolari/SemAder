[
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "check cache first and display the image",
            "cache the image",
            "clean up the image data"
        ],
        "FuncName": "DkImageContainer_3273 imageScaledToWidth.txt"
    },
    {
        "Branch": [
            "If condition met, display image"
        ],
        "Loop": [
            "Loop condition met, display image"
        ],
        "Normal": [
            "docWidget - 0, folderView - 1, displaying image"
        ],
        "FuncName": "centralwidget_3124 CentralWidget.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "always keep in mind that a file does not exist, and it's not an image"
        ],
        "FuncName": "DkImageContainer_3273 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The QOI image format expects nChannels to be either 3 for RGB data or 4 for RGBA. The image format supports color channels with values ranging from 0 to 255."
        ],
        "FuncName": "QoiImageSaver_6831 save.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check for the channels and add them to the chanMap",
            "Return a list of indices of activated channels in ChannelPacket"
        ],
        "FuncName": "softimage_pvt_3595 channels.txt"
    },
    {
        "Branch": [
            " Check if we're running on a little endian processor and read image file header"
        ],
        "Loop": [
            ""
        ],
        "Normal": [
            " Check if we're running on a little endian processor"
        ],
        "FuncName": "softimage_pvt_3595 read_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "deliver image when loaded"
        ],
        "FuncName": "DkImageContainer_3273 imageLoaded.txt"
    },
    {
        "Branch": [
            "our file watcher with image update timer"
        ],
        "Loop": [
            "our file watcher with image update timer loop"
        ],
        "Normal": [
            "our file watcher with image update timer"
        ],
        "FuncName": "DkImageContainer_3273 DkImageContainerT.txt"
    },
    {
        "Branch": [
            "Set image container editability based on image code"
        ],
        "Loop": [],
        "Normal": [
            " TODO this shouldn't be used without notifying the user see issue 799. Image container editability is currently set to false."
        ],
        "FuncName": "DkImageContainer_3273 setEdited.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Add edit history entry with explicitly edited metadata and implicitly modified image, including image metadata such as resolution and format.",
            "how about a signal with image processing techniques such as filtering and enhancement."
        ],
        "FuncName": "DkImageContainer_3273 setMetaData.txt"
    },
    {
        "Branch": [
            "image condition: if image exists",
            "image condition: if image does not exist"
        ],
        "Loop": [
            "image loop: loop through all images",
            "image loop: loop through all images with specific condition"
        ],
        "Normal": [
            "image metadata: add edit history entry with explicitly edited metadata and implicitly modified image",
            "image signal: how about a signal"
        ],
        "FuncName": "DkImageContainer_3273 setMetaData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "For now, just PSDs are not cached because their file might be way larger than the part we need to read, and image data is read from the specified file path into a buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageContainer_3273 loadFileToBuffer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do not update edited files. If the image is updated, it will be refreshed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if an image exists, do not perform this action. Instead, check for updates.",
            "we utilize our own file watcher, as the qt watcher employs locks to check for updates, which may be more accurate but are quite complex.",
            "if the user attempts to delete the file while it is being watched in nomacs, it may lead to unexpected behavior.",
            "the qt watcher's use of locks to check for updates might be more accurate, but they are quite complex and can cause issues.",
            "if the user wants to delete the file while it is being watched in nomacs, it may cause problems."
        ],
        "FuncName": "DkImageContainer_3273 checkForFileUpdates.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO this shouldn't be used without notifying the user see issue 799, image metadata is stored"
        ],
        "FuncName": "DkImageContainer_3273 saveMetaDataIntern.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "selected do not connect twice, image updated successfully"
        ],
        "FuncName": "DkImageContainer_3273 receiveUpdates.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO this shouldn't be used without notifying the user, see issue #799. This is a metadata description for an image."
        ],
        "FuncName": "DkImageContainer_3273 saveMetaDataIntern.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "force a reload and update image container status"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageContainer_3273 savingFinished.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Loading PSD images to buffer as they are large files, loading only required parts."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageContainer_3273 loadFileToBuffer.txt"
    },
    {
        "Branch": [
            " evaluate the condition of if statement in image code"
        ],
        "Loop": [
            " check the condition of loop in image code"
        ],
        "Normal": [
            " ensure the requires clause is not violated in image code",
            " allow the normalizer to learn the mean and standard deviation of image samples"
        ],
        "FuncName": "auto_2173 auto_train_rbf_classifier.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: SIMD-enabled if condition"
        ],
        "Loop": [
            "Loop-Condition-Str: SIMD-enabled loop condition"
        ],
        "Normal": [
            " clang-format off",
            " if (OIIO_POPCOUNT_ENABLED)   caps.emplace_back (popcnt);",
            " Description: SIMD instructions are enabled for popcount capability.",
            " clang-format on"
        ],
        "FuncName": "imageio_76 oiio_simd_caps.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO write an error message",
                    "filter out high frequency components"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "get properties",
            "perform frequency filtering"
        ],
        "FuncName": "IPLFrequencyFilter_5631 processInputData.txt"
    },
    {
        "Branch": [
            "if (condition)"
        ],
        "Loop": [
            "while (condition)"
        ],
        "Normal": [
            "nothing to do",
            "image processing"
        ],
        "FuncName": "imageio_76 premult.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Which iteration of the pattern? In image processing, this refers to the repetition of a pattern in a digital image."
        ],
        "FuncName": "imageio_76 wrap_mirror.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Coordinate normalization within a cycle range. Shortcut periodic if we're sure it's a power of 2"
        ],
        "FuncName": "imageio_76 wrap_periodic_pow2.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case: pixels within each row are contiguous, converting each scanline as a single unit, which is efficient when copying all channels from source to destination, and the formats are identical.",
                    "Be efficient by converting each scanline as a single unit.",
                    "Converting each scanline as a single unit is efficient when copying all channels, and the formats are identical.",
                    "Converting each scanline as a single unit is efficient when copying all channels, and the formats are identical."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If no format conversion is taking place, use the simplified copy_image, which is efficient when copying all channels from source to destination, and the formats are identical."
        ],
        "FuncName": "imageio_76 convert_image.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case: pixels within each row are contiguous",
                    "in both src and dst and we're copying all channels.",
                    "Be efficient by converting each scanline as a single",
                    "unit.",
                    "This involves copying a depth layer high image with a",
                    "width of width and height of height, and n channels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageio_76 copy_image.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Optimize for contiguous scanlines but not from scanline to scanline",
                    "Image type: optimizing for contiguous storage of scanlines"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageio_76 _contiguize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << resize gradient: << event->size(); Adjusting gradient size to match image dimensions."
        ],
        "FuncName": "DkToolbars_9985 resizeEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note that sliderWidth should be odd in order to get a pretty rendered slider. This is a code snippet for image rendering, where sliderWidth is a critical parameter that determines the appearance of the image. "
        ],
        "FuncName": "DkToolbars_9985 DkGradient.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculates the normalized position of the slider within the widget's width.",
            "return (qreal)(pos) / (qreal)(width() - sliderWidth);"
        ],
        "FuncName": "DkToolbars_9985 DkColorSlider.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "right align search filters for images",
            "addWidget(quickFilterEdit); with image filtering capabilities"
        ],
        "FuncName": "DkToolbars_9985 allActionsAdded.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pass the actual position to the Gradient: The Gradient is a visual effect that changes color as the mouse moves over it, created using a linear or radial gradient. The color transition is smooth and gradual, giving a sense of depth and dimensionality to the image."
        ],
        "FuncName": "DkToolbars_9985 mouseMoveEvent.txt"
    },
    {
        "Branch": [
            "Which iteration of the pattern? (Image: Conditional Statement)"
        ],
        "Loop": [
            "Which iteration of the pattern? (Image: Loop Condition)"
        ],
        "Normal": [
            "Which iteration of the pattern? (Image: Iteration)"
        ],
        "FuncName": "DkToolbars_9985 DkMainToolBar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "reset adds a slider at the start and end of the linear gradient"
        ],
        "FuncName": "DkToolbars_9985 setGradient.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Draw the filled triangle at the top of the slider: This is an image code.",
            "Draw the empty triangle at the top of the slider: This is also an image code."
        ],
        "FuncName": "DkToolbars_9985 paintEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "At this point the checkbox is disabled, hence enable it... This action involves the image of a checkbox being enabled."
        ],
        "FuncName": "DkToolbars_9985 enableTFCheckBoxClicked.txt"
    },
    {
        "Branch": [
            "on mouse up"
        ],
        "Loop": [
            "on mouse up"
        ],
        "Normal": [
            "on mouse up"
        ],
        "FuncName": "DkToolbars_9985 mouseReleaseEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << resize gradient:  << event->size(); Adjusting toolbar size."
        ],
        "FuncName": "DkToolbars_9985 resizeEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "user needs to decide... with a visual representation of a decision tree",
            "this->setIconSize(QSize(DkSettingsManager::param().effectiveIconSize(), DkSettingsManager::param().effectiveIconSize())); with an icon of a settings gear",
            "toolBarActions[toolbar_reset]->setToolTip(was geht?); with a tooltip of a question mark over a reset button"
        ],
        "FuncName": "DkToolbars_9985 createIcons.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "At first, verify if the current image mode is valid. If it is, proceed with enabling the tool bar and emitting a channel changed signal.",
            "if (mImageMode != mode_invalid_format) {",
            "enableToolBar(true);",
            "emit channelChanged(0);",
            "}"
        ],
        "FuncName": "DkToolbars_9985 applyImageMode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " user needs to decide... Image toolbar icon is displayed.",
            " this->setIconSize(QSize(DkSettingsManager::param().effectiveIconSize(), DkSettingsManager::param().effectiveIconSize())); Image icon size is set to effective icon size.",
            " toolBarActions[toolbar_reset]->setToolTip(was geht?); Image toolbar reset button tooltip is set."
        ],
        "FuncName": "DkToolbars_9985 createIcons.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "add actions with image icon",
            "view image",
            "edit image",
            "view image"
        ],
        "FuncName": "DkToolbars_9985 createDefaultToolBar.txt"
    },
    {
        "Branch": [
            "Add conditional toolbar based on image filter"
        ],
        "Loop": [
            "Add looped toolbar based on image threshold"
        ],
        "Normal": [
            "Add toolbar below all previous toolbars with image preview"
        ],
        "FuncName": "DkToolbars_9985 createTransferToolBar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " grab the single colour from the given colour data",
            " initialise the best error in image processing"
        ],
        "FuncName": "singlecolourfit_6677 SingleColourFit.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " user defined  do nothing, aspect ratio settings are also updated",
            " no aspect ratio  clear boxes, image scaling is also affected"
        ],
        "FuncName": "DkToolbars_9985 onRatioBoxCurrentIndexChanged.txt"
    },
    {
        "Branch": [
            "Set background color for if condition in image code",
            "Use background color to highlight if condition in image"
        ],
        "Loop": [
            "Set background color for loop condition in image code",
            "Use background color to highlight loop condition in image"
        ],
        "Normal": [
            "Set background color to avoid frustrated users",
            "Use background color to improve user experience"
        ],
        "FuncName": "DkToolbars_9985 onBgColButtonClicked.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "set movie toolbar into current toolbar",
            "display movie toolbar"
        ],
        "FuncName": "DkToolbars_9985 showMovieToolBar.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "re-map the indices",
                    "save the block",
                    "save the error",
                    "image processing: re-mapping indices for image analysis"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "image processing: iterating through image data",
            "image processing: finding optimal end-points for image analysis"
        ],
        "Normal": [
            "image processing: building table of lookups for image data",
            "image processing: finding best end-points and indexing for image analysis",
            "image processing: building block for image data if optimal end-points found"
        ],
        "FuncName": "singlecolourfit_6677 Compress3.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remap the indices",
                    "save the best block and minimum error",
                    "save the best block and minimum error"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "build the table of lookups",
            "find the best end-points and index",
            "build the block if we win"
        ],
        "FuncName": "singlecolourfit_6677 Compress4.txt"
    },
    {
        "Branch": [
            "Alpha image encoded as 2-bit image."
        ],
        "Loop": [
            {
                "loopstr": [
                    "White, with 0 alpha, encoded as 2-bit image.",
                    "White with full alpha, encoded as 2-bit image."
                ]
            }
        ],
        "Normal": [
            "Blocks in each dimension, with 2-bit image encoding."
        ],
        "FuncName": "PvrTcEncoder_9888 EncodeAlpha2Bpp.txt"
    },
    {
        "Branch": [
            "PVRTC compression for RGB 4BPP bitmaps"
        ],
        "Loop": [
            {
                "loopstr": [
                    "PVRTC uses weightings of 0, 3/8, 5/8 and 1",
                    "The boundaries for these are 3/16, 1/2 (=8/16), 13/16",
                    "This is a specific image compression technique"
                ]
            }
        ],
        "Normal": [
            "PVRTC is used for image compression"
        ],
        "FuncName": "PvrTcEncoder_9888 EncodeRgb4Bpp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "PVRTC uses weightings of 0, 3/8, 5/8 and 1. This is a key characteristic of PVRTC compression for RGB images.",
                    "The boundaries for these are 3/16, 1/2 (=8/16), 13/16. These values are crucial for the compression process."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "PvrTcEncoder_9888 EncodeRgb4Bpp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "White, with 0 alpha, encoded in PvrTcPacket format",
                    "White with full alpha, encoded in PvrTcPacket format"
                ]
            }
        ],
        "Normal": [
            "Blocks in each dimension, with 4 Bpp Bitmap encoded in PvrTcPacket"
        ],
        "FuncName": "PvrTcEncoder_9888 EncodeAlpha4Bpp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "PVRTC uses weightings of 0, 3/8, 5/8 and 1. This is a characteristic of PVRTC-encoded RGBA color images.",
                    "The boundaries for these are 3/16, 1/2 (=8/16), 13/16. These boundaries are crucial for the PVRTC encoding process."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "PvrTcEncoder_9888 EncodeRgba4Bpp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Component ID encoding ",
                    "H, V sampling factors ",
                    "Compression table number "
                ]
            }
        ],
        "Normal": [
            "Normal parameter length count ",
            "JPEG image is %uw * %uh, %d color components, %d bits sampling\\n",
            "JPEG process: %s\\n"
        ],
        "FuncName": "rdjpgcom_5816 process_SOFn.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "process.setProcessChannelMode(QProcess::ForwardedChannels); Set the wallpaper to the image code: <image>QPixmap(\"path/to/image.jpg\")</image>."
        ],
        "FuncName": "wallpapersetter_8708 setWallpaper.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "not a valid file name, please enter a valid file name",
                    "please advance to the next option by pressing -"
                ]
            }
        ],
        "Normal": [
            "On Mac, please fetch a command line tool that allows you to read JPEG headers.",
            "in case the C library doesn't provide this functionality, you may need to install a third-party library.",
            "Please parse any command line switches or options provided.",
            "Open the input file using the appropriate file path.",
            "On Unix-based systems, please enter a single file name or no file name at all.",
            "Scan the JPEG headers to ensure the file is a valid JPEG image.",
            "Once complete, you will see a success message indicating that all done.",
            "To suppress any warnings about return values, you can use the appropriate flag or option."
        ],
        "FuncName": "rdjpgcom_5816 main.txt"
    },
    {
        "Branch": [
            "If the device supports the specified image format, then"
        ],
        "Loop": [
            "For each image format supported by the device"
        ],
        "Normal": [
            "The device supports writing image files."
        ],
        "FuncName": "qpsdplugin_4061 capabilities.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find 0xFF byte; count and skip any non-FFs.",
            "Get marker code byte, swallowing any duplicate FF bytes. Extra FFs* are legal as pad bytes, so don't count them in discarded_bytes.",
            "This is a JPEG marker code: FF C0 (Start of Image)"
        ],
        "FuncName": "rdjpgcom_5816 next_marker.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "APP12 contains: JPEG file header, which includes the image type and compression method."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Expect SOI (Start of Image) at start of file ",
            " Scan miscellaneous markers until we reach SOS (Start of Scan), which indicates the start of the image data. ",
            " end loop "
        ],
        "FuncName": "rdjpgcom_5816 scan_JPEG_header.txt"
    },
    {
        "Branch": [
            "Check if image exists"
        ],
        "Loop": [
            "Loop through each image"
        ],
        "Normal": [
            " make sure it's non destructive and the image is clear"
        ],
        "FuncName": "strutil_test_6183 test_case.txt"
    },
    {
        "Branch": [
            "Test if condition formatting with image code"
        ],
        "Loop": [
            "Test loop condition formatting with image code"
        ],
        "Normal": [
            "Test custom formatting of spans with image code"
        ],
        "FuncName": "strutil_test_6183 test_format_custom.txt"
    },
    {
        "Branch": [
            "Test if condition with image type"
        ],
        "Loop": [
            "Test loop condition with image type"
        ],
        "Normal": [
            "Test windows long filename syntax with image description"
        ],
        "FuncName": "strutil_test_6183 test_get_rest_arguments.txt"
    },
    {
        "Branch": [
            "This is a conditional statement for image processing. It will check if the image meets certain conditions before proceeding."
        ],
        "Loop": [
            "This is a loop condition for image processing. It will iterate over the image data to perform specific tasks."
        ],
        "Normal": [
            "NOSONAR",
            "This is a normal string for image processing. It will be used as a placeholder or a default value."
        ],
        "FuncName": "strutil_test_6183 test_comparisons.txt"
    },
    {
        "Branch": [
            "This string will test if the join function can handle conditional statements with image codes."
        ],
        "Loop": [
            "This string will test if the join function can handle loop conditions with image codes."
        ],
        "Normal": [
            "Test join's len parameter. This string will be enhanced with image type description. It will test the functionality of the join function with different types of data and lengths, including image codes."
        ],
        "FuncName": "strutil_test_6183 test_join.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Test formatting with Strutil::sprintf() for image processing.",
            "---------------------------------------",
            "Test formatting with Strutil::fmt::format(), which uses the Python conventions for image formatting:"
        ],
        "FuncName": "strutil_test_6183 test_format.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "An empty string hashes to 0 in image processing, where it represents a grayscale value of 0.",
            "In image analysis, checking the hash of a longer image ensures that it is indeed a constexpr, meaning its value is known at compile-time, which is crucial for optimizing image processing tasks."
        ],
        "FuncName": "strutil_test_6183 test_hash.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no eating, image description: a person eating"
        ],
        "FuncName": "strutil_test_6183 test_parse.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make sure that the vector-returning version works with image processing algorithms that extract features from images."
        ],
        "FuncName": "strutil_test_6183 test_extract.txt"
    },
    {
        "Branch": [
            "Check if locale is set to English"
        ],
        "Loop": [
            "Loop through locale settings"
        ],
        "Normal": [
            "save original locale",
            "Locale settings include image formats like JPEG and PNG"
        ],
        "FuncName": "strutil_test_6183 test_locale.txt"
    },
    {
        "Branch": [
            "image code: if condition",
            "image code: if condition with nul embedded in the string",
            "image code: if condition with long string",
            "image code: if condition with empty string"
        ],
        "Loop": [
            "image code: loop condition",
            "image code: loop condition with nul embedded in the string",
            "image code: loop condition with long string",
            "image code: loop condition with empty string"
        ],
        "Normal": [
            "image code: expected",
            "image code: nul embedded in the string",
            "image code: long string",
            "image code: empty string"
        ],
        "FuncName": "strutil_test_6183 test_safe_strlen.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "No time, including invalid date and time formats such as 2022-02-30 24:00:00 and 2022-02-30",
            "Out of range values, including dates before 1970-01-01 and after 2038-01-19"
        ],
        "FuncName": "strutil_test_6183 test_datetime.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Hexadecimal stream %s printf %s Strutil::sprintf %s\n"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Hexadecimal\n"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "For every possible float value, test that printf(.9g), which",
            "we are sure preserves full precision as text, exactly matches",
            "Strutil::sprintf(.9g) and also matches stream output with",
            "precision(9).  VERY EXPENSIVE!  Takes tens of minutes to run.",
            "Don't do this unless you really need to test it."
        ],
        "FuncName": "strutil_test_6183 test_float_formatting.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "force resize selection area with an image width of 16:9"
        ],
        "FuncName": "cropoverlay_4251 setAspectRatio.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "shift relative to (0,0) and scale to image size",
            "bound to image size with image drawing rectangle"
        ],
        "FuncName": "cropoverlay_4251 mapPointToImage.txt"
    },
    {
        "Branch": [
            "Create a floating UI element using a constructor, initialize properties and styles."
        ],
        "Loop": [],
        "Normal": [
            "tmp for testing with image-related description: This is a temporary string for testing purposes, related to image processing."
        ],
        "FuncName": "cropoverlay_4251 CropOverlay.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "resize image",
            "flip image if needed",
            "crop selection to ensure it's within image bounds"
        ],
        "FuncName": "cropoverlay_4251 resizeSelectionFree.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "draw handles if there is no interaction going on and selection is large enough",
                    "and selection is large enough",
                    "image region and selection area will be drawn"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "cropoverlay_4251 paintEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "user just clicked without moving the mouse clear, mouse button released, clearing selection area and updating mouse status."
        ],
        "FuncName": "cropoverlay_4251 mouseReleaseEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "determine direction and update selection area size and position based on mouse movement"
        ],
        "FuncName": "cropoverlay_4251 mouseMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "JustQtThings int QRect::bottom() const Note that for historical reasons this function returns top() + height() - 1; use y() + height() to retrieve the true y-coordinate. same for QRect::right(). This function is used to adjust the size and proportion of the selection area."
        ],
        "FuncName": "cropoverlay_4251 resizeSelectionAR.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "start selection!",
                    "Left mouse button click event handled."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "move to hovertarget",
                    "Right mouse button click event handled."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "cropoverlay_4251 mousePressEvent.txt"
    },
    {
        "Branch": [
            "If statement in Verilog code: conditional logic based on image"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop condition in Verilog code: iterative logic based on image",
                    "get rid of string parsing"
                ]
            }
        ],
        "Normal": [
            "Normal statement in Verilog code: sequential logic based on image",
            "interpret the verilog backwards and process it"
        ],
        "FuncName": "zohtwo_7714 write_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u9ad8\u4f4d\u4f4d\u662f\u8bbe\u7f6e\uff0c\u4ea4\u6362\u8be5\u533a\u57df\u7684\u7aef\u70b9\u548c\u7d22\u5f15",
                    "\u8be5\u64cd\u4f5c\u4e0e[image]\u7c7b\u578b\u7684\u76f8\u5173\u63cf\u8ff0"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u53cc\u91cd\u68c0\u67e5\u8868",
                    "\u8be5\u64cd\u4f5c\u6d89\u53ca[image]\u7c7b\u578b\u7684\u76f8\u5173\u63cf\u8ff0"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zohtwo_7714 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale endpoints with color",
            "really need a IntVector3 for color mapping",
            "interpolate between color values",
            "interpolate between color values",
            "interpolate between color values"
        ],
        "FuncName": "zohtwo_7714 generate_palette_quantized.txt"
    },
    {
        "Branch": [
            "assign index value to image block"
        ],
        "Loop": [
            "assign index value to image block"
        ],
        "Normal": [
            "build list of possibles",
            "assign index value to image block"
        ],
        "FuncName": "zohtwo_7714 assign_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "if this was an improvement, move the endpoint and continue search from there, considering image processing techniques such as thresholding, edge detection, and image segmentation to refine the search"
                ]
            }
        ],
        "Normal": [
            "we have the old endpoints: old_endpts, which can be used as a reference for image analysis",
            "we have the perturbed endpoints: new_endpts, which can be used to simulate image noise and distortions",
            "we have the temporary endpoints: temp_endpts, which can be used as a buffer for image processing operations",
            "start with the best current error, and then apply image filtering techniques such as Gaussian blur and median filter to refine the search",
            "copy real endpoints so we can perturb them, and then apply image transformations such as rotation and scaling to explore different perspectives",
            "do a logarithmic search for the best error for this endpoint (which) can be achieved by applying image compression techniques such as JPEG and PNG"
        ],
        "FuncName": "zohtwo_7714 perturb_one.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved mode, return all zeroes",
                    "\u89e3\u538b\u7f29\u4e8c\u7ef4\u56fe\u5757\u6570\u636e: reserved mode, return all zeroes"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "lookup",
            "\u89e3\u538b\u7f29\u4e8c\u7ef4\u56fe\u5757\u6570\u636e: lookup"
        ],
        "FuncName": "zohtwo_7714 decompresstwo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "collect the mse values that are within 5% of the best values optimize each one and choose the best image with the lowest mse",
            "hack for now -- just use the best image WORK"
        ],
        "FuncName": "zohtwo_7714 compresstwo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "CIE delta E test with modifications",
                    "ramp down the color test in scotopic regions",
                    "diff in A",
                    "diff in B",
                    "max difference in colorimetric data between two images"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "result.maxz = z;",
                    "maximum intensity difference between two images"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "pure luminance test",
                    "test for luminance differences between two images"
                ]
            }
        ],
        "Normal": [
            "maximum value of 3 color channels",
            "converting colorspaces from Adobe RGB (1998) to LAB",
            "copying and converting up to 3 color channels to float",
            "constructing LAB and luminance images from XYZ data",
            "LAB image contains XYZ data",
            "luminance image contains XYZ data",
            "constructing Gaussian pyramids of blurred images"
        ],
        "FuncName": "imagebufalgo_yee_7210 compare_Yee.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "handle simple cases",
                    "project each pixel value along the principal direction",
                    "choose as endpoints the minimum and maximum projection points along the principal direction",
                    "clamp endpoints",
                    "the argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best",
                    "shape based on endpoints being clamped, which is related to image processing techniques such as image segmentation and feature extraction"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zohtwo_7714 roughtwo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "returns the threshold luminance given the adaptation luminance. This is a fundamental concept in image processing, where the threshold luminance is used to separate objects from the background.",
            "units are candelas per meter squared, which is a unit of luminance commonly used in photography and image analysis."
        ],
        "FuncName": "imagebufalgo_yee_7210 tvi.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "precisions for all channels need to be the same. Image processing requires consistent precision to avoid errors and ensure accurate results."
                ]
            }
        ],
        "Normal": [
            "throw No candidate found, should never happen (refinetwo). Image analysis failed to find a suitable candidate, indicating a potential issue with the image processing algorithm."
        ],
        "FuncName": "zohtwo_7714 refinetwo.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "NOSONAR",
                    "Converts XYZ color space RGB values to LAB color space RGB values.",
                    "powf(ri, 1.0f / 3.0f);"
                ]
            }
        ],
        "Normal": [
            "Reference white point",
            "B",
            "LAB color space conversion involves RGB to XYZ transformation, followed by XYZ to LAB conversion."
        ],
        "FuncName": "imagebufalgo_yee_7210 XYZToLAB_color.txt"
    },
    {
        "Branch": [
            "Conditional statements are used to control the flow of a program.",
            "They are used to execute a block of code if a certain condition is met.",
            "For example, an if statement can be used to check if a variable is greater than 5."
        ],
        "Loop": [
            "Looping statements are used to execute a block of code repeatedly.",
            "They are used to perform a task multiple times until a certain condition is met.",
            "For example, a for loop can be used to iterate over a list of numbers."
        ],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "The image type is used to represent visual data.",
            "It can be used to display images, videos, and other multimedia content.",
            "For example, an image type can be used to display a picture of a cat."
        ],
        "FuncName": "IPLConvertToGray_8180 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress",
                    "Converting images to grayscale involves converting each pixel's color values to a single value representing the overall brightness of the pixel."
                ]
            },
            {
                "loopstr": [
                    "progress",
                    "Converting images to grayscale involves converting each pixel's color values to a single value representing the overall brightness of the pixel."
                ]
            },
            {
                "loopstr": [
                    "progress",
                    "Converting images to grayscale involves converting each pixel's color values to a single value representing the overall brightness of the pixel."
                ]
            },
            {
                "loopstr": [
                    "r = red->p(x,y);",
                    "g = green->p(x,y);",
                    "b = blue->p(x,y);",
                    "unsigned char pixel = HIBYTE(red->p(x,y) * 77 + green->p(x,y) * 151 + blue->p(x,y) * 28);",
                    "unsigned char pixel = (unsigned char) (0.2125 * red->p(x,y)) + (0.7154 * green->p(x,y)) + (0.0721 * blue->p(x,y));",
                    "unsigned char pixel = (unsigned char) ((r+r+r+b+g+g+g+g)>>3);",
                    "ipl_basetype pixel = (0.2125f * red->p(x,y)) + (0.7154f * green->p(x,y)) + (0.0721f * blue->p(x,y));",
                    "Grayscale conversion methods include using the luminance component of the YCbCr color space, or by combining the red, green, and blue components using different weights."
                ]
            }
        ],
        "Normal": [
            "delete previous result",
            "properties"
        ],
        "FuncName": "IPLConvertToGray_8180 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " fix any bad flags",
            "compute the storage requirements for image data"
        ],
        "FuncName": "squish_252 GetStorageRequirements.txt"
    },
    {
        "Branch": [
            "Write ElementaryStreamDescriptorBox for if condition"
        ],
        "Loop": [
            "Write ElementaryStreamDescriptorBox for loop condition"
        ],
        "Normal": [
            "Write the whole stuff, then figure out if we wrote the correct size for it (we allow mES_Descriptor to be incorrect); rewrite everything with the correct size. However, this may increase the size due to bigger size having been written and thus moving the remaining of the data forward, so we may need to loop even thrice. ElementaryStreamDescriptorBox contains image type related metadata."
        ],
        "FuncName": "elementarystreamdescriptorbox_378 writeBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "actual error is NO_MEDIA. HEIF files do not support multimedia content."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "content type not set. HEIF files require a valid MIME type to be saved."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "this should not be needed. actual contenttype is written Item::save. HEIF files are optimized for image content.",
            "re-use of data? HEIF files support efficient reuse of image metadata."
        ],
        "FuncName": "MimeItem_7355 save.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Fill in struct ES_Descriptor",
            "Expandable class... need to find out size based on (from ISO/IEC 14496-1)",
            "int sizeOfInstance = 0;",
            "bit(1) nextByte;",
            "bit(7) sizeOfInstance;",
            "while(nextByte) {",
            "bit(1) nextByte;",
            "bit(7) sizeByte;",
            "sizeOfInstance = sizeOfInstance<<7 | sizeByte;",
            "}",
            "Fill in struct ES_Descriptor.DecoderConfigDescriptor",
            "DecoderConfigDescriptor contains information about the decoder, including its version, capabilities, and configuration",
            "DecoderSpecificInfo contains additional information specific to the decoder, such as its parameters and settings"
        ],
        "FuncName": "elementarystreamdescriptorbox_378 parseBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u590d\u5236rgba\u503c",
                    "\u89e3\u538bDXT\u538b\u7f29\u56fe\u50cf"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u89e3\u538b\u5757",
                    "\u5c06\u89e3\u538b\u7684\u50cf\u7d20\u5199\u5165\u6b63\u786e\u7684\u56fe\u50cf\u4f4d\u7f6e",
                    "\u524d\u8fdb",
                    "\u89e3\u538bDXT\u538b\u7f29\u56fe\u50cf"
                ]
            },
            {
                "loopstr": [
                    "\u83b7\u53d6\u76ee\u6807\u4f4d\u7f6e",
                    "\u89e3\u538bDXT\u538b\u7f29\u56fe\u50cf"
                ]
            }
        ],
        "Normal": [
            "\u4fee\u590d\u4efb\u4f55\u574f\u6807\u5fd7",
            "\u521d\u59cb\u5316\u5757\u8f93\u5165",
            "\u5faa\u73af\u8fc7\u5757",
            "\u89e3\u538bDXT\u538b\u7f29\u56fe\u50cf"
        ],
        "FuncName": "squish_252 DecompressImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "resize during read via QImageReader (faster) and image resizing is supported for JPEG, PNG, and BMP formats"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If read() returns false there's no guarantee that size conversion worked properly. So we fallback to manual. Manual resizing and cropping is supported for JPEG, PNG, and BMP formats. Se far I've seen this happen only on some weird (corrupted?) jpeg saved from camera. Force reset reader because it is really finicky and can fail on the second read attempt (yeah wtf)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "manual resize & crop. slower but should just work. Supported image formats: JPEG, PNG, and BMP"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "force reader to close file so it can be deleted later. Image resizing and cropping is supported for JPEG, PNG, and BMP formats"
        ],
        "FuncName": "thumbnailerrunnable_1506 createThumbnail.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle in-place operation",
                    " Flip the image horizontally"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Compute the destination ROI it's the source ROI reflected across the midline of the display window",
            " The image is flipped vertically"
        ],
        "FuncName": "imagebufalgo_orient_2213 flip.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Handle in place operation",
                    "Reflect image across midline of display window"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Compute the destination ROI, it s the source ROI reflected across the midline of the display window."
        ],
        "FuncName": "imagebufalgo_orient_2213 flop_.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle in-place operation",
                    " Rotate the image 180 degrees"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Rotate the image 180 degrees. Rotated full ROI swaps width and height and keeps its origin where the original origin was"
        ],
        "FuncName": "imagebufalgo_orient_2213 rotate180_.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle in place operation",
                    " Reflect the image across the x-axis for horizontal flip",
                    " Reflect the image across the y-axis for vertical flip"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Compute the destination ROI, it s the source ROI reflected across the midline of the display window.",
            " Image flipping involves reflecting the image across a certain axis or line."
        ],
        "FuncName": "imagebufalgo_orient_2213 flip.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle in place operation",
                    " Rotate image 180 degrees"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Compute the destination ROI it s the source ROI reflected across the midline of the display window",
            " Image reflected horizontally and vertically"
        ],
        "FuncName": "imagebufalgo_orient_2213 flop.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale crop with image processing",
            "force reader to close file so it can be deleted later",
            "remove temporary file"
        ],
        "FuncName": "imagebufalgo_orient_2213 flip_.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle in-place operation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Compute the destination ROI, it's the source ROI reflected across the midline of the display window."
        ],
        "FuncName": "imagebufalgo_orient_2213 rotate90_.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end, image node ID"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end of the image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Rotate image 270 degrees in place"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Rotate image 270 degrees around the midline of the display window"
        ],
        "FuncName": "imagebufalgo_orient_2213 rotate270_.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end",
                    "Getting adjacent node IDs, a crucial step in image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Neighbor Node IDs: one past the end"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end, related to image processing and computer vision"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end",
                    "Image code: adjacent node ID"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end",
                    "Neighbor node ID: node1"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one past the end",
                    "Image: A picture or graphic that represents the end of a sequence or iteration."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "find_max_factor_graph_nmplp_840 node_id.txt"
    },
    {
        "Branch": [
            "Image condition: %s\n"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loaded images: %d\n",
                    "Iteration %d: %f, %f avg, %lf seconds, %d images\n"
                ]
            }
        ],
        "Normal": [
            "Image: %s\n",
            "Learning Rate: %g, Momentum: %g, Decay: %g\n",
            "Number of images: %d\n"
        ],
        "FuncName": "dice_2949 train_dice.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "initialize column sums at row -1 by scanning images and detecting target regions"
                ]
            },
            {
                "loopstr": [
                    "set to sum at point(-1,r) by detecting target regions in images and computing sum of rectangles",
                    "We compute it's value in the next loop by scanning images and detecting target regions.",
                    "Update the first part of column sums since we only work on the c+width part of column sums in the main loop by scanning images and detecting target regions.",
                    "in the main loop by scanning images and detecting target regions."
                ]
            },
            {
                "loopstr": [
                    "update the sum in this column now that we are on the next row by scanning images and detecting target regions"
                ]
            },
            {
                "loopstr": [
                    "update the sum in this column now that we are on the next row by scanning images and detecting target regions",
                    "add in the new right side of the rect and subtract the old right side by detecting target regions in images"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "scan_image_640 scan_image_old.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "get properties",
            "cv::OrbFeatureDetector detector; // Orb Feature Detector",
            "cv::Ptr<cv::ORB> detector = cv::ORB::create(300, 1.2f, 4, 31, 0, 2, cv::ORB::FAST_SCORE, 31, 20); // Orb Feature Detector Parameters",
            "cv::Ptr<cv::SURF> detector = cv::SURF::create(minHessian); // SURF Detector",
            "detector.detect(input, keypoints); // Detect keypoints in the image"
        ],
        "FuncName": "IPLFeatureDetection_4525 processInputData.txt"
    },
    {
        "Branch": [
            "Use version to 1 if needed, with item location"
        ],
        "Loop": [
            "Use version to 1 if needed, with item location"
        ],
        "Normal": [
            "Use version to 1 if needed, with item location"
        ],
        "FuncName": "itemlocationbox_8972 addLocation.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Validation Accuracy: %f, %d images with dice rolls"
        ],
        "FuncName": "dice_2949 validate_dice.txt"
    },
    {
        "Branch": [
            "Write item property association box data. This is a code string for image type."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Write item property association box data for each image code."
                ]
            }
        ],
        "Normal": [
            "Write item property association box data."
        ],
        "FuncName": "itempropertyassociation_6096 writeBox.txt"
    },
    {
        "Branch": [
            "Move image layer to position 0, 0;"
        ],
        "Loop": [
            "Move image layer to position 0, 0;"
        ],
        "Normal": [
            "Check limits; Move image layer to position 0, 0;"
        ],
        "FuncName": "mapoverlay_4519 moveMainImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Save extra space for outer rect border one pixel for right and bottom sides. This is related to image cropping and alignment."
        ],
        "FuncName": "mapoverlay_4519 updatePosition.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (QWidget::isVisible() == isVisible) // already in this state. The image is visible on the map.",
            "return;"
        ],
        "FuncName": "mapoverlay_4519 animateVisible.txt"
    },
    {
        "Branch": [
            " Update map display based on if condition result "
        ],
        "Loop": [
            " Recalculate map size and position for each loop iteration "
        ],
        "Normal": [
            " Always calculate this first for properly map location ",
            " Include map image type description: Update map display with calculated size and position "
        ],
        "FuncName": "mapoverlay_4519 updateMap.txt"
    },
    {
        "Branch": [
            "image comparison",
            "pixel difference"
        ],
        "Loop": [
            "image iteration",
            "frame by frame"
        ],
        "Normal": [
            "init optical flow",
            "basic optical flow settings",
            "optical flow inputs and outputs",
            "optical flow properties"
        ],
        "FuncName": "IPLOpticalFlow_1114 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "if this point is less than 10 from the origin and it's an image with a high contrast ratio"
                ]
            }
        ],
        "Normal": [
            "The svm functions use column vectors to contain a lot of the data on which they operate. So the first thing we do here is declare a convenient typedef. This typedef declares a matrix with 2 rows and 1 column. It will be the object that contains each of our 2 dimensional samples. Now we make objects to contain our samples and their respective labels. Now let's put some data into our samples and labels objects. We do this by looping over a bunch of points and labeling them according to their distance from the origin. Here we normalize all the samples by subtracting their mean and dividing by their standard deviation. This is generally a good idea since it often heads off numerical stability problems and also prevents one large feature from smothering others. Doing this doesn't matter much in this example so I'm just doing this here so you can see an easy way to accomplish this with the library. Let the normalizer learn the mean and standard deviation of the samples now normalize each sample Now that we have some data we want to train on it. We are going to train a binary SVM with the RBF kernel to classify the data. However, there are three parameters to the training. These are the SVM C parameters for each class and the RBF kernel's gamma parameter. Our choice for these parameters will influence how good the resulting decision function is. To test how good a particular choice of these parameters is we can use the cross_validate_trainer() function to perform n-fold cross validation on our training data. However, there is a problem with the way we have sampled our distribution above. The problem is that there is a definite ordering to the samples. That is, the first half of the samples look like they are from a different distribution than the second half. This would screw up the cross validation process, but we can fix it by randomizing the order of the samples with the following function call. And now we get to the important bit. Here we define a function, cross_validation_score(), that will do the cross-validation we mentioned and return a number indicating how good a particular setting of gamma, c1, and c2 is. And finally, we call this global optimizer that will search for the best parameters. It will call cross_validation_score() 50 times with different settings and return the best parameter setting it finds. find_max_global() uses a global optimization method based on a combination of non-parametric global function modeling and quadratic trust region modeling to efficiently find a global maximizer. It usually does a good job with a relatively small number of calls to cross_validation_score(). In this example, you should observe that it finds settings that give perfect binary classification of the data and the image has a high resolution."
        ],
        "FuncName": "model_selection_ex_2441 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Rolling a dice: %f\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "dice_2949 test_dice.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "get properties",
            "Obtain first image",
            "Convert the image to grayscale using cvtColor function from OpenCV library",
            "Convert the next image to grayscale using cvtColor function from OpenCV library"
        ],
        "FuncName": "IPLOpticalFlow_1114 processInputData.txt"
    },
    {
        "Branch": [
            "If the application data directory exists, then..."
        ],
        "Loop": [
            "While the application data directory is not found, try..."
        ],
        "Normal": [
            "this gives us a roaming profile on windows, allowing the application to access user data from any device."
        ],
        "FuncName": "DkUtils_8865 getAppDataPath.txt"
    },
    {
        "Branch": [
            "check if files contain a link and resolve the symbolic link"
        ],
        "Loop": [
            "check if files contain a link and resolve the symbolic link"
        ],
        "Normal": [
            "check if files contain a link"
        ],
        "FuncName": "DkUtils_8865 resolveSymLink.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO: could somebody with a mac please add the corresponding calls? Currently, the system has 1024 MB of available memory.",
            " convert to MB (system memory: 1024 MB)"
        ],
        "FuncName": "DkUtils_8865 getFreeMemory.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if the number has zeros we get into troubles:",
                    "101 and 12 result in '01' and '2'",
                    "for double sort this means: 01 < 2 (though 101 > 12)",
                    "so we simply search the last non zero number that was equal and prepend that",
                    "if there is no such number (e.g. img001 vs img101) we are fine already",
                    "this fixes #469",
                    "image comparison: comparing two image codes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "find the last non-zero number (just check one string they are the same)",
                    "image comparison: finding the last non-zero number"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "the first value is the most significant bit",
            "so we try to find the first difference in the strings",
            "this gives us an advantage:",
            "img1 and img10 are sorted correctly since the string compare",
            "does here what it should",
            "img4 and img10 are also sorted correctly since 4 < 10",
            "in addition we don't get into troubles with large numbers",
            "as we skip identical values...",
            "if both values start with a digit",
            "we're good to go with a string compare here...",
            "image comparison: comparing image codes with string comparison"
        ],
        "FuncName": "DkUtils_8865 naturalCompare.txt"
    },
    {
        "Branch": [
            "Compare the creation time of two files"
        ],
        "Loop": [
            "Compare the file names of two files"
        ],
        "Normal": [
            " avoid equality because we keep our directory position/index using the sorted position",
            "These strings are used for file comparison in the image processing code."
        ],
        "FuncName": "DkUtils_8865 compDateCreated.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO: could somebody add the corresponding calls? This requires access to the system's total memory space.",
            " convert to MB, considering the system's available memory."
        ],
        "FuncName": "DkUtils_8865 getTotalMemory.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Select a language from the dropdown menu to view translations in {language}."
                ]
            }
        ],
        "Normal": [
            "Find all translations in {language}."
        ],
        "FuncName": "DkUtils_8865 addLanguages.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " try manual conversion first, this fixes the DSC josef.jpg problems (url fragments) - This string is related to image processing, specifically converting URL to local file information."
        ],
        "FuncName": "DkUtils_8865 urlToLocalFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " converts a user readable file filter to a suffix only filter",
            "Applies to image file types such as JPEG, PNG, GIF, and BMP."
        ],
        "FuncName": "DkUtils_8865 suffixOnly.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "convert date to QDateTime object"
        ],
        "FuncName": "DkUtils_8865 convertDate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "convert date to a readable format, such as 'YYYY-MM-DD' or 'MM/DD/YYYY'"
        ],
        "FuncName": "DkUtils_8865 convertDateString.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "nominator",
                    "denominator",
                    "if exposure time is less than a second -> compute the gcd for nice values (1/500 instead of 2/1000)",
                    "image description: a mathematical concept used to find the greatest common divisor"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "do not show fractions like 9/1 -> it is more natural to write 9 in these cases",
                    "image description: a mathematical concept used to simplify fractions"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkUtils_8865 cleanFraction.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "get Tweety.svg from https://upload.wikimedia.org/wikipedia/en/0/02/Tweety.svg with image type: vector",
            "get 100919-snoop-dogg-feature.jpg from https://thenypost.files.wordpress.com/2019/10/100919-snoop-dogg-feature.jpg with image type: photograph"
        ],
        "FuncName": "DkUtils_8865 fileNameFromUrl.txt"
    },
    {
        "Branch": [
            "jpg",
            "[*.jpg, ...]"
        ],
        "Loop": [
            "jpg",
            "[*.jpg, ...]"
        ],
        "Normal": [
            "jpg file",
            "jpg and other files"
        ],
        "FuncName": "DkUtils_8865 hasValidSuffix.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << seek() to a specific position in the video: << pos << sec;"
        ],
        "FuncName": "videoplayermpv_7043 seek.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "fixes urls for windows - yes that actually annoys me. This string contains a URL."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DkUtils_8865 findUrlsInTextNewline.txt"
    },
    {
        "Branch": [
            "check if the process can run as a daemon",
            "if not: it cannot run as a daemon"
        ],
        "Loop": [
            "check if the process can run in a loop",
            "if not: it cannot run in a loop"
        ],
        "Normal": [
            "check if we can attach to the shared memory",
            "if not: we are the first",
            "the process is designed to run as a daemon and attach to shared memory",
            "if not attached, it is likely the first instance"
        ],
        "FuncName": "DkUtils_8865 tryRunning.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << seekRelative():  << pos <<  sec; // seek relative to video player's current position"
        ],
        "FuncName": "videoplayermpv_7043 seekRelative.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "setMuted(!settings->playVideoSounds()) - Controls video playback sounds.",
            "setVideoUnscaled(!settings->expandImage()) - Expands the video image."
        ],
        "FuncName": "videoplayermpv_7043 readSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << replacing:  << itemData[0] <<  with:  << value; Image data: [itemData[0]]"
        ],
        "FuncName": "DkUtils_8865 setData.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u8fdb\u5ea6",
                    "\u8fb9\u7f18\u68c0\u6d4b"
                ]
            },
            {
                "loopstr": [
                    "\u8fdb\u5ea6",
                    "\u8fb9\u7f18\u68c0\u6d4b"
                ]
            }
        ],
        "Normal": [
            "\u5220\u9664\u4e0a\u6b21\u7ed3\u679c",
            "\u83b7\u53d6\u5c5e\u6027",
            "\u8fdb\u884c\u8fb9\u7f18\u68c0\u6d4b"
        ],
        "FuncName": "IPLMorphologicalEdge_5959 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "connect(settings, SIGNAL(settingsChanged()), this, SLOT(readSettings()))",
            "Initialize video player with transparent background, enable mouse tracking, create MPV control, set layout, and connect signals"
        ],
        "FuncName": "videoplayermpv_7043 VideoPlayerMpv.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if the parent contains the key, I am valid too",
            "the parent must not check its kids again",
            "if a child contains the key, I am valid too"
        ],
        "FuncName": "DkUtils_8865 contains.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Write box headers and store image metadata",
            "Pad with language code and store image format",
            "Predefined image header box with image-specific descriptions"
        ],
        "FuncName": "mediaheaderbox_4580 writeBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "not enough weights -> uniform, missing weights -> 0, image channel weighted sum"
        ],
        "FuncName": "py_imagebufalgo_4023 IBA_channel_sum_weight.txt"
    },
    {
        "Branch": [
            "Testing the accuracy of basic elastic network solver and efficient elastic network solver for image: make sure the two solvers agree"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Testing the accuracy of basic elastic network solver and efficient elastic network solver for image: make sure the two solvers agree"
                ]
            }
        ],
        "Normal": [
            "Testing the accuracy of basic elastic network solver and efficient elastic network solver for image"
        ],
        "FuncName": "elastic_net_5027 perform_test.txt"
    },
    {
        "Branch": [
            "Conditional statement for ImageBufAlgo.",
            "Controls the flow of execution in ImageBufAlgo."
        ],
        "Loop": [
            "Loop condition for ImageBufAlgo.",
            "Determines the number of iterations in ImageBufAlgo."
        ],
        "Normal": [
            "This code snippet processes ImageBufAlgo.",
            "Utilizes ImageBufAlgo for image processing tasks."
        ],
        "FuncName": "py_imagebufalgo_4023 declare_imagebufalgo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Adjusting contrast and threshold of image: resizing black pixel values to range [0, 0.0f] and white pixel values to range [0, 1.0f].",
            "Adjusting contrast and threshold of image: resizing white pixel values to range [0, 1.0f] and white pixel values to range [0, 1.0f].",
            "Adjusting contrast and threshold of image: resizing min pixel values to range [0, 0.0f] and min pixel values to range [0, 1.0f].",
            "Adjusting contrast and threshold of image: resizing max pixel values to range [0, 1.0f] and max pixel values to range [0, 1.0f].",
            "Adjusting contrast and threshold of image: resizing sthresh pixel values to range [0, 0.5f] and sthresh pixel values to range [0, 1.0f].",
            "Adjusting contrast and threshold of image: resizing scontrast pixel values to range [0, 1.0f] and scontrast pixel values to range [0, 1.0f]."
        ],
        "FuncName": "py_imagebufalgo_4023 IBA_contrast_remap.txt"
    },
    {
        "Branch": [
            "If the image is present"
        ],
        "Loop": [
            "Loop through each image"
        ],
        "Normal": [
            "First parse the box header",
            "Pad, Language",
            "Predefined Image Type"
        ],
        "FuncName": "mediaheaderbox_4580 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "read the image as unsigned char",
            "from a PNG file"
        ],
        "FuncName": "io_png_9009 io_png_read_u8.txt"
    },
    {
        "Branch": [
            "read the image as float if the condition is met"
        ],
        "Loop": [
            "read the image as float in each iteration"
        ],
        "Normal": [
            "read the image as float"
        ],
        "FuncName": "io_png_9009 io_png_read_f32.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read the RGB image and handle error"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read the existing RGB image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "read the image and convert it to RGB"
        ],
        "FuncName": "io_png_9009 io_png_read_u8_rgb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "pattern might be inverted. This is an image code string.",
                    "The image code string is used to identify the image type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Determine the minimum and maximum value for each color channel in the image.",
            "Find the best bitmap match by counting the bits that don't match, including the inverted bitmaps.",
            "This process is crucial for image analysis and processing."
        ],
        "FuncName": "tiv_lib_7090 findCharData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculate the average color value for each bucket, considering the image's pixel intensity and color distribution."
        ],
        "FuncName": "tiv_lib_7090 createCharData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u9519\u8bef",
                    "\u8bfb\u53d6 PNG \u683c\u5f0f\u7684\u7070\u5ea6\u56fe\u50cf\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u5355\u901a\u9053 32 \u4f4d\u6d6e\u70b9\u6570\u56fe\u50cf"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5df2\u7ecf\u7070\u8272",
                    "\u8bfb\u53d6 PNG \u683c\u5f0f\u7684\u7070\u5ea6\u56fe\u50cf\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u5355\u901a\u9053 32 \u4f4d\u6d6e\u70b9\u6570\u56fe\u50cf"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u8bfb\u53d6\u56fe\u7247",
            "\u8bfb\u53d6 PNG \u683c\u5f0f\u7684\u7070\u5ea6\u56fe\u50cf\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u5355\u901a\u9053 32 \u4f4d\u6d6e\u70b9\u6570\u56fe\u50cf"
        ],
        "FuncName": "io_png_9009 io_png_read_f32_gray.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read PNG image, convert to RGB color space, return float array, error"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "already RGB"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "read the image, convert to RGB color space, return float array"
        ],
        "FuncName": "io_png_9009 io_png_read_f32_rgb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u8bfb\u53d6\u6587\u4ef6\u51fa\u73b0\u95ee\u9898\uff0c\u6211\u4eec\u4f1a\u5728\u8fd9\u91cc\u5904\u7406PNG\u6587\u4ef6\u7684\u9519\u8bef"
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u901a\u9053\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u901a\u9053\u5faa\u73af\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u884c\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u884c\u5faa\u73af\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u50cf\u7d20\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u50cf\u7d20\u5faa\u73af\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u901a\u9053\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u901a\u9053\u5faa\u73af\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u884c\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u884c\u5faa\u73af\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u50cf\u7d20\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u50cf\u7d20\u5faa\u73af\u5904\u7406"
                ]
            }
        ],
        "Normal": [
            "\u6613\u53d8\u6027\uff1a\u7531\u4e8esetjmp/longjmp\uff0c\u53ef\u80fd\u5bfc\u81f4\u56fe\u50cf\u5904\u7406\u9519\u8bef",
            "\u53c2\u6570\u68c0\u67e5\uff1a\u786e\u4fdd\u51fd\u6570\u53c2\u6570\u6b63\u786e",
            "\u6253\u5f00PNG\u8f93\u51fa\u6587\u4ef6\uff1a\u521b\u5efaPNG\u6587\u4ef6\u7684\u8f93\u51fa\u6d41",
            "\u5206\u914d\u548c\u521d\u59cb\u5316\u4ea4\u9519\u6570\u7ec4\u548c\u884c\u6307\u9488\uff1a\u4e3a\u56fe\u50cf\u5904\u7406\u5206\u914d\u5185\u5b58",
            "\u521b\u5efa\u548c\u521d\u59cb\u5316png_struct *\uff0c\u4f7f\u7528\u9ed8\u8ba4\u7684stderr\u548c\u9519\u8bef\u5904\u7406\uff1a\u521b\u5efaPNG\u6587\u4ef6\u7684\u7ed3\u6784\u4f53",
            "\u5206\u914d\u548c\u521d\u59cb\u5316\u56fe\u50cf\u4fe1\u606f\u7684\u5185\u5b58\uff1a\u4e3a\u56fe\u50cf\u4fe1\u606f\u5206\u914d\u5185\u5b58",
            "\u8bbe\u7f6e\u9519\u8bef\u5904\u7406\uff1a\u8bbe\u7f6e\u9519\u8bef\u5904\u7406\u51fd\u6570",
            "\u4f7f\u7528\u6807\u51c6C\u6d41\u8bbe\u7f6e\u8f93\u5165\u63a7\u5236\uff1a\u8bbe\u7f6e\u8f93\u5165\u6d41",
            "\u8bbe\u7f6e\u56fe\u50cf\u4fe1\u606f\uff1a\u8bbe\u7f6e\u56fe\u50cf\u7684\u4fe1\u606f",
            "\u8bbe\u7f6e\u56fe\u50cf\u5934\uff1a\u8bbe\u7f6e\u56fe\u50cf\u7684\u5934\u90e8\u4fe1\u606f",
            "TODO\uff1a\u91cd\u8981\u4f4d\uff08sBIT\uff09\uff0c\u4f3d\u9a6c\uff08gAMA\uff09\uff0c\u6ce8\u91ca\uff08\u6587\u672c\uff09\u5757\uff1a\u5f85\u5b8c\u6210\u7684\u529f\u80fd",
            "\u4ea4\u9519\u5e76\u5c06RRR GGG BBB\u8f6c\u6362\u4e3aRGB RGB RGB *\u56fe\u50cf\u4ee5\u5c42\u6b21\u7ed3\u6784\u4ea4\u9519 *\u8fd9\u6d89\u53ca\u66f4\u591a\u7684\u5185\u5b58\u4ea4\u6362\uff0c\u4f46\u5141\u8bb8\u901a\u7528\u5faa\u73af\uff1a\u5bf9\u56fe\u50cf\u8fdb\u884c\u5c42\u6b21\u7ed3\u6784\u4ea4\u9519\u5904\u7406",
            "\u8bbe\u7f6e\u884c\u6307\u9488\uff1a\u8bbe\u7f6e\u884c\u6307\u9488",
            "\u5199\u51fa\u6574\u4e2a\u56fe\u50cf\u5e76\u7ed3\u675f\uff1a\u5c06\u56fe\u50cf\u5199\u5165PNG\u6587\u4ef6",
            "\u6e05\u7406\u548c\u91ca\u653e\u4efb\u4f55\u5185\u5b58\u5206\u914d\uff0c\u5173\u95ed\u6587\u4ef6\uff1a\u6e05\u7406\u5185\u5b58\u548c\u5173\u95ed\u6587\u4ef6"
        ],
        "FuncName": "io_png_9009 io_png_write_raw.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " if we get here, there was a problem reading the PNG image file "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " iterating through each channel "
                ]
            },
            {
                "loopstr": [
                    " iterating through each row "
                ]
            },
            {
                "loopstr": [
                    " iterating through each pixel "
                ]
            },
            {
                "loopstr": [
                    " iterating through each channel "
                ]
            },
            {
                "loopstr": [
                    " iterating through each row "
                ]
            },
            {
                "loopstr": [
                    " iterating through each pixel "
                ]
            }
        ],
        "Normal": [
            " volatile because of setjmp/longjmp ",
            " checking parameters ",
            " opening the PNG input file ",
            " reading in some of the signature bytes and checking the signature ",
            " creating and initializing the png_struct * with default stderr and error handling ",
            " allocating and initializing memory for image information ",
            " setting error handling ",
            " freeing all memory associated with the png_ptr and info_ptr ",
            " setting up the input control using standard C streams ",
            " letting libpng know that some bytes have been read ",
            " setting the read filter transforms to get 8-bit RGB, whatever the original file may contain, strip 16-bit samples to 8 bits, expand 1, 2, and 4-bit samples to bytes ",
            " reading in the entire image at once ",
            " getting image information ",
            " allocating the output data RGB array, deinterlacing and converting PNG RGB to RGB (8-bit to 8-bit, 8-bit to 8-bit, 8-bit to 8-bit), the image is deinterlaced layer by layer, this generic loop also works for one single channel ",
            " cleaning up and freeing any memory allocated, closing the file "
        ],
        "FuncName": "io_png_9009 io_png_read_raw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file fft_test_data.dat we want to decode and return. This data is a compressed binary representation of the original data.",
            "Put the data into the istream sin. This is a step in the decompression process.",
            "Decode the base64 text into its compressed binary form. This is where the magic happens.",
            "Decompress the data into its original form. This is the final step in the decompression process.",
            "Return the decoded and decompressed data. This is the final output of the function."
        ],
        "FuncName": "fft_7810 get_decoded_string.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " The base64 encoded data from the image file we want to decode and return.",
            " Put the data into the input stream",
            " Decode the base64 text into its compressed binary form",
            " Decompress the data into its original image form",
            " Return the decoded and decompressed image data"
        ],
        "FuncName": "correlation_tracker_9027 get_decoded_string_frame_000103.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file 'examples\\video_frames\\frame_000100.bmp' we want to decode and return.",
            "Put the data into the istream sin, which is a binary stream for reading image data.",
            "Decode the base64 text into its compressed binary form, which is typically a JPEG or PNG image.",
            "Decompress the data into its original form, revealing the original image data.",
            "Return the decoded and decompressed image data, which can be displayed or processed further."
        ],
        "FuncName": "correlation_tracker_9027 get_decoded_string_frame_000100.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " The base64 encoded data from the file '..\\..\\examples\\video_frames\\frame_000102.bmp' we want to decode and return. This data is a compressed binary form of the image.",
            " Put the data into the istream sin",
            " Decode the base64 text into its compressed binary form, which is a binary representation of the image.",
            " Decompress the data into its original form, restoring the image to its original state.",
            " Return the decoded and decompressed data, which is the original image."
        ],
        "FuncName": "correlation_tracker_9027 get_decoded_string_frame_000102.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The mip level slider, allowing users to control the level of detail in images.",
            "The mip level dropdown, providing a user-friendly interface for selecting the mip level.",
            "The mip level is controlled by the user through the mip level knob and dropdown.",
            "The mip level is read from the file by the Reader, and its value is stored when the Read is serialized."
        ],
        "FuncName": "txReader_4922 knobs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Big-endian TIFF image file",
            "Little-endian TIFF image file",
            "EXR image file"
        ],
        "FuncName": "txReader_4922 test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Full size content view can confuse saveGeometry, making it think the window is taller than it really is, so the restored window ends up taller. Turn it off before saving geometry. This issue is related to image rendering and layout, where the image is not properly scaled or cropped, resulting in a distorted or cut-off image."
        ],
        "FuncName": "mainwindow_4975 closeEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Mip level other than 0. This data is extracted from the image buffer and placed into the row buffer, which is a common operation in image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "txReader_4922 engine.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Make the image larger so we can detect small faces. This involves resizing the image to increase the size of the faces.",
                    "Now tell the face detector to give us a list of bounding boxes around all the faces in the image. The face detector will identify the locations and sizes of the detected faces.",
                    "Now we will go ask the shape_predictor to tell us the pose of each face we detected. The shape_predictor will provide information about the facial landmarks and their corresponding coordinates.",
                    "Now let's view our face poses on the screen. This involves displaying the detected faces with their corresponding landmarks and poses.",
                    "We can also extract copies of each face that are cropped, rotated upright, and scaled to a standard size as shown here: Each face will be processed to enhance its quality and make it suitable for further analysis."
                ]
            },
            {
                "loopstr": [
                    "You get the idea, you can get all the face part locations if you want them. Here we just store them in shapes so we can put them on the screen. The face part locations will be stored and can be used for various applications such as face recognition or facial expression analysis."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "face_landmark_detection_ex_3372 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "To account for full size content view on mac, consider using a larger image or adjusting the layout to accommodate the image's dimensions."
        ],
        "FuncName": "mainwindow_4975 getTitlebarOverlap.txt"
    },
    {
        "Branch": [
            "Update window title and properties to handle if condition"
        ],
        "Loop": [
            "Update window title and properties to handle loop condition"
        ],
        "Normal": [
            "Repaint to handle error message, related to image processing"
        ],
        "FuncName": "mainwindow_4975 fileChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "bgcolor: background color of the image",
            "menubarenabled: enables or disables the menu bar for the image",
            "Menu bar is effectively always enabled on macOS: a note about the menu bar behavior on macOS",
            "titlebaralwaysdark: sets the title bar to always be dark",
            "quitonlastwindow: quits the application when the last window is closed",
            "slideshow timer: a timer for slideshow functionality",
            "repaint in case background color changed: repaints the image when the background color changes"
        ],
        "FuncName": "mainwindow_4975 settingsUpdated.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If esc is not used in a shortcut, let it exit fullscreen; Ensure Esc key does not conflict with other operations."
        ],
        "FuncName": "mainwindow_4975 shortcutsUpdated.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Enable this window's actions when a file is loaded. This action is triggered by an image or a button."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mainwindow_4975 disableActions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "check if the program is configured to resize the window based on image size and screen resolution",
            "check if window is maximized or fullscreened to adjust image size accordingly",
            "Try to capture the current screen to determine optimal image size",
            "perform a makeshift validity check to ensure image size is suitable",
            "Use the first screen as a fallback option for image size",
            "Windows reports incorrect minimum width, so we constrain image size relative to dpi to prevent unusual issues with small images",
            "Adjust image position to match the center after changing the window geometry",
            "This approach provides a smoother experience than setting a single geometry for some reason",
            "Verify that the titlebar is not above or below the available screen area to ensure optimal image size"
        ],
        "FuncName": "mainwindow_4975 setWindowSize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Hideicontemporarilyspeedupupdatesincertaincases"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Ifwearewithintheboundsoftheopenwithlist"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mainwindow_4975 populateOpenWithMenu.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "The virtual siblings include the screen itself, so iterate directly over the screen's children."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mainwindow_4975 screenContaining.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Timing parallel for loop timing these strings are image code strings."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "parallel_test_4044 time_parallel_for.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Assign only part of the elements in vector, utilizing parallel processing for efficient computation.",
            " Note that things become a little more complex if the loop bodies are not totally independent, requiring additional synchronization.",
            " In the first two cases, each iteration of the loop accessed different memory locations, eliminating the need for thread synchronization.",
            " However, in the summing loop, synchronization is required to protect the sum variable, which can be achieved using a mutex.",
            " In general, parallel for loops must ensure thread safety by employing appropriate synchronization techniques, similar to those used in multi-threaded code."
        ],
        "FuncName": "parallel_for_ex_6125 example_using_lambda_functions.txt"
    },
    {
        "Branch": [
            "Get command line argument for if condition",
            "clang-format off",
            "clang-format on"
        ],
        "Loop": [
            "Get command line argument for loop condition",
            "clang-format off",
            "clang-format on"
        ],
        "Normal": [
            "Get command line argument",
            "clang-format off",
            "clang-format on"
        ],
        "FuncName": "parallel_test_4044 getargs.txt"
    },
    {
        "Branch": [
            " else if(0==strcmp(argv[2], \"valid\")) validate_voxel(cfg, weights); "
        ],
        "Loop": [],
        "Normal": [
            " else if(0==strcmp(argv[2], \"valid\")) validate_voxel(cfg, weights); "
        ],
        "FuncName": "voxel_4467 run_voxel.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Image: %d x %d\n",
                    "Prediction: %s. Time elapsed: %f seconds.\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "voxel_4467 test_voxel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Chew through events in case we have something that alters stateBuf in queue, which is a crucial step in image processing.",
            "Apply buffer, a fundamental concept in image manipulation.",
            "Wait till layout stuff happens, a common scenario in GUI development.",
            "Before calling focusOn(), a key function in image editing."
        ],
        "FuncName": "folderviewproxy_8520 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "dither",
                    "animated GIF image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "gifoutput_3684 start_subimage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Only support 8 bit channels for now. This is a characteristic of BMP image files.",
            "Scanline size is rounded up to align to 4-byte boundary, which is a requirement for BMP file format.",
            "If user asked for tiles -- which this format doesn't support, emulate it by buffering the whole image, allowing for efficient image data processing.",
            "BMP files support up to 8-bit channels, enabling detailed image representation."
        ],
        "FuncName": "bmpoutput_8117 open.txt"
    },
    {
        "Branch": [
            "if (image.is_valid())"
        ],
        "Loop": [
            "for (int i = 0; i < image.get_height(); i++)"
        ],
        "Normal": [
            "dither",
            "image is a valid image",
            "image height is 0"
        ],
        "FuncName": "gifoutput_3684 finish_subimage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "pad with zeroes if needed, similar to image padding",
            "Swap RGB pixels into BGR format, a common image processing operation"
        ],
        "FuncName": "bmpoutput_8117 write_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "f->close();  // Close the file stream, a common operation in image processing."
        ],
        "FuncName": "gifoutput_3684 fclose.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "make a random bump"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "move the point around in a circle",
                    "randomly drop measurements",
                    "figure out the next position",
                    "test the serialization a few times"
                ]
            }
        ],
        "Normal": [
            "This test has a point moving in a circle around the origin. The point also gets a random bump in a random direction at each time step."
        ],
        "FuncName": "filtering_5861 test_filter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " if (tablename == TIFF) and TIFF image is displayed in the viewer"
        ],
        "FuncName": "exif_7476 tag_table.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Emulate tiles by buffering the whole image",
            "Write a block of pixels into the image buffer"
        ],
        "FuncName": "bmpoutput_8117 write_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "already closed",
                    "image output is closed, pixels are written to buffer and output is reset"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Handle tile emulation -- output the buffered pixels",
                    "image output is handled, buffered pixels are output"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "bmpoutput_8117 close.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Inform caller about corrupted entry.",
                    "Calculating TIFF directory entry data size for image code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Sizes of TIFFDataType members",
            "Relevant to image type: TIFF directory entry data size"
        ],
        "FuncName": "exif_7476 tiff_data_size.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Short data are stored in the offset field itself. This is a characteristic of image files.",
                    "Image files typically store short data in the offset field itself."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Invalid span -- it is not entirely contained in the data window.",
                    "Signal error by returning an empty span. This may occur when working with image data.",
                    "Image processing may result in an invalid span if the data window is not entirely contained."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Long data. Image files can store long data, such as pixel values or image metadata."
        ],
        "FuncName": "exif_7476 makernote_handler.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6570\u636e\u5b58\u50a8\u5728\u504f\u79fb\u5b57\u6bb5\u672c\u8eab",
                    "\u56fe\u50cf\u5c5e\u6027\u4e2d\u7684TIFF\u76ee\u5f55\u4e2d\u76844\u5b57\u8282\u65e0\u7b26\u53f7\u6574\u6570\u503c"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u65e0\u6548\u8de8\u5ea6--\u5b83\u4e0d\u662f\u6570\u636e\u7a97\u53e3\u7684\u5b8c\u5168\u5305\u542b\u5bf9\u8c61\u3002",
                    "\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u7a7a\u8de8\u5ea6\u6765\u53d1\u51fa\u4fe1\u53f7\u9519\u8bef\u3002",
                    "\u56fe\u50cf\u5c5e\u6027\u4e2d\u7684TIFF\u76ee\u5f55\u4e2d\u76844\u5b57\u8282\u65e0\u7b26\u53f7\u6574\u6570\u503c"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u957f\u6570\u636e",
            "\u56fe\u50cf\u5c5e\u6027\u4e2d\u7684TIFF\u76ee\u5f55\u4e2d\u76844\u5b57\u8282\u65e0\u7b26\u53f7\u6574\u6570\u503c"
        ],
        "FuncName": "exif_7476 version4uint8_handler.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6570\u636e\u5b58\u50a8\u5728\u504f\u79fb\u5b57\u6bb5\u672c\u8eab",
                    "\u8be5\u8de8\u5ea6\u662fTIFF\u56fe\u50cf\u6570\u636e\u7684\u6709\u6548\u90e8\u5206"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u65e0\u6548\u7684\u8de8\u5ea6 -- \u5b83\u4e0d\u5b8c\u5168\u5305\u542b\u5728\u6570\u636e\u7a97\u53e3\u5185\u3002",
                    "\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u7a7a\u8de8\u5ea6\u6765\u8868\u793a\u4fe1\u53f7\u9519\u8bef\u3002",
                    "\u8be5\u8de8\u5ea6\u662fTIFF\u56fe\u50cf\u6570\u636e\u7684\u65e0\u6548\u90e8\u5206"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u957f\u6570\u636e",
            "TIFF\u56fe\u50cf\u6570\u636e"
        ],
        "FuncName": "exif_7476 tiff_dir_data.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case -- write a 1-channel image as a gray palette. This involves creating and writing a bitmap header with the appropriate information for a grayscale image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Write palette, if there is one. This is only used for grayscale images, and the palette is just the 256 possible gray values. The bitmap header will contain information such as the image dimensions, pixel depth, and color palette."
        ],
        "FuncName": "bmpoutput_8117 create_and_write_bitmap_header.txt"
    },
    {
        "Branch": [
            "Importance of points within the image cropping region based on their distance from the edge."
        ],
        "Loop": [],
        "Normal": [
            "Distance from edge: Importance of points within the image cropping region based on their distance from the edge."
        ],
        "FuncName": "SmartCrop_9097 importance.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " this is some funky magic to preserve detail a bit more for image degradation and reduce image quality, specifically for skin tones (r) and detail (g) Saturation (b) does not get this boost to enhance image quality."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SmartCrop_9097 downSample.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "not found with EXIF tags: camera model, lens model, aperture value, shutter speed, ISO value"
        ],
        "FuncName": "exif_7476 exif_tag_lookup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Img = 100x100, width = 95x95, scale = 100/95, 1/scale > min",
                    "don't set minscale smaller than 1/scale",
                    "-> don't pick crops that need upscaling",
                    "prescale if possible"
                ]
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SmartCrop_9097 smartCropRect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read EXIF tags from the image's EXIF directory.",
                    "only swab true offsets, not data embedded in the offset field"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read EXIF tags from the image's EXIF directory.",
                    "Special case: It's a pointer to a private EXIF directory.",
                    "Handle the whole thing recursively.",
                    "int stored in offset itself",
                    "Don't recurse if we've already visited this IFD"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read EXIF tags from the image's EXIF directory.",
                    "We have encountered JPEG files that inexplicably have the",
                    "directory count for the GPS data using the wrong byte order.",
                    "In this case, since there are only 32 possible GPS related",
                    "tags, we use that as a sanity check and skip the corrupted",
                    "data block. This isn't a very general solution, but it's a",
                    "rare case and clearly a broken file. We're just trying not to",
                    "crash in this case.",
                    "Read GPS tags from the image's GPS directory."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read EXIF tags from the image's EXIF directory.",
                    "Special case: It's a pointer to a private EXIF directory.",
                    "Handle the whole thing recursively.",
                    "int stored in offset itself",
                    "Don't recurse if we've already visited this IFD"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Make a copy of the pointed-to TIFF directory, swab the components",
            "if necessary.",
            "Read EXIF tags from the image's EXIF directory."
        ],
        "FuncName": "exif_7476 read_exif_tag.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " In the byte swap case, copy it into a vector because the upstream source isn't mutable. EXIF: Adding EXIF items to image metadata.",
                    " upstream source isn't mutable. EXIF: Adding EXIF items to image metadata."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " In the byte swap case, copy it into a vector because the upstream source isn't mutable. EXIF: Adding EXIF items to image metadata.",
                    " upstream source isn't mutable. EXIF: Adding EXIF items to image metadata."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Don't grab the terminating null EXIF: Ignoring null termination in image metadata."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Not sure how to handle bytes generally, but certainly for just one, add it as an int. EXIF: Adding byte values as integers to image metadata.",
                    " one, add it as an int. EXIF: Adding byte values as integers to image metadata."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Add it as bytes EXIF: Adding byte values to image metadata."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " Because the values in the blob aren't 32-bit-aligned, memcpy them into ints to do the swapping. EXIF: Swapping 32-bit values in image metadata.",
                    " Because the values in the blob aren't 32-bit-aligned, memcpy them into ints to do the swapping. EXIF: Swapping 32-bit values in image metadata.",
                    "NOSONAR",
                    "NOSONAR"
                ]
            },
            {
                "loopstr": [
                    " Because the values in the blob aren't 32-bit-aligned, memcpy them into ints to do the swapping. EXIF: Swapping 32-bit values in image metadata.",
                    " Because the values in the blob aren't 32-bit-aligned, memcpy them into ints to do the swapping. EXIF: Swapping 32-bit values in image metadata.",
                    "NOSONAR",
                    "NOSONAR"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "exif_7476 add_exif_item_to_spec.txt"
    },
    {
        "Branch": [
            "Calculate the edge of the image using the if condition."
        ],
        "Loop": [
            "Calculate the edge of the image using the loop condition."
        ],
        "Normal": [
            "Calculate the edge of the image using the width function.",
            "The image edge calculation is a typical operation in image processing."
        ],
        "FuncName": "SmartCrop_9097 edgeDetect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6dfb\u52a0\u5230\u6570\u636e\u5411\u91cf\u4e2d\u5e76\u4f7f\u7528\u5176\u504f\u79fb\u91cf",
                    "TIFF\u76ee\u5f55\u6761\u76ee\uff1a\u6dfb\u52a0\u5230\u6570\u636e\u5411\u91cf\u4e2d\u5e76\u4f7f\u7528\u5176\u504f\u79fb\u91cf"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u4e0d\u8981\u91cd\u590d\u6dfb\u52a0",
            "TIFF\u76ee\u5f55\u6761\u76ee\uff1a\u4e0d\u8981\u91cd\u590d\u6dfb\u52a0"
        ],
        "FuncName": "exif_7476 append_tiff_dir_entry.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This range of Exif tags go in the main TIFF directories.",
                    "Whatever.",
                    "EXIF tags include metadata such as camera settings, date and time, and location information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Add some required Exif tags that wouldn't be in the spec",
                    "EXIF tags provide additional metadata about the image, such as camera settings and location information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Add some required Exif tags that wouldn't be in the spec",
                    "EXIF tags include metadata such as camera settings, date and time, and location information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "unsigned int size = (unsigned int) makerdirs_offset;",
                    "EXIF tags can include metadata about the camera, such as the camera model and firmware version."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "addr of next IFD (none)",
                    "EXIF tags provide metadata about the image, including camera settings and location information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "ndirs for gps",
                    "gps dirs",
                    "addr of next IFD (none)",
                    "GPS EXIF tags include metadata such as location information and timestamp."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "ndirs for canon",
                    "canon dirs",
                    "addr of next IFD (none)",
                    "Canon EXIF tags include metadata such as camera settings and location information."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Which tag domain are we using?",
                    "The tag domain determines the type of metadata included in the EXIF tags."
                ]
            }
        ],
        "Normal": [
            "const TagMap& canon_tagmap (pvt::canon_maker_tagmap_ref());",
            "Reserve maximum space that an APP1 can take in a JPEG file, so",
            "we can push_back to our heart's content and know that no offsets",
            "or pointers to the exif vector's memory will change due to",
            "reallocation.",
            "Layout:",
            "                     .-----------------------------------------",
            "    (tiffstart) ---->|  TIFFHeader",
            "                     |    magic",
            "                     |    version",
            "                  .--+--  diroff",
            "                  |  |-----------------------------------------",
            "            .-----+->|  d",
            "            |     |  |   a",
            "            |  .--+->|    t",
            "            |  |  |  |     a",
            "        .---+--+--+->|  d",
            "        |   |  |  |  |   a",
            "      .-+---+--+--+->|    t",
            "      | |   |  |  |  |     a",
            "      | |   |  |  |  +-----------------------------------------",
            "      | |   |  |  `->|  number of top dir entries",
            "      | |   `--+-----+- top dir entry 0",
            "      | |      |     |  ...",
            "      | |      | .---+- top dir Exif entry (point to Exif IFD)",
            "      | |      | |   |  ...",
            "      | |      | |   +------------------------------------------",
            "      | |      | `-->|  number of Exif IFD dir entries (n)",
            "      | |      `-----+- Exif IFD entry 0",
            "      | |            |  ...",
            "      | |        .---+- Exif entry for maker note",
            "      | |        |   |  ...",
            "      | `--------+---+- Exif IFD entry n-1",
            "      |          |   +------------------------------------------",
            "      |           `->|  number of makernote IFD dir entries",
            "      `--------------+- Makernote IFD entry 0",
            "                     |  ...",
            "                     `------------------------------------------",
            "Put a TIFF header",
            "N.B. need to swap_endian head.tiff_diroff  below, once we know the sizes",
            "Accumulate separate tag directories for TIFF, Exif, GPS, and Interop.",
            "Go through all spec attribs, add them to the appropriate tag",
            "directory (tiff, gps, or exif), adding their data to the main blob.",
            "If we're a canon camera, construct the dirs for the Makernote,",
            "with the data adding to the main blob.",
            "If any legit Exif info was found (including if there's a maker note),",
            "add some extra required Exif fields.",
            "If any GPS info was found, add a version tag to the GPS fields.",
            "Compute offsets:",
            "TIFF dirs will start after the data",
            "zero pad for next IFD offset",
            "Exif dirs will start after the TIFF dirs.",
            "zero pad for next IFD offset",
            "GPS dirs will start after Exif",
            "zero pad for next IFD offset",
            "MakerNote is after GPS",
            "zero pad for next IFD offset",
            "If any Maker info was found, add a MakerNote tag to the Exif dirs",
            "If any Exif info was found, add a Exif IFD tag to the TIFF dirs",
            "If any GPS info was found, add a GPS IFD tag to the TIFF dirs",
            "All the tag dirs need to be sorted",
            "Create a lambda that tests for order, accounting for endianness",
            "Now mash everything together",
            "addr of next IFD (none)",
            "Now go back and patch the header with the offset of the first TIFF",
            "directory. Some hoop jumping is necessary to avoid triggering ubsan",
            "by having an unaligned acces.",
            "EXIF tags include metadata about the image, including camera settings, date and time, and location information."
        ],
        "FuncName": "exif_7476 encode_exif.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "rotate the image between 360 and 0 degrees"
        ],
        "FuncName": "qvimagecore_9174 rotateImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No directory specified and a file is not already loaded from which we can infer one. This may be an image file."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If the current folder changed since the last image, assign a new seed for random sorting. This may be related to image processing.",
            "Sorting, a process often used in image editing.",
            "Set current file index variable, which could be used to display a sequence of images."
        ],
        "FuncName": "qvimagecore_9174 updateFolderInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Set allocation limit to 8 GiB on Qt6, utilizing image processing capabilities.",
            "Connect to settings signal, enabling image data synchronization."
        ],
        "FuncName": "qvimagecore_9174 QVImageCore.txt"
    },
    {
        "Branch": [
            "check if image is loaded or requested",
            "load image if not already loaded"
        ],
        "Loop": [
            "check if image is loaded or requested"
        ],
        "Normal": [
            "check if image is already loaded or requested",
            "read image from cache if loaded"
        ],
        "FuncName": "qvimagecore_9174 requestCachingFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "loop through folders with color correction",
            "enable preloading mode for faster image loading",
            "sort images by ascending alphabetical order",
            "allow detection of mime content for optimized image display",
            "update folder information to reflect new settings, including sort order",
            "perform colorspace conversion for accurate image rendering"
        ],
        "FuncName": "qvimagecore_9174 settingsUpdated.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "un-supported. AAC decoder configuration is not supported."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "tbd. AAC decoder configuration is TBD."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "AACDecoderConfiguration_7192 parse.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Compare absoluteFilePath first because it's way faster, but double-check with",
                    "QFileInfo::operator== because it respects file system case sensitivity rules",
                    "This ensures accurate comparisons of file paths, even with different cases"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "qvimagecore_9174 updateLoadedIndexInFolder.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0 AAC-Main 1 AAC-LC 2 AAC-SSR 3 AAC-LTP. AAC (Advanced Audio Coding) is a perceptual audio coding format for digital audio. It is designed to be the successor of the MP3 format. AAC has a higher compression ratio and better sound quality than MP3.",
            "byte_alignment(); //Note 1 : If called from within an AudioSpecificConfig(), this byte_alignment shall be relative to the start of the AudioSpecificConfig(). This is a comment explaining the purpose of the byte_alignment function."
        ],
        "FuncName": "AACDecoderConfiguration_7192 program_config_element.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u89e3\u7801AAC\u7f16\u7801\u5668\u7684\u7279\u5b9a\u914d\u7f6e\uff0c\u4f8b\u5982 tbd in version 3 "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "AACDecoderConfiguration_7192 GASpecificConfig.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Values in this enum are from an external user, so not guaranteed to be bounded to the enum values. This string is related to image type because it describes the possible values of an enum that can be used to represent image data."
        ],
        "FuncName": "astcenc_entry_1322 validate_profile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO: should verify that only correct valid packets exist in the HEIF audio decoder configuration. This involves checking for the presence of audio samples, sample rates, and channel counts in the aConfig array."
        ],
        "FuncName": "AACDecoderConfiguration_7192 convertToRawData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Not all enum values are handled; SWZ_Z is invalid for compression. This is a related image description."
        ],
        "FuncName": "astcenc_entry_1322 validate_compression_swz.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Values in this enum are from an external user, so not guaranteed to be bounded to the enum values. This string is related to an image, where the image is used to represent the external user."
        ],
        "FuncName": "astcenc_entry_1322 validate_decompression_swz.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Flags field must not contain any unknown flag bits, which can be related to image compression.",
            "Flags field must only contain at most a single map type, used in image encoding.",
            "Decode_unorm8 must only be used with an LDR profile, a type of image compression technique."
        ],
        "FuncName": "astcenc_entry_1322 validate_flags.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "First parse the box header, then extract the image data from the CompositionOffsetBox"
        ],
        "FuncName": "compositionoffsetbox_9641 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \\setHandle\\ << this->hDir << \\ -> \\ << hDir; \\// Sets directory handle for image processing."
        ],
        "FuncName": "windowsworker_6425 setDirectoryHandle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The field has only 4 bits. The value 15 indicates that any number of reference images permitted by the sample entry may be used. This is a common use case in image processing where multiple images are referenced for a single sample."
        ],
        "FuncName": "codingconstraintsbox_2636 setMaxRefPicUsed.txt"
    },
    {
        "Branch": [
            "Write If-Condition box headers"
        ],
        "Loop": [
            "Write Loop-Condition box headers"
        ],
        "Normal": [
            "Write box headers",
            "Compose ISOBMFF bitstream for CompositionOffsetBox"
        ],
        "FuncName": "compositionoffsetbox_9641 writeBox.txt"
    },
    {
        "Branch": [
            "Write encoding constraint box. These strings are image codes."
        ],
        "Loop": [
            "Write encoding constraint box. These strings are image codes."
        ],
        "Normal": [
            "reserved int(26) Write encoding constraint box."
        ],
        "FuncName": "codingconstraintsbox_2636 writeBox.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in image code."
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition in image code."
        ],
        "Normal": [
            "Normal-Str: discard reserved int(26): A reserved integer value in image code."
        ],
        "FuncName": "codingconstraintsbox_2636 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "trainer.be_verbose();",
            "While we are at it, make sure the krr_trainer works with sparse samples",
            "Now test some of the sparse helper functions, specifically designed to handle image data"
        ],
        "FuncName": "svm_c_linear_582 test_sparse.txt"
    },
    {
        "Branch": [
            "test if-conditional kernel functions",
            "test if-conditional kernel functions with alias detection"
        ],
        "Loop": [
            "test loop-conditional kernel functions",
            "test loop-conditional kernel functions with alias detection"
        ],
        "Normal": [
            "test the alias detection",
            "test the alias detection with image type related description"
        ],
        "FuncName": "kernel_matrix_5789 perform_test.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Extract contained box bitstream and type. This involves parsing the sample description box and extracting the contained sample entries.",
                    "Add new sample entry types based on handler if necessary. This step requires a deep understanding of the image type and its associated metadata."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "sampledescriptionbox_279 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "calculate the DPCA matrix and eigenvalues of two samples",
            "calculate the DPCA matrix and eigenvalues of two samples"
        ],
        "FuncName": "discriminant_pca_4915 test5.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "To subtract variance along 3rd axis, perform this operation.",
                    "To subtract variance along 1st axis, perform this operation."
                ]
            }
        ],
        "Normal": [
            "The 1st and 3rd columns of the transformation matrix should be all zero since the 1st and 3rd axes' variation has been eliminated.",
            "The 1st and 3rd columns of the transformation matrix are all zero since all variation along the 1st and 3rd axes has been killed."
        ],
        "FuncName": "discriminant_pca_4915 test3.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Perform subtraction of variance along the 3rd axis in image code: do this"
                ]
            }
        ],
        "Normal": [
            "In image transformation, the 3rd column of the matrix should be zero since variance along the 3rd axis is killed",
            "Image transformation: 3rd column of transformation matrix is all zero since variance along the 3rd axis is removed"
        ],
        "FuncName": "discriminant_pca_4915 test2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "generate a bunch of 4 dimensional vectors and compute the normal PCA transformation matrix",
            "and just make sure it is a unitary matrix as it should be.",
            "check that all eigen values are greater than 0",
            "check that the eigenvalues are sorted",
            "now make sure the serialization worked",
            "now test swap",
            "PCA transformation matrix for image processing, ensuring unitary matrix and sorted eigenvalues"
        ],
        "FuncName": "discriminant_pca_4915 test1.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "top1: %f, %lf seconds, %d images, CIFAR-10 dataset, image classification accuracy evaluation"
        ],
        "FuncName": "cifar_7240 test_cifar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "trainer.be_verbose(); This line enables verbose mode for the trainer.",
            "There shouldn't be any margin violations since this dataset is so trivial.  So that means the objective should be exactly the squared norm of the decision plane (times 0.5), which is a key concept in Support Vector Machines (SVMs).",
            "This statement is related to the image of a decision plane in a high-dimensional space, where each point represents a data sample."
        ],
        "FuncName": "svm_c_linear_582 test_dense.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "tev's strings are always utf8 encoded, however fs::path does not know this. Therefore: convert the string to a std::u8string and pass _that_ string to the fs::path constructor, which will then take care of converting the utf8 string to the native file name encoding for images.",
            "fs::path uses native file system encoding for image file names, which may not be utf8.",
            "utf8 encoded string to fs::path for image file name requires conversion for image file name encoding."
        ],
        "FuncName": "Common_1075 toPath.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "4d: %.2f%%\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "cifar_7240 test_cifar_multi.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Default value of 0. Is actually returned when the filter is empty or when there is no match. This value is used when the image code is not found in the string.",
                    "is actually returned when the filter is empty or when there is no match. This value is used when the image code is not found in the string."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "perform matching on lowercase strings, where the image code is treated as a special character.",
            "we don't want people entering multiple spaces in a row to match everything, including the image code.",
            "match every word of the filter separately, including the image code."
        ],
        "FuncName": "Common_1075 matchesFuzzy.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: initialized with default values",
            "If-Condition-Str: image type related description"
        ],
        "Loop": [
            "Loop-Condition-Str: initialized with default values",
            "Loop-Condition-Str: image type related description"
        ],
        "Normal": [
            "init: image initialization",
            "basic settings: image properties",
            "inputs and outputs: image data processing",
            "properties: image metadata"
        ],
        "FuncName": "IPLFloodFill_303 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "copy data from our buffer",
                    "reading n characters from the buffer as image code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "read more data into our buffer",
                    "copy all the data from our buffer",
                    "reading n characters from the buffer as image code"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "sockstreambuf_8656 xsgetn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "the write was not successful so return that 0 bytes were written, which is a common issue when dealing with image data"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "the write was not successful so return that 0 bytes were written, which is a common issue when dealing with image data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Add a sanity check here to ensure the image data is properly formatted"
        ],
        "FuncName": "sockstreambuf_8656 xsputn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "An error occurred. This is a code string."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sockstreambuf_8656 overflow.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "get properties",
            "double sigma = getProcessPropertyDouble(sigma); double lowThreshold = getProcessPropertyDouble(lowThreshold); double highThreshold = getProcessPropertyDouble(highThreshold);",
            "std::stringstream s; s << Window: ; s << window; addInformation(s.str());",
            "/ Detector parameters",
            "/ Detecting corners in images",
            "/ Normalizing detected corners",
            "/ Drawing red circles around detected corners in images"
        ],
        "FuncName": "IPLFloodFill_303 processInputData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u4e00\u4e2a\u9519\u8bef\u53d1\u751f\u4e86\uff0c\u9700\u8981\u4ece\u8fde\u63a5\u8bfb\u53d6\u5e76\u586b\u5145\u7f13\u51b2\u533a"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u53d1\u751f\u9519\u8bef\u6216\u8fde\u63a5\u8d85\u65f6\uff08EOF\uff09\uff0c\u9700\u8981\u4ece\u8fde\u63a5\u8bfb\u53d6\u5e76\u586b\u5145\u7f13\u51b2\u533a"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u5c06putback\u5b57\u7b26\u590d\u5236\u5230in_buffer\u7684putback\u7ed3\u675f\uff0c\u5e76\u4e14\u8fd9\u4e9b\u5b57\u7b26\u53ef\u80fd\u6765\u81ea\u7f13\u51b2\u533a\u6216\u8fde\u63a5",
            "\u91cd\u7f6ein_buffer\u6307\u9488\uff0c\u51c6\u5907\u8bfb\u53d6\u6765\u81ea\u7f13\u51b2\u533a\u6216\u8fde\u63a5\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26"
        ],
        "FuncName": "sockstreambuf_8656 underflow.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete_result; flood fill object destroyed."
        ],
        "FuncName": "IPLFloodFill_303 destroy.txt"
    },
    {
        "Branch": [
            "Check if console is visible",
            "Check if console is hidden"
        ],
        "Loop": [],
        "Normal": [
            " Only toggle the console if it was actually spawned by tev. If we are running in a foreign console, then we should leave it be.",
            "Console is visible, displaying console related information.",
            "Console is hidden, hiding console related information."
        ],
        "FuncName": "Common_1075 toggleConsole.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Debugging -- dump the proxies to disk",
                    "Verify proxy content matches original file"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Use ImageOutput.write_image interface to write to outproxy",
            "Use ImageBuf.write interface to write to outproxybuf",
            "Now read back in the actual disk file we wrote earlier.",
            "OK, now we have three vectors:",
            "- readbuf contains the bytes we actually wrote to disk",
            "- outproxy.buffer() contains the bytes we wrote to the proxy using",
            "  ImageOutput.write_image().",
            "- outproxybuf.buffer() contains the bytes we wrote to the proxy using",
            "  ImageBuf.write().",
            "These should all match, byte-for-byte.",
            "Image proxy verification: proxy content should match original image data"
        ],
        "FuncName": "imageinout_test_9725 test_write_proxy.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "add this task just to perturb the thread pool before it goes out of scope, ensuring concurrent execution and thread pool utilization.",
                    "verify that exceptions thrown by tasks are properly propagated and handled by the thread pool."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "thread_pool_3376 perform_test.txt"
    },
    {
        "Branch": [
            "Use if statement to check the image type, for example: if (image.type == 'jpg' || image.type == 'png')"
        ],
        "Loop": [
            "Use loop to iterate over the image array, for example: for (let image of images)"
        ],
        "Normal": [
            "clang-format off",
            "clang-format on"
        ],
        "FuncName": "ivmain_9244 getargs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Helpful for debugging to make sure that any crashes dump a stack trace, including image-related errors ",
            " Globally force classic C locale, and turn off all formatting internationalization, for the entire maketx application, which affects image processing ",
            " N.B. This will apply to the default IC that any ImageBuf's get the shared one, used for image caching ",
            " 1 GB cache for storing image data "
        ],
        "FuncName": "maketx_1700 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set the default percentile, including 25th, 50th, and 75th percentiles for image analysis.",
            " Populate the unpacked percentile values, such as brightness, contrast, and saturation, for image enhancement."
        ],
        "FuncName": "astcenc_percentile_tables_8751 get_2d_percentile_table.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "%s: Predicted in %f seconds. Object detected in the image."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "coco_7876 test_coco.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "define the objective function we optimize to find the best filter",
            "optimal momentum filter is one that balances noise reduction and detail preservation"
        ],
        "FuncName": "kalman_filter_5565 find_optimal_momentum_filter.txt"
    },
    {
        "Branch": [
            "Check if image size is 4x4 pixel"
        ],
        "Loop": [
            "Loop through each pixel in the image"
        ],
        "Normal": [
            "Make 4x4 1-channel float source image, value 0.5, write it. This image will be used as a reference.",
            "Make a 4x4 4-channel uint8 buffer, initialize with 0. This buffer will be used to store the image data.",
            "Read in the image, making sure it's the correct size, several different ways, including from a file and from a memory buffer.",
            "Repeat the process for tiled images, where the image is divided into smaller sections.",
            "Clean up any resources used during the image processing."
        ],
        "FuncName": "imageinout_test_9725 test_read_tricky_sizes.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "list *plist = get_paths(/home/pjreddie/data/people-art/test.txt); Object Detection Results: bounding boxes, classes, and scores are detected in the image.",
            "list *plist = get_paths(/home/pjreddie/data/voc/test/2007_test.txt); Object Detection Results: bounding boxes, classes, and scores are detected in the image."
        ],
        "FuncName": "coco_7876 validate_coco.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Allow lossy formats to have a little more error, such as JPEG with a low compression ratio, which may result in a larger file size but still maintain acceptable image quality.",
            "Read the disk file into readbuf as a blob -- just a byte-for-byte copy of the file, but in memory, allowing for efficient processing of large image files.",
            "Read the in-memory file using an ioproxy, with ImageInput, enabling the application to work with various image formats, including compressed and uncompressed ones.",
            "Read the in-memory file using an ioproxy again, but with ImageInput, which facilitates the processing of image data in a flexible and efficient manner."
        ],
        "FuncName": "imageinout_test_9725 test_read_proxy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "define the objective function we optimize to find the best filter for image processing"
        ],
        "FuncName": "kalman_filter_5565 find_optimal_momentum_filter.txt"
    },
    {
        "Branch": [
            "Check the condition before writing to the buffer"
        ],
        "Loop": [
            "Iterate through the data to be written to the buffer"
        ],
        "Normal": [
            "Emulate tiles by buffering the whole image",
            "Write data to the buffer in a tile-based manner"
        ],
        "FuncName": "jpegoutput_4983 write_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Expanding 2-channel image to 3-channel image for edge cases"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Conforming to JFIF's limitation of 1 or 3 channels by temporarily modifying the image specification",
            "to contiguize the first 1 or 3 channels, then restoring it",
            "The tonative_scanline function requires the true number of channels",
            "to arrange the data properly, but modifying the image specification",
            "permanently would affect subsequent calls to write_scanline and write_image"
        ],
        "FuncName": "jpegoutput_4983 write_scanline.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Already closed. JPEG image output closed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We've been emulating tiles; now dump as scanlines. Freeing tile memory."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "But if we've only written some scanlines, write the rest to avoid errors and ensure JPEG compression is complete."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We had an IOProxy of some type that was not IOFile. JPEG image data was written to a memory buffer, which is now being copied to the IOProxy. JPEG output is closed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "jpegoutput_4983 close.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "check if output is free",
                    "click event",
                    "special styling",
                    "image processing"
                ]
            },
            {
                "loopstr": [
                    "check if output is free",
                    "click event",
                    "image compression"
                ]
            }
        ],
        "Normal": [
            "set up GUI",
            "spacer",
            "set default",
            "connect events",
            "image rendering"
        ],
        "FuncName": "ConnectionDialog_2469 ConnectionDialog.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "set output stream",
                    "Writing JPEG data to output stream"
                ]
            },
            {
                "thenstr": [
                    "For 3 or more channels, write the first 3 as RGB and drop any additional channels.",
                    "Converting image data to RGB format for JPEG output"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Two channels are tricky. If the first channel name is Y, assume it's a luminance image and write it as a single-channel grayscale. Otherwise, punt, write it as an RGB image with third channel black.",
                    "Handling two-channel image data for JPEG output"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Back door for copy()",
                    "Copying image data for JPEG output"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0x0404",
                    "four bytes of zeroes",
                    "size of block",
                    "Writing JPEG marker header (APP2 code and marker length)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Calculate the number of markers we'll need, rounding up of course per spec, count starts at 1",
                    "Determining number of JPEG markers needed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "length of profile to put in this marker",
                    "Write the JPEG marker header (APP2 code and marker length)",
                    "NOSONAR",
                    "Processing JPEG marker data"
                ]
            }
        ],
        "Normal": [
            "Save name and spec for later use",
            "NOTE: we appear to let a large number of channels be allowed, but that's only because we robustly truncate to only RGB no matter what we are handed.",
            "set error handler",
            "create compressor",
            "Set image and compression parameters",
            "JFIF can only handle grayscale and RGB. Do the best we can with this limited format by switching to 1 or 3 channels.",
            "next scanline we'll write",
            "Write JPEG comment, if sent an 'ImageDescription'",
            "Write EXIF info",
            "Start the blob with Exif\\ and two nulls.  That's how it always is in the JPEG files I've examined.",
            "Write IPTC IIM metadata tags, if we have anything",
            "Write XMP packet, if we have anything",
            "Write ICC profile, if we have anything",
            "If user asked for tiles -- which JPEG doesn't support, emulate it by buffering the whole image."
        ],
        "FuncName": "jpegoutput_4983 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "prevent selection state, a condition in image processing to remove unwanted pixels"
        ],
        "FuncName": "IPProcessEdge_9857 itemChange.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "add some margin for straight vertical or horizontal lines",
            "edge boundary rectangle",
            "image edge detection"
        ],
        "FuncName": "IPProcessEdge_9857 boundingRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "calculate distance from line to point and check if mouse is on the line",
            "redraw the image with mouse position"
        ],
        "FuncName": "IPProcessEdge_9857 hoverMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "main line",
            "find intersections for arrows",
            "2",
            "image: This is a line",
            "image: Finding intersections for arrows is a crucial step",
            "image: The number 2 represents a specific point"
        ],
        "FuncName": "IPProcessEdge_9857 updatePosition.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO: if mIsTransform changes AFTER the property is associated with an item, we should move it to correct place in the props list. (declarative properties first, then transformative). This is a transformation-related condition.",
                    "This condition is related to image transformation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "RawProperty_7989 setRawType.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "default value",
            "0 0 0",
            "0 1 0",
            "0 0 0",
            "inputs and outputs",
            "properties",
            "image processing",
            "morphological operations",
            "Hit-Miss transformation"
        ],
        "FuncName": "IPLMorphologyHitMiss_3530 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \"Image metadata: \" << m_metadataValue;",
            "qDebug() << \"Image metadata label: \" << m_metadataLabel;"
        ],
        "FuncName": "exiv2wrapper_5333 cacheSections.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "normalize_image(weights[i])",
                    "Extracting convolutional layer weights from image code."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "convolutional_layer_1027 get_weights.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Show the convolutional layer's weights and output: show_image(dc, buff);",
            "Save the convolutional layer's weights and output: save_image(dc, buff);"
        ],
        "FuncName": "convolutional_layer_1027 visualize_convolutional_layer.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "%s: Predicted in %f seconds. Object detection using YOLO algorithm.",
                    "draw_detections(im, l.side*l.side*l.n, thresh, boxes, probs, voc_names, alphabet, 20); Object detection results will be displayed on the image."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "yolo_1046 test_yolo.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Progress in Image Processing"
                ]
            },
            {
                "loopstr": [
                    "Breaks both image loops"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "IPLMorphologyHitMiss_3530 hitmiss.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "copy constructor doesnt work: uses Hit-Miss algorithm to process image data",
            "result = new IPLImage(*image); uses image data from Hit-Miss algorithm",
            "get properties from image data",
            "propertyMutex.lock(); accesses image data mutex",
            "propertyMutex.unlock(); releases image data mutex",
            "the algorithm needs a working plane to process image data"
        ],
        "FuncName": "IPLMorphologyHitMiss_3530 processInputData.txt"
    },
    {
        "Branch": [
            "float scale = 1/sqrt(size*size*c);",
            "If the condition is met, the scale is adjusted accordingly."
        ],
        "Loop": [
            "float scale = 1/sqrt(size*size*c);",
            "The loop iterates until the condition is met, updating the scale accordingly."
        ],
        "Normal": [
            "float scale = 1/sqrt(size*size*c);",
            "The scale is computed using the size and c values."
        ],
        "FuncName": "convolutional_layer_1027 make_convolutional_layer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "list *plist = get_paths(data/voc.2007.test);",
            "list *plist = get_paths(data/voc.2012.test);",
            "YOLO network validation for image classification and object detection.",
            "YOLO network validation for image classification and object detection."
        ],
        "FuncName": "yolo_1046 validate_yolo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init image",
            "basic image settings",
            "image inputs and outputs",
            "all image properties which can later be changed by gui",
            "BMP_DEFAULT|BMP_SAVE_RLE|EXR|J2K|JPEG|JPEG_PROGRESSIVE|",
            "PNG_DEFAULT|PNG_INTERLACED|PNM_SAVE_RAW|PNM_SAVE_ASCII|",
            "TIFF_DEFAULT image format"
        ],
        "FuncName": "IPLSaveImage_9231 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Loaded: %lf seconds\n",
                    "Image loaded: %d images, %lf seconds\n"
                ]
            }
        ],
        "Normal": [
            "%s\n",
            "Learning Rate: %g, Momentum: %g, Decay: %g\n",
            "Image processing: int N = plist->size;\n",
            "while(i*imgs < N*120){\n"
        ],
        "FuncName": "yolo_1046 train_yolo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Allocate memory to store image data with m_cumcapacity.resize(npixels);"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "deepdata_8055 alloc.txt"
    },
    {
        "Branch": [
            "Validate image data integrity and consistency: image integrity check"
        ],
        "Loop": [],
        "Normal": [
            "int nchannels = int (m_channeltypes.size()); image validation: ensure correct number of channels"
        ],
        "FuncName": "deepdata_8055 sanity.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Make the image bigger by a factor of two to detect faces as small as 40 by 40 pixels. This is useful since the face detector looks for faces that are about 80 by 80 pixels or larger. Therefore, if you want to find faces that are smaller than that then you need to upsample the image as we do here by calling pyramid_up().",
                    "Detect faces in the image and get a list of bounding boxes around all the faces.",
                    "Show the image on the screen with the face detections as red overlay boxes and display the results of the face detection."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "face_detection_ex_1338 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This is doing a BSP based grid search for the minimum of f.  Here we use a binary space partitioning algorithm to find the minimum value of f().  We start with an initial grid size and then iteratively shrink the grid size until we reach the minimum value.",
            "We do 100 iterations where we keep shrinking the grid size.  In each iteration, we divide the current grid into two smaller sub-grids and then select the sub-grid that contains the minimum value of f()."
        ],
        "FuncName": "bsp_8650 bsp_job_node_0.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Assume that the image data is already in linear space.",
                    "DDS image file loading, decompression or conversion to target floating point format."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "COM must be initialized on the thread executing load().",
            "DDS image file loading, decompression or conversion to target floating point format."
        ],
        "FuncName": "DdsImageLoader_4618 load.txt"
    },
    {
        "Branch": [
            "image: conditional statement",
            "image: conditional statement"
        ],
        "Loop": [
            "image: loop condition",
            "image: loop condition"
        ],
        "Normal": [
            "image: sending data to node 1 for summation, image: node 1 will accumulate values",
            "image: propagating accumulated values from node 1 to node 0",
            "image: this block is logically redundant and does not perform any meaningful operation",
            "image: this block is logically redundant and does not perform any meaningful operation"
        ],
        "FuncName": "bsp_8650 test4_job_driver.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Data already allocated: set pixels individually. This is an image processing technique used to optimize pixel allocation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "deepdata_8055 set_all_samples.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Data already allocated. Turn it into an insert or delete. Image processing may involve resizing, cropping, or rotating the image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "deepdata_8055 set_samples.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The sample spans depth, so split it.",
                    "See http://www.openexr.com/InterpretingDeepPixels.pdf",
                    "We have to proceed in two passes, since we may reuse the alpha values, we can't overwrite them yet.",
                    "Now that we've adjusted the colors, do the alphas",
                    "Image depth slicing and processing for depth values and sample counts."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is an alpha!",
                    "Alpha channel processing for image data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "z front",
                    "Image depth slicing and processing for depth values and sample counts.",
                    "z back"
                ]
            },
            {
                "loopstr": [
                    "skip if not an alpha",
                    "Alpha channel processing for image data."
                ]
            }
        ],
        "Normal": [
            "No channel labeled Z -- we don't know what to do",
            "The samples are not extended -- nothing to split",
            "No depth or sample count data available for processing."
        ],
        "FuncName": "deepdata_8055 split.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "different number of channels",
            "different sample size -- MUST differ in types",
            "requires identical channel types for DeepData objects"
        ],
        "FuncName": "deepdata_8055 same_channeltypes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Nothing in our pixel yet, so just copy src's pixel",
                    "Deep pixel merge is performed to combine pixel data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No samples to merge",
            "Need to merge the pixels",
            "First, merge all of src's samples into our pixel",
            "Now ALL the samples from both images are in our pixel.",
            "Mutually split the samples against each other.",
            "sort first so we only loop once",
            "Now merge the overlaps",
            "Deep pixel merge is performed to combine pixel data."
        ],
        "FuncName": "deepdata_8055 merge_deep_pixels.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Duplicating pixel: dst pixel was 0x12345678",
                    " std::cout << \"dst pixel was \" << pixel << \"\\n\";"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Copying empty pixel -- set samples to 0 and we're done",
                    "Duplicating pixel: source pixel was 0x12345678",
                    " std::cout << \"Source pixel was \" << srcpixel << \"\\n\";"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "deepdata_8055 copy_deep_pixel.txt"
    },
    {
        "Branch": [
            "If the condition is met, the reduction-tree loop will be executed."
        ],
        "Loop": [
            "The expansion-tree loop will be executed as long as the condition is met."
        ],
        "Normal": [
            "The reduction-tree loop is a type of image code that reduces the size of an image.",
            "The expansion-tree loop is a type of image code that expands the size of an image."
        ],
        "FuncName": "astcenc_compute_variance_7401 brent_kung_prefix_sum.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compute maximum block size and from that the working memory buffer size",
            "Perform block-wise averages calculations across the image",
            "Initialize fields which are not populated until later",
            "Determine the number of parallel tasks for image processing"
        ],
        "FuncName": "astcenc_compute_variance_7401 init_compute_averages.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u8ba1\u6570\u6bcf\u4e2a\u6807\u7b7e\u7684\u56fe\u50cf\u6570\u91cf",
                    "\u56fe\u50cf\u6570\u636e\u96c6\u6807\u7b7e\u7edf\u8ba1"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "main_7653 print_all_label_stats.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Extract contained box bitstream and type",
                    "Handle this box based on the type",
                    "HEVC configuration box: parsing configuration data",
                    "HEVC coding constraint box: parsing coding constraints"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "hevcsampleentry_6994 parseBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Swizzle data structure 4 = ZERO, 5 = ONE, with pixel region variance calculation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Swizzle data structure 4 = ZERO, 5 = ONE (in FP16), with pixel region variance calculation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Summed-area table lookups for alpha average, with pixel region variance calculation"
                ]
            },
            {
                "loopstr": [
                    "Summed-area table lookups for alpha average, with pixel region variance calculation"
                ]
            }
        ],
        "Normal": [
            "Unpack the memory structure into local variables, for image processing",
            "Compute memory sizes and dimensions that we need, for image processing",
            "Scaling factors to apply to Y and Z for accesses into the work buffers, for image processing",
            "Scaling factors to apply to Y and Z for accesses into result buffers, for image processing",
            "Macros to act as accessor functions for the work-memory, for image processing",
            "Load N and N^2 values into the work buffers, for image processing",
            "Pad with an extra layer of 0s; this forms the edge of the SAT tables, for image processing",
            "Generate summed-area tables for N and N^2; this is done in-place, using a Brent-Kung parallel-prefix based algorithm to minimize precision loss, for image processing",
            "Compute a few constants used in the variance-calculation, for image processing",
            "Use the summed-area tables to compute variance for each neighborhood, for image processing"
        ],
        "FuncName": "astcenc_compute_variance_7401 compute_pixel_region_variance.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If nothing is in this pixel or we don't have Z's, just return a huge number. This is related to image pixel transparency.",
                    "return a huge number. This is related to image pixel transparency."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If there aren't alpha channels, just return the closest Z. This is related to image pixel transparency and Z-value calculation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We hit an opaque sample. Return its far side. This is related to image pixel transparency and opaque sample detection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Will be Z if Zback is missing. This is related to image pixel transparency and Z-value calculation.",
            "A[RGB]_channel() returns A_channel if the specific channel is missing. This is related to image pixel transparency and channel handling.",
            "There are samples, Z, and alpha channels. Figure out where it gets opaque. This is related to image pixel transparency and opaque sample detection.",
            "We never hit an opaque sample. Return huge number. This is related to image pixel transparency and Z-value calculation."
        ],
        "FuncName": "deepdata_8055 opaque_z.txt"
    },
    {
        "Branch": [
            "Check if the label is present in the image"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterate through the image and check for the label we are looking for"
                ]
            }
        ],
        "Normal": [
            "Image classification model is trained on a dataset with a specific label"
        ],
        "FuncName": "main_7653 split_dataset.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "don't even bother loading images that don't have objects.",
                    "extract tiles of a specified size from images containing objects.",
                    "figure out what chips we want to take from this image",
                    "extract tiles of a specified size from images containing objects.",
                    "and put the chips into the output."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "main_7653 tile_dataset.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Don't even bother loading images that don't have objects. Image processing requires object presence.",
                    "Figure out what chips we want to take from this image for object-based image analysis."
                ]
            },
            {
                "loopstr": [
                    "Now transform the boxes to the crop and also mark them as ignored if they",
                    "have already been cropped out or are outside the crop. This step ensures accurate object detection.",
                    "Put a 64bit hash of the image data into the name to make sure there are no",
                    "file name conflicts. This prevents data duplication and ensures unique file names."
                ]
            },
            {
                "loopstr": [
                    "Ignore boxes outside the cropped image to maintain object integrity.",
                    "Mark boxes we include in the crop as ignored. Also mark boxes that",
                    "aren't totally within the crop as ignored. This step refines object detection accuracy."
                ]
            }
        ],
        "Normal": [
            "Cropped image will be this times wider than the object, ensuring proper object scaling."
        ],
        "FuncName": "main_7653 resample_dataset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set the current directory to be the one that contains the metadata file. We do this because the file might contain file paths which are relative to this folder. This is a typical operation when working with image datasets, such as rotating images for data augmentation."
        ],
        "FuncName": "main_7653 rotate_dataset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reload uncolored icon with updated color palette"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "iconwidget_4731 setColorMode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " We need to calculate the image size and consider metadata rotation. This involves checking if the image is rotated by metadata and adjusting the values accordingly."
        ],
        "FuncName": "Utils_677 getSizeWithMetadata.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " remap the indices to match the closest code in the codebook",
                    " save the block of points that are closest to the code",
                    " save the error that results from mapping to the code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " find the closest code in the codebook to each point",
                    " save the index of the closest code",
                    " accumulate the error that results from mapping to the code"
                ]
            }
        ],
        "Normal": [
            " cache some values in the codebook",
            " create a codebook that maps points to codes",
            " match each point to the closest code in the codebook",
            " save this scheme if it results in the lowest error"
        ],
        "FuncName": "rangefit_2542 Compress4.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "automatically increment ID",
            "add input",
            "image code string"
        ],
        "FuncName": "IPLProcess_7405 addInput.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "propertyMutex.lock(); // Locking the mutex for image processing.",
            "propertyMutex.unlock(); // Unlocking the mutex after image processing."
        ],
        "FuncName": "IPLProcess_7405 setProperty.txt"
    },
    {
        "Branch": [
            "Check if image condition is met"
        ],
        "Loop": [
            "Loop through image collection"
        ],
        "Normal": [
            "automatically increment ID",
            "related to image processing"
        ],
        "FuncName": "IPLProcess_7405 addOutput.txt"
    },
    {
        "Branch": [
            "When DICOM file is loaded, check if it contains any image data."
        ],
        "Loop": [
            "For each image in the DICOM file, process its metadata."
        ],
        "Normal": [
            "If user doesn't want to provide any config, just use an empty spec.",
            "The image data is stored in the DICOM file's pixel data element."
        ],
        "FuncName": "dicominput_4267 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find the minimum and maximum values and their indices, calculate the shift value, and write the ARW encoded binary data. These strings are for image processing."
        ],
        "FuncName": "arw_encode_1364 arw_encode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If user doesn't want to provide any config, just use an empty spec.",
            "Open specified DICOM file and store its information into ImageSpec object."
        ],
        "FuncName": "dicominput_4267 open.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Get convolutional layer weights: normalize_image(weights[i]);"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "convolutional_layer_222 get_weights.txt"
    },
    {
        "Branch": [
            "If the condition is met, the image will be processed."
        ],
        "Loop": [
            "The loop will iterate over the image pixels."
        ],
        "Normal": [
            "float scale = 1.0/sqrt(size*size*c);",
            "This line calculates the scale factor for the image pixels."
        ],
        "FuncName": "convolutional_layer_222 make_convolutional_layer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "show convolutional layer weights and outputs: show_image(dc, buff);",
            "save convolutional layer weights and outputs: save_image(dc, buff);"
        ],
        "FuncName": "convolutional_layer_222 visualize_convolutional_layer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "already there",
                    "DICOM subimage found"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Want an earlier subimage, Easier to close and start again",
                    "Searching for DICOM subimage"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Open if it's not already opened",
            "Advance to the desired DICOM subimage"
        ],
        "FuncName": "dicominput_4267 seek_subimage.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Notify other hosts of the expected incoming connection count"
                ]
            }
        ],
        "Normal": [
            "Inform each node of its node ID",
            "Now inform them who will connect"
        ],
        "FuncName": "bsp_5482 send_out_connection_orders.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Write DICOM metadata to XML."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Note: casting to float may not be necessary."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "DICOM VR codes explained:",
                    "https://dicom.nema.org/Dicom/2013/output/chtml/part05/sect_6.2.html"
                ]
            }
        ],
        "Normal": [
            "Failed to retrieve metadata from DicomImage.",
            "Opening file again with DcmFileFormat.",
            "Unable to get DICOM metadata."
        ],
        "FuncName": "dicominput_4267 read_metadata.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "tellt otherendournodeid"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "bsp_5482 connect_all.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Layout-independent method for creating keyboard shortcuts, mostly using native keyboard layout.",
            "-------------------------",
            "Still has some issues like when you use two layouts with different characters on the same button.",
            "For example, a letter on one layout and a symbol on the other.",
            "I'm leaving this as-is because trying to fix all layouts will turn into a mess quickly.",
            "You can always add the same keybind using your alternative layout if it doesn't work.",
            "Use alternative characters accessed by shift key, such as punctuation on the numbers row.",
            "Debug message: \"RESULT: \" << sequence;"
        ],
        "FuncName": "shortcutbuilder_6251 fromEventNativeScanCode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remove Key_ at the beginning",
                    "rename some keys to match the ones from inputmap",
                    "just a bandaid",
                    "image: a shortcut key sequence built from event text"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "image: no condition specified for loop"
        ],
        "Normal": [
            "layout-dependent method",
            "-------------------------",
            "Works on platforms for which there is no native scancode support from Qt.",
            "Keybinds will work only on the same layout they were added (except non-printables).",
            "image: a layout-dependent method for keybinds"
        ],
        "FuncName": "shortcutbuilder_6251 fromEventText.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure the range is good and set image properties",
            "set image values and attributes",
            "determine if increasing element count affects image rendering"
        ],
        "FuncName": "Writer_602 SetElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "write image data to ensure a good range",
            "validate image entry to prevent errors",
            "The DPX specification mandates that image data begins on an 8K boundary for optimal performance",
            "update file pointer for proper image data",
            "write image data to the file"
        ],
        "FuncName": "Writer_602 WriteElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " make sure the range is good and the image data starts on a 8K boundary.",
            " make sure the entry is valid for image data.",
            " The DPX spec recommends that image data starts on a 8K boundary and should be written correctly.",
            " update file ptr for image writing.",
            " write image data to file."
        ],
        "FuncName": "Writer_602 WriteElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "write image data, including type and format, to ensure correct file writing for image elements",
            "ensure image entry validity",
            "The DPX spec recommends that image data starts on an 8K boundary for optimal image rendering",
            "update file pointer for image writing",
            "perform image write operation"
        ],
        "FuncName": "Writer_602 WriteElement.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u4e0d\u53d1\u9001\u5230\u81ea\u5df1\u6216\u5df2\u7ec8\u6b62\u7684\u8282\u70b9\uff0c\u5411\u5176\u4ed6\u8282\u70b9\u5e7f\u64ad\u4e00\u4e2a\u5b57\u8282\u7684\u503c\u3002"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "bsp_5482 broadcast_byte.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5faa\u73af\u5982\u679c\u6709\u6362\u884c\u7b26\u586b\u5145\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u5199\u4e00\u884c\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d",
                    "\u5199\u6362\u884c\u7b26\u586b\u5145\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d"
                ]
            }
        ],
        "Normal": [
            "\u6587\u4ef6\u6307\u9488\u4f4d\u7f6e\u540e\u5199\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d",
            "\u5199\u6570\u636e\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d",
            "\u56fe\u50cf\u7ed3\u675f\u586b\u5145\uff0c\u5199\u6570\u636e\u5230\u6587\u4ef6\u4e2d"
        ],
        "FuncName": "Writer_602 WriteThrough.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Note that the reason we have this epoch counter is so we can tell if a sent message is from before or after one of these all nodes waiting synchronization events.  If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial.",
                    "sent message is from before or after one of these all nodes waiting synchronization events.  If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial.",
                    "If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial.",
                    "If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial.",
                    "If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial.",
                    "If we didn't have the epoch count we would have a race condition where one node gets the SEE_ALL_IN_WAITING_STATE message before others and then sends out a message to another node before that node got the SEE_ALL_IN_WAITING_STATE message.  Then that node would think the normal message came before SEE_ALL_IN_WAITING_STATE which would be bad. This is related to image processing where synchronization is crucial."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If there aren't any nodes left to give us messages then return right now. We need to check the msg_buffer size to make sure there aren't any unprocessed message there. Recall that this can happen because status messages always jump to the front of the message buffer.  So we might have learned about the node terminations before processing their messages for us. This is related to image processing where data buffering is crucial.",
                    "If all running nodes are currently blocking forever on receive_data() end switch() This is related to image processing where data reception is crucial."
                ]
            }
        ],
        "Normal": [
            "end while (true) This is related to image processing where continuous execution is crucial."
        ],
        "FuncName": "bsp_5482 receive_data.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "tell the other end that we are intentionally dropping the connection"
                ]
            },
            {
                "loopstr": [
                    "tell the other end that we are intentionally dropping the connection"
                ]
            }
        ],
        "Normal": [
            "now wait for all the other nodes to terminate"
        ],
        "FuncName": "bsp_5482 close_all_connections_gracefully.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (fp != stdout) fclose(fp); This is an image file, which is saved in PBM format."
        ],
        "FuncName": "image-pnm_6952 image_save_pnm.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "optimize the single big Q and b in image processing"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "opt_qp_solver_2145 test_solve_qp_box_constrained_blockdiag.txt"
    },
    {
        "Branch": [
            "Image Condition: Write file size in the header",
            "Image Condition: Rewrite all of the offsets in the header"
        ],
        "Loop": [],
        "Normal": [
            "Image Description: Write file size in the header",
            "Image Description: Rewrite all of the offsets in the header"
        ],
        "FuncName": "Writer_602 Finish.txt"
    },
    {
        "Branch": [
            "Check for updated replies",
            "Parse JSON data",
            "Update latest version number",
            "Update log and publish date"
        ],
        "Loop": [],
        "Normal": [
            "Remove heading",
            "Remove additional newline if present"
        ],
        "FuncName": "updatechecker_1354 readReply.txt"
    },
    {
        "Branch": [
            "If-Condition-Str with image description: This string is used in image code to represent a conditional statement."
        ],
        "Loop": [
            {
                "loopstr": [
                    " cout << \\ni: << i << endl; cout << best eval x: << trans(x); cout << best eval y: << y << endl; cout << best eval function index: << function_idx << endl; This loop is used in image code to iterate over a sequence of values."
                ]
            }
        ],
        "Normal": [
            "Normal-Str with image description: This string is used in image code to represent a normal statement."
        ],
        "FuncName": "global_optimization_5958 test_global_function_search.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "test with some graph regularization terms and image processing techniques"
                ]
            }
        ],
        "Normal": [
            "build out the dense version of the QP so we can test it against the dense solver with image analysis.",
            "now make sure the two solvers agree on the outputs and image results."
        ],
        "FuncName": "opt_qp_solver_2145 test_solve_qp_box_constrained_blockdiag_compact.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " const double obj1 = 0.5*trans(solution)*m*solution + trans(solution)*b; const double obj2 = 0.5*trans(true_solution)*m*true_solution + trans(true_solution)*b; cout << iters: << iters << endl; cout << obj1: << obj1 << endl; cout << obj2: << obj2 << endl; cout << obj1-obj2: << obj1-obj2 << endl; "
        ],
        "FuncName": "opt_qp_solver_2145 test_solve_qp_box_constrained.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "generate two groups of points that are pairwise close within each set and",
            "pairwise far apart between each set, according to dist_thresh distance threshold.",
            "make sure we generated the points correctly.",
            "It is slightly counterintuitive but true that points picked using the above procedure",
            "will have elements of their convex hulls that are much closer together than",
            "dist_thresh, even though none of the vertices of the hulls are that close",
            "together.  This is especially true in high dimensions.  So let's use this to",
            "test find_gap_between_convex_hulls().  It should be able to find a pair of",
            "points in the convex hulls of our sets that are a lot closer together than",
            "dist_thresh.",
            "First we need to convert the vectors to matrices.",
            "make sure c1 and c2 are convex combinations.",
            "now test that the points found are close together.",
            "Convex hulls are a fundamental concept in geometry and computer science, used to",
            "define the shape of an object or a set of points. They are particularly useful",
            "in image processing, computer vision, and machine learning applications.",
            "In the context of image processing, convex hulls can be used to extract the",
            "contour of an object from an image, or to detect shapes and patterns within",
            "an image. They can also be used to describe the shape of a set of points,",
            "such as a set of pixels in an image, and to compute various shape descriptors",
            "such as the area, perimeter, and convexity of the shape."
        ],
        "FuncName": "opt_qp_solver_2145 test_find_gap_between_convex_hulls.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The Holder function, a mathematical function used in global optimization problems.",
            "return -abs(sin(x0)*cos(x1)*exp(abs(1-sqrt(x0*x0+x1*x1)/pi)));",
            "A more complex version of the Holder function with discontinuities and multiple local minima.",
            "The Holder function tilted towards the point (10,10)."
        ],
        "FuncName": "global_optimization_5958 complex_holder_table.txt"
    },
    {
        "Branch": [
            "if condition"
        ],
        "Loop": [
            "loop condition"
        ],
        "Normal": [
            "should fail int",
            "image type: int"
        ],
        "FuncName": "paramlist_test_18 test_paramlist.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " should fail int, the image type requires a valid image file or a string describing an image."
        ],
        "FuncName": "paramlist_test_18 test_paramlistspan.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if a has closed normally",
                    "establish a link between a and b"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "signal that the link() function is ending",
                    "throw the exception for this error",
                    "terminate the link between a and b"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if there was an error reading from the socket",
                    "if there was an error writing to the socket then break",
                    "retry the data transfer between a and b"
                ]
            }
        ],
        "Normal": [
            "make sure requires clause is not broken",
            "if we fail to make the thread",
            "forward data from a to b using image processing",
            "becomes true if one of the connections returns an error",
            "if there was an error then shutdown both connections and delete image data",
            "wait for the other thread to end and process image",
            "make sure connections are shutdown and image data is deleted",
            "both threads have ended so the connections are no longer needed and image processing is complete",
            "if service_connection terminated due to an error then set error to true and discard image",
            "if we are ending because of an error",
            "signal that the link() function is ending and image processing is terminated"
        ],
        "FuncName": "linker_kernel_1_9260 link.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "signal that this function is ending",
                    "image: a red circle with a line through it, indicating cancellation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "if b has closed normally",
                    "image: a green checkmark, indicating success"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if there was an error reading from the socket",
                    "image: a magnifying glass with a red X, indicating error",
                    "if there was an error writing to the socket then break",
                    "image: a broken chain, indicating interruption"
                ]
            }
        ],
        "Normal": [
            "if the connections are gone for whatever reason then return",
            "image: a person leaving, indicating departure",
            "forward data from b to a",
            "image: a arrow pointing from b to a, indicating data transfer",
            "if there was an error then shutdown both connections",
            "image: a warning sign, indicating caution",
            "if there was an error then signal that",
            "image: a red flag, indicating alert",
            "signal that this function is ending"
        ],
        "FuncName": "linker_kernel_1_9260 service_connection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For the sake of test time, reduce the default iterations for DEBUG, CI, and code coverage builds. Explicit use of --iters or --trials will override this, since it comes before the getargs() call. This is an image code related string."
        ],
        "FuncName": "filter_test_6425 main.txt"
    },
    {
        "Branch": [
            "The if condition is checked when the application is running.",
            "This string is related to the image of a conditional statement."
        ],
        "Loop": [
            "The loop condition is checked repeatedly until the condition is met.",
            "This string is related to the image of a loop structure."
        ],
        "Normal": [
            "TODO: finish changelogs",
            "When the changelogs are shown, the application will display the changelog window.",
            "This string is related to the image of a changelog window."
        ],
        "FuncName": "core_4031 onUpdate.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Graph it with filter"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "filter_test_6425 graph_2d.txt"
    },
    {
        "Branch": [
            "mimeData->text() should already contain an url to copy to clipboard"
        ],
        "Loop": [],
        "Normal": [
            "mimeData->text() should already contain an url to copy to clipboard"
        ],
        "FuncName": "core_4031 copyFileClipboard.txt"
    },
    {
        "Branch": [
            "When the file is activated, the file path will be loaded.",
            "When the file is activated, the file path will be loaded. This is a code string."
        ],
        "Loop": [
            "When the file is activated, the file path will be loaded.",
            "When the file is activated, the file path will be loaded. This is a code string."
        ],
        "Normal": [
            "We are not using asynchronous loading, so it will not flicker. Image loading is a common operation in web development."
        ],
        "FuncName": "core_4031 onDirectoryViewFileActivated.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "clang-format off",
            "ap.arg(--threads %d, &numthreads)",
            "This line is related to the image processing and describes the number of threads used.",
            "help(Strutil::fmt::format(Number of threads (default: {}) numthreads));",
            "clang-format on"
        ],
        "FuncName": "filter_test_6425 getargs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO: this is unreliable. GUI display.",
            " how to make it wait until a window is shown? GUI rendering."
        ],
        "FuncName": "core_4031 showGui.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Graph it: This string is associated with an image of a graph.",
                    "Time it: This string is associated with an image of a timer."
                ]
            }
        ],
        "Normal": [
            "bench.units (Benchmarker::Unit::ms): This string is associated with an image of a benchmark unit."
        ],
        "FuncName": "filter_test_6425 graph_1d.txt"
    },
    {
        "Branch": [
            "Welcome to our program! This is the first version: 1.0."
        ],
        "Loop": [],
        "Normal": [
            "Welcome to our program! This is the first version: 1.0. Now, let's show some sort of welcome screen."
        ],
        "FuncName": "core_4031 onFirstRun.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no files left",
            "image mode && removed current file && updated UI and status"
        ],
        "FuncName": "core_4031 onFileRemoved.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no files left. Please load a new image file to continue.",
            "image mode enabled. Removed current file. Load a new image file to proceed."
        ],
        "FuncName": "core_4031 onFileRenamed.txt"
    },
    {
        "Branch": [
            "update file information"
        ],
        "Loop": [
            "load first file"
        ],
        "Normal": [
            "update file count",
            "load first file image description: The first file is loaded and its information is updated."
        ],
        "FuncName": "core_4031 onFileAdded.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "temporarily copypasted from ImageStatic needs refactoring",
                    "backup the original file if possible",
                    "save file",
                    "------------------------------------------",
                    "opening image from clipboard"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "everything ok remove the backup",
                    "image opened successfully"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "revert on fail",
                    "failed to open image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "try opening url",
            "try to save buffer image then open",
            "opening image from clipboard"
        ],
        "FuncName": "core_4031 openFromClipboard.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "overwriting file with a folder",
                    "remove dst file; give up if not writable",
                    "interactive copy or move file or directory"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "SINGLE FILE COPY ===========================================================================",
            "DIR COPY (RECURSIVE) =======================================================================",
            "copy all contents",
            "TODO: skip symlinks? test",
            "interactive directory copy"
        ],
        "FuncName": "core_4031 doInteractiveCopy.txt"
    },
    {
        "Branch": [
            "if the image has a central difference derivative"
        ],
        "Loop": [
            "loop through the image to calculate the derivative"
        ],
        "Normal": [
            "flags force one byte per channel output, calculate the central difference derivative of the image"
        ],
        "FuncName": "gradient_8813 central_differences.txt"
    },
    {
        "Branch": [
            "read png image header and pixel data"
        ],
        "Loop": [],
        "Normal": [
            "flags force one byte per channel output",
            "png image pixel data processing"
        ],
        "FuncName": "libpng_test_8081 main.txt"
    },
    {
        "Branch": [
            "Compute Sobel x-derivative of image"
        ],
        "Loop": [
            "Compute Sobel y-derivative of image"
        ],
        "Normal": [
            "flags force one byte per channel output. Sobel operator used to compute the gradient of the image in the x and y directions."
        ],
        "FuncName": "gradient_8813 sobel_operator.txt"
    },
    {
        "Branch": [
            "Randomly select n paths from the given path. These are string representations of image codes."
        ],
        "Loop": [
            {
                "loopstr": [
                    "if(i == 0) printf(%s\n, paths[index]);"
                ]
            }
        ],
        "Normal": [
            "These strings are related to image processing and analysis."
        ],
        "FuncName": "data_6713 get_random_paths.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "workaround for mpv. If we play video while mainwindow is hidden we get black screen. This issue is related to image playback and requires a specific image type.",
                    "affects only initial startup (e.g. we open webm from file manager) and is related to image rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "core_4031 guiSetImage.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Detecting straight lines in an image using Hough transform.",
                    "Generate a line segment that is rotating around inside the image.",
                    "The line is generated based on the values in angle1 and angle2.",
                    "Each iteration creates a slightly different line.",
                    "A point 90 pixels away from the center of the image but rotated by angle1.",
                    "Now make a line that goes through arc but rotate it by angle2.",
                    "Next, blank out the input image and then draw our line on it.",
                    "Pick the window inside img on which we will run the Hough transform.",
                    "Now let's compute the hough transform for a subwindow in the image.",
                    "The output is stored in himg.",
                    "The Hough image pixel with the largest value indicates where the line is.",
                    "We find the coordinates of the largest pixel:",
                    "The ht object gives us the line segment in the original image that corresponds to this point in Hough transform space.",
                    "Finally, let's display all these things on the screen.",
                    "We copy the original input image into a color image and then draw the detected line on top in red.",
                    "The detected line is exactly contained within the subwindow and overlaps the original line.",
                    "We can also display the Hough transform itself using the jet color scheme."
                ]
            }
        ],
        "Normal": [
            "Creating an input image for the Hough transform.",
            "The Hough transform will operate on a 300x300 subwindow of its input image.",
            "Detecting straight lines in an image using Hough transform."
        ],
        "FuncName": "hough_transform_ex_1922 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Loading and processing image data: %d images loaded.",
            "printf(Loading image data: %d\\n, rand());"
        ],
        "FuncName": "data_6713 load_thread.txt"
    },
    {
        "Branch": [
            "Read the label from the given path and load it into the matrix."
        ],
        "Loop": [],
        "Normal": [
            "Read the label from the given path and load it into the matrix, a common operation in image processing."
        ],
        "FuncName": "data_6713 load_tags_paths.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Make a temporary copy so we for sure have a 0-terminated string.",
                    "Grab the first value from it",
                    "Skip the value (eat until we find a delimiter -- space, comma, tab)",
                    "Skip the delimiter",
                    "done if nothing left to parse",
                    "Image analysis: Detecting text within the image to understand the parsing process."
                ]
            }
        ],
        "Normal": [
            "Erase any leading whitespace",
            "Image processing: Removing unnecessary whitespace to improve image clarity."
        ],
        "FuncName": "paramlist_1196 parse_elements.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "character %c"
                ]
            }
        ],
        "Normal": [
            "newline character \n"
        ],
        "FuncName": "data_6713 print_letters.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "normalize_data_rows(d); image data normalized",
            "translate_data_rows(d, -128); image data translated"
        ],
        "FuncName": "data_6713 load_all_cifar10.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "printf(%d\n, count); // Image code: printf\u51fd\u6570\u7528\u4e8e\u8f93\u51fa\u6570\u5b57"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "data_6713 fill_hierarchy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Special case for retrieving a string already in string form, which is a code in the image format.",
            " super inexpensive."
        ],
        "FuncName": "paramlist_1196 get_ustring.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Special case for retrieving a string already in ustring form, which includes image codes such as Unicode characters, emojis, and ASCII art, super inexpensive.",
            "Note: Image codes are represented as Unicode characters, which can include images, icons, and other visual elements."
        ],
        "FuncName": "paramlist_1196 get_ustring_indexed.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Writing a 16bit ppm file, utilizing PPM image format for raw pixel data output."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Debugging statement, utilizing std::cerr for console output, writing raw pixel data to PNM file using PNMOutput::write_raw()."
        ],
        "FuncName": "pnmoutput_1515 write_raw.txt"
    },
    {
        "Branch": [
            "Parameter value retrieval for conditional statements in image processing",
            "Default value returned if parameter not found in image processing pipeline"
        ],
        "Loop": [
            "Parameter value retrieval for loop conditions in image processing",
            "Default value returned if parameter not found in image processing pipeline"
        ],
        "Normal": [
            "Special case for retrieving a string already in ustring form",
            "super inexpensive",
            "Related to image processing: parameter value retrieval for normal cases"
        ],
        "FuncName": "paramlist_1196 get_ustring.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Default implementation: write each scanline individually",
                    "start at the last scanline",
                    "PNM output file format: each scanline is written individually"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "pnmoutput_1515 write_scanlines.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Handle tile emulation -- output the buffered pixels",
                    "Pixel data output"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "pnmoutput_1515 close.txt"
    },
    {
        "Branch": [
            "If condition string"
        ],
        "Loop": [
            "Loop condition string"
        ],
        "Normal": [
            "Special case for retrieving a string already in ustring form, which may include image-related metadata such as image dimensions, resolution, or file format.",
            "super inexpensive image processing."
        ],
        "FuncName": "paramlist_1196 get_ustring.txt"
    },
    {
        "Branch": [
            "Image condition string: a string that represents a condition to check for an image.",
            "Image condition string: a string that represents a condition to check for an image."
        ],
        "Loop": [
            "Image loop condition string: a string that represents a condition to loop through images.",
            "Image loop condition string: a string that represents a condition to loop through images."
        ],
        "Normal": [
            "Image retrieval string: a string that retrieves a string value from a specified name, or returns a specified default value. These strings are used in image code.",
            "Image retrieval string: a string that retrieves a string value from a specified name, or returns a specified default value. These strings are used in image code."
        ],
        "FuncName": "paramlist_1196 get_ustring.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "a conversion happened... PNMOutput::write_scanline() writes a scanline to a PBM image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "DBG std::cerr << PNMOutput::write_scanline()n; PNMOutput::write_scanline() writes a scanline to a PBM image."
        ],
        "FuncName": "pnmoutput_1515 write_scanline.txt"
    },
    {
        "Branch": [
            "Write image buffer block if condition is met"
        ],
        "Loop": [
            "Write image buffer block in loop if condition is met"
        ],
        "Normal": [
            "Emulate tiles by buffering the whole image and writing image buffer block"
        ],
        "FuncName": "pnmoutput_1515 write_tile.txt"
    },
    {
        "Branch": [
            "Insert image into cache, return success or failure"
        ],
        "Loop": [],
        "Normal": [
            "TODO: what state returns here, insert image into cache with description"
        ],
        "FuncName": "cache_1856 insert.txt"
    },
    {
        "Branch": [
            "conditional image check"
        ],
        "Loop": [
            "loop through image array"
        ],
        "Normal": [
            "image usage based on type"
        ],
        "FuncName": "printinfo_4782 brief_format_name.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Ensure uniform printing of NaN and Inf on all platforms",
                    "This is related to image processing, where NaN and Inf values are common in image data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "printinfo_4782 print_nums.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Force a read now for reasonable-sized first images in the file. This can greatly speed up the multithread case for tiled images by not having multiple threads working on the same image lock against each other on the file handle. Image processing involves reading images from the file into a buffer. These strings are related to image processing codes.",
                    " This can greatly speed up the multithread case for tiled images by not having multiple threads working on the same image lock against each other on the file handle. Image processing involves reading images from the file into a buffer. These strings are related to image processing codes.",
                    " We guess that reasonable size is 200 MB, that's enough to hold a 4k RGBA float image. Larger things will simply fall back on ImageCache. Image processing involves reading images from the file into a buffer. These strings are related to image processing codes.",
                    " simply fall back on ImageCache. Image processing involves reading images from the file into a buffer. These strings are related to image processing codes."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "printinfo_4782 read_input.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Before sha-1, be sure to point back to the highest-res MIP level",
                    "This involves retrieving image metadata and processing it for serialization."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Requested a subset of metadata but not res, etc.? Kill first line.",
                    "This requires analyzing the image metadata to determine which information to include."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We print info about how many subimages are stored in file",
                    "only when we have more then one subimage",
                    "This involves iterating over the image data to count the number of subimages."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Totalsize += imagebytes;",
                    "This involves calculating the total size of the image data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Info about num of subimages and their resolutions",
                    "This requires accessing the image metadata to retrieve information about the subimages and their resolutions."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case for first line in serialized text case.",
                    "This involves handling the first line of the serialized text differently than the rest."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Count MIP levels",
            "Unescape the strings if we're printing for human consumption, except for",
            "the first line which corresponds to the filename and on windows might",
            "contain backslashes as path separators."
        ],
        "FuncName": "printinfo_4782 print_info_subimage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special handling of deep data",
                    "Image type: code, Description: Output depth data to a specified output stream."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "printinfo_4782 dump_data.txt"
    },
    {
        "Branch": [
            "Testing image cache performance with if condition"
        ],
        "Loop": [
            "Testing image cache performance with loop condition"
        ],
        "Normal": [
            "Don't hold anything while testing image cache performance"
        ],
        "FuncName": "imagespeed_test_3867 test_read.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Reading 64 lines of image data. UNKNOWN -> native"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imagespeed_test_3867 time_read_64_scanlines_at_a_time.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " std::cout << float(sum/npixels/iters) << \n; // Average channel value of 3D image"
        ],
        "FuncName": "imagespeed_test_3867 time_loop_pixels_3D_getchannel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "std::cout << float(sum/npixels/iters) << 'Average pixel value: ' << std::endl;"
        ],
        "FuncName": "imagespeed_test_3867 time_loop_pixels_1D.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "UNKNOWN -> native: Reads a line of pixel data from a file."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imagespeed_test_3867 time_read_scanline_at_a_time.txt"
    },
    {
        "Branch": [
            "write image data to output file if condition is met"
        ],
        "Loop": [],
        "Normal": [
            "write image data to output file"
        ],
        "FuncName": "imagespeed_test_3867 time_write_imagebuf.txt"
    },
    {
        "Branch": [
            "If the average pixel value is greater than 128, then the image is considered bright."
        ],
        "Loop": [
            "Loop through each pixel in the image and calculate its average value."
        ],
        "Normal": [
            "The average pixel value is calculated by summing up all pixel values and dividing by the total number of pixels and iterations.",
            " std::cout << float(sum/npixels/iters) << \n;",
            "This value represents the overall brightness of the image."
        ],
        "FuncName": "imagespeed_test_3867 time_iterate_pixels_slave_pos.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculates the average pixel value of a 3D image after a specified number of iterations. The formula used is sum/npixels/iters."
        ],
        "FuncName": "imagespeed_test_3867 time_loop_pixels_3D.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " std::cout << float(sum/npixels/iters) << \n; // Display the average pixel value of the image.",
            "std::cout << float(sum/npixels/iters); // Display the average pixel value of the image."
        ],
        "FuncName": "imagespeed_test_3867 time_iterate_pixels.txt"
    },
    {
        "Branch": [
            "Check if the image exists and is not corrupted"
        ],
        "Loop": [
            "Loop through each pixel in the image"
        ],
        "Normal": [
            " Otherwise leave at the default",
            "The image data format is set to RGB"
        ],
        "FuncName": "imagespeed_test_3867 set_dataformat.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculate the average pixel value in the entire image: "
        ],
        "FuncName": "imagespeed_test_3867 time_iterate_pixels_slave_incr.txt"
    },
    {
        "Branch": [
            "QR decomposition is a factorization of a matrix into a product of an orthogonal matrix Q and a triangular matrix R."
        ],
        "Loop": [
            "QR decomposition can be used to solve systems of linear equations."
        ],
        "Normal": [
            "none of the matrices we should be passing in to test_qr() should be non-full rank.",
            "now make us a non-full rank matrix",
            "In QR decomposition, the matrix Q is orthogonal, meaning that its transpose is its inverse: Q^T = Q^-1."
        ],
        "FuncName": "matrix_qr_2719 test_qr.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " for image points within 13 units from the origin, the condition is met"
                ]
            },
            {
                "loopstr": [
                    " for image parameters, the trainer requires sigma and fraction correctly classified",
                    " for image kernel matrices, symmetry and positive semidefiniteness are required"
                ]
            }
        ],
        "Normal": [
            " We are going to be working with 2 dimensional image samples and trying to perform",
            " binary classification on them using our new ukf_kernel.",
            " Now let's generate some image training data",
            " A valid image kernel must always give rise to kernel matrices which are symmetric ",
            " and positive semidefinite (i.e. have nonnegative eigenvalues).  This next",
            " bit of code makes a kernel matrix and checks if it has these properties.",
            " here we make an instance of the krr_trainer object that uses our new image kernel.",
            " Finally, let's test how good our new image kernel is by doing some leave-one-out cross-validation.",
            " Since it is very easy to make a mistake while coding a derivative it is a good idea",
            " to compare your derivative function against a numerical approximation and see if",
            " the results are similar.  If they are very different then you probably made a ",
            " mistake.  So here we compare the results at a test image point. "
        ],
        "FuncName": "using_custom_kernels_ex_3712 main.txt"
    },
    {
        "Branch": [
            "If the sum of two numbers is greater than the maximum value of the data type, store the carry in the most significant digit of the result.",
            ""
        ],
        "Loop": [
            "Add the current number and the carry, and put the low word of the result into the register.",
            "Add the current number and the carry, and put the low word of the result into the register."
        ],
        "Normal": [
            "Put the value of the carry part of the result into the carry part of the temporary variable.",
            "One past the end of the current number.",
            "If there is a final carry, add it to the result."
        ],
        "FuncName": "bigint_kernel_2_1760 short_add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u4e0d\u8981\u6301\u6709\u4efb\u4f55\u4e1c\u897f\uff0c\u50cf\u7d20\u8fed\u4ee3",
            "\u5f3a\u5236\u6574\u4e2a\u56fe\u50cf\u4e00\u6b21\u6027\u5168\u90e8\u8bfb\u53d6\u5e76\u663e\u793a"
        ],
        "FuncName": "imagespeed_test_3867 test_pixel_iteration.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "subtract *number2 from *number1 and then subtract any carry. This operation is typical in image processing when dealing with pixel values, where subtracting a large integer from another large integer is a common operation.",
                    "put the low word of temp into *r. The result of the subtraction is then stored in the register *r, which can be further processed for image analysis."
                ]
            },
            {
                "loopstr": [
                    "subtract the carry from *number1. In image processing, the carry can be thought of as the remaining value after a subtraction operation, which needs to be accounted for to maintain the accuracy of the result.",
                    "put the low word of temp into *r. The result of the subtraction is then stored in the register *r, which can be further processed for image analysis."
                ]
            }
        ],
        "Normal": [
            "adjust the number of digits used appropriately. In image processing, the number of digits used to represent pixel values can affect the accuracy of the result, so adjusting the number of digits is crucial for obtaining a precise image."
        ],
        "FuncName": "bigint_kernel_2_1760 long_sub.txt"
    },
    {
        "Branch": [
            "Perform subtraction on uint16 values to obtain a data_record object"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Subtract the carry from the *number to get the result",
                    "Put the low word of temp into the register *r"
                ]
            }
        ],
        "Normal": [
            "Put the low word of temp into the data location *data",
            "Check if a digit was lost during the subtraction"
        ],
        "FuncName": "bigint_kernel_2_1760 short_sub.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " put the carry into the most significant digit in the result",
                    "This operation is performed when the current digit of min_num is greater than the current digit of max_num."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " add *min_num, *max_num and the current carry",
                    " put the low word of temp into *r",
                    "This loop continues until all digits of min_num and max_num have been processed."
                ]
            },
            {
                "loopstr": [
                    " add *max_num and the current carry",
                    " put the low word of temp into *r",
                    "This loop continues until all digits of max_num have been processed."
                ]
            }
        ],
        "Normal": [
            " put value into the carry part of temp",
            " the number with the least digits used",
            " the number with the most digits used",
            " one past the end of min_num",
            " one past the end of max_num",
            " check if there was a final carry",
            "This operation is performed after the loop to check if there is any remaining carry."
        ],
        "FuncName": "bigint_kernel_2_1760 long_add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "result",
            "source",
            "shift right by one bit, get the new number"
        ],
        "FuncName": "bigint_kernel_2_1760 shift_right.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " if we are losing a digit in this division, the image type of integer division is used",
            " perform the actual division with image type of integer division"
        ],
        "FuncName": "bigint_kernel_2_1760 short_div.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "result",
            "source",
            "set the number of digits used in the result",
            "if the upper bits from s were zero then don't count this first word",
            "now zero the rest of the result"
        ],
        "FuncName": "bigint_kernel_2_1760 shift_left.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "increment result",
                    "Performing long division: incrementing result when condition is true"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if (temp <= remainder)",
                    "Long division loop condition: checking if temp is less than or equal to remainder"
                ]
            },
            {
                "loopstr": [
                    "if there was no carry then we are done",
                    "if we hit the end of r and there is still a carry then",
                    "the next digit of r is 1 and there is one more digit used",
                    "Long division loop conditions: checking for termination conditions"
                ]
            }
        ],
        "Normal": [
            "zero result",
            "copy lhs into remainder",
            "if rhs is bigger than lhs then result == 0 and remainder == lhs",
            "so then we can quit right now",
            "make a temporary number",
            "shift rhs left until it is one shift away from being larger than lhs and",
            "put the number of left shifts necessary into shifts",
            "while (lhs > temp)",
            "make sure lhs isn't smaller than temp",
            "we want to execute the loop shifts +1 times",
            "Performing long division: normal flow of operations"
        ],
        "FuncName": "bigint_kernel_2_1760 long_div.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "put the final carry into the most significant digit of the result. This is an image of a multiplication algorithm that uses a large integer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "multiply and add in the carry. This is an image of a loop that iterates over the digits of the multiplier.",
                    "put the low word of temp into the result. This is an image of a shift operation that moves the low word of the temporary result to the final result."
                ]
            }
        ],
        "Normal": [
            "if there is a final carry. This is an image of a check that determines if there is a final carry after the multiplication."
        ],
        "FuncName": "bigint_kernel_2_1760 short_mul.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Perform 1D Fast Fourier Transform (FFT) and store the result in a complex image. The result is then stored in a double-precision floating-point array, and a scaling operation is performed by dividing each element of the array by the square of the height of the image. This operation is performed iteratively for each element of the array using nested loops."
        ],
        "FuncName": "IPLComplexImage_3701 IFFT.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Load external apps list",
            "Manage external applications",
            "External app management dialog"
        ],
        "FuncName": "ExternalAppsDialog_1678 ExternalAppsDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "for (int y = 1; y < size; y++) for (int x = 0; x < size; x++) p(x, 0) += p(x, y); for (int y = 1; y < size; y++) for (int x = 0; x < size; x++) p(x, y) = p(x, 0); Fast Fourier Transform (FFT) is applied to complex images."
        ],
        "FuncName": "IPLComplexImage_3701 FFT.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "performing blocks of butterflies in this loop"
                ]
            },
            {
                "loopstr": [
                    "executing step butterflies"
                ]
            }
        ],
        "Normal": [
            "calculating the complex root of unity w",
            "computing the twiddle factors",
            "now computing the inverse decimation in frequency. This first",
            "outer loop iterates log2(len) number of times"
        ],
        "FuncName": "bigint_kernel_2_1760 ifft.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "stage of computation in the frequency domain",
            "power of Wn in the frequency domain",
            "bit-reversal ordering in place for FFT",
            "decimation in time algorithm for FFT"
        ],
        "FuncName": "IPLComplexImage_3701 lineFFT.txt"
    },
    {
        "Branch": [
            "comparing two bigint values for equality"
        ],
        "Loop": [],
        "Normal": [
            "if lhs and rhs are definitely not equal",
            "bigint comparison for equality"
        ],
        "FuncName": "bigint_kernel_2_1760 is_equal_to.txt"
    },
    {
        "Branch": [
            "if the image is a complex number"
        ],
        "Loop": [
            {
                "loopstr": [
                    "do blocks of butterflies in this loop, where each butterfly is a complex number"
                ]
            },
            {
                "loopstr": [
                    "do step butterflies, where each step is a complex number"
                ]
            }
        ],
        "Normal": [
            "compute the complex root of unity w, which is a complex number",
            "compute the twiddle factors, which are complex numbers",
            "now compute the decimation in frequency.  This first",
            "outer loop loops log2(len) number of times, where len is the length of the image, which is a complex number"
        ],
        "FuncName": "bigint_kernel_2_1760 fft.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u6211\u4eec\u5728\u51cf\u6cd5\u4e2d\u4e22\u5931\u4e86\u4e00\u4e2a\u6570\u5b57",
                    "\u8868\u793a\u6709\u8fdb\u4f4d\uff0c\u9700\u8981\u7ee7\u7eed\u51cf\u6cd5"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u5982\u679c\u6ca1\u6709\u8fdb\u4f4d\u5219\u8df3\u51fa\u5faa\u73af",
                    "\u8868\u793a\u51cf\u6cd5\u5b8c\u6210\uff0c\u4e0d\u5b58\u5728\u8fdb\u4f4d"
                ]
            }
        ],
        "Normal": [
            "\u590d\u5236\u5269\u4f59\u7684\u6570\u5b57\u5230d",
            "\u51c6\u5907\u8fdb\u884c\u4e0b\u4e00\u8f6e\u51cf\u6cd5"
        ],
        "FuncName": "bigint_kernel_2_1760 decrement.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Draws an image rectangle (source texture) onto a window rectangle, scaling to fit while maintaining aspect ratio.",
                    "Resizes the target rectangle to fit the window, preserving the image's aspect ratio.",
                    "If the window is smaller than the image, scales down the image while maintaining aspect ratio.",
                    "If the window is larger than the image, centers the image without scaling up.",
                    "Logs a message indicating the rendering of a frame on the target rectangle.",
                    "Ensures there is a background if the target rectangle has an offset.",
                    "Copies the frame into the target area.",
                    "Flips the framebuffer."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fails to retrieve the renderer."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fails to query the texture."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The texture is empty."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "viewflif_5541 draw_image.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Explicit position: Iterating through an image dataset",
            "Iterate a few times: Performing a limited number of iterations on an image"
        ],
        "FuncName": "imagebuf_test_363 iterator_read_test.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Checking whether the iterator wraps around in a circular pattern."
                ]
            }
        ],
        "Normal": [
            "The desired output should have 48 wrapped pixels around the image."
        ],
        "FuncName": "imagebuf_test_363 iterator_wrap_test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create a 16x16 x 3-channel float buffer filled with zeros for an image.",
            "Wrap the entire buffer with a green color to create an image.",
            "Perform a strided wrap in the interior of the buffer: a 3x3 image with extra spacing between pixels and rows, filled with red.",
            "The strided image buffer should appear all-red.",
            "The wrapped image buffer should not appear as a single color.",
            "Write both buffers to disk and verify they match our expectations."
        ],
        "FuncName": "imagebuf_test_363 ImageBuf_test_appbuffer_strided.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error: decoding failed",
                    "FLIF image decoding failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Set the quality to 100% for FLIF image decoding (lower value will decode a lower-quality preview)",
            "Set the scale-down factor to 1 for FLIF image decoding (higher value will decode a downsampled preview)",
            "Set the maximum size to twice the screen resolution for FLIF image decoding; if an image is larger, a downsampled preview will be decoded",
            "Alternatively, set the decode width to exactly the screen width for FLIF image decoding (height will be set to respect aspect ratio)",
            "FLIF decoder set fit function called with decode width and 0",
            "Set the callback function to render the partial (and final) decoded FLIF images",
            "Do the first callback when at least 5.00% quality has been decoded for FLIF image",
            "No callback was set, so we manually call our callback function to render the final FLIF image/frames"
        ],
        "FuncName": "viewflif_5541 decodeThread.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Usage:  %s  image.flif: a FLIF image decoder and viewer."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: failed to retrieve display mode using SDL_GetWindowDisplayMode."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: failed to create decode thread for FLIF image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: failed to decode FLIF image due to unknown error."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Rendered %i frames in %.2f seconds, achieving %.4f frames per second with FLIF image decoding."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Background color will be used to fill the window in case the aspect ratio does not match the image.",
            "Decoding the FLIF image progressively...",
            "Decoding the entire FLIF image...",
            "Ensure that the decoding process is properly aborted if it was not completed yet."
        ],
        "FuncName": "viewflif_5541 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error: No decoded image found. Please check the image file or update the texture."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: Could not create window. Please check the window creation settings."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "On Windows, a window cannot be resized from a non-GUI thread. Therefore delegate the resize to the event loop. do_maximize flag"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: No decoded image found. Please check the image file or update the texture."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: Could not create surface. Please check the surface creation settings."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Alpha-blend decoded frame on top of checkerboard background. Image/animation with alpha channel is being rendered."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: Could not create surface. Please check the surface creation settings."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Error: Could not get renderer. Please check the renderer settings."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Could not create texture! Please check the texture creation settings."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Copy the decoded pixels to a temporary surface. Draw checkerboard background for image/animation with alpha channel. Convert the surface to a texture (for accelerated blitting)."
                ]
            }
        ],
        "Normal": [
            "Old versions Microsoft C did not use the standard print specifiers. See: https://msdn.microsoft.com/en-us/library/tcxf1dw6(v=vs.90).aspx In fact, mingw-w64 had to provide their own implementation just to work the issue with the incompatibility with old versions of msvcrt.dll. See: https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/ ",
            "%lli bytes read, rendering at quality=%.2f%%. Image rendering progress.",
            "Set the window title and size. Update the window settings.",
            "Allocate enough room for the texture pointers and frame delays. Update the texture settings.",
            "Produce one SDL_Texture per frame. Update the texture rendering."
        ],
        "FuncName": "viewflif_5541 updateTextures.txt"
    },
    {
        "Branch": [
            "Test image buffer configuration.",
            "Image buffer configuration test."
        ],
        "Loop": [
            "Image buffer configuration loop test.",
            "Test image buffer configuration loop."
        ],
        "Normal": [
            "Note: This function must run after ImageBuf_test_appbuffer, which writes A.tif, and test image buffer configuration.",
            "Clear A because it would be unwise to let the ImageBuf outlive the custom ImageCache we passed it to use, and ensure image buffer configuration is correct."
        ],
        "FuncName": "imagebuf_test_363 test_open_with_config.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Closed: The window has been closed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Quit: The user has chosen to quit the application."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Refresh the window if its size changes: This ensures the window remains up-to-date and visually appealing."
        ],
        "FuncName": "viewflif_5541 do_event.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Test roi set and retrieve on an ImageSpec, including image type description",
            "Test roi set and retrieve on an ImageBuf, including image type description",
            "outside xy, beyond image boundaries",
            "outside z, beyond image depth",
            "outside ch, beyond image channels"
        ],
        "FuncName": "imagebuf_test_363 test_roi.txt"
    },
    {
        "Branch": [
            " bench.work (size_t(xres*yres*nchans));  # Image pixel data buffer size calculation"
        ],
        "Loop": [
            "  # Loop through each pixel in the image"
        ],
        "Normal": [
            " bench.work (size_t(xres*yres*nchans));  # Image pixel data buffer size calculation"
        ],
        "FuncName": "imagebuf_test_363 time_get_pixels.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "buf exists scope and is destroyed without anybody retrieving the error. This behavior is similar to image buffering, where an image is loaded into memory and then destroyed if not used."
        ],
        "FuncName": "imagebuf_test_363 test_uncaught_error.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "First, write a test image with 6 channels, including RGB and alpha channels.",
            "Now read it back using the channel range option, which allows you to specify a subset of channels to read.",
            "force, TypeDesc::FLOAT, This is a floating-point image type."
        ],
        "FuncName": "imagebuf_test_363 test_read_channel_subset.txt"
    },
    {
        "Branch": [
            " Ensure that ImageBuf iterators over empty ROIs immediately appear and exit with a specific condition related to image processing."
        ],
        "Loop": [
            " Ensure that ImageBuf iterators over empty ROIs immediately terminate and meet the loop condition associated with image handling."
        ],
        "Normal": [
            " Ensure that ImageBuf iterators over empty ROIs immediately appear and exit with a specific condition related to image processing.",
            "done"
        ],
        "FuncName": "imagebuf_test_363 test_empty_iterator.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Write two images with visual representations of code snippets.",
            " Read an image from a source, such as a file or database.",
            " Ensure that image A is not held open, as it will be removed shortly.",
            " Replace the green image with a red one, displaying it under the ImageBuf.",
            " Read the image again from a different ImageBuf.",
            " Verify that the image has the new color, rather than the underlying ImageCache's old color.",
            " Ensure that image B is not held open, as it will be removed next."
        ],
        "FuncName": "imagebuf_test_363 test_write_over.txt"
    },
    {
        "Branch": [
            "Testing image buffer conditions",
            "Image buffer conditions are working as expected"
        ],
        "Loop": [
            "Testing loop conditions on image buffer",
            "Loop conditions on image buffer are working as expected",
            "should not look local",
            "should look local"
        ],
        "Normal": [
            "Testing image buffer functionality",
            "Making a source image for testing",
            "Make a source image"
        ],
        "FuncName": "imagebuf_test_363 main.txt"
    },
    {
        "Branch": [
            "Using APQ to find the minimum value in an if condition.",
            "APQ optimization for if condition."
        ],
        "Loop": [
            "Using APQ to find the minimum value in a loop condition.",
            "APQ optimization for loop condition."
        ],
        "Normal": [
            "APQ optimization for large vectors: avoid using BFGS.",
            "APQ optimization for long input points: skip approximate derivative tests."
        ],
        "FuncName": "optimization_4514 test_apq.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Make 4x4 1-channel float source image, value 0.5, write it. Image type: 2D image.",
            " Using the cache, it should look tiled and using the IC Image type: 2D image.",
            " Iterate with a ConstIterator, make sure it's still IC backed Image type: 2D image.",
            " should not look local Image type: 2D image.",
            " Make a mutable iterator and traverse the image, even though it's an Image type: 2D image.",
            " image file reference. Image type: 2D image.",
            " The mere existence of the mutable iterator and traversal with it Image type: 2D image.",
            " should still not change anything. Image type: 2D image.",
            " should not look local Image type: 2D image.",
            " should look tiled Image type: 2D image.",
            " Make a mutable iterator and traverse the image, altering the pixels. Image type: 2D image.",
            " Writing through the iterator should have localized the IB Image type: 2D image.",
            " should look local now Image type: 2D image.",
            " should look untiled Image type: 2D image."
        ],
        "FuncName": "imagebuf_test_363 test_mutable_iterator_with_imagecache.txt"
    },
    {
        "Branch": [
            "test function Brown's boundary solver"
        ],
        "Loop": [],
        "Normal": [
            "pick random bounds with image processing techniques"
        ],
        "FuncName": "optimization_4514 test_bound_solver_brown.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "pick random bounds and sometimes put the upper bound at zero so we can have",
            "a test where the optimal value has a bound active at 0 so make sure this case",
            "works properly with image processing and analysis."
        ],
        "FuncName": "optimization_4514 test_bound_solver_rosen.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Input file available from https://github.com/nokiatech/heif_conformance. Image data is extracted from HEIF file for further processing.",
            "Find the item ID. Image ID is required for decoding.",
            "Feed 'data' to decoder and display the cover image. Image data is then processed and displayed accordingly."
        ],
        "FuncName": "example_8124 example1.txt"
    },
    {
        "Branch": [
            "Test the boundary of the negative Rosenbrock function"
        ],
        "Loop": [
            "Find the maximum value of the negative Rosenbrock function within the given bounds"
        ],
        "Normal": [
            "Pick random bounds for the negative Rosenbrock function",
            "Compute the gradient residual of the negative Rosenbrock function"
        ],
        "FuncName": "optimization_4514 test_bound_solver_neg_rosen.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Get property struct by index to access rotation angle",
                    " Assume only one property",
                    " Image rotation angle property accessed via HEIF file"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " For example, handle 'irot' transformational property is anti-clockwise rotation",
                    " Anti-clockwise rotation property handled in HEIF file"
                ]
            }
        ],
        "Normal": [
            " Input file available from https://github.com/nokiatech/heif_conformance",
            " Find item IDs of 'iden' (identity transformation) type derived images",
            " For demo purposes, assume there was one 'iden' item",
            " 'dimg' item reference points from the 'iden' derived item to the input(s) of the derivation",
            " For demo purposes, assume there was one",
            " Get 'iden' item properties to find out what kind of derivation it is",
            " HEIF file contains item properties for derivation"
        ],
        "FuncName": "example_8124 example4.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "handle error here. HEIC file reading and decoding process failed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Thumbnail references ('thmb') are from the thumbnail image to the master image. HEIC file decoding in progress."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Decode data and display the image. Show master image later. HEIC file information retrieved."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Decode and display. HEIC file successfully processed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Input file available from https://github.com/nokiatech/heif_conformance. Image file processing started.",
            "Verify that the file has one or several images in the MetaBox. HEIC file format supported.",
            "Find the item ID of the first master image. Image decoding initiated."
        ],
        "FuncName": "example_8124 example2.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "raw result with line detection and image output"
                ]
            }
        ],
        "Normal": [
            "delete previous result with line detection",
            "WARNING: cv::HoughLinesP does not work in debug mode!!!",
            "destroys the std::vector<cv::Vec4i> lines with line image output",
            "get properties of detected lines"
        ],
        "FuncName": "IPLHoughLineSegments_699 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete Hough line segment result image code"
        ],
        "FuncName": "IPLHoughLineSegments_699 destroy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Try opening a file with an Exif item, which includes image metadata.",
            " The file is available from https://github.com/nokiatech/heif_conformance, a repository containing HEIF conformance test files.",
            " Find the primary item ID, which is a unique identifier for the Exif data.",
            " Find item(s) referencing to the primary item with cdsc (content describes) item reference, which provides a detailed description of the image.",
            " Optional: verify the item ID we got is really of Exif type, ensuring it contains image metadata.",
            " Get item size from parsed information, which includes the size of the Exif data.",
            " Request item data, which includes the Exif payload and other image metadata.",
            " Write Exif item data to a file, including the Exif payload and other image metadata.",
            " Note this data does not contain Exif payload only. The payload is preceded by 4-byte exif_tiff_header_offset, a field as defined by class ExifDataBlock() in ISO/IEC 23008-12:2017, a standard for HEIF file format."
        ],
        "FuncName": "example_8124 example8.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one second average image encoding.",
                    "image encoding bitrate: 64-128 kbps."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " NOTE: AAC-LC only. image encoding supported.",
            " This is just a simple guestimate. slightly pessimistic, returns bitrates higher than actually needed for image encoding."
        ],
        "FuncName": "AudioTrack_3851 save.txt"
    },
    {
        "Branch": [
            "Create image container for conditional statements",
            "Update image list for conditional statements"
        ],
        "Loop": [
            {
                "loopstr": [
                    " NOTE: we had this here: oIdx != -1 && QFileInfo(oldImages.at(oIdx)->filePath()).lastModified() == f.lastModified()",
                    " however, that did not detect file changes & slowed down the process - so I removed it",
                    " Image update condition: file modification time comparison"
                ]
            }
        ],
        "Normal": [
            " TODO: change files to QStringList",
            " Image processing: file list conversion"
        ],
        "FuncName": "DkImageLoader_7681 createImages.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This line takes seconds if you have lots of files and slow loading (e.g. network)",
                    "Might get empty too (e.g. someone deletes all images)",
                    "Disabled threaded sorting - people didn't like it (#484 and #460)",
                    "If (files.size() > 2000) {",
                    "\tCreateImages(files, false);",
                    "\tsortImagesThreaded(images);",
                    "}",
                    "Else",
                    "Image processing will be performed for large files"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Stop showing",
                    "Image processing will be cancelled"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If (creatingImages) {",
            "\t//Emit showInfoSignal(tr(\\Indexing folder...\\), 4000);\t// Stop showing",
            "\tReturn false;",
            " }",
            "Folder changed signal was emitted",
            "New folder is loaded",
            "Else",
            "\tQDebug() << \\Ignoring... old dir: \\ << dir.absolutePath() << \\ NewDir: \\ << newDir << \\ File size: \\ << images.size();",
            "Image processing will be performed for the new folder"
        ],
        "FuncName": "DkImageLoader_7681 loadDir.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "Hough line detection parameters",
            "line segment detection threshold",
            "minimum line segment length",
            "maximum line segment gap"
        ],
        "FuncName": "IPLHoughLineSegments_699 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " read image decoder config and store its id if not seen before",
                    " read image data",
                    " feed image data to writer",
                    " create new image based on that data:",
                    " if this input image was the primary image -> also mark output image as primary image",
                    " copy other properties over",
                    " image data is fed to the writer to create a new image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " feed new decoder config to writer and store input to output id pairing information",
                    " new decoder config is fed to the writer to store input to output id pairing"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " if we haven't yet read this property for other image -> do so and add it to writer as",
                    " well",
                    " create new property for images in writer",
                    " if the property has not been read for other images, it is added to the writer"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " create reader and writer instances",
            " partially configure writer output",
            " Input file available from https://github.com/nokiatech/heif_conformance",
            " read major brand of file and store it to writer config.",
            " add major brand to writer config",
            " read compatible brands of file and store it to writer config.",
            " add compatible brands to writer config",
            " initialize writer now that we have all the needed information from reader",
            " get information about all input file content",
            " map which input decoder config id matches the writer output decoder config ids",
            " Image Rotation property as an example of Image Properties:",
            " map which input image property matches the writer output property.",
            " go through all items in input file and store master image decoder configs",
            " image rotation property is an example of image properties"
        ],
        "FuncName": "example_8124 example7.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "this is dead code and could crash see sort() for a correct way to do it",
            "sort images container in ascending order by comparing image pointers",
            "std::sort(images.begin(), images.end(), imageContainerLessThanPtr);"
        ],
        "FuncName": "DkImageLoader_7681 sortImages.txt"
    },
    {
        "Branch": [
            "if here is a folder update bug - this was before -- if (QFileInfo(filePath).isFile() || hasZipMarker) { image: loading image container }"
        ],
        "Loop": [],
        "Normal": [
            "if here is a folder update bug - this was before -- if (QFileInfo(filePath).isFile() || hasZipMarker) { image: loading image container }"
        ],
        "FuncName": "DkImageLoader_7681 load.txt"
    },
    {
        "Branch": [
            "if here is a folder update bug - this was before -- if (QFileInfo(filePath).isFile() || hasZipMarker) { image: Image container loaded }"
        ],
        "Loop": [],
        "Normal": [
            "if here is a folder update bug - this was before -- if (QFileInfo(filePath).isFile() || hasZipMarker) { image: Loaded image container }"
        ],
        "FuncName": "DkImageLoader_7681 load.txt"
    },
    {
        "Branch": [
            "if one image is from zip than all should be: This statement implies that if one image file is contained within a zip archive, all images in the zip should be considered."
        ],
        "Loop": [
            "for images in zip the images[idx]->file() == file comparison somehow does not work: In this loop, the code is attempting to compare the file path of an image at index idx within a zip archive with a file path, but it seems the comparison is not working as expected."
        ],
        "Normal": [
            "if one image is from zip than all should be: This statement implies that if one image file is contained within a zip archive, all images in the zip should be considered.",
            "for images in zip the images[idx]->file() == file comparison somehow does not work: In this loop, the code is attempting to compare the file path of an image at index idx within a zip archive with a file path, but it seems the comparison is not working as expected."
        ],
        "FuncName": "DkImageLoader_7681 findFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " if (basicLoader.hasImage() && !file.exists()) Loads the image file at the specified index.",
            "return;",
            "file requested becomes current file"
        ],
        "FuncName": "DkImageLoader_7681 loadFileAt.txt"
    },
    {
        "Branch": [
            " if (!img.isNull() && !file.exists())",
            " Image file does not exist, skipping..."
        ],
        "Loop": [],
        "Normal": [
            " if (!img.isNull() && !file.exists())",
            " Image file does not exist, skipping...",
            "\treturn;",
            " if (!file.exists() && !virtualFile.exists()) {",
            "\tqDebug() << virtualFile.absoluteFilePath() << 'does not exist...!!!'.;",
            "\treturn;",
            " }",
            " update dir",
            " Processing image file..."
        ],
        "FuncName": "DkImageLoader_7681 changeFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Re-reload the image. These strings are from the image code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageLoader_7681 reloadImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Do we load a new image? These are image codes.",
                    "Reset updates"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This causes a crash. Because the release will trigger the saving of metadata (in a different thread) - and the auto_ptr does not like that at all. Anyhow we don't need to save the metadata twice. These are image codes.",
                    "Because the release will trigger the saving of",
                    "Metadata (in a different thread) - and",
                    "The auto_ptr does not like that at all",
                    "Anyhow we don't need to save the metadata twice",
                    "CurrentImage->saveMetaDataThreaded();"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Force index folder if we dir out of the zip. These are image codes.",
            "Else. These are image codes.",
            "qDebug() << empty image assigned; // TODO. These are image codes.",
            "If the file stays the same, we just want to update the pointer. These are image codes.",
            "Cancel action if the image is currently loading. These are image codes."
        ],
        "FuncName": "DkImageLoader_7681 setCurrentImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "when an image is loaded, update the image load signal, send an event, update the cache and history, and update the status bar information"
        ],
        "FuncName": "DkImageLoader_7681 imageLoaded.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "retrieve the extension name (that's more user friendly)",
                    "display image of extension icon"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "the subsequent modals destroy the active window",
            "display a warning image about potential loss of data"
        ],
        "FuncName": "DkImageLoader_7681 copyUserFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Add history item with edited metadata (exif rotation) and image rotation applied",
                    "new edit with modified metadata including image rotation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "via ImageContainer, BasicLoader with image processing"
        ],
        "FuncName": "DkImageLoader_7681 rotateImage.txt"
    },
    {
        "Branch": [
            "Compare the current file with the latest updated file in the history",
            "Check if the file has been modified recently"
        ],
        "Loop": [
            "Iterate over the recent files and folders",
            "Loop through the updated history records"
        ],
        "Normal": [
            "sync with other instances",
            "try to collect images from different folders",
            "maximum 5 most recent images from the same folder",
            "sync with other instances",
            "update",
            "Retrieve settings from the DkSettings class",
            "Save the settings to the disk"
        ],
        "FuncName": "DkImageLoader_7681 updateHistory.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "deleted from the end",
                    "image file removed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageLoader_7681 deleteFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "qDebug() << sF; Save user file as dialog."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "note: basename removes the whole file name from the first dot... Save user file as dialog."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Save user file as dialog. Save metadata only",
                    "DkBasicLoader::saveMetaData() (otherwise called after saving). Notify listeners about saved image",
                    "Skip the rest which is only relevant when re-encoding/saving the image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Save user file as dialog. jxl has to be before old jpeg to avoid triggering jpg_dialog for .JXL format"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "TODO glitch if (!mCurrentImage->getMetaData()->isLoaded()); see rotateImage(). Saving image normally, clear exif rotation flag to prevent double rotation",
            "the subsequent modals destroy the active window. Save user file as dialog.",
            "don't ask the user if save was hit & the file format is supported for saving. Save user file as dialog.",
            "default value. Save user file as dialog.",
            "Save user file as dialog. Save only metadata if image itself hasn't been edited (after exif rotation)",
            "Below are the compress/encode routines; at the end of a long call chain (saveIntern internSave Threaded). Save user file as dialog.",
            "savetoBuffer() is responsible for adding the exif data to the image buffer soup. Save user file as dialog., which is then written to the specified file."
        ],
        "FuncName": "DkImageLoader_7681 saveUserFileAs.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "load system default open dialog",
                    "Temporarily save file: load system default open dialog"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageLoader_7681 saveTempFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ok I did not destroy the original file - so delete the back-up",
                    "-> this reverts the file - but otherwise we spam to the disk",
                    "actions reverted here include meta data saving and file recovery",
                    "file type: image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if exif crashed it saved a backup file with the format: filename.png1232",
            "delete the destroyed file",
            "now recovering image file"
        ],
        "FuncName": "DkImageLoader_7681 restoreFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u68c0\u6d4b\u5230\u6587\u4ef6\u5939\u66f4\u65b0\u5e76\u89e6\u53d1\u66f4\u65b0\uff0c\u95f4\u9694 XX \u79d2",
                    "\u60f3\u8c61\u4e00\u4e2a\u6587\u4ef6\u5939\uff0c\u5176\u4e2d\u6709 100 \u4e2a\u6587\u4ef6\u88ab\u5199\u5165...",
                    "\u7531\u4e8e\u6b64\u64cd\u4f5c\u53ef\u80fd\u5f88\u5feb\uff0c\u7f29\u7565\u56fe\u52a0\u8f7d\u5668\uff08\u53ca\u5176\u4ed6\uff09\u5c06\u521b\u5efa\u66f4\u5927\u7684\u504f\u79fb\u91cf\u5e76\u964d\u4f4e\u7cfb\u7edf\u901f\u5ea6"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkImageLoader_7681 directoryChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "simulate a folder update operation with image processing"
        ],
        "FuncName": "DkImageLoader_7681 setFolderFilter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "QDir oldDir = file.absoluteDir();",
            "QDir imageLoaderDir; imageLoaderDir.setPath(\"/path/to/image/loader/directory\");"
        ],
        "FuncName": "DkImageLoader_7681 setDir.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "This line may take a few seconds to complete, especially with many files and slow loading (e.g., network), which typically involves images."
                ]
            }
        ],
        "Normal": [
            "Find the first subfolder containing images."
        ],
        "FuncName": "DkImageLoader_7681 updateSubFolders.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "This line takes a few seconds to display, especially if you have many files and slow loading (e.g., network). It is similar to navigating through a folder hierarchy, similar to the 'Next Folder' or 'Previous Folder' button in an image viewer, which allows you to browse through a collection of images."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DkImageLoader_7681 getSubFolderIdx.txt"
    },
    {
        "Branch": [
            "return mCurrentImage->pixmap()->image()"
        ],
        "Loop": [],
        "Normal": [
            "return mCurrentImage->pixmap()->image()"
        ],
        "FuncName": "DkImageLoader_7681 getPixmap.txt"
    },
    {
        "Branch": [
            "Receive image update signal"
        ],
        "Loop": [
            "Connect or disconnect signal with slot function"
        ],
        "Normal": [
            "!selected - do not connect twice"
        ],
        "FuncName": "DkImageLoader_7681 receiveUpdates.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Clear images if they are edited: images are updated and cleared when edited.",
                    "Do not count the last and the current image: ignore the last and current image in the loop.",
                    "Ignore the last and current one: skip the last and current image in the loop.",
                    "Fully load the next image: load the next image in the loop."
                ]
            }
        ],
        "Normal": [
            "No caching, delete all: delete all images without caching.",
            "If cache memory is disabled: check if cache memory is disabled.",
            "For each image: clear the image in the loop.",
            "Clear the image: clear the image data.",
            "Return: exit the function.",
            "Cache memory is disabled: cache memory is disabled if the parameter is set to false."
        ],
        "FuncName": "DkImageLoader_7681 updateCacher.txt"
    },
    {
        "Branch": [
            "Perform convolution operation if the kernel is float and in local memory"
        ],
        "Loop": [
            "Perform convolution operation for all pixels in the image"
        ],
        "Normal": [
            "Ensure that the kernel is float and in local memory",
            "Convolve the image with the kernel to produce the output"
        ],
        "FuncName": "imagebufalgo_370 convolve.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " N.B.: Don't log time, convolve will catch it. This is an image processing technique.",
            " K.write (\\K.exr\\); This is an image file format."
        ],
        "FuncName": "imagebufalgo_370 laplacian.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " N.B.: Don't log time, convolve will catch it. This is a Laplacian operator used in image processing to detect edges.",
            " K.write (\\K.exr\\); This is an image file written using the K.write function, which is a common operation in image processing pipelines."
        ],
        "FuncName": "imagebufalgo_370 laplacian.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ensure that the kernel is float and in local memory. This is a common practice in image processing, where the kernel is used to convolve with the image data."
        ],
        "FuncName": "imagebufalgo_370 convolve.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " N.B. Don't log time, it will get caught by the constituent parts",
            " Apply sharpening filter to the source image, store in Sharpened",
            " Compute the difference between the source image and the sharpened version",
            " Scale the difference image by the contrast",
            " Add the scaled difference to the original, to get the final answer"
        ],
        "FuncName": "imagebufalgo_370 unsharp_mask.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Source image have float pixels so just iterate and call the user's op",
                    "pixels so just iterate and call the user's op"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_370 perpixel_op.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Named continuous filter from filter.h, which is a type of image processing kernel."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Binomial filter, a type of image processing kernel used for smoothing and edge detection."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "sums to zero, so don't normalize it, which is a common technique in image processing to avoid amplifying noise."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Round up size to odd, which is a common technique in image processing to ensure that the size of an image is odd, which can be useful for certain algorithms."
        ],
        "FuncName": "imagebufalgo_370 make_kernel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create a logger with the same name as the root logger logp for image logging purposes.",
            "Set the logging level of all loggers to INFO for image logging purposes.",
            "Configure the example.test_class to print WARN or higher messages for image logging purposes.",
            "Configure loggers from a text config file for image logging purposes."
        ],
        "FuncName": "logger_ex_2_664 setup_loggers.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If we're pasting fewer than 2 channels, zero out channel 1.",
                    "Apply 2D FFT to the input image, resulting in a complex-valued 2D array."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "One channel only",
            "Construct a spec that describes the result, including the frequency domain representation of the input image.",
            "And a spec that describes the transposed intermediate, highlighting the rearrangement of the image data.",
            "Resize dst to match the dimensions of the original image.",
            "Copy src to a 2-channel (for complex) float buffer, preparing the data for the FFT operation.",
            "Apply 2D FFT to the rows of the input image, resulting in a complex-valued 2D array stored in temp buffer B.",
            "Transpose and shift back to A, rearranging the image data to facilitate the next FFT operation.",
            "Apply 2D FFT to what was originally the columns of the input image, resulting in a complex-valued 2D array stored in B.",
            "Transpose again, into the dest, completing the final rearrangement of the image data."
        ],
        "FuncName": "imagebufalgo_370 fft.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If we're pasting fewer than 2 channels, zero out channel 1. This is a common operation in image processing, where we need to handle cases with less than 2 channels, such as grayscale images."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "One channel only. In image processing, a single-channel image is a 2D array where each pixel has only one value, such as grayscale images.",
            "Construct a spec that describes the result. In the context of image processing, a spec can represent the metadata of the output image, including its dimensions, data type, and other attributes.",
            "And a spec that describes the transposed intermediate. This refers to the intermediate result after transposing the image, which is a common operation in image processing.",
            "Resize dst. This operation involves resizing the destination image to match the dimensions of the source image.",
            "Copy src to a 2-channel (for complex) float buffer. In image processing, copying the source image to a 2-channel buffer is necessary for operations that require complex numbers, such as Fourier transforms.",
            "FFT the rows (into temp buffer B). The Fast Fourier Transform (FFT) is a powerful tool in image processing, used to transform an image from the spatial domain to the frequency domain.",
            "Transpose and shift back to A. After performing the FFT, the image needs to be transposed and shifted back to its original position.",
            "FFT what was originally the columns (back to B). This is the second part of the FFT operation, where the columns of the image are transformed.",
            "Transpose again, into the dest. After the second FFT, the image needs to be transposed again to its final position."
        ],
        "FuncName": "imagebufalgo_370 fft.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Fill the hole in the image using the pullback algorithm.",
                    " small->write(Strutil::fmt::format(\"%04d.exr\", small->spec().width));"
                ]
            },
            {
                "loopstr": [
                    "Fill the hole in the image using the pullback algorithm.",
                    " big.write(Strutil::sprintf(\"%04.exr\", big.spec().width));"
                ]
            }
        ],
        "Normal": [
            "Fill alpha holes in the image by pulling back up the pyramid.",
            " We generate a bunch of temp images to form an image pyramid.",
            " These give us a place to stash them and make sure they are",
            " auto-deleted when the function exits.",
            " First, make a writable copy of the original image (converting",
            " to float as a convenience) as the top level of the pyramid.",
            " Construct the rest of the pyramid by successive x/2 resizing and",
            " then dividing nonzero alpha pixels by their alpha (this spreads",
            " out the defined part of the image).",
            " Now pull back up the pyramid by doing an alpha composite of level",
            " i over a resized level i+1, thus filling in the alpha holes.  By",
            " time we get to the top, pixels whose original alpha are",
            " unchanged, those with alpha < 1 are replaced by the blended",
            " colors of the higher pyramid levels.",
            " Now copy the completed base layer of the pyramid back to the",
            " original requested output."
        ],
        "FuncName": "imagebufalgo_370 fillholes_pushpull.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Construct a spec that describes the result of the inverse discrete Fourier transform.",
            "Apply the inverse Fast Fourier Transform to the rows of the image (into a temporary buffer B).",
            "Transpose and shift the result back to array A.",
            "Apply the inverse Fast Fourier Transform to what was originally the columns of the image (back to buffer B).",
            "Transpose the result again, storing it into the destination image, and in the process discard the imaginary part and convert back to a single (real) channel."
        ],
        "FuncName": "imagebufalgo_370 ifft.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " push%04d.exr: fill image holes and push/pull."
                ]
            },
            {
                "loopstr": [
                    " pull%04.exr: fill image holes and push/pull."
                ]
            }
        ],
        "Normal": [
            " N.B. Don't log time, it will be caught by the constituent parts",
            " We generate a bunch of temp images to form an image pyramid.",
            " These give us a place to stash them and make sure they are",
            " auto-deleted when the function exits.",
            " First, make a writable copy of the original image (converting",
            " to float as a convenience) as the top level of the pyramid.",
            " Construct the rest of the pyramid by successive x/2 resizing and",
            " then dividing nonzero alpha pixels by their alpha (this spreads",
            " out the defined part of the image).",
            " Now pull back up the pyramid by doing an alpha composite of level",
            " i over a resized level i+1, thus filling in the alpha holes.  By",
            " time we get to the top, pixels whose original alpha are",
            " unchanged, those with alpha < 1 are replaced by the blended",
            " colors of the higher pyramid levels.",
            " Now copy the completed base layer of the pyramid back to the",
            " original requested output."
        ],
        "FuncName": "imagebufalgo_370 fillholes_pushpull.txt"
    },
    {
        "Branch": [
            "If the image is loaded, then"
        ],
        "Loop": [
            "Loop through each image in the dataset"
        ],
        "Normal": [
            "Image data is used for machine learning models"
        ],
        "FuncName": "Writer_2713 SetUserData.txt"
    },
    {
        "Branch": [
            "Write user data if image code condition is met."
        ],
        "Loop": [
            "Write user data in loop if image code condition is met."
        ],
        "Normal": [
            "Write user data. These strings are for image code."
        ],
        "FuncName": "Writer_2713 WriteUserData.txt"
    },
    {
        "Branch": [
            "filename",
            "image filename",
            "image file name"
        ],
        "Loop": [],
        "Normal": [
            "image filename",
            "image file name"
        ],
        "FuncName": "thumbnailwidgetcmp_5942 drawSingleLineText.txt"
    },
    {
        "Branch": [
            "check if image is within valid range",
            "verify image description is accurate"
        ],
        "Loop": [
            "loop through image elements",
            "iterate over image range"
        ],
        "Normal": [
            "ensure image range is properly set",
            "configure image values",
            "determine if image element count increases"
        ],
        "FuncName": "Writer_2713 SetElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "ensure the range is valid for image data writing",
            "validate the entry for image data writing",
            "update file pointer for image data writing",
            "set image data offset in header",
            "write image data to file"
        ],
        "FuncName": "Writer_2713 WriteElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure the range is good and write the image data",
            "make sure the entry is valid and contains image metadata",
            "update file ptr and prepare image data for writing",
            "this->header.SetDataOffset(element, this->fileLoc); write image data to file",
            "write image data to file"
        ],
        "FuncName": "Writer_2713 WriteElement.txt"
    },
    {
        "Branch": [
            "Check if the image data is valid before writing it to the Cineon file."
        ],
        "Loop": [
            "Loop through each image element to be written to the Cineon file."
        ],
        "Normal": [
            " ensure the image range is within the valid limits",
            " verify the image entry is correct",
            " update the file pointer to the correct location",
            " set the data offset of the header to the current file location",
            " write the image data to the Cineon file"
        ],
        "FuncName": "Writer_2713 WriteElement.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "not loaded",
                    "todo: recolor once in shrRes",
                    "thumbnail generation failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "invalid thumb",
                    "image decoding error"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "thumbnailwidgetcmp_5942 paint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "loop if have end of line padding",
                    "write image data to file: line padding"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "write one line: write image data to file",
                    "write end of line padding: write image data to file"
                ]
            }
        ],
        "Normal": [
            "file pointer location after write: write image data to file",
            "write data: write image data to file",
            "end of image padding: image data written to file"
        ],
        "FuncName": "Writer_2713 WriteThrough.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "write the file size in the header and update the offsets in the image header",
            "rewrite all of the offsets in the image header"
        ],
        "FuncName": "Writer_2713 Finish.txt"
    },
    {
        "Branch": [
            "Write Tile to Buffer: Conditional statement in image code"
        ],
        "Loop": [
            "Write Tile to Buffer: Looping condition in image code"
        ],
        "Normal": [
            "Emulate tiles by buffering the whole image",
            "Buffering involves writing tile data to a buffer in memory",
            "This is a common technique in image processing and rendering"
        ],
        "FuncName": "webpoutput_9700 write_tile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "save with thumbnail preview"
        ],
        "FuncName": "thumbnailwidgetcmp_5942 drawDropHover.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Weve been emulating tiles; now dump as scanlines. WebP output is disabled and resources are released."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "already closed. WebP output is disabled and resources are released."
        ],
        "FuncName": "webpoutput_9700 close.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Lossless encoding (0=lossy(default), 1=lossless).",
            " forcing UINT8 format"
        ],
        "FuncName": "webpoutput_9700 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "WebP requires unassociated alpha, and it's sRGB. It supports lossy and lossless compression, and it's a raster image format.",
                    "Handle this all by wrapping an IB around it. This will allow the image to be compressed and stored in a WebP file."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "webpoutput_9700 write_scanline.txt"
    },
    {
        "Branch": [
            "Note: not exactly precise.",
            "Correct way: dst[0] = uint8_t(float(((eightBits>>6)&0x3)*(255.0f/4.0f) )); LodePNG\u89e3\u6790\u56fe\u50cf\u6570\u636e\uff0c\u751f\u6210ImageContainer\u5bf9\u8c61\u3002"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Note: not exactly precise.",
                    "Correct way: dst[0] = uint8_t(float(((eightBits>>6)&0x3)*(255.0f/4.0f) ));",
                    "LodePNG\u683c\u5f0f\u7684\u56fe\u50cf\u6570\u636e\u9700\u8981\u6839\u636e\u50cf\u7d20\u503c\u8fdb\u884c\u8f6c\u6362\uff0c\u751f\u6210ImageContainer\u5bf9\u8c61\u3002"
                ]
            },
            {
                "loopstr": [
                    "Note: not exactly precise.",
                    "Correct way: dst[0] = uint8_t(float(((eightBits>>4)&0xf)*(255.0f/16.0f) ));",
                    "LodePNG\u683c\u5f0f\u7684\u56fe\u50cf\u6570\u636e\u9700\u8981\u6839\u636e\u50cf\u7d20\u503c\u8fdb\u884c\u8f6c\u6362\uff0c\u751f\u6210ImageContainer\u5bf9\u8c61\u3002"
                ]
            }
        ],
        "Normal": [
            "LodePNG\u683c\u5f0f\u7684\u56fe\u50cf\u6570\u636e\u9700\u8981\u6839\u636e\u50cf\u7d20\u503c\u8fdb\u884c\u8f6c\u6362\uff0c\u751f\u6210ImageContainer\u5bf9\u8c61\u3002"
        ],
        "FuncName": "image_decode_4409 imageParseLodePng.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Intel little endian",
                    "JPG\u56fe\u50cf\u89e3\u6790\u5668"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Motorola big endian",
                    "JPG\u56fe\u50cf\u89e3\u6790\u5668"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Reference(s):",
                    "EXIF Tags",
                    "https://web.archive.org/web/20190218005249/https://sno.phy.queensu.ca/~phil/exiftool/TagNames/EXIF.html",
                    "JPG\u56fe\u50cf\u89e3\u6790\u5668"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_decode_4409 imageParseJpeg.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "requires - len(bound1) == len(bound2) == len(is_integer_variable) - for all valid i: bound1[i] != bound2[i] - solver_epsilon >= 0 - f() is a real valued multi-variate function. It must take scalar real numbers as its arguments and the number of arguments must be len(bound1). ensures - This function performs global optimization on the given f() function. The goal is to maximize the following objective function: f(x) subject to the constraints: min(bound1[i],bound2[i]) <= x[i] <= max(bound1[i],bound2[i]) if (is_integer_variable[i]) then x[i] is an integer value (but still represented with float type). - find_max_global() runs until it has called f() num_function_calls times. Then it returns the best x it has found along with the corresponding output of f(). That is, it returns (best_x_seen,f(best_x_seen)). Here best_x_seen is a list containing the best arguments to f() this function has found. - find_max_global() uses a global optimization method based on a combination of non-parametric and parametric methods. The non-parametric method is a multi-start local search algorithm, where the initial solutions are generated using a latin hypercube sampling strategy. The parametric method is a gradient-based optimization algorithm, which uses a quasi-Newton method to find the optimal solution. The algorithm is designed to handle non-convex objective functions and constraints, and it can handle a large number of variables and constraints. - The algorithm has been tested on a variety of benchmark problems, and it has shown to be very effective in finding the global optimum.",
            "-------------------------------------------------",
            "-------------------------------------------------"
        ],
        "FuncName": "global_optimization_8154 bind_global_optimization.txt"
    },
    {
        "Branch": [
            "free image resources after close input"
        ],
        "Loop": [
            "free image resources after close input"
        ],
        "Normal": [
            "free image resources after close input"
        ],
        "FuncName": "ffmpeginput_9203 close.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Quick naive test just make sure the extension is valid for one of the supported file types, such as image formats like JPEG, PNG, or GIF, supported by this reader.",
            "the supported file types supported by this reader."
        ],
        "FuncName": "ffmpeginput_9203 valid_file.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved (7) - Color information box: RGB(255, 0, 0)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "colourinformationbox_224 writeBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read the current video frame",
                    "current_frame = m_frame->display_picture_number;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ffmpeginput_9203 read_frame.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u672a\u901a\u8fc7\u547d\u4ee4\u884c\u53c2\u6570\u63d0\u4f9b\u989c\u8272\u7a7a\u95f4\uff0c\u5219\u9009\u62e9\u5217\u8868\u4e2d\u7684\u9876\u90e8\u989c\u8272\u7a7a\u95f4\u3002",
                    "OCIO\u83dc\u5355\u63d0\u4f9b\u4e86\u591a\u79cd\u989c\u8272\u7a7a\u95f4\u9009\u62e9"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewer_2816 createOCIOMenus.txt"
    },
    {
        "Branch": [
            "If condition met, update status bar with image information."
        ],
        "Loop": [],
        "Normal": [
            "Update status bar; tr(iv status);"
        ],
        "FuncName": "imageviewer_2816 updateStatusBar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Display the current image. These strings are used in the image code.",
            "glwin->trigger_redraw();",
            "printAct->setEnabled(true);",
            "fitImageToWindowAct->setEnabled(true);",
            "fullScreenAct->setEnabled(true);"
        ],
        "FuncName": "imageviewer_2816 displayCurrentImage.txt"
    },
    {
        "Branch": [
            "Reload current image based on if condition."
        ],
        "Loop": [
            "Reload current image based on loop condition."
        ],
        "Normal": [
            "Reload current image.",
            "Trigger redraw of the GL window."
        ],
        "FuncName": "imageviewer_2816 reload.txt"
    },
    {
        "Branch": [
            "If Condition:  The image is displayed when the mouse is over the control."
        ],
        "Loop": [
            "Loop Condition:  The image is displayed for a specified number of times."
        ],
        "Normal": [
            " Note: the order of the above MUST match the order of enum MouseMode. The image is displayed when the mouse is over the control."
        ],
        "FuncName": "imageviewer_2816 createStatusBar.txt"
    },
    {
        "Branch": [
            "Read image viewer settings if condition"
        ],
        "Loop": [
            "Read image viewer settings loop condition"
        ],
        "Normal": [
            " only safe because it's called after menu setup, image viewer settings applied"
        ],
        "FuncName": "imageviewer_2816 readSettings.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Otherwise, the image has already been processed by add_image."
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Get the last image from the list.",
                    "Read the image using its index and a callback function."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imageviewer_2816 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "We need the spec available to compare the image format with OpenGL's capabilities.",
                    "Used to check whether we'll need to do adjustments in the CPU.",
                    "If true, images should be loaded as UINT8.",
                    "OpenGL's capabilities are checked to determine if color space conversion is needed.",
                    "Color space conversion is done on the CPU if necessary.",
                    "ImageCache *imagecache = ImageCache::create (true);",
                    "Check whether IvGL recommends generating mipmaps for this image.",
                    "If the image is too big and autoMipmap is checked, generate mipmaps.",
                    "Read the image from disk or from the ImageCache if available."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "OpenGL does not support 64-bit floats as pixel size."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Loading HALF-FLOAT as FLOAT."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the image is in sRGB, but OpenGL can't load sRGB textures then we'll need to do the transformation on the CPU after loading the image.",
                    "We (so far) can only do this with UINT8 images, so make sure that it gets loaded in this format.",
                    "Loading as UINT8 to do sRGB."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The image was read successfully.",
                    "Check if we've got to do sRGB to linear (ie, when not supported by OpenGL).",
                    "Do the first pixel transform to fill-in the secondary image buffer.",
                    "This involves converting the image from sRGB to linear RGB."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewer_2816 loadCurrentImage.txt"
    },
    {
        "Branch": [
            "Sort images by date"
        ],
        "Loop": [],
        "Normal": [
            "updateActions(); Sort images by date"
        ],
        "FuncName": "imageviewer_2816 sortByImageDate.txt"
    },
    {
        "Branch": [
            "Reverse image list"
        ],
        "Loop": [
            "Reverse image list"
        ],
        "Normal": [
            "Reverse image list",
            "updateActions();"
        ],
        "FuncName": "imageviewer_2816 sortReverse.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " print({}:{}:{} {}:{}:{}\n, year, month, day, hour, min, sec);",
            " fill in defaults",
            " Converting datetime to time_t for image processing."
        ],
        "FuncName": "imageviewer_2816 DateTime_to_time_t.txt"
    },
    {
        "Branch": [
            "Image Path: /images/if-condition.jpg; Image Description: A conditional image for if statements."
        ],
        "Loop": [
            "Image Path: /images/loop-condition.jpg; Image Description: A looping image for loop conditions."
        ],
        "Normal": [
            "updateActions(); Image Path: /images/normal-action.jpg; Image Description: An image for normal actions."
        ],
        "FuncName": "imageviewer_2816 sortByPath.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Interpolation amount: This is a parameter used to control the level of detail in an image, typically used in image compression or rendering."
                ]
            }
        ],
        "Normal": [
            "Center view position: This refers to the process of resizing an image to a larger size, often used in image editing software.",
            "Mouse position: This is not directly related to image processing, but can be used to control the zoom level or position of an image in a graphical user interface."
        ],
        "FuncName": "imageviewer_2816 zoomIn.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Interpolation amount: controls the level of detail in the image, with higher values producing a more detailed image."
                ]
            }
        ],
        "Normal": [
            "Center view position: refers to the central point of the image, around which the view is centered.",
            "Mouse position: indicates the current position of the mouse cursor on the image."
        ],
        "FuncName": "imageviewer_2816 zoomOut.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "zoomInAct->setEnabled(!fitImageToWindowAct->isChecked()); Image zoom in enabled when image does not fit in the window.",
            "zoomOutAct->setEnabled(!fitImageToWindowAct->isChecked()); Image zoom out enabled when image does not fit in the window.",
            "normalSizeAct->setEnabled(!fitImageToWindowAct->isChecked()); Normal size enabled when image does not fit in the window."
        ],
        "FuncName": "imageviewer_2816 updateActions.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " For latlong environment maps, in order to conserve energy, we must weight the pixels by sin(t*PI) because pixels closer to the pole are actually less area on the sphere. Doing this will tend to over-represent the high latitudes in low-res MIP levels. We fold the area weighting into our linear interpolation by adjusting yfrac. This is a common technique used in image processing to reduce the effect of high-latitude pixels in environment maps.",
                    " Pixels closer to the pole have less area on the sphere, so we weight them by sin(t*PI) to conserve energy."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Get the four texels",
            " Bilinearly interpolate the texels to get the final pixel value."
        ],
        "FuncName": "maketexture_5227 interppixel_NDC_clamped.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "cout << \"samples.size(): \" << tsamples.size() << endl;",
                    "cout << \"test: \"<< active;",
                    "cout << \"test: \"<< random << \" (randomly sampled)\";",
                    "cout << \"\\n\\n***********\\n\\n\\\" << flush;"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "active_learning_2964 test_rank_unlabeled_training_samples.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Interleaved channels are faster to read. This is a characteristic of image data, where multiple color channels are stored in a single array.",
            " Force fixed tile-size across the board. This option is related to image processing and tiling, where a fixed tile size is enforced for efficiency and consistency."
        ],
        "FuncName": "maketexture_5227 set_oiio_options.txt"
    },
    {
        "Branch": [
            "When the image is not a good representation of the data, the active learning method shouldn't do much worse than random selection and often much better.",
            "However, when the image is a poor representation of the data, picking the worst ranked element should do way worse than random selection."
        ],
        "Loop": [
            "The image is not a good representation of the data.",
            "The image is a poor representation of the data."
        ],
        "Normal": [
            "When we pick the best/front ranked element then the active learning method shouldn't do much worse than random selection and often much better.",
            "However, picking the worst ranked element should do way worse than random selection."
        ],
        "FuncName": "active_learning_2964 perform_test.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "accumulate to dh_ds and dh_dt using corresponding sobel 3x3 weights, where sobel 3x3 weights are used to calculate horizontal and vertical gradients of images"
                ]
            }
        ],
        "Normal": [
            "sobel normalization, which is used to normalize the gradients calculated by sobel 3x3 weights"
        ],
        "FuncName": "maketexture_5227 sobel_gradient.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if (found_nonfinite < 3)",
                    "     std::cerr << \"maketx ERROR: Found non-finite value in ROI, which may indicate an image with non-finite values\"",
                    "               << \" at (x=\" << x << \", y=\" << y << \")\\n\"",
                    " skip other channels, there's no point"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "maketexture_5227 check_nan_block.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Copy additional attributes from source image to target image, including image code",
                    "Special instruction -- don't copy it to the destination spec"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Copy additional attributes from source image to target image, including image code: special case: we want maketx:uvslopes_scale to turn",
            "into uvslopes_scale"
        ],
        "FuncName": "maketexture_5227 maketx_merge_spec.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u4f7f\u7528\u5de6\u8fb9\u548c\u53f3\u8fb9\u7684\u6bcf\u4e2a\u65b0\u50cf\u7d20\u6765\u4fee\u590d\u7eac\u7ebf\u56fe\u50cf\u7684\u8fb9\u7f18\uff0c\u786e\u4fdd\u5176\u6b63\u786e\u663e\u793a"
                ]
            }
        ],
        "Normal": [
            "\u7b2c\u4e00\u884c\u548c\u6700\u540e\u4e00\u884c\u5168\u90e8\u586b\u5145\u4e3a\u5b9e\u5fc3\uff0c\u56e0\u4e3a\u5b83\u4eec\u90fd\u5728\u6781\u70b9",
            "\u5de6\u8fb9\u548c\u53f3\u8fb9\u7684\u5339\u914d\uff0c\u56e0\u4e3a\u5b83\u4eec\u90fd\u5728\u539f\u70b9"
        ],
        "FuncName": "maketexture_5227 fix_latl_edges.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Create texture: Send error to stream"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "maketexture_5227 make_texture.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "including the command itself",
                    "including the command itself"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Grab the next word or quoted string",
                    "Uniformize commands that start with '-' and those that start",
                    "with '--'.",
                    "Some commands are known to be followed by arguments that might",
                    "contain slashes, yet not be filenames. Remember to skip those.",
                    "In particular, we're looking for things that might have arbitrary",
                    "strings including slashes, for example, attribute names and color",
                    "space names.",
                    "Whatever's left when we're not disabling stripping for this arg,",
                    "for anything that looks like a filename by having directory",
                    "separators, strip out the directory name so that command lines",
                    "appear to match even if filenames have different relative paths.",
                    "Add the maybe-stripped string to the output, surrounding by",
                    "double quotes if it contains any spaces.",
                    "image processing commands, such as image resizing, cropping, or",
                    "format conversion, may be included in this category."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "maketexture_5227 stripdir_cmd_line.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Always use round down mode",
                    "OpenEXR always uses border sampling for environment maps",
                    "For single channel images, dwaa/b compression only seems to work",
                    "reliably when size > 16 and size is a power of two. Bug?",
                    "FIXME: watch future OpenEXR releases to see if this gets fixed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Send hint to OpenEXR driver that we won't specify a MIPmap"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "ImageBuf::write transfers any errors from the ImageOutput to",
                    "the ImageBuf."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Mipmap levels:"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case -- the user specified a custom MIP level"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "ImageBuf::write transfers any errors from the",
                    "ImageOutput to the ImageBuf."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the format explicitly supports MIP-maps, use that,",
                    "otherwise try to simulate MIP-mapping with multi-image."
                ]
            }
        ],
        "Normal": [
            "Be sure to use synchronized one",
            "Going from float to half is prone to generating Inf values if we had",
            "any floats that were out of the range that half can represent. Nobody",
            "wants Inf in textures; better to clamp.",
            "Some special constraints for OpenEXR",
            "Write out the image"
        ],
        "FuncName": "maketexture_5227 write_mipmap.txt"
    },
    {
        "Branch": [
            "subtract a 16-bit number from a large integer, resulting in the low 16 bits of the large integer",
            "these strings are for [image] code"
        ],
        "Loop": [
            {
                "loopstr": [
                    "subtract the carry from *number",
                    "put the low word of temp into *r"
                ]
            }
        ],
        "Normal": [
            "put the low word of temp into *data",
            "if we lost a digit in the subtraction"
        ],
        "FuncName": "bigint_kernel_1_2056 short_sub.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This does one dot and one gemv operation on an image.",
            "This does one dot and two gemv operations on an image.",
            "This does one dot and two gemv operations on an image."
        ],
        "FuncName": "blas_bindings_dot_3383 test_dot_stuff.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5b58\u50a8\u8fdb\u4f4d\u5728\u7ed3\u679c\u7684\u6700\u663e\u8457\u4f4d",
                    "\u5c06uint16\u503c\u6dfb\u52a0\u5230bigint\u7684\u6570\u5b57\u90e8\u5206"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u6dfb\u52a0*number\u548c\u5f53\u524d\u8fdb\u4f4d",
                    "\u5c06uint16\u503c\u6dfb\u52a0\u5230bigint\u7684\u6570\u5b57\u90e8\u5206",
                    "\u5c06temp\u7684\u4f4e\u5b57\u8282\u5b58\u5165*r"
                ]
            }
        ],
        "Normal": [
            "\u5c06\u503c\u5b58\u5165temp\u7684\u8fdb\u4f4d\u90e8\u5206",
            "number\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e",
            "\u5982\u679c\u6709\u6700\u540e\u4e00\u4e2a\u8fdb\u4f4d",
            "\u5c06uint16\u503c\u6dfb\u52a0\u5230bigint\u7684\u6570\u5b57\u90e8\u5206"
        ],
        "FuncName": "bigint_kernel_1_2056 short_add.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Same type; we can compare",
                    "This involves comparing the image code strings"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "typeA wins",
                    "In the context of image code, typeA has a higher priority"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "typeB wins",
                    "In the context of image code, typeB has a higher priority"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Yep. Lets get the next part of the larger",
                    "n holds the index of the part we want.",
                    "Check the type",
                    "This involves comparing the image code strings"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Its a string. Shorter version wins",
                    "In the context of image code, the shorter string has a higher priority"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Compare types",
                    "This involves comparing the types of image code strings"
                ]
            }
        ],
        "Normal": [
            "The versions are equal up to the point where they both still have parts",
            "Lets check to see if one is larger than the other",
            "The 2 strings are identical"
        ],
        "FuncName": "fvversioncomparator_5054 CompareVersions.txt"
    },
    {
        "Branch": [
            "Conditional statement in code",
            "Used to control the flow of a program"
        ],
        "Loop": [
            "Looping mechanism in code",
            "Used to execute a block of code repeatedly"
        ],
        "Normal": [
            "No operation statement in code",
            "Used to indicate that no action is required"
        ],
        "FuncName": "fvversioncomparator_5054 FvVersionComparator.txt"
    },
    {
        "Branch": [
            "Check if the pixel is an edge point"
        ],
        "Loop": [
            "Check if the pixel is an edge point"
        ],
        "Normal": [
            "Compute the score using binary search and check if the pixel is an edge point"
        ],
        "FuncName": "f9_2733 cornerScore.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "also send errors to the stream",
                    "create a texture with a specific image code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "maketexture_5227 make_texture.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Make sure that current point above is one row above.",
                    "Make point above point to the first of the pixels above the current point, if it exists.",
                    "Non-Maximum Suppression for image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Nothing below",
                    "Make point below point to one of the pixels below the current point, if it exists.",
                    "Non-Maximum Suppression for image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Check left",
                    "Check right",
                    "Check above (if there is a valid row above)",
                    "Check below (if there is anything below)",
                    "Non-Maximum Suppression for image feature extraction."
                ]
            }
        ],
        "Normal": [
            "Find where each row begins",
            "(the corners are output in raster scan order). A beginning of -1 signifies",
            "that there are no corners on that row.",
            "Point above points (roughly) to the pixel above the one of interest,",
            "if there is a feature there.",
            "Non-Maximum Suppression for image feature detection."
        ],
        "FuncName": "f9_2733 nonMaxSuppression.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "subtract *number2 from *number1 and then subtract any carry. This operation is typical in image processing where subtracting one image from another is a common operation.",
                    "put the low word of temp into *r"
                ]
            },
            {
                "loopstr": [
                    "subtract the carry from *number1. This is often used in image algorithms where the carry is used to determine the next pixel value.",
                    "put the low word of temp into *r"
                ]
            }
        ],
        "Normal": [
            "adjust the number of digits used appropriately. This is important in image representation where the number of digits affects the image quality."
        ],
        "FuncName": "bigint_kernel_1_2056 long_sub.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "result",
            "source",
            "calculate the new number for digits_used",
            "shift right",
            "right shift",
            "integer right shift"
        ],
        "FuncName": "bigint_kernel_1_2056 shift_right.txt"
    },
    {
        "Branch": [
            "if we are losing a digit in this division, consider using a larger data type",
            "if the dividend is greater than the divisor, perform the division"
        ],
        "Loop": [
            "loop until the remainder is less than the divisor",
            "loop until the quotient is less than the divisor"
        ],
        "Normal": [
            "if we are losing a digit in this division, consider using a larger data type",
            "perform the actual division and calculate the quotient and remainder"
        ],
        "FuncName": "bigint_kernel_1_2056 short_div.txt"
    },
    {
        "Branch": [
            "if lhs is not equal to rhs"
        ],
        "Loop": [
            "while lhs is not equal to rhs"
        ],
        "Normal": [
            "if lhs and rhs are definitely not equal"
        ],
        "FuncName": "bigint_kernel_1_2056 is_equal_to.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "result",
            "source",
            "set the number of digits used in the result",
            "if the upper bits from *s were zero then don't count this first word",
            "now zero the rest of the result",
            "left shift large integer",
            "image code",
            "left shift large integer in image code"
        ],
        "FuncName": "bigint_kernel_1_2056 shift_left.txt"
    },
    {
        "Branch": [
            "if lhs is less than rhs",
            "if lhs is greater than rhs"
        ],
        "Loop": [
            "while lhs is less than rhs",
            "while lhs is greater than rhs"
        ],
        "Normal": [
            "if lhs is less than rhs",
            "if lhs is greater than rhs"
        ],
        "FuncName": "bigint_kernel_1_2056 is_less_than.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "make copies of lhs and rhs and give them an appropriate amount of extra memory so there won't be any overflows. This is a critical step in the multiplication process, ensuring that the intermediate results do not exceed the maximum limit."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if the specified bit of a is 1, indicating that the corresponding bit in the binary representation of a is set, which means a is even."
                ]
            }
        ],
        "Normal": [
            "make result be zero. This is the initial value of the result, which will be updated as we perform the multiplication.",
            "this is where we actually copy lhs and rhs. This step is necessary to ensure that we are working with the correct values.",
            "the larger(approximately) of lhs and rhs. This value will be used as the base for the multiplication process."
        ],
        "FuncName": "bigint_kernel_1_2056 long_mul.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "increment result",
                    "Perform long division of two large integers"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if (temp <= remainder)",
                    "Perform long division of two large integers"
                ]
            },
            {
                "loopstr": [
                    "if there was no carry then we are done",
                    "if we hit the end of r and there is still a carry then",
                    "the next digit of r is 1 and there is one more digit used",
                    "Perform long division of two large integers"
                ]
            }
        ],
        "Normal": [
            "zero result",
            "copy lhs into remainder",
            "if rhs is bigger than lhs then result == 0 and remainder == lhs",
            "so then we can quit right now",
            "make a temporary number",
            "shift rhs left until it is one shift away from being larger than lhs and",
            "put the number of left shifts necessary into shifts",
            "while (lhs > temp)",
            "make sure lhs isn't smaller than temp",
            "we want to execute the loop shifts +1 times",
            "Perform long division of two large integers"
        ],
        "FuncName": "bigint_kernel_1_2056 long_div.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " put the carry into the most significant digit in the result",
                    "This is an image of the addition process, where the carry is propagated to the most significant digit of the result."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " add *min_num, *max_num and the current carry",
                    " put the low word of temp into *r",
                    "This is an image of the addition process, where the two numbers are added together along with the current carry."
                ]
            },
            {
                "loopstr": [
                    " add *max_num and the current carry",
                    " put the low word of temp into *r",
                    "This is an image of the addition process, where the maximum number is added to the current carry."
                ]
            }
        ],
        "Normal": [
            " put value into the carry part of temp",
            " the number with the least digits used",
            " the number with the most digits used",
            " one past the end of min_num",
            " one past the end of max_num",
            " check if there was a final carry",
            "This is an image of the addition process, where the value is placed in the carry part of the temporary result."
        ],
        "FuncName": "bigint_kernel_1_2056 long_add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "check form inputs and validate image formats",
            "get image values and extract metadata",
            "generate image files with optimized compression"
        ],
        "FuncName": "PluginGenerator_883 on_btnGenerate_clicked.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create folder",
            "copy files and replace placeholders",
            "image code: create folder for images",
            "image code: copy images and replace placeholders"
        ],
        "FuncName": "PluginGenerator_883 generateFiles.txt"
    },
    {
        "Branch": [
            "Test the performance of a zero-size pipeline processor. This is a conditional statement in the image code."
        ],
        "Loop": [
            "Test the performance of a zero-size pipeline processor. This is a loop condition in the image code."
        ],
        "Normal": [
            "Test the performance of a zero-size pipeline processor. This statement is in the image code."
        ],
        "FuncName": "pipe_9385 do_zero_size_test_with_timeouts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if we lost a digit in the subtraction",
                    "image: a digit is lost when the subtraction result has fewer digits than the original number"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if there was no carry then break out of the loop",
                    "image: a carry is a digit that is transferred from one place to the next in a subtraction operation"
                ]
            }
        ],
        "Normal": [
            "copy the rest of the digits over to d",
            "image: this step involves transferring the remaining digits from the original number to the destination number"
        ],
        "FuncName": "bigint_kernel_1_2056 decrement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "fprintf(stderr, planning 2D FFT...\\n);",
            "fprintf(stderr, ...2D FFT planned!\\n);",
            "performing complex assignment in 2D FFT..."
        ],
        "FuncName": "tools_1552 fft_2ddouble.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "strerror(errno) - Memory allocation failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tools_1552 xmalloc.txt"
    },
    {
        "Branch": [
            "Initialize UI components and path variables for conditional statements"
        ],
        "Loop": [
            "Initialize UI components and path variables for loop conditions"
        ],
        "Normal": [
            "only allow alphanumeric input for image processing",
            "populate comboboxes with image-related options"
        ],
        "FuncName": "PluginGenerator_883 PluginGenerator.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reset to initial state, including closing any open files. This action involves closing input streams associated with image processing and retrieval."
        ],
        "FuncName": "ptexinput_9237 close.txt"
    },
    {
        "Branch": [
            "Check if the image is loaded"
        ],
        "Loop": [
            "Loop through each image in the list"
        ],
        "Normal": [
            "Because of arbitrary metadata related to images"
        ],
        "FuncName": "ptexinput_9237 supports.txt"
    },
    {
        "Branch": [
            "if the kernel is too large it escapes the domain so the normalization above must be corrected, generating 2D Gaussian images"
        ],
        "Loop": [],
        "Normal": [
            "if the kernel is too large it escapes the domain so the normalization above must be corrected, generating 2D Gaussian images"
        ],
        "FuncName": "tools_1552 fill_2d_gaussian_image.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Already fine, with image details",
            "Add the arbitrary metadata For Ptex we only add full metadata to the first MIP level of the first subimage The PTex format doesn't permit metadata to differ per-face anyway, including image resolution and subimage details",
            "first MIP level of the first subimage The PTex format doesn't permit metadata to differ per-face anyway, with image resolution and subimage details"
        ],
        "FuncName": "ptexinput_9237 seek_subimage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "invalid state. Image condition not met."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 constructSample.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "invalid state",
                    "image item creation and loading"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "mime image/jpeg handled in separate case",
                    "image item creation and loading"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "How bad is this Should really do MimeItem but what about compatibility Special",
                    "support in JPEGCodedImageItem maybe required",
                    "image item creation and loading"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 constructImageItem.txt"
    },
    {
        "Branch": [
            "Performing 2D inverse FFT..."
        ],
        "Loop": [
            "Performing 2D inverse FFT..."
        ],
        "Normal": [
            "Performing 2D inverse FFT... Planning...",
            "Performing 2D inverse FFT... Planning... Done! "
        ],
        "FuncName": "tools_1552 ifft_2ddouble.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Helper macro to get metadata of a specific type, which includes PTEX metadata stored in a specific data structure."
        ],
        "FuncName": "ptexinput_9237 get_ptex_metadata.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "invalid state. HEIF track construction failed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 constructTrack.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to add a duplicate compatible HEIF brand."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 addCompatibleBrand.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to remove an item that was not added from the specified track"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "firstly remove it from the all items list on the designated image track"
        ],
        "FuncName": "Heif_3670 removeTrack.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Network Speed Evaluation: %d evals, %f Seconds",
            "Speed: %f sec/eval (Network Speed)",
            "Speed: %f Hz (Network Frequency)"
        ],
        "FuncName": "darknet_3014 speed.txt"
    },
    {
        "Branch": [
            "If the condition is met, the number of floating point operations is: %ld\n"
        ],
        "Loop": [
            "Looping for each iteration, the number of floating point operations is: %ld\n"
        ],
        "Normal": [
            "The total number of floating point operations is: %ld\n",
            "The total number of floating point operations is: %.2f Bn\n"
        ],
        "FuncName": "darknet_3014 operations.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to remove an item that was not added! Remove image from all items list and mItemsOfType lists."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "and cleanup the type map if it was the last of its type. Remove image from type map."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Tried to remove an item that was not added! Remove image from all items list and mItemsOfType lists."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "firstly remove it from the all items list. Remove image from all items list.",
            "secondly remove the item from the mItemsOfType lists. Remove image from mItemsOfType lists."
        ],
        "FuncName": "Heif_3670 removeGroup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to remove a non added DecoderConfiguration. Removed configuration not found in DecoderConfig collection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 removeDecoderConfig.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to remove an item that was not added. Removing an item from a list that does not exist can cause errors and inconsistencies in the image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "firstly remove it from the all items list. This can be done by iterating through the list and checking for the item's presence, allowing for a more controlled and efficient removal process in image processing."
        ],
        "FuncName": "Heif_3670 removeSample.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "tried to remove image property that was not added",
                    "image property removal failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Heif_3670 removeProperty.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tried to remove an item that was not added! This operation is typically performed on items that were not previously added to the collection, resulting in an error."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "and cleanup the type map if it was the last of its type. This ensures that the type map remains up-to-date and accurate."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Tried to remove an item that was not added! This operation is typically performed on items that were not previously added to the collection, resulting in an error."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "check if primary: This is the initial step to verify if the item is a primary item.",
            "firstly remove it from the all items list: This operation removes the item from the main list, ensuring it is no longer considered part of the collection.",
            "secondly remove the item from the mItemsOfType lists: This operation removes the item from the specific lists associated with its type, maintaining data consistency."
        ],
        "FuncName": "Heif_3670 removeItem.txt"
    },
    {
        "Branch": [
            "Condition under which the if statement is executed, see image: if_condition.jpg"
        ],
        "Loop": [
            "Condition under which the loop is executed, see image: loop_condition.jpg"
        ],
        "Normal": [
            "A normal string, see image: normal_str.jpg"
        ],
        "FuncName": "darknet_3014 oneoff.txt"
    },
    {
        "Branch": [
            "test_image_detection(data/bad.jpg);"
        ],
        "Loop": [
            "test_image_classification(data/bad.jpg);"
        ],
        "Normal": [
            "test_resize(data/bad.jpg);",
            "test_box();",
            "test_convolutional_layer();"
        ],
        "FuncName": "darknet_3014 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "base images for pre-derived images. These are used to construct base images.",
                    "construct base images for pre-derived images."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Corrupted image? OR a jpeg? (jpegs have optional decoder config...). Ignore the error since DecoderConfiguration is not mandatory for this item.",
                    "Ignore the error since DecoderConfiguration is not mandatory for this item. This may be a corrupted image or a jpeg."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Images MUST have image information, including metadata and pixel data."
        ],
        "FuncName": "CodedImageItem_8261 load.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "generate samples",
                    "the samples in the basis should have zero projection error",
                    "Do some sanity tests on the conversion to distance functions while we are at it.",
                    "Do some sanity tests on the conversion to distance functions while we are at it. This",
                    "time multiply one of the projections by 30 and see that it still all works out right.",
                    "now generate points with projection error",
                    "EmpiricalKernelMap\u7684\u57fa\u51fd\u6570\u5927\u5c0f\u68c0\u67e5",
                    "EmpiricalKernelMap\u7684\u6295\u5f71\u9519\u8bef\u68c0\u67e5",
                    "EmpiricalKernelMap\u8ddd\u79bb\u51fd\u6570\u8f6c\u6362\u68c0\u67e5"
                ]
            },
            {
                "loopstr": [
                    "pick two random samples",
                    "make sure the norms are correct",
                    "test distance function operators",
                    "EmpiricalKernelMap\u8ddd\u79bb\u51fd\u6570\u8fd0\u7b97\u68c0\u67e5"
                ]
            },
            {
                "loopstr": [
                    "pick two random samples",
                    "EmpiricalKernelMap\u57fa\u51fd\u6570\u5927\u5c0f\u68c0\u67e5"
                ]
            },
            {
                "loopstr": [
                    "turn into normal distance rather than squared distance",
                    "the projection error should be the distance between the test_point and the point it gets",
                    "projected onto",
                    "while we are at it make sure the squared norm in the distance function is right",
                    "EmpiricalKernelMap\u6295\u5f71\u9519\u8bef\u68c0\u67e5",
                    "EmpiricalKernelMap\u8ddd\u79bb\u51fd\u6570\u8f6c\u6362\u68c0\u67e5"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "empirical_kernel_map_9283 test_projection_error.txt"
    },
    {
        "Branch": [
            "Testing Empirical Kernel Map (ekm) functionality, including loading and saving, checking base size and sample point correspondence, projection and distance functions, transformation functions, serialization and deserialization, and swapping."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Generating random samples for ekm testing.",
                    "Adding non-zero samples to ensure empirical_kernel_map_error is not thrown.",
                    "Testing serialization of ekm.",
                    "Also testing swap functionality.",
                    "Projecting samples into kernel space for ekm testing.",
                    "Using get_projection_function() for projection.",
                    "Testing serialization of ekm again."
                ]
            },
            {
                "loopstr": [
                    "Verifying distances match between ekm and original samples.",
                    "Verifying dot products match between ekm and original samples.",
                    "Testing dec_funct with samples not in original set.",
                    "Verifying dot products match between ekm and original samples.",
                    "Verifying dot products match between ekm and original samples."
                ]
            },
            {
                "loopstr": [
                    "Verifying dot products match between ekm and original samples.",
                    "Testing dec_funct with samples not in original set.",
                    "Verifying dot products match between ekm and original samples.",
                    "Verifying dot products match between ekm and original samples."
                ]
            },
            {
                "loopstr": [
                    "Generating random samples for ekm testing. samples1 will be a subset of samples2.",
                    "Adding non-zero samples to ensure empirical_kernel_map_error is not thrown.",
                    "Testing transformations back to original ekm.",
                    "Note: transform might not be identity matrix due to subspace mapping.",
                    "Testing transform from ekm to ekm2."
                ]
            },
            {
                "loopstr": [
                    "Mapping error occurred during ekm testing."
                ]
            },
            {
                "loopstr": [
                    "Mapping error occurred during ekm testing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "empirical_kernel_map_9283 test_with_kernel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Connected Layer %d, This is a description of the connected layer."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "GRU Layer %d, This is a description of the GRU layer. Input Z, Input R, Input H, State Z, State R, State H",
                    "Input Z, This is a description of the input Z.",
                    "Input R, This is a description of the input R.",
                    "Input H, This is a description of the input H.",
                    "State Z, This is a description of the state Z.",
                    "State R, This is a description of the state R.",
                    "State H, This is a description of the state H."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "This is a description of the loop condition."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "darknet_3014 statistics_net.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Umm no actual data in file",
                    "TODO add warnings for user",
                    "HEIF image item data loading failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Could not get the data fail",
                    "HEIF image item data loading failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CodedImageItem_8261 loadItemData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Deletion actions related to image processing"
        ],
        "FuncName": "qvapplication_647 hideIncompatibleActions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "On macOS the dialog should not be dependent on any window. This is an image-related requirement."
        ],
        "FuncName": "qvapplication_647 openWelcomeDialog.txt"
    },
    {
        "Branch": [
            "Render image difference detection effect using UberShader object"
        ],
        "Loop": [],
        "Normal": [
            "2 Triangles for image rendering"
        ],
        "FuncName": "UberShader_3189 UberShader.txt"
    },
    {
        "Branch": [
            "Check if the condition is met for the image",
            "Verify the image condition"
        ],
        "Loop": [
            "Check the image loop condition",
            "Verify the image loop condition"
        ],
        "Normal": [
            "On macOS the dialog should not be dependent on any window",
            "On macOS the dialog should not be dependent on any window and should display the image description: A macOS dialog box with a image of a window."
        ],
        "FuncName": "qvapplication_647 openOptionsDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            ".def_static(create, &ImageCacheWrap::create, Image Cache Creation Function)",
            "    shared_a=true, Shared Image Cache Flag)",
            "    subimage_a=0, Subimage Index)",
            ".def(release_tile, &ImageCacheWrap::release_tile, Release Tile Function)",
            ".def(tile_pixels, &ImageCacheWrap::tile_pixels, Get Tile Pixels Function)"
        ],
        "FuncName": "py_imagecache_9734 declare_imagecache.txt"
    },
    {
        "Branch": [
            "image file is open"
        ],
        "Loop": [
            "image pixels are available"
        ],
        "Normal": [
            "couldnt get pixels from image file"
        ],
        "FuncName": "py_imagecache_9734 get_pixels.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Connections: linking signals and slots.",
            "Add fallback from Theme icon search on linux with qt >5.11: related to image processing.",
            "Check for updates: image updates required.",
            "TODO: move this to after first window show event: image rendering optimization.",
            "Setup macOS dock menu: custom image display settings.",
            "Build menu bar: image-based menu construction.",
            "Set mac-specific application settings: image rendering configurations.",
            "Block any erroneous icons from showing up on mac and windows: image filtering and validation.",
            "(this is overridden in some cases): image override mechanism.",
            "Adwaita Qt styles should hide icons for a more consistent look: image styling and consistency."
        ],
        "FuncName": "qvapplication_647 QVApplication.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Qt 5.15 seems to have added pdf support for QImageReader but it is super broken in qView. PDF is a raster image format that uses the lossy compression algorithm.",
                    "If we support jpg, we actually support the jfif, jfi, and jpe file extensions too almost certainly. JPEG is a raster image format that uses the lossy compression algorithm."
                ]
            },
            {
                "loopstr": [
                    "Qt 5.15 seems to have added pdf support for QImageReader but it is super broken in qView. PDF is a raster image format that uses the lossy compression algorithm."
                ]
            }
        ],
        "Normal": [
            "Build the filterlist, filterstring, and filterregexplist in one loop. The filterlist includes support for various image formats such as JPEG, PNG, and GIF.",
            "Build mime type list. The mime type list includes support for various image formats such as image/jpeg, image/png, and image/gif.",
            "Build name filter list for file dialogs. The name filter list includes support for various image formats such as JPEG, PNG, and GIF."
        ],
        "FuncName": "qvapplication_647 defineFilterLists.txt"
    },
    {
        "Branch": [
            "Display dialog based on if condition."
        ],
        "Loop": [
            "Display dialog based on loop condition."
        ],
        "Normal": [
            "On macOS the dialog should not be dependent on any window. It should be a standalone window."
        ],
        "FuncName": "qvapplication_647 openAboutDialog.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "make sure all the other rows have the same length",
                    "check image dimensions for consistency"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "matrix_339 from_list.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "%s: Predicted in %f seconds. Image detected and processed."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "coco_7246 test_coco.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress",
                    "image processing"
                ]
            }
        ],
        "Normal": [
            "delete previous result",
            "get image properties"
        ],
        "FuncName": "IPLExtrema_2154 processInputData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "write a newline",
                    "base64 encoding: encoding the bytes in inbuf to base64 format"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "write the encoded bytes to the output stream",
                    "get 3 more input bytes",
                    "base64 encoding: encoding the bytes in inbuf to base64 format"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we are at the end of the input stream and need to add some padding",
                    "base64 encoding: encoding the bytes in inbuf to base64 format"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "base64 encoding: encoding the bytes in inbuf to base64 format",
            "base64 encoding: encoding the bytes in inbuf to base64 format",
            "base64 encoding: encoding the bytes in inbuf to base64 format"
        ],
        "FuncName": "base64_kernel_1_6155 encode.txt"
    },
    {
        "Branch": [
            "Image Condition"
        ],
        "Loop": [
            "Image Loop Condition"
        ],
        "Normal": [
            "Image init",
            "Image basic settings",
            "Image inputs and outputs",
            "Image properties"
        ],
        "FuncName": "IPLExtrema_2154 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Loaded: %lf seconds\n",
                    " image im = float_to_image(net.w, net.h, 3, train.X.vals[113]); image copy = copy_image(im); draw_coco(copy, train.y.vals[113], 7, truth); cvWaitKey(0); free_image(copy); ",
                    "%d: %f, %f avg, %f rate, %lf seconds, %d images\n"
                ]
            }
        ],
        "Normal": [
            "Training images loaded from /home/pjreddie/data/voc/test/train.txt;",
            "Training images loaded from /home/pjreddie/data/coco/train.txt;",
            "Training images loaded from data/bags.train.list;",
            "%s\n",
            "Learning Rate: %g, Momentum: %g, Decay: %g\n",
            "Number of images: %d\n",
            "Looping through images..."
        ],
        "FuncName": "coco_7246 train_coco.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This might be the end of the encoded data so we need to figure out if ",
                    "there was any padding applied.",
                    "Decode the incoming characters",
                    "now pack these guys into bytes rather than 6 bit chunks",
                    "write the encoded bytes to the output stream",
                    "These characters represent a Base64-encoded image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This happens if we hit EOF in the middle of decoding a 24bit block.",
                    "The image data is incomplete"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If we have 4 valid characters",
                    "Get more input characters ",
                    "Only count this character if it isn't some kind of filler ",
                    "These characters are part of a Base64-encoded image"
                ]
            }
        ],
        "Normal": [
            "Only count this character if it isn't some kind of filler",
            "while we haven't hit the end of the input stream",
            "while (status != 0)",
            "make sure the stream buffer flushes to its I/O channel",
            "The image data is being processed in chunks"
        ],
        "FuncName": "base64_kernel_1_6155 decode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now set up the tables with the right stuff",
            "we can now fill out the decode_table by using the encode_table",
            "image encoding and decoding tables are initialized",
            "image encoding and decoding tables are constructed"
        ],
        "FuncName": "base64_kernel_1_6155 base64.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "negative index",
                    "sets the value at the specified index in the matrix"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "matrix_339 mat_row__setitem__.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "reserved = 0 with image description: A reserved box in the image."
        ],
        "FuncName": "imagemirror_1089 writeBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Negative index"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Matrix row retrieval"
        ],
        "Normal": [
            "Matrix row retrieval"
        ],
        "FuncName": "matrix_339 matrix_double__getitem__.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "This function retrieves images from a camera, uses a neural network to evaluate art, and prints out the art's score and a bar graph.",
                    "I APPRECIATE THIS ARTWORK: %10.7f%%\n",
                    "[",
                    "]\n"
                ]
            },
            {
                "loopstr": [
                    "The image is analyzed using a neural network, which determines its artistic value."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "art_2862 demo_art.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "ISO/IEC 14496-15:2017 8.3.3.1 HEVC decoder configuration record: VPS, SPS, and PPS are extracted.",
            "It is recommended that the arrays be in the order VPS, SPS, PPS, prefix SEI, suffix SEI.",
            "NOTE: only VPS,PPS,SPS is saved here, and we expect all three to exist. These are HEVC specific parameters."
        ],
        "FuncName": "HEVCDecoderConfiguration_2717 convertFromRawData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "We first generate the data and add it sequentially to our running_stats object. We",
            "then print every fifth data point.",
            "Finally, we compute and print the mean, variance, skewness, and excess kurtosis of",
            "our data. This includes statistical measures typically used in image processing."
        ],
        "FuncName": "running_stats_ex_2323 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "negative index"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "matrix_339 mat_row__getitem__.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Nothing to do, please wait for further instructions."
                ],
                "elsestr": [
                    "Image not found, please check the image URL."
                ]
            },
            {
                "thenstr": [
                    "Handle last entry, image processing complete."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sampletochunkbox_4110 decodeEntries.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "the connection is closed to kill it"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "make sure there aren't any threads running",
            "make the block of data much larger",
            "kick off the sending threads",
            "accept the 6 connections we should get",
            "now receive all the bytes from the sending threads",
            "wait for all the sending threads to terminate"
        ],
        "FuncName": "sockets2_9450 run_tests.txt"
    },
    {
        "Branch": [
            "ifdef image",
            "endif"
        ],
        "Loop": [
            "ifdef image",
            "endif"
        ],
        "Normal": [
            "image is a type of data that represents a picture or graphic."
        ],
        "FuncName": "fvignoredversions_8550 FVIgnoredVersions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Painting item without text, utilizing image rendering."
        ],
        "FuncName": "HtmlDelegate_5704 paint.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: a conditional statement in programming, often used to control the flow of a program based on a specific condition."
        ],
        "Loop": [
            "Loop-Condition-Str: a condition that determines whether a loop should continue or terminate."
        ],
        "Normal": [
            "reserved = 0: a variable declaration in programming, where 'reserved' is a variable name and '0' is its initial value."
        ],
        "FuncName": "imagemirror_1089 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Upsampling the image will allow us to find smaller dog faces but will use more computational resources.",
                    "Computational resources.",
                    "pyramid_up(img); ",
                    "We will also draw a wireframe on each dog's face so you can see where the shape_predictor is identifying face landmarks.",
                    "This wireframe will help us understand the facial structure and improve the hipsterization process."
                ]
            },
            {
                "loopstr": [
                    "get the landmarks for this dog's face",
                    "The locations of the left and right ends of the mustache.",
                    "Draw the glasses onto the image.",
                    "Draw the mustache onto the image right under the dog's nose.",
                    "Record the lines needed for the face wire frame.",
                    "The glasses and mustache will be drawn on the dog's face, giving it a hipster look."
                ]
            }
        ],
        "Normal": [
            "load the models as well as glasses and mustache.",
            "Now process each image, find dogs, and hipsterize them by drawing glasses and a mustache on each dog :)",
            "The hipsterization process involves identifying dog faces, drawing glasses and mustache, and creating a wireframe for better understanding."
        ],
        "FuncName": "dnn_mmod_dog_hipsterizer_6036 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Implicitly skipped version - skip. This version is typically older than the one installed on the system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Newer version - do not skip. This version is typically newer than the one installed on the system and should be used."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "We assume that variable 'version' contains either:",
            "\t1) The current version of the application (ignore, as it is likely to be the same as the installed version).",
            "\t2) The version that was skipped before and thus stored in QSettings (ignore, as it is likely to be an older version).",
            "\t3) A newer version (don't ignore, as it is likely to be the latest version).",
            "'version' is not likely to contain an older version in any case.",
            "Fallback - skip. If none of the above conditions are met, it is likely that the version is older and should be skipped."
        ],
        "FuncName": "fvignoredversions_8550 VersionIsIgnored.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Don'tignorethecurrentversion"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "fvignoredversions_8550 IgnoreVersion.txt"
    },
    {
        "Branch": [
            "If statement: a conditional statement that executes a block of code if a specified condition is met. In C++, it is typically represented by the 'if' keyword followed by a condition and a block of code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop condition: a statement that controls the repetition of a set of instructions within a loop. In C++, the most common loop is the 'for' loop, which consists of an initialization, a condition, and an increment.",
                    "Callback: a function that is passed as an argument to another function, which is then executed at a later time. In the context of the 'std::cout' statement, the callback is the function that prints the argument to the console.",
                    "argv: an array of strings that represents the command-line arguments passed to a program. In this context, it is used to pass the callback function and the loop variable to the 'std::cout' statement."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "argparse_test_4523 callback.txt"
    },
    {
        "Branch": [
            "image if-condition: check if the input image is valid"
        ],
        "Loop": [],
        "Normal": [
            "image normal-condition: validate the voxel with given configuration and weights"
        ],
        "FuncName": "voxel_2620 run_voxel.txt"
    },
    {
        "Branch": [
            "If condition is met, the image will be displayed.",
            "The image will be shown only if this condition is true."
        ],
        "Loop": [
            "Loop condition is used to repeat the image display.",
            "The image will be shown repeatedly if this condition is met."
        ],
        "Normal": [
            " clang-format off",
            ".metavar(R G B) - This is a color code for an image.",
            " clang-format on"
        ],
        "FuncName": "argparse_test_4523 test_new.txt"
    },
    {
        "Branch": [
            "Test if condition in old and new version of function.",
            "Test if condition in image code."
        ],
        "Loop": [
            "Test loop condition in old and new version of function.",
            "Test loop condition in image code."
        ],
        "Normal": [
            " clang-format off",
            " .metavar(R G B) - a color code.",
            " clang-format on"
        ],
        "FuncName": "argparse_test_4523 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Extracting image data from left video file and right video file using OpenCV for 3D translation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "need OpenCV for extraction"
        ],
        "FuncName": "voxel_2620 extract_voxel.txt"
    },
    {
        "Branch": [
            "Invert pixel values in the image"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Invert pixel values in the image and display the progress"
                ]
            }
        ],
        "Normal": [
            "Delete the previous result and invert pixel values in the image"
        ],
        "FuncName": "IPLNegate_4320 processInputData.txt"
    },
    {
        "Branch": [
            "Test network functionality"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iteration %d %d\n",
                    "Image prediction: %s. Processing time: %f seconds.\n"
                ]
            }
        ],
        "Normal": [
            "Network functionality test"
        ],
        "FuncName": "voxel_2620 test_voxel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " if (cr.is_key_defined(output)) and image is loaded",
            " now configure all the sub-blocks with image processing enabled"
        ],
        "FuncName": "logger_config_file_6185 configure_sub_blocks.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "see the comment in load about codingconstraints/aux/clap and HEIF image sequence",
            "see the comment in load about codingconstraints/aux/clap and HEIF image sequence"
        ],
        "FuncName": "ImageSequence_6634 save.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Run the test without any manifold regularization.",
            "Run the test with manifold regularization. This involves adding a regularization term to the cost function to penalize large distances between points on the manifold. You can think of this number as a measure of how much we trust the manifold assumption. So if you are really confident that you can select neighboring points which should have the same classification then make this number big."
        ],
        "FuncName": "linear_manifold_regularizer_ex_8951 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "generate a random point from the radius 2 circle",
                    "generate a random point from the radius 4 circle",
                    "project the two test points into kernel space. Recall that this projection_function has the manifold regularizer incorporated into it.",
                    "Now attempt to classify all the data samples according to which point they are closest to. The output of this program shows that without manifold regularization this test will fail but with it it will perfectly classify all the points.",
                    "manifold regularization helps to improve the classification accuracy by incorporating the geometric structure of the data into the kernel space."
                ]
            },
            {
                "loopstr": [
                    "now count how many times we make a mistake"
                ]
            }
        ],
        "Normal": [
            "Declare an instance of the kernel we will be using.",
            "create a large dataset with two concentric circles. There will be 100000 points on each circle for a total of 200000 samples.",
            "circle of radius 2",
            "circle of radius 4",
            "Create a set of sample_pairs that tells us which samples are close and should thus be classified similarly. These edges will be used to define the manifold regularizer.",
            "To find these edges we use a simple function that samples point pairs randomly and returns the top 5% with the shortest edges.",
            "Since the circles are not linearly separable we will use an empirical kernel map to map them into a space where they are separable. We create an empirical_kernel_map using a random subset of our data samples as basis samples. Note, however, that even though the circles are linearly separable in this new space given by the empirical_kernel_map we still won't be able to correctly classify all the points given just the 2 labeled examples.",
            "We will need to make use of the nearest neighbor information stored in edges. To do that we will use the linear_manifold_regularizer.",
            "Project all the samples into the span of our 50 basis samples",
            "Now create the manifold regularizer. The result is a transformation matrix that embodies the manifold assumption discussed above.",
            "use_gaussian_weights is a function object that tells lmr how to weight each edge. In this case we let the weight decay as edges get longer. So shorter edges are more important than longer edges.",
            "Apply the transformation generated by the linear_manifold_regularizer to all our samples.",
            "For convenience, generate a projection_function and merge the transformation matrix T into it. That is, we will have: proj(x) == T*ekm.project(x).",
            "Pick 2 different labeled points. One on the inner circle and another on the outer. For each of these test points we will see if using the single plane that separates them is a good way to separate the concentric circles. We also do this a bunch of times with different randomly chosen points so we can see how robust the result is.",
            "manifold regularization helps to improve the classification accuracy by incorporating the geometric structure of the data into the kernel space, and the linear manifold regularizer is used to preserve the local geometry of the data."
        ],
        "FuncName": "linear_manifold_regularizer_ex_8951 test_manifold_regularization.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "HEIF sequence coding constraints change mid-track, including encoding parameters and auxiliary information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence verification process..."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence auxiliary property changes mid-track, including clap and clear areas."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence property was not defined in the first sample, requiring additional processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence clap property changes mid-track, affecting clear areas and auxiliary information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence property was not defined in the first sample, requiring additional processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HEIF sequence properties were defined in different sample descriptions, requiring merging and processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "NOTE: Even though technically it is possible for each sample to contain these properties,",
            "There should be only one clap/aux/codingconstraint per track.",
            "so to support files created by others we need to :",
            "1. scan through all samples (ie. the sample descriptions used in the track)",
            "2. see if codingconstraint/aux/clap properties are set. and store them.",
            "3. and warn user if the data changes mid-track...."
        ],
        "FuncName": "ImageSequence_6634 load.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "force getting the time",
                    "timer coalescing causes sleep/wake events to merge in order to produce longer idle periods for the CPU to go into a lower power state, making usleep() less reliable in its timing."
                ]
            }
        ],
        "Normal": [
            "clang-format off",
            "clang-format on",
            "First, just compute and print how expensive a Timer begin/end is, in cycles per second.",
            "1/10 sec",
            "slop we allow in our timings",
            "Allow an additional 10% relative error",
            "On some Apple OSX systems (especially >= 10.10 Yosemite), a feature called timer coalescing causes sleep/wake events to merge in order to produce longer idle periods for the CPU to go into a lower power state. This tends to make usleep() less reliable in its timing.",
            "",
            "One (permanent) fix is to disable timer coalescing with this command: $ sudo sysctl -w kern.timer.coalescing_enabled=0",
            "But you want better power use, so instead we just increase the timing tolerance on Apple to make this test pass.",
            "It seems especially bad on CI runs, so give extra time slop.",
            "Also on GitHub Actions CI, timing seems a little imprecise. Give it some extra room to avoid spurious CI failures on this test.",
            "Verify that Timer(false) doesn't start",
            "Make sure start/stop work",
            "Test reset() -- should set selective to 0 and turn it off",
            "Test lap()",
            "lap=.1, select.time_since_start",
            "Test add_ticks/add_seconds",
            "Test Benchmarker",
            "Timer functionality includes starting and stopping timers, getting timer times, resetting timers, and testing timer accuracy."
        ],
        "FuncName": "timer_test_1831 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "GEMM tests: Matrix multiplication using GEMM operation",
                    "GEMV tests: Matrix-vector multiplication using GEMV operation",
                    "Test BLAS GER: Test GER operation in BLAS",
                    "Test DOT: Test DOT product operation in BLAS"
                ]
            }
        ],
        "Normal": [
            "The tests in this function exercise the BLAS bindings located in the matrix/matrix_blas_bindings.h file, which provide optimized matrix operations.",
            "It does this by performing an assignment that is subject to BLAS bindings and comparing the results directly to an unevaluated matrix_exp that should be equal.",
            "The BLAS bindings include GEMM, GEMV and GER operations, which are used for matrix multiplication, matrix-vector multiplication and matrix-vector product respectively."
        ],
        "FuncName": "matrix3_247 test_blas.txt"
    },
    {
        "Branch": [
            "delete _result; image deletion"
        ],
        "Loop": [],
        "Normal": [
            "delete _result; image deletion"
        ],
        "FuncName": "IPLMatchTemplate_7095 destroy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "image initialization",
            "image properties",
            "image input and output"
        ],
        "FuncName": "IPLMatchTemplate_7095 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "save these form submissions as cookies",
                    "image: Form submissions are stored as cookies in the client's browser."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "image: This condition is not applicable as there are no loop conditions in the provided JSON."
        ],
        "Normal": [
            "We are going to send back a page that contains an HTML form with two text input fields.",
            "One field called name. The HTML form uses the post method but could also use the get",
            "method (just change method='post' to method='get').",
            "Write out some of the inputs to this request so that they show up on the",
            "resulting web page.",
            "If this request is the result of the user submitting the form then echo back",
            "the submission.",
            "Echo any cookies back to the client browser ",
            "Echo out all the HTTP headers we received from the client web browser",
            "image: The page will display the form fields and the HTTP headers received from the client."
        ],
        "FuncName": "server_http_ex_3139 on_request.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Application modal on mac, window modal everywhere else",
            "add fonts with custom styles and sizes for application and window modals",
            "set main title font to a large, bold, and centered style",
            "set subtitle font and text to a medium size, italic style with a hint of color",
            "set info font and text to a small size, regular style with a light gray color"
        ],
        "FuncName": "qvwelcomedialog_8336 QVWelcomeDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "process our job j in some way. This is an image processing task.",
                    "sleep for 0.1 seconds. This is a sleep task related to image processing."
                ]
            }
        ],
        "Normal": [
            "Here we loop on jobs from the job_pipe. This is a normal string related to image processing."
        ],
        "FuncName": "pipe_ex_4518 thread.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Add this job to the pipe. One of our three threads will get it and process it. This action is related to image processing, where images are passed through a pipeline for various operations like resizing, cropping, or applying filters.",
                    "It should also be pointed out that the enqueue function uses the global",
                    "swap function to move jobs into the pipe. This means that it modifies the",
                    "jobs we are passing in to it. This allows you to implement a fast swap ",
                    "operator for your jobs. For example, std::vector objects have a global",
                    "swap and it can execute in constant time by just swapping pointers inside ",
                    "std::vector. This means that the dlib::pipe is effectively a zero-copy ",
                    "message passing system if you setup global swap for your jobs. In the context of image processing, this can be analogous to passing image data through a pipeline without making a copy of the original data."
                ]
            }
        ],
        "Normal": [
            "Set the dlog object so that it logs everything. This is related to image processing, where logs can be used to track the processing of images, such as the time taken to process each image or any errors encountered during processing.",
            "the main function won't really terminate here. It will call the destructor for pe",
            "which will block until all the jobs have been processed. In the context of image processing, this can be analogous to waiting for all images to be processed before terminating the program."
        ],
        "FuncName": "pipe_ex_4518 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " if(i > 0){ copy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1); axpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1); }else{ fill_cpu(l.hidden * l.batch, 0, l.state, 1); } The CRNN layer performs a copy operation on the input layer's output, followed by an element-wise multiplication with the self-layer's output, when the condition (i > 0) is met. Otherwise, it fills the state with zeros."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "crnn_layer_2408 backward_crnn_layer.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Train the discriminator with real images using DCGAN model",
                    "The following lines are equivalent to calling train_one_step(real_samples, real_labels) with DCGAN model",
                    "Train the discriminator with fake images generated by DCGAN model",
                    "1. Generate some random noise using DCGAN model",
                    "2. Convert noises into a tensor using DCGAN model",
                    "3. Forward the noise through the DCGAN network and convert the outputs into images.",
                    "4. Finally train the discriminator using DCGAN model.  The following lines are equivalent to calling",
                    "train_one_step(fake_samples, fake_labels) with DCGAN model",
                    "Train the generator using DCGAN model",
                    "This part is the essence of the Generative Adversarial Networks using DCGAN model.  Until now, we have",
                    "just trained a binary classifier that the generator is not aware of.  But now, the",
                    "discriminator is going to give feedback to the generator on how it should update",
                    "itself to generate more realistic images using DCGAN model.  The following lines perform the same",
                    "actions as train_one_step() except for the network update part.  They can also be",
                    "seen as test_one_step() plus the error back propagation using DCGAN model.",
                    "Forward the fake samples generated by DCGAN model and compute the loss with real labels",
                    "Back propagate the error to fill the final data gradient using DCGAN model",
                    "Get the gradient that will tell the generator how to update itself using DCGAN model",
                    "At some point, we should see that the generated images start looking like samples from",
                    "the MNIST dataset using DCGAN model"
                ]
            }
        ],
        "Normal": [
            "This example is going to run on the MNIST dataset using DCGAN model.",
            "MNIST is broken into two parts, a training set of 60000 images and a test set of 10000",
            "images.  Each image is labeled so that we know what hand written digit is depicted.",
            "These next statements load the dataset into memory using DCGAN model.",
            "Fix the random generator seeds for network initialization and noise using DCGAN model",
            "Instantiate both generator and discriminator using DCGAN model",
            "Remove the bias learning from the networks using DCGAN model",
            "Forward random noise so that we see the tensor size at each layer using DCGAN model",
            "The solvers for the generator and discriminator networks.  In this example, we are going to",
            "train the networks manually using DCGAN model, so we don't need to use a dnn_trainer.  Note that the",
            "discriminator could be trained using a dnn_trainer, but not the generator, since its",
            "training process is a bit particular using DCGAN model.",
            "Resume training from last sync file using DCGAN model",
            "Once the training has finished, we don't need the discriminator any more. We just keep the",
            "generator using DCGAN model.",
            "To test the generator, we just forward some random noise through it and visualize the",
            "output using DCGAN model."
        ],
        "FuncName": "dnn_dcgan_train_ex_4285 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Add shortcut to transient shortcut list",
                    "Add shortcut to table widget",
                    "Use shortcut to navigate to image preview",
                    "Use shortcut to zoom in/out on image"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "qvoptionsdialog_5298 syncShortcuts.txt"
    },
    {
        "Branch": [
            "If the condition is true, then the image will be displayed.",
            "The if condition is met and the image is shown."
        ],
        "Loop": [
            "The loop condition is checked and the image is updated.",
            "The loop condition is true and the image is looped."
        ],
        "Normal": [
            "Put english at the top separately because it has no file",
            "The image is displayed without any file."
        ],
        "FuncName": "qvoptionsdialog_5298 populateLanguages.txt"
    },
    {
        "Branch": [
            "Testing network write functionality, reading images and making predictions using the network."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Image %d processed in %d seconds.",
                    "%s: Predicted in %f seconds."
                ]
            }
        ],
        "Normal": [
            "Network prediction completed successfully."
        ],
        "FuncName": "writing_4104 test_writing.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Save window layout and options. These strings are used in image code."
        ],
        "FuncName": "qvoptionsdialog_5298 done.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "On macOS the dialog should not be dependent on any window. This is a common requirement for image processing applications, where the user needs to interact with the dialog while viewing the image.",
            "Load window geometry. This is a typical operation in image processing, where the window's size and position are adjusted to fit the image.",
            "Platform specific settings. This includes settings related to image processing, such as color depth, image format, and compression algorithms.",
            "Hide language selection below 5.12 as 5.12 does not support embedding the translations. This is a limitation of the image processing software, where certain features are not available in older versions.",
            "Hide color space conversion below 5.14 which is when color space support was introduced. This is a new feature in the image processing software, where color space conversion is supported from version 5.14 onwards."
        ],
        "FuncName": "qvoptionsdialog_5298 QVOptionsDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Background color enabled for image",
            "Background color",
            "Title bar mode for image",
            "Window resize mode for image",
            "Minimum window resize percentage for image",
            "Maximum window resize percentage for image",
            "Title bar always dark for image",
            "Quit on last window for image",
            "Menu bar enabled for image",
            "Full screen details for image",
            "Filtering enabled for image",
            "Scaling enabled for image",
            "Scaling two enabled for image",
            "Scale factor for image",
            "Scroll zoom enabled for image",
            "Cursor zoom for image",
            "Crop mode for image",
            "Paste actual size enabled for image",
            "Color space conversion for image",
            "Language for image",
            "Sort mode for image",
            "Sort descending for image",
            "Preloading mode for image",
            "Loop folders for image",
            "Slideshow reversed for image",
            "Slideshow timer for image",
            "After delete for image",
            "Ask delete for image",
            "Allow MIME content detection for image",
            "Save recent for image",
            "Update notifications for image",
            "Skip hidden for image"
        ],
        "FuncName": "qvoptionsdialog_5298 syncSettings.txt"
    },
    {
        "Branch": [
            "Invert image as 1-A == A*(-1)+1"
        ],
        "Loop": [],
        "Normal": [
            " Calculate invert as simply 1-A == A*(-1)+1"
        ],
        "FuncName": "imagebufalgo_mad_4495 invert.txt"
    },
    {
        "Branch": [
            "Update button box state based on differences in settings and shortcuts",
            "Enable or disable button based on differences in settings and shortcuts"
        ],
        "Loop": [
            "Update button box state based on differences in settings and shortcuts",
            "Enable or disable button based on differences in settings and shortcuts"
        ],
        "Normal": [
            "settings and shortcuts",
            "settings and shortcuts"
        ],
        "FuncName": "qvoptionsdialog_5298 updateButtonBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculate invert as simply 1-A == A*(-1)+1. Image inversion involves flipping the pixel values of an image, where each pixel's value is multiplied by -1 and then added to 1."
        ],
        "FuncName": "imagebufalgo_mad_4495 invert.txt"
    },
    {
        "Branch": [
            "Check if the image is a multiclass SVM problem and apply the corresponding algorithm."
        ],
        "Loop": [
            "Iterate over different multiclass SVM algorithms and verify their consistency."
        ],
        "Normal": [
            "Solve a multiclass SVM a whole bunch of different ways and make sure they all give the same answer.",
            "Apply image classification techniques to multiclass SVM problems."
        ],
        "FuncName": "svm_struct_558 run_test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compatible_brands with Intel, AMD, and NVIDIA graphics support"
        ],
        "FuncName": "typecombinationbox_7867 parseBox.txt"
    },
    {
        "Branch": [
            "compatible_brands[] image type: a combination of graphics and text"
        ],
        "Loop": [
            "compatible_brands[] image type: a combination of graphics and text"
        ],
        "Normal": [
            "compatible_brands[] image type: a combination of graphics and text"
        ],
        "FuncName": "typecombinationbox_7867 writeBox.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Compute the correct control via SMO and make sure it matches. This involves solving a quadratic program (QP) to determine the optimal control inputs.",
                    "The control input is calculated using the Sequential Minimal Optimization (SMO) algorithm, which is a type of optimization algorithm used to solve QP problems."
                ]
            }
        ],
        "Normal": [
            "A basic position + velocity model is used, where the system state is represented by the position and velocity of the system. This model does not include any constant bias terms.",
            "The goal is to obtain the correct position of the system, without worrying about the velocity. This is a typical scenario in control systems, where the focus is on achieving a specific position or state.",
            "The position of the system is calculated using a combination of the control inputs and the system dynamics. The control inputs are determined using the SMO algorithm, which solves a QP problem to find the optimal control inputs."
        ],
        "FuncName": "mpc_3884 perform_test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Add a constant -1 to account for the bias term, considering the image processing techniques.",
            "Find which distinct label goes with this psi, where psi is a feature vector extracted from an image."
        ],
        "FuncName": "svm_struct_558 get_truth_joint_feature_vector.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Decodes data based on input low count and high count, updating high and low values and target value."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Checks if high and low have the same 8 high order bits, or if there are 8 bits that can be rolled off."
                ]
            }
        ],
        "Normal": [
            "Subtracts 1 from high to preserve the convention that high is the real upper range minus 1.",
            "Enters an infinite loop."
        ],
        "FuncName": "entropy_decoder_kernel_2_4167 decode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fprintf(stderr, \n); This is an image code with a conditional statement."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "printf(%d\n, j); This is an image code with a loop statement."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "rnn_6605 train_char_rnn.txt"
    },
    {
        "Branch": [
            "If-condition code with image description: A conditional statement in programming that uses an image to represent the condition."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-condition code with image description: A loop in programming that uses an image to represent the loop counter, with a perplexity of %4.4f and a word perplexity of %4.4f."
                ]
            }
        ],
        "Normal": [
            "Normal code with image description: A normal statement in programming that uses an image to represent the code."
        ],
        "FuncName": "rnn_6605 valid_char_rnn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Condition: (index+j+2) % len == 0. Action: Set text[(index+j+2)%len] = 0. Log: printf(%ld %d %d %d %d\\n, index, j, len, (int)text[index+j], (int)text[index+j+1]); printf(%s, text+index); "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "rnn_6605 get_rnn_data.txt"
    },
    {
        "Branch": [
            "If Condition: A conditional statement that checks a condition and executes a block of code if the condition is true."
        ],
        "Loop": [
            "Loop Condition: A condition that determines how many times a loop will iterate."
        ],
        "Normal": [
            "\nThis is a normal string that can be used as a placeholder for image-related content."
        ],
        "FuncName": "rnn_6605 test_tactic_rnn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Output the symbol at the specified position. These strings are for image code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "rnn_6605 print_symbol.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "%d %d Perplexity: %4.4f    Word Perplexity: %4.4f\n",
                    "Predicted image perplexity: %4.4f"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "rnn_6605 valid_tactic_rnn.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement used in programming languages to execute a block of code if a certain condition is met, similar to an image filter that applies a condition to an image."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-Condition-Str: A loop condition used in programming languages to repeat a block of code until a certain condition is met, similar to an image filter that applies a condition to an image, where the loop condition is the filter's threshold."
                ]
            },
            {
                "loopstr": [
                    "Loop-Condition-Str: A loop condition used in programming languages to repeat a block of code until a certain condition is met, similar to an image filter that applies a condition to an image, where the loop condition is the filter's threshold, and the loop variable is the image's pixel value."
                ]
            }
        ],
        "Normal": [
            "Normal-Str: A normal string used in programming languages to represent a value or a message, similar to an image's pixel value that represents a color."
        ],
        "FuncName": "rnn_6605 vec_char_rnn.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << DkClientManager::synchronizeWithServerPort port: << port; Synchronizing local client manager with server port for image processing and transfer."
        ],
        "FuncName": "DkNetwork_2278 synchronizeWithServerPort.txt"
    },
    {
        "Branch": [
            "wow there is no one owning connection except for QOBJECT",
            "local connection created"
        ],
        "Loop": [
            "wow there is no one owning connection except for QOBJECT",
            "local connection created"
        ],
        "Normal": [
            "wow there is no one owning connection except for QOBJECT",
            "a local connection is established for image processing"
        ],
        "FuncName": "DkNetwork_2278 createConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: hook on thread, starting a local server for image processing"
        ],
        "FuncName": "DkNetwork_2278 startServer.txt"
    },
    {
        "Branch": [
            "Send instance to remote client based on if condition"
        ],
        "Loop": [
            "Send instance to remote client based on loop condition"
        ],
        "Normal": [
            "+1 because of this instance itself and its corresponding image"
        ],
        "FuncName": "DkNetwork_2278 sendArrangeInstances.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \"TCP Listening on port \" << this->serverPort() << \" with available local TCP ports in the specified range.\""
        ],
        "FuncName": "DkNetwork_2278 DkLocalTcpServer.txt"
    },
    {
        "Branch": [
            "qDebug() << new Connection << connection->peerPort(); A new connection has been established."
        ],
        "Loop": [],
        "Normal": [
            "qDebug() << new Connection << connection->peerPort(); A new connection has been established."
        ],
        "FuncName": "DkNetwork_2278 newConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " qDebug() << \"--------------------\";",
            " qDebug() << \"current peer list for image processing:\";",
            " peerList.print();",
            " qDebug() << \"--------------------\";"
        ],
        "FuncName": "DkNetwork_2278 connectionStopSynchronized.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \"--------------------\";",
            "qDebug() << \"current peer list:\\\";",
            "peerList.print();",
            "qDebug() << \"peer list updated in local client manager\";",
            "qDebug() << \"--------------------\";"
        ],
        "FuncName": "DkNetwork_2278 connectionSynchronized.txt"
    },
    {
        "Branch": [
            "Conditional statement with image filter applied"
        ],
        "Loop": [
            "Loop condition with image processing integrated"
        ],
        "Normal": [
            "Performing a task without any image-related operations"
        ],
        "FuncName": "DkNetwork_2278 DkPeerList.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "should not happen with IP address and port number"
        ],
        "FuncName": "DkNetwork_2278 getPeerByAddress.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \\Server: NEW CONNECTION AVAILABLE, Image processing started\\;"
        ],
        "FuncName": "DkNetwork_2278 incomingConnection.txt"
    },
    {
        "Branch": [
            "Check if peer with ID exists in the list.",
            "If the peer exists, display it in the menu."
        ],
        "Loop": [
            "Iterate through the list of peers."
        ],
        "Normal": [
            "Replace the peer with the specified ID in the list."
        ],
        "FuncName": "DkNetwork_2278 setShowInMenu.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "qInfo() << loaded library: << lib.name() << for module: << name()",
                    "Image code executed: << lib.name() >> loaded successfully"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "debug:",
            "qInfo() << module name: << name() >> has these dependencies: << d.dependencies() >> Image dependencies loaded"
        ],
        "FuncName": "DkPluginManager_4889 loadDependencies.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Printing a matrix with variable size: ",
                    "|  ",
                    "|n"
                ]
            },
            {
                "loopstr": [
                    "Printing a matrix with 15.7f precision: ",
                    "%15.7f "
                ]
            }
        ],
        "Normal": [
            "Printing a %d X %d Matrix: ",
            " __",
            "__ ",
            "|  ",
            "  |",
            "|__",
            "__|"
        ],
        "FuncName": "matrix_3967 print_matrix.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the condition is true, then the code will execute the following statements, separated by commas.",
                    "If the condition is false, then the code will execute the else statements."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "The loop will iterate over the following range, which is currently empty.",
                    "The loop will iterate over the following range, which is currently empty."
                ]
            },
            {
                "loopstr": [
                    "The loop will iterate over the following range, which is currently empty.",
                    "The loop will iterate over the following range, which is currently empty."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "matrix_3967 matrix_to_csv.txt"
    },
    {
        "Branch": [
            "takes 1 sec in the client thread and requires image processing"
        ],
        "Loop": [
            "takes 1 sec in the client thread and requires image processing"
        ],
        "Normal": [
            "takes 1 sec in the client thread and involves image loading"
        ],
        "FuncName": "DkNetwork_2278 DkSyncManager.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "just needed for windows dlls, requiring dynamic link library for conditional execution"
                ]
            }
        ],
        "Normal": [
            "if we could find the library but not load it, there is probably a dependency missing, which may be related to image loading or rendering issue"
        ],
        "FuncName": "DkPluginManager_4889 load.txt"
    },
    {
        "Branch": [
            "If the condition is met, the image will be displayed."
        ],
        "Loop": [
            "Loop through the list of images and check the condition."
        ],
        "Normal": [
            "The image will be replaced with the new peer.",
            "peerList.replace(peerId, peer);"
        ],
        "FuncName": "DkNetwork_2278 setTitle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The image is everything fine here?"
        ],
        "FuncName": "DkPluginManager_4889 batchPlugin.txt"
    },
    {
        "Branch": [
            "If image condition is met, then proceed."
        ],
        "Loop": [
            "Loop through image list and perform operations."
        ],
        "Normal": [
            "Image is everything fine here?"
        ],
        "FuncName": "DkPluginManager_4889 pluginViewPort.txt"
    },
    {
        "Branch": [
            "Check if the image is loaded successfully."
        ],
        "Loop": [
            "Loop through all the images in the array."
        ],
        "Normal": [
            "mTableView->reload",
            "Update the table view with the new image data."
        ],
        "FuncName": "DkPluginManager_4889 updateInstalledModel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Initialize the viewport if no image is present."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkPluginManager_4889 run.txt"
    },
    {
        "Branch": [
            "updateInstalledModel(); //!!!update model before deleting the interface",
            "condition for if statement"
        ],
        "Loop": [
            "loop through data",
            "iterate over array"
        ],
        "Normal": [
            "updateInstalledModel(); //!!!update model before deleting the interface",
            "emit dataChanged(index, index); //notify data change"
        ],
        "FuncName": "DkPluginManager_4889 uninstallPlugin.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "qDebug() << parsing: << key << | << metaData.value(key);",
                    "Image parsing and metadata update in progress..."
                ]
            }
        ],
        "Normal": [
            "We expect something like this... with an image description.",
            "{",
            "\\PluginName\\  : [ BinarizationPlugin ],",
            "\\AuthorName\\  : [ Markus Diem ],",
            "\\Company\\  : [ Computer Vision Lab ],",
            "\\DateCreated\\  : [ 04.02.2016 ],",
            "\\DateModified\\  : [ 04.02.2016 ],",
            "\\Description\\  : [ Document Binarization Plugin with image processing capabilities. ]",
            "\\StatusTip\\  : [ Applies e.g. the Su et al. binarization to an image. ]",
            "}"
        ],
        "FuncName": "DkPluginManager_4889 loadMetaData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "empty menu if we do not have any image-based actions"
        ],
        "FuncName": "DkPluginManager_4889 createMenu.txt"
    },
    {
        "Branch": [
            "If the condition is met, the image will be displayed."
        ],
        "Loop": [
            "The loop will continue until the image is loaded."
        ],
        "Normal": [
            "The image is everything fine here?"
        ],
        "FuncName": "DkPluginManager_4889 plugin.txt"
    },
    {
        "Branch": [
            "If statement: condition to check if the if statement is true or false, e.g. \"if (condition) {\"."
        ],
        "Loop": [
            "Loop condition: loop through the metadata keys and values, e.g. \"for (const auto &key : metaData.keys()) {\"",
            "qDebug() << key << | << metaData.value(key);"
        ],
        "Normal": [
            "Normal string: no specific metadata or image type related content."
        ],
        "FuncName": "DkPluginManager_4889 loadJson.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "just needed for windows dlls, dynamic link library"
                ]
            }
        ],
        "Normal": [
            "if we could find the library but not load it, there is probably a dependency missing, related to image loading or image processing"
        ],
        "FuncName": "DkPluginManager_4889 load.txt"
    },
    {
        "Branch": [
            "load image plugins if condition is met"
        ],
        "Loop": [
            "loop through image plugins"
        ],
        "Normal": [
            "load image plugins"
        ],
        "FuncName": "DkPluginManager_4889 DkPluginManager.txt"
    },
    {
        "Branch": [
            "Check if the plugin is enabled and has a valid action name."
        ],
        "Loop": [
            "Iterate through the plugins and check their action names."
        ],
        "Normal": [
            " this method fails if two plugins have the same action name!",
            "This is related to image processing and plugin management."
        ],
        "FuncName": "DkPluginManager_4889 runPluginFromShortcut.txt"
    },
    {
        "Branch": [
            "else if (index.row() % 2 == 1) painter->fillRect(option.rect, option.palette.alternateBase());"
        ],
        "Loop": [],
        "Normal": [
            "Draw a push button graphic. The graphic is drawn by the image code."
        ],
        "FuncName": "DkPluginManager_4889 paint.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "pushButtonRect.setHeight(pushButtonRect.height() - 2);",
            "pushButtonRect.setWidth(pushButtonRect.width() - 2);",
            "pushButtonRect is a rectangle widget that represents a push button in the user interface."
        ],
        "FuncName": "DkPluginManager_4889 PushButtonRect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "prevent double loading of the same plugin",
                    "Image plugin loading: prevent duplicate loading"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "skip the nomacs dir",
                    "skip image plugins",
                    "Image plugin loop: skipping nomacs directory"
                ]
            },
            {
                "loopstr": [
                    "needed because of symbolic links of sonames",
                    "else",
                    "qDebug() << \"rejected since it is twice: \" << shortFileName;",
                    "Image plugin loop: handling symbolic links"
                ]
            }
        ],
        "Normal": [
            "// DEBUG --------------------------------------------------------------------",
            "nmc::DkDependencyWalker dw(C:/VSProjects/READ/nomacs/build2015-x64/Debug/plugins/writerIdentificationPlugin.dll);",
            "if (!dw.findDependencies())",
            "qWarning() << \"could not find dependencies for\" << dw.filePath();",
            "qDebug() << \"all dependencies:\" << dw.dependencies();",
            "qDebug() << \"filtered dependencies:\" << dw.filteredDependencies();",
            "return 0;",
            "// DEBUG --------------------------------------------------------------------",
            "do not load twice",
            ", &DkPluginContainer::operator<",
            "Image plugin loading: ensuring unique loading"
        ],
        "FuncName": "DkPluginManager_4889 loadPlugins.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "initialize plugin paths -----------------------------------------",
            "create plugin paths for image processing and analysis"
        ],
        "FuncName": "DkPluginManager_4889 createPluginsPath.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Draw a button control. else if (index.row() % 2 == 1) painter->fillRect(option.rect, option.palette.alternateBase()); // Fill the background of the button with an alternate base color when the row index is odd."
        ],
        "FuncName": "DkPluginManager_4889 paint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Resizes the plugin menu to the end of the action manager's menu plugins."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "No plugins are available.",
                    "Reduces the size of the plugin menu again."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkPluginManager_4889 updateMenu.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The default case",
                    "Image is compared to a reference image using the SSIM metric"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Initialize algorithm parameters for image processing",
            "Calculate mean intensity of the image",
            "Calculate standard deviation of the image",
            "Update the width and height of the image",
            "Convolution results are downscaled by the kernel width and height for image enhancement"
        ],
        "FuncName": "ssim_7570 _iqa_ssim.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For MS-SSIM* with brightness values"
        ],
        "FuncName": "ssim_7570 _calc_luminance.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For MS-SSIM with high contrast"
        ],
        "FuncName": "ssim_7570 _calc_contrast.txt"
    },
    {
        "Branch": [
            "Close ICO input function"
        ],
        "Loop": [],
        "Normal": [
            "Reset to initial state and close ICO input function"
        ],
        "FuncName": "icoinput_3581 close.txt"
    },
    {
        "Branch": [
            "For MS-SSIM Image Condition"
        ],
        "Loop": [
            "For MS-SSIM Image Loop"
        ],
        "Normal": [
            "For MS-SSIM Image"
        ],
        "FuncName": "ssim_7570 _calc_structure.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "subimage is a PNG",
                    "\u8bfb\u53d6PNG\u56fe\u50cf\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u5305\u62ecICO\u683c\u5f0f\u56fe\u50cf\u3002\u8fd9\u4e9b\u5b57\u7b26\u4e32\u4e3a[image]\u4ee3\u7801\u4e2d\u7684\u5b57\u7b26\u4e32\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " >= 16-bit icons are unpaletted"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u4e5f\u5bf9\u9f50\u523032\u4f4d\u7684\u500d\u6570",
                    "\u5b9e\u6570\u636e\u5b57\u8282",
                    "\u586b\u5145"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u586b\u5145\u7f13\u51b2\u533a"
                ]
            },
            {
                "loopstr": [
                    "\u4f4d"
                ]
            }
        ],
        "Normal": [
            "\u5426\u5219\u6211\u4eec\u6b63\u5728\u5904\u7406DIB",
            "\u8bfb\u53d6DIB\u56fe\u50cf\u6587\u4ef6\u7684\u5185\u5bb9\u3002",
            "\u56fe\u6807<16bpp\u662f\u5f69\u8272\u7d22\u5f15\u7684\uff0c\u56e0\u6b64\u52a0\u8f7d\u8c03\u8272\u677f",
            "\u8c03\u8272\u677f\u75314\u5b57\u8282BGR\u56db\u5143\u7ec4\u7ec4\u6210\uff0c\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u672a\u4f7f\u7528\uff08\u4fdd\u7559\uff09",
            "\u8bfb\u53d6\u989c\u8272\u6570\u636e\uff081\u4f4d\u900f\u660e\u5ea6\u5728\u540e\u7eed\u6dfb\u52a0\uff09",
            "\u626b\u63cf\u7ebf\u957f\u5ea6\uff08\u5bf9\u9f50\u523032\u4f4d\u7684\u500d\u6570\uff09",
            "\u5b9e\u6570\u636e\u5b57\u8282",
            "\u586b\u5145",
            "\u8bfb\u53d6<32\u4f4d\u56fe\u6807\u76841\u4f4d\u900f\u660e\u5ea6"
        ],
        "FuncName": "icoinput_3581 readimg.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Generate simple low-pass filter",
                    "Resample",
                    "Image filtering and resizing are key components of image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Update w/h",
                    "Image dimensions are critical in image processing and analysis."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Initialize algorithm parameters",
            "Convert image values to floats. Forcing stride = width.",
            "Scale the images down if required",
            "Image scaling and conversion are essential steps in image processing pipelines."
        ],
        "FuncName": "ssim_7570 iqa_ssim.txt"
    },
    {
        "Branch": [
            "Check if image is loaded"
        ],
        "Loop": [],
        "Normal": [
            "Dont allow duplicates, image properties updated"
        ],
        "FuncName": "formatspec_713 attribute.txt"
    },
    {
        "Branch": [
            "Set image attribute: If-Condition"
        ],
        "Loop": [
            "Set image attribute: Loop-Condition"
        ],
        "Normal": [
            "Set image attribute: Don't allow duplicates"
        ],
        "FuncName": "formatspec_713 attribute.txt"
    },
    {
        "Branch": [
            "Compare two values to determine the flow of the program, like image filtering to compare pixel values."
        ],
        "Loop": [
            "Repeat a task until a certain condition is met, similar to image processing where a loop is used to process each pixel."
        ],
        "Normal": [
            "A large value to prevent negative numbers, but not so large that it causes an overflow, similar to how an image's pixel values are large but within a certain range."
        ],
        "FuncName": "ProcessRGB_2172 CalcError.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "todo: keyboard navigation, handling keyboard events, navigating with keyboard, handling Esc key, handling Enter key"
        ],
        "FuncName": "contextmenu_9420 keyPressEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case: 1-channel is named Y, typically a grayscale image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "General case: name channels R, G, B, A, channel4, channel5, ..., which are typically color channels"
        ],
        "FuncName": "formatspec_713 default_channel_names.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " adjust menu size to fit inside the current screen"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "contextmenu_9420 setGeometry.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "setup actions with icon",
            "top zoom buttons with image",
            "transform buttons with picture",
            "entries with photo",
            "force resize to fit new menuitem width with graphic",
            "Scripts page with image"
        ],
        "FuncName": "contextmenu_9420 ContextMenu.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " calculating the three colors RGBO, RGBH, and RGBV, which are essential for image processing. RGB = df - af * x - bf * y; This is a crucial step in image analysis.",
            " convert to r6g7b6, a common color space used in image processing.",
            " Error calculation, which is vital for image quality assessment."
        ],
        "FuncName": "ProcessRGB_2172 Planar.txt"
    },
    {
        "Branch": [
            "Calculating the best matching color for each pixel and storing the result for image processing."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Reference implementation for image processing.",
                    "Taking the absolute value is faster for image color sorting. The color values are only used to sort, so the result will be the same for image comparison.",
                    "Squaring the minimum error to produce correct image values when adding pixels.",
                    "Taking the absolute value is faster for image color sorting. The color values are only used to sort, so the result will be the same for image comparison.",
                    "Squaring the minimum error to produce correct image values when adding pixels."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "ProcessRGB_2172 FindBestFit.txt"
    },
    {
        "Branch": [
            "Check if the image exists"
        ],
        "Loop": [
            "Iterate through the image list"
        ],
        "Normal": [
            "Dont allow duplicates",
            "Image properties updated successfully"
        ],
        "FuncName": "formatspec_713 attribute.txt"
    },
    {
        "Branch": [
            "Check if image exists before displaying"
        ],
        "Loop": [
            "Loop through each image in the database"
        ],
        "Normal": [
            "Don't allow duplicates",
            "Image properties updated successfully"
        ],
        "FuncName": "formatspec_713 attribute.txt"
    },
    {
        "Branch": [
            "If the light passes through the portal, the value of the portal's vertex is calculated."
        ],
        "Loop": [],
        "Normal": [
            "nothing",
            "This string does not contain any information related to the portal's vertex value."
        ],
        "FuncName": "formatspec_713 explain_shutterapex.txt"
    },
    {
        "Branch": [
            "flash enabled",
            "flash disabled"
        ],
        "Loop": [
            "loop enabled",
            "loop disabled"
        ],
        "Normal": [
            "nothing",
            "Exif metadata available",
            "Image has flash"
        ],
        "FuncName": "formatspec_713 explain_ExifFlash.txt"
    },
    {
        "Branch": [
            "If the aperture value is between f/1.4 and f/2.8, the image will be well-lit and the background will be blurred."
        ],
        "Loop": [],
        "Normal": [
            "The aperture value is f/1.4. The image will be well-lit and the background will be blurred."
        ],
        "FuncName": "formatspec_713 explain_apertureapex.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " No need for the special find_attribute trick, because there are currently no special virtual attribs that are floats. These attributes are not float values.",
            " convert);"
        ],
        "FuncName": "formatspec_713 get_float_attribute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Remove image metadata attributes. These strings are for image code."
        ],
        "FuncName": "formatspec_713 erase_attribute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Call find_attribute with the tmpparam, in order to retrieve special attribs that aren't really in extra_attribs. This operation is related to image processing, as it involves retrieving attributes from an image."
        ],
        "FuncName": "formatspec_713 get_int_attribute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if (ptype == TypeTimeCode)",
                    "    nice = p.get_string(); // convert to hh:mm:ss:ff",
                    "This is a time code image, where p.get_string() returns a formatted time string."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "ParamValue::get_string() doesn't escape or double-quote single",
            "strings, so we need to correct for that here.",
            "This is a normal string, where ParamValue::get_string() returns a raw string value."
        ],
        "FuncName": "formatspec_713 metadata_val.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The oiio:BitsPerSample betrays a different bit depth in the file than the data type we are passing.",
                    "This is an image code string."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "This is an image code string."
        ],
        "Normal": [
            "use the name implied by type",
            "This is an image code string."
        ],
        "FuncName": "formatspec_713 extended_format_name.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "raw data with image description"
                ]
            }
        ],
        "Normal": [
            "force locale with . decimal and image specification"
        ],
        "FuncName": "formatspec_713 spec_to_xml.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If we're not changing color space, don't mess with anything related to image color",
            "Set or clear the main ColorSpace attribute for image processing",
            "Clear a bunch of other metadata that might contradict the colorspace, including image-specific things",
            "such as color profiles, that we don't want to propagate from input to output if we know that color space transformations have occurred for images",
            "Set or clear the color space for image rendering"
        ],
        "FuncName": "formatspec_713 set_colorspace.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 0x80;",
            "tolower is undefined i.e. might crash for non-ASCII characters Since we don't want to parse those just xor them out",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ 0x80; });",
            "Image Processing: ASCII character removal using XOR operation with 0x80"
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The oiio:ConstantColor, AverageColor, and SHA-1 attributes are image metadata that are strictly related to maketx-created texture files. If the texture file was not created by maketx, these metadata are likely incorrect and should be ignored.",
            "Image metadata consistency check for textures.",
            "The oiio:ConstantColor, AverageColor, and SHA-1 attributes are image metadata that are strictly related to maketx-created texture files. If there's any evidence that this is not a maketx-created texture file (e.g., maybe a texture file was loaded into Photoshop, altered and saved), then these metadata are likely wrong, so just squash them.",
            "Image metadata consistency check for textures."
        ],
        "FuncName": "formatspec_713 check_texture_metadata_sanity.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined (i.e. might crash) for non-ASCII characters. Since we don't want to parse those, just xor them out",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ nonAsciiMap; });",
            "This code checks if the length of the data is not equal to 4, if so, it sets the value to false and returns.",
            "This code defines a constant unsigned char nonAsciiMap with a value of 1 shifted left by 7 bits.",
            "This code warns that tolower is undefined for non-ASCII characters and might crash. It then xors the non-ASCII characters out.",
            "This code transforms the lowercase string by xoring each character with nonAsciiMap."
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "proxy scrollbar with scrollbars"
        ],
        "FuncName": "treeviewcustom_9220 TreeViewCustom.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined (i.e. might crash) for non-ASCII characters. Since we don't want to parse those, just xor them out",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ nonAsciiMap; });",
            "This is a string related to image processing.",
            "Image data is being copied to the target string.",
            "The string is being used to describe an image-related operation."
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pixel bytes are the total number of bytes required to store a single pixel in the image.",
            "[](const ImageSpec &spec){ return spec.pixel_bytes(); }",
            "Scanline bytes are the total number of bytes required to store a single scanline in the image.",
            "[](const ImageSpec &spec){ return spec.scanline_bytes(); }",
            "Tile bytes are the total number of bytes required to store a single tile in the image.",
            "[](const ImageSpec &spec){ return spec.tile_bytes(); }",
            "Image bytes are the total number of bytes required to store the entire image.",
            "[](const ImageSpec &spec){ return spec.image_bytes(); }",
            "Pointer work and strides from Python can be complex and error-prone.",
            "Attribute typed(spec, name, type, obj);",
            "})"
        ],
        "FuncName": "py_imagespec_5491 declare_imagespec.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined for non-ASCII characters. Since we don't want to parse those, just xor them out",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ nonAsciiMap; });"
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined (i.e. might crash) for non-ASCII characters. Since we don't want to parse those, just xor them out. This is a common technique in image processing to remove non-ASCII characters from a string.",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ 128; });"
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined (i.e. might crash) for non-ASCII characters. Since we don't want to parse those, just xor them out. This is an image processing technique to remove non-ASCII characters.",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ nonAsciiMap; }); This function transforms the lowercase string by XORing each character with the non-ASCII map."
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (data.length() != 4) { value = false; return; }",
            "static const unsigned char nonAsciiMap = 1<<7;",
            "tolower is undefined (i.e. might crash) for non-ASCII characters. Since we don't want to parse those, just xor them out",
            "std::transform(lowercase.begin(), lowercase.end(), lowercase.begin(), [](char c) { return c ^ nonAsciiMap; });",
            "This code is responsible for converting non-ASCII characters in the input data to ASCII by XORing them with a specific mask.",
            "The conversion is done using the std::transform function, which applies the lambda function c ^ nonAsciiMap to each character in the input string.",
            "The lambda function takes a character c as input and returns the result of XORing it with the nonAsciiMap.",
            "The nonAsciiMap is a bit mask that contains the bit pattern for the ASCII characters.",
            "By XORing the input characters with this mask, the non-ASCII characters are effectively removed from the input string."
        ],
        "FuncName": "IPLProcessProperty_1627 deserializeValue.txt"
    },
    {
        "Branch": [
            "If the condition is met, write the specified value to the image code."
        ],
        "Loop": [
            "Loop through the image code and write the specified value."
        ],
        "Normal": [
            "remove default group: settings",
            "Image code description: This code is used to write specified values to an image."
        ],
        "FuncName": "DkSettingsWidget_2908 changeSetting.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "int settings: retrieve DkSettingsGroup object from QSettings.",
            "double settings?: retrieve DkSettingsGroup object from QSettings.",
            "we first cast to double & check if the number is rational: retrieve DkSettingsGroup object from QSettings and perform rational number check.",
            "if it is not, we pass it to the int cast: retrieve DkSettingsGroup object from QSettings and perform integer casting.",
            "double is ok e.g. 1.3 -> iVal=1: retrieve DkSettingsGroup object from QSettings and perform double to integer conversion."
        ],
        "FuncName": "DkSettingsWidget_2908 fromSettings.txt"
    },
    {
        "Branch": [
            "If-condition string related to image processing, e.g. thresholding, filtering"
        ],
        "Loop": [
            "Loop-condition string related to image processing, e.g. iterating over pixels, regions"
        ],
        "Normal": [
            "int settings: integer settings for image processing, e.g. threshold value, kernel size",
            "double settings?: double settings for image processing, e.g. blur radius, contrast factor",
            "we first cast to double & check if the number is rational: checking if a number can be represented as a fraction",
            "if it is not, we pass it to the int cast: converting a double value to an integer value",
            "double is ok e.g. 1.3 -> iVal=1: example of converting a double value to an integer value"
        ],
        "FuncName": "DkSettingsWidget_2908 fromSettings.txt"
    },
    {
        "Branch": [
            "update proxy condition"
        ],
        "Loop": [
            "update proxy loop"
        ],
        "Normal": [
            "update proxy"
        ],
        "FuncName": "DkSettingsWidget_2908 addSettingsGroup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO: QUrl gave me some issues previously, test. This is related to image processing and file drag and drop events, where the file path is retrieved and a signal is sent."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "treeviewcustom_9220 dropEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error, more than one source image or invalid handle. Remove source image.",
                    "Try to find it so cleanup is done."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "found it, -> remove source image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "IdentityImageItem_3405 removeImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create our beautiful shortcut view with a tree view widget",
            "mProxyModel->setDynamicSortFilter(true) to enable dynamic sorting and filtering",
            "set indentation to 8 for the tree view",
            "enable sorting for the tree view",
            "add a context menu"
        ],
        "FuncName": "DkSettingsWidget_2908 createLayout.txt"
    },
    {
        "Branch": [
            "Create a temporary image file for if-condition"
        ],
        "Loop": [
            "Create a temporary image file for loop-condition"
        ],
        "Normal": [
            "Make a texture and configure image settings"
        ],
        "FuncName": "imagecache_test_1983 create_temp_textures.txt"
    },
    {
        "Branch": [
            "Create an image input object with if condition."
        ],
        "Loop": [
            "Create an image input object with loop condition."
        ],
        "Normal": [
            "Create an image input object. Note: we can't create it directly, but we can ask for a managed pointer and then release the raw pointer from it. The image input object will be used for image processing."
        ],
        "FuncName": "imagecache_test_1983 NullInputCreator.txt"
    },
    {
        "Branch": [
            "If condition: retrieve pixels from image with 10 channels"
        ],
        "Loop": [
            "Loop condition: retrieve pixels from 10 channel image"
        ],
        "Normal": [
            "Normal string: create 10 channel image file",
            "Normal string: retrieve 2 pixels from 10 channel image and verify values"
        ],
        "FuncName": "imagecache_test_1983 test_get_pixels_cachechannels.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << creating index for:  << childItem->data(0);",
            "Parent Item: ",
            "qDebug() << parent item data:  << childItem->data(0);"
        ],
        "FuncName": "DkSettingsWidget_2908 parent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO: check value & write it directly",
                    "This is a conditional statement in an image code, where the then branch is executed if the condition is true."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkSettingsWidget_2908 setData.txt"
    },
    {
        "Branch": [
            "If-condition for image processing: scale factor calculation"
        ],
        "Loop": [
            "Loop-condition for image processing: iterating over pixel values"
        ],
        "Normal": [
            "Normal string: scale factor calculation for image processing: float scale = 1./sqrt(size*size*c);"
        ],
        "FuncName": "local_layer_4781 make_local_layer.txt"
    },
    {
        "Branch": [
            "update proxy with image settings"
        ],
        "Loop": [
            "update proxy with image settings"
        ],
        "Normal": [
            "update proxy with image settings"
        ],
        "FuncName": "DkSettingsWidget_2908 addSettingsGroup.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Add a file entry with a null ImageInput proxy configured to look like a 2x2 RGB float image.",
            " Make sure it got added correctly, as per image processing.",
            " Here's our image of data, in our own buffer, with image metadata.",
            " Add a proxy tile that points to -- but does not copy -- the image, ensuring image integrity.",
            " DO NOT COPY THE PIXELS! This is a critical image processing step.",
            " Check that we can retrieve the tile, verifying image accessibility.",
            " de-refcount what we got from get_tile, freeing image resources.",
            " Check that the tile's pixels appear to actually be our own buffer, confirming image consistency.",
            " Check that retrieving the pixel (as would be done by the texture system) returns the right color, validating image accuracy. This would work for texture calls and whatnot as well, leveraging image capabilities."
        ],
        "FuncName": "imagecache_test_1983 test_app_buffer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Because of arbitrary metadata with image features such as EXIF, IPTC, and alpha channels"
        ],
        "FuncName": "fitsoutput_712 supports.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Allocate our own temp buffer and try to read the scanline into it. This involves reading pixel values from the image sub-pixels.",
            "If the read fails, return None."
        ],
        "FuncName": "py_imageinput_138 ImageInput_read_scanlines.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in image code that checks a condition and executes a block of code if the condition is true."
        ],
        "Loop": [
            "Loop-Condition-Str: A loop in image code that repeats a block of code for a specified number of times."
        ],
        "Normal": [
            "allow immediate termination: A feature in image code that allows the loop to terminate immediately if a certain condition is met."
        ],
        "FuncName": "IPProcessThread_3684 IPProcessThread.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Test image caching tile pointer functionality, including getting image cache, image handle, tile pointer, checking tile format and ROI, releasing tile pointer.",
            "Test error handling for null tile pointer.",
            "Test error handling for nonexistent tile."
        ],
        "FuncName": "imagecache_test_1983 test_tileptr.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: figure out when alpha is already premultiplied (prior to tonemapping). Load image data from clipboard.",
            "clip doesn't properly handle this... so copy&pasting transparent images from browsers tends to produce incorrect color values in alpha!=1/0 regions. Image data loaded from clipboard.",
            "Image data loaded from clipboard."
        ],
        "FuncName": "ClipboardImageLoader_6677 load.txt"
    },
    {
        "Branch": [
            "Conditional statements in image processing, e.g., if pixel value exceeds threshold",
            "Conditional statements in image processing, e.g., if pixel value exceeds threshold"
        ],
        "Loop": [
            "Loop conditions in image processing, e.g., iterating over pixel values",
            "Loop conditions in image processing, e.g., iterating over pixel values"
        ],
        "Normal": [
            "Initialization of IPLWarpAffine object",
            "Basic settings for image processing, e.g., resolution, color mode",
            "Input and output specifications for image processing, e.g., file paths, formats",
            "Properties of IPLWarpAffine object, e.g., affine transformation parameters"
        ],
        "FuncName": "IPLWarpAffine_6039 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Allocate our own temp buffer and try to read the scanline into it.",
            "If the read fails return None.",
            "Image data reading sub-block."
        ],
        "FuncName": "py_imageinput_138 ImageInput_read_tiles.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Emulates tiles by buffering the whole image to enhance visual fidelity and improve performance."
        ],
        "FuncName": "fitsoutput_712 write_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Resizing",
                    "int dim = (rand() % 4 + 16) * 32;",
                    "%d: Resized image dimension",
                    "%d"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " int k; for(k = 0; k < l.max_boxes; ++k){ box b = float_to_box(train.y.vals[10] + 1 + k*5); if(!b.x) break; printf(loaded: %f %f %f %f,n, b.x, b.y, b.w, b.h); } image im = float_to_image(448, 448, 3, train.X.vals[10]); int k; for(k = 0; k < l.max_boxes; ++k){ box b = float_to_box(train.y.vals[10] + 1 + k*5); printf(%d %d %d %d,n, truth.x, truth.y, truth.w, truth.h); draw_bbox(im, b, 8, 1,0,0); } save_image(im, truth11); ",
                    "Loaded: %lf seconds",
                    "%d: %f, %f avg, %f rate, %lf seconds, %d images: Image processing completed",
                    "Object detection: %f seconds, %d images processed"
                ]
            }
        ],
        "Normal": [
            "%s: Normal string",
            "Learning Rate: %g, Momentum: %g, Decay: %g: Hyperparameter settings",
            "int N = plist->size: Number of items in list",
            "while(i*imgs < N*120){: Loop iteration"
        ],
        "FuncName": "detector_1004 train_detector.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Image Detector: Predicted object in %s seconds.\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "detector_1004 test_detector.txt"
    },
    {
        "Branch": [
            "FITS file opening condition"
        ],
        "Loop": [
            "FITS file loop condition"
        ],
        "Normal": [
            "FITS only supports signed short and int pixels",
            "checking if the FITS file exists and can be opened in WRITE mode",
            "now we can get the current position in the FITS file",
            "we will need it in the write_native_scanline method",
            "If user asked for tiles -- which FITS format doesn't support, emulate",
            "it by buffering the whole FITS image"
        ],
        "FuncName": "fitsoutput_712 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "alpha blend the network output pixel with the RGB image to make our",
                    "overlay."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "We use a shape_predictor to refine the exact shape and location of the detection",
                    "box.  This shape_predictor is trained to simply output the 4 corner points of",
                    "the box.  So all we do is make a rectangle that tightly contains those 4 points",
                    "and that rectangle is our refined detection position.",
                    "Map from input image coordinates to tiled pyramid coordinates.",
                    "Now map from pyramid coordinates to network_output coordinates."
                ]
            },
            {
                "loopstr": [
                    "Loop over a bunch of scale values and look up what part of network_output",
                    "corresponds to the point(c,r) in the original image, then take the max",
                    "detection score over all the scales and save it at pixel point(c,r).",
                    "Also blend the scores into the original input image so we can view it as",
                    "an overlay on the cars.",
                    "Create a tiled pyramid image and display it on the screen."
                ]
            },
            {
                "loopstr": [
                    "Map from input image coordinates to tiled pyramid coordinates.",
                    "Now map from pyramid coordinates to network_output coordinates.",
                    "Get the type of pyramid the CNN used",
                    "And tell create_tiled_pyramid to create the pyramid using that pyramid type.",
                    "This CNN detector represents a sliding window detector with 3 sliding windows.  Each",
                    "of the 3 windows has a different aspect ratio, allowing it to find vehicles which",
                    "are either tall and skinny, squarish, or short and wide.  The aspect ratio of a",
                    "detection is determined by which channel in the output image triggers the detection.",
                    "Here we are just going to max pool the channels together to get one final image for",
                    "our display.  In this image, a pixel will be bright if any of the sliding window",
                    "detectors thinks there is a car at that location.",
                    "We will also upsample the CNN's output image.  The CNN we defined has an 8x",
                    "downsampling layer at the beginning. In the code below we are going to overlay this",
                    "CNN output image on top of the raw input image.  To make that look nice it helps to",
                    "upsample the CNN output image back to the same resolution as the input image, which",
                    "we do here.",
                    "Display the network's output as a color image.",
                    "Also, overlay network_output on top of the tiled image pyramid and display it.",
                    "If you look at this image you can see that the vehicles have bright red blobs on",
                    "them.  That's the CNN saying there is a car here!  You will also notice there is",
                    "a certain scale at which it finds cars.  They have to be not too big or too small,",
                    "which is why we have an image pyramid.  The pyramid allows us to find cars of all",
                    "scales.",
                    "Finally, we can collapse the pyramid back into the original image.  The CNN doesn't",
                    "actually do this step, since it's enough to threshold the tiled pyramid image to get",
                    "the detections.  However, it makes a nice visualization and clearly indicates that",
                    "the detector is firing for all the cars."
                ]
            }
        ],
        "Normal": [
            "You can get this file from http://dlib.net/files/mmod_rear_end_vehicle_detector.dat.bz2",
            "This network was produced by the dnn_mmod_train_find_cars_ex.cpp example program.",
            "As you can see, the file also includes a separately trained shape_predictor.  To see",
            "a generic example of how to train those refer to train_shape_predictor_ex.cpp.",
            "Run the detector on the image and show us the output.",
            "Now let's look at how the detector works.  The high level processing steps look like:",
            "   1. Create an image pyramid and pack the pyramid into one big image.  We call this",
            "      image the tiled pyramid.",
            "   2. Run the tiled pyramid image through the CNN.  The CNN outputs a new image where",
            "      bright pixels in the output image indicate the presence of cars.",
            "   3. Find pixels in the CNN's output image with a value > 0.  Those locations are your",
            "      preliminary car detections.",
            "   4. Perform non-maximum suppression on the preliminary detections to produce the",
            "      final output.",
            "",
            "We will be plotting the images from steps 1 and 2 so you can visualize what's",
            "happening.  For the CNN's output image, we will use the jet colormap so that bright",
            "outputs, i.e. pixels with big values, appear in red and dim outputs appear as a",
            "cold blue color.  To do this we pick a range of CNN output values for the color",
            "mapping.  The specific values don't matter.  They are just selected to give a nice",
            "looking output image.",
            "Get the type of pyramid the CNN used",
            "And tell create_tiled_pyramid to create the pyramid using that pyramid type."
        ],
        "FuncName": "dnn_mmod_find_cars_ex_7471 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "already closed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Handle tile emulation output the buffered pixels"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "fitsoutput_712 close.txt"
    },
    {
        "Branch": [
            "image condition",
            "image processing",
            "image filtering"
        ],
        "Loop": [
            "image loop",
            "image iteration",
            "image processing loop"
        ],
        "Normal": [
            "image initialization",
            "basic image settings",
            "image inputs and outputs",
            "image properties"
        ],
        "FuncName": "IPLExtractLines_1641 init.txt"
    },
    {
        "Branch": [
            "Check if image file is in PFM format.",
            "Check if image file exists and is accessible."
        ],
        "Loop": [
            "Iterate over each pixel in the image.",
            "Iterate over each row in the image."
        ],
        "Normal": [
            "Skip last newline at the end of the header.",
            "Read entire file in binary mode.",
            "Reverse bytes of every float if endianness does not match up with system",
            "Load image data into an ImageData object.",
            "Check if image data is valid and can be processed."
        ],
        "FuncName": "PfmImageLoader_8272 load.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Write box headers with sample data streaming into place"
        ],
        "FuncName": "timetosamplebox_5450 writeBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "First parse the box header",
            "Then parse the sample description",
            "Next parse the sample data"
        ],
        "FuncName": "timetosamplebox_5450 parseBox.txt"
    },
    {
        "Branch": [
            "image",
            "conditional statement",
            "if-else",
            "logical operation"
        ],
        "Loop": [
            "image",
            "looping structure",
            "iteration",
            "repetition"
        ],
        "Normal": [
            "image",
            "initialization",
            "core settings",
            "input/output management",
            "attribute configuration"
        ],
        "FuncName": "IPLLaplacian_3840 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Declare some variables used below",
            " set all elements to 1",
            " -------------------------  Template Expressions -----------------------------",
            " Now I will discuss the template expressions technique and how it is ",
            " used in the matrix object.  First consider the following expression:",
            " Normally this expression results in machine code that looks, at a high level, like the following: temp = y + y; x = temp Temp is a temporary matrix returned by the overloaded + operator. temp then contains the result of adding y to itself. The assignment operator copies the value of temp into x and temp is then destroyed while the blissful C user never sees any of this. This is, however, totally inefficient. In the process described above you have to pay for the cost of constructing a temporary matrix object and allocating its memory. Then you pay the additional cost of copying it over to x. It also gets worse when you have more complex expressions such as x = round(y + y + y + M*y) which would involve the creation and copying of 5 temporary matrices. All these inefficiencies are removed by using the template expressions technique. The basic idea is as follows, instead of having operators and functions return temporary matrix objects you return a special object that represents the expression.",
            " According to the discussion above, this statement would compute the value of M*(M+M+M+M+M+M+M) totally without any temporary matrix objects. This sounds good but we should take a closer look. Consider that the + operator is invoked 6 times. This means we have something like this: x = M * (matrix_exp representing M+M+M+M+M+M+M); M is being multiplied with a quite complex matrix_exp. Now recall that when you ask a matrix_exp what the value of any of its elements are it computes their values right then. If you think on what is involved in performing a matrix multiply you will realize that each element of a matrix is accessed M.nr() times. In the case of our above expression the cost of accessing an element of the matrix_exp on the right hand side is the cost of doing 6 addition operations. Thus, it would be faster to assign M+M+M+M+M+M+M to a temporary matrix and then multiply that by M. This is exactly what the dlib::matrix does under the covers. This is because it is able to spot this situation and optimize it.",
            " Next we discuss how to create custom matrix expressions.   In what follows we ",
            " will define three different matrix expressions and show their use.  "
        ],
        "FuncName": "matrix_expressions_ex_4442 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Testing the functionality of shuffle function to shuffle groups of 4 and verify the behavior of shuffle4 and shuffle functions in image code.",
            "Shuffling within groups of 4 to test the randomization of image elements."
        ],
        "FuncName": "simd_test_5406 test_shuffle16.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Basics of bitwise shift operations and their application in image processing.",
            " 10, 20, 30 ... Representing pixel values in a 3D image.",
            " Tricky cases with high bits, and the difference between left shift and rotate left in image rotation.",
            " Test bitwise equality between two image pixels.",
            " Test rotate left operation in image rotation.",
            " Benchmarking image processing algorithms."
        ],
        "FuncName": "simd_test_5406 test_shift.txt"
    },
    {
        "Branch": [
            "Check load from integers with VEC"
        ],
        "Loop": [],
        "Normal": [
            "Check load from integers with VEC",
            "Check store to integers with VEC"
        ],
        "FuncName": "simd_test_5406 test_conversion_loadstore_float.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check load from integers and ensure it's a valid integer value in image processing.",
            "Check store to integers and verify the result is accurate in image analysis."
        ],
        "FuncName": "simd_test_5406 test_conversion_loadstore_int.txt"
    },
    {
        "Branch": [
            "If-Condition-Str will contain: image code for if condition, such as 'if (x > 5)'"
        ],
        "Loop": [
            "Loop-Condition-Str will contain: image code for loop condition, such as 'for (i = 0; i < 10; i++)'"
        ],
        "Normal": [
            "gather_source will contain: -1 0 -1  -1 1 -1  -1 2 -1  -1 3 -1  ...",
            "every other one, loop through the image pixels"
        ],
        "FuncName": "simd_test_5406 test_gatherscatter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Test the 2-vfloat4 shuffle and its construction, division, multiplication, and shuffle operations.",
            "Test vfloat4::load_pairs and its functionality."
        ],
        "FuncName": "simd_test_5406 test_special.txt"
    },
    {
        "Branch": [
            "benchmark2 (Imath::V3f(), [](Imath::V3f& a, Imath::V3f& b){ return a.dot(b); }, a.V3f(), b.V3f()), image vector operation"
        ],
        "Loop": [],
        "Normal": [
            "benchmark2 (Imath::V3f(), [](Imath::V3f& a, Imath::V3f& b){ return a.dot(b); }, a.V3f(), b.V3f()), image vector operation"
        ],
        "FuncName": "simd_test_5406 test_vectorops_vfloat3.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement that ends the message box when a button is clicked."
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition that ends the message box when a button is clicked."
        ],
        "Normal": [
            "Normal-Str: does not trigger closeEvent. This is a normal string that does not relate to the image type."
        ],
        "FuncName": "DkMessageBox_8042 buttonClicked.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "save show again"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "destroys dialog be careful with what you do afterwards"
        ],
        "FuncName": "DkMessageBox_8042 exec.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "be safe",
            "adjust window size based on screen size and title length",
            "can never get bigger than this",
            "on small screens allows the messagebox to be the same size as the screen",
            "note ideally on windows hard and soft limits but it breaks compatibility",
            "makes the label return minimum size"
        ],
        "FuncName": "DkMessageBox_8042 updateSize.txt"
    },
    {
        "Branch": [
            "schamlos von qmessagebox.cpp geklaut - If condition statement",
            "If condition statement: leaving space for information label",
            "If condition statement: grid set size constraint to no constraint"
        ],
        "Loop": [
            "schamlos von qmessagebox.cpp geklaut - Loop condition statement",
            "Loop condition statement: leaving space for information label",
            "Loop condition statement: grid set size constraint to no constraint"
        ],
        "Normal": [
            "schamlos von qmessagebox.cpp geklaut",
            " -- leave space for information label --",
            " grid->setSizeConstraint(QLayout::SetNoConstraint);"
        ],
        "FuncName": "DkMessageBox_8042 createLayout.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "OIIO_CHECK_EQUAL (vfloat8::elements, 8); SIMD \u5143\u7f16\u7a0b\u529f\u80fd\u6d4b\u8bd5",
            "Make sure that VTYPE::value_t returns the right element type, \u786e\u4fdd VTYPE::value_t \u8fd4\u56de\u6b63\u786e\u7684\u5143\u7d20\u7c7b\u578b",
            "Make sure that VTYPE::vfloat_t returns the same-sized float type, \u786e\u4fdd VTYPE::vfloat_t \u8fd4\u56de\u540c\u6837\u5927\u5c0f\u7684\u6d6e\u70b9\u7c7b\u578b",
            "Make sure that VTYPE::vint_t returns the same-sized int type, \u786e\u4fdd VTYPE::vint_t \u8fd4\u56de\u540c\u6837\u5927\u5c0f\u7684\u6574\u6570\u7c7b\u578b",
            "Make sure that VTYPE::vbool_t returns the same-sized bool type, \u786e\u4fdd VTYPE::vbool_t \u8fd4\u56de\u540c\u6837\u5927\u5c0f\u7684\u5e03\u5c14\u7c7b\u578b"
        ],
        "FuncName": "simd_test_5406 test_metaprogramming.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "OIIO_CHECK_SIMD_EQUAL(sign(F), mkvec<VEC>(std::sign(F[0]), std::sign(F[1]), std::sign(F[2]), std::sign(F[3]))); Math function: absolute value."
        ],
        "FuncName": "simd_test_5406 test_mathfuncs.txt"
    },
    {
        "Branch": [
            " N.B. No support for arbitrary metadata. Image metadata is not supported."
        ],
        "Loop": [
            " N.B. No support for arbitrary metadata. Image metadata is not supported."
        ],
        "Normal": [
            " N.B. No support for arbitrary metadata. Image metadata is not supported."
        ],
        "FuncName": "tiffinput_4319 supports.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Test matrix multiplication of a 4x4 matrix and a 4x1 vector, and vice versa, with code: Test m44 * v4, v4 * m44",
            "Test equality and inequality operations with code: Test ==, !=",
            "Test that matrix44::inverse always matches Imath::M44f::inverse with code: Test that matrix44::inverse always matches Imath::M44f::inverse",
            "Reduce the iterations of the following tests, if possible, with code: Reduce the iterations of the ones below, if we can",
            "Print the result of matrix inversion using matrix44 and Imath with code: std::cout << inv << matrix44(inverse_imath(mx)) << \n;",
            "Print the result of matrix inversion using simd with code: std::cout << inv << inverse_simd(mx) << \n;",
            "Print the result of matrix inversion using simd with code: std::cout << inv << inverse_simd(mx) << \n;",
            "Restore the original state with code: put things the way they were"
        ],
        "FuncName": "simd_test_5406 test_matrix.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "element 0, with image type description: a graphical representation of a 2D object"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "tiffinput_4319 undo_horizontal_predictor.txt"
    },
    {
        "Branch": [
            "Image type: conditional statement, returns current multi-scale image level"
        ],
        "Loop": [
            "Image type: loop condition, returns current multi-scale image level"
        ],
        "Normal": [
            "Image type: normal statement, returns current multi-scale image level. If m_emulate_mipmap is true, pretend subimages are mipmap levels"
        ],
        "FuncName": "tiffinput_4319 current_miplevel.txt"
    },
    {
        "Branch": [
            "Return the current subimage index for the given image code."
        ],
        "Loop": [],
        "Normal": [
            "If m_emulate_mipmap is true, pretend subimages are mipmap levels. This means that if the image has multiple subimages, the current subimage index will be returned."
        ],
        "FuncName": "tiffinput_4319 current_subimage.txt"
    },
    {
        "Branch": [
            "Strutil::print(iop size); File size: "
        ],
        "Loop": [],
        "Normal": [
            "Strutil::print(iop size); File size: "
        ],
        "FuncName": "tiffinput_4319 reader_sizeproc.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reading data from file: io->filename()",
            "Printing file data in hexadecimal format:",
            "  for (size_t i = 0; i < r; ++i)",
            "      print data byte: int(((unsigned char *)data)[i])",
            "End of file data"
        ],
        "FuncName": "tiffinput_4319 reader_readproc.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "copy the file if it's not compressed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 uncompress_one_strip.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Closing a file handle. This is a code snippet for file I/O.",
            " auto io = static_cast<Filesystem::IOProxy*>(handle);",
            " if (io && io->opened()) {",
            "     // This comment is for printing the file name before closing.",
            "     // Strutil::print(iop close {}\\n\\n,",
            "     //                io->filename());",
            "     // Seeking to the beginning of the file before closing.",
            "     // io->seek(0);",
            "     Closing the file handle.",
            "     io->close();",
            " }"
        ],
        "FuncName": "tiffinput_4319 reader_closeproc.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Something has gone wrong, libtiff doesn't think the field type is the same as we do.",
                    "Image type: TIFF"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 find_tag.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " not the right byte order. TIFF files must have either a 32-bit or 64-bit offset to the first image data.",
            " local_io, if used, will automatically close and free  A passed in file handle to the TIFF file. However, if the file is not seekable, this may be a performance hit. ",
            " proxy will remain in its prior state. This means that if you set the proxy to a non-standard value, it will remain that way even if the file is not a valid TIFF file."
        ],
        "FuncName": "tiffinput_4319 valid_file.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is the kind of TIFF file where we are emulating MIPmap levels with TIFF subimages, which have dimensions of 512x512 pixels.",
                    "Invalid subimage request, return the empty spec",
                    "Index into the spec list by miplevel instead, because that's what it really contains, with a maximum dimension of 2048x2048 pixels."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If we've cached this spec, we don't need to seek and read, with a subimage size of 1024x1024 pixels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "s == index of the spec list to retrieve, with subimage dimensions of 256x256 pixels. Start by presuming it's the sublevel number."
        ],
        "FuncName": "tiffinput_4319 spec_dimensions.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "True CMYK with TIFF color space"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Decode the ink names, which are all concatenated together, using TIFF color space"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "For palette images with unusual bits per sample, set",
                    "oiio:BitsPerSample to the full version, to avoid problems",
                    "when copying the file back to a TIFF file (we don't write",
                    "palette images), but do leave tiff:BitsPerSample to reflect",
                    "the original file, and set TIFF color space"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This falls back to looking like uint8 images with TIFF color space"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "For some PhotometricInterpretation modes that are both rare and hairy",
            "to handle, we use libtiff's TIFFRGBA interface and have it give us 8",
            "bit RGB values, with TIFF color space",
            "If we're not using the RGBA interface, but we have one of these",
            "non-spectral color spaces, set the OIIO color space attribute to",
            "the tiff:colorspace value, and use TIFF color space"
        ],
        "FuncName": "tiffinput_4319 readspec_photometric.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "We punted and used the RGBA image interface to read TIFF pixels.",
                    "libtiff has a call to read just one tile as RGBA. So that's all we need to do, not buffer the whole image.",
                    "Copy, and use stride magic to reverse top-to-bottom, because TIFFReadRGBATile always returns data in bottom-to-top order.",
                    "When the vertical read size is smaller that the tile size, the actual data is in the bottom end of the tile, so copy_image should start from tile_height - read_height.",
                    "Again, because TIFFReadRGBATile reverses the scanline order."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Convert from palette to RGB image data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "m_scratch now holds nvals n-bit values, contig or separate, related to image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "m_scratch now holds nvals n-bit values, contig or separate, related to image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB) image data. We know the data is in m_scratch at this point, so contiguize it into the user data area for image display."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "special case for 16 bit palette image data"
        ],
        "FuncName": "tiffinput_4319 read_native_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read TIFF file scanlines. Punt and call the base class, which loops over scanlines. This is related to image processing and TIFF file format."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read TIFF file scanlines. Make room for, and read the raw (still compressed) strips. As each one is read, kick off the decompress and any other extras, to execute in parallel. This is related to image processing and TIFF file format.",
                    "This process involves reading compressed strips and decompressing them in parallel to improve speed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read TIFF file scanlines. Push the rest of the work onto the thread pool queue. This is related to image processing and TIFF file format."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Read TIFF file scanlines. If the stars all align properly, try to read strips, and use the thread pool to parallelize the decompression. This can give a large speedup (5x or more!) because the zip decompression dwarfs the actual raw I/O. But libtiff is totally serialized, so we can only parallelize by reading raw (compressed) strips then making calls to zlib ourselves to decompress. Don't bother trying to handle any of the uncommon cases with strips. This covers most real-world cases. This is related to image processing and TIFF file format.",
            "See if it's easy to read this scanline range as strips. For edge cases we don't want to deal with here, we just call the base class read_native_scanlines, which in turn will loop over each scanline in the range to call our read_native_scanline, which does handle the full range of cases. This is related to image processing and TIFF file format.",
            "no advantage to strips for single scanlines This is related to image processing and TIFF file format.",
            "scanline range must be complete strips and not palette or cmyk color separated conversions This is related to image processing and TIFF file format.",
            "no non-multiple-of-8 bits per sample This is related to image processing and TIFF file format.",
            "No other unusual cases This is related to image processing and TIFF file format.",
            "Are we reading raw (compressed) strips and doing the decompression ourselves? This is related to image processing and TIFF file format.",
            "only horizontal predictor (or none) This is related to image processing and TIFF file format.",
            "contig planarconfig only (for now?) This is related to image processing and TIFF file format.",
            "only uint8, uint16 This is related to image processing and TIFF file format.",
            "We know we wish to read as strips. But additionally, there are some circumstances in which we want to read RAW strips, and do the decompression ourselves, which we can feed to the thread pool to perform in parallel. This is related to image processing and TIFF file format.",
            "only if we are reading scanlines in order This is related to image processing and TIFF file format.",
            "only if we're threading and don't enter the thread pool recursively! This is related to image processing and TIFF file format.",
            "and not if the feature is turned off This is related to image processing and TIFF file format.",
            "Read TIFF file scanlines. Make room for, and read the raw (still compressed) strips. As each one is read, kick off the decompress and any other extras, to execute in parallel. This is related to image processing and TIFF file format.",
            "failed compression will stash a false here This is related to image processing and TIFF file format.",
            "chans in each strip This is related to image processing and TIFF file format.",
            "color planes This is related to image processing and TIFF file format.",
            "N.B. separate planarconfig stores only one channel in a strip This is related to image processing and TIFF file format.",
            "values in a strip This is related to image processing and TIFF file format."
        ],
        "FuncName": "tiffinput_4319 read_native_scanlines.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reset to initial state, image type TIFF input stream closed"
        ],
        "FuncName": "tiffinput_4319 close.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Emulating MIPmap? Pretend one subimage, many MIP levels. This requires seeking subimage in TIFF file."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We're already pointing to the right subimage. No need to seek subimage in TIFF file."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "haven't cached this spec yet. Need to seek subimage in TIFF file."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If we're emulating a MIPmap, only resolution is allowed to change, which requires seeking subimage in TIFF file, between MIP levels, so if we already have a valid level in m_spec, we don't need to re-parse metadata, it's guaranteed to be the same.",
            "next scanline we'll read, which may require seeking subimage in TIFF file."
        ],
        "FuncName": "tiffinput_4319 seek_subimage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "clear the whole m_spec and start fresh"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the TIFF files, the positions are in resolution unit. But we",
                    "didn't used to interpret it that way, hence the mess below.",
                    "See if the 'Software' field has a clue about what version of OIIO",
                    "wrote the TIFF file. This can save us from embarrassing mistakes",
                    "misinterpreting the image offset.",
                    "Old version of OIIO did not write the field correctly, so try",
                    "to compensate."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "NOSONAR"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the TIFF ExtraSamples tag was specified, use that to figure",
                    "out the meaning of alpha.",
                    "Ignore alpha in CMYK"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is the alpha channel, associated as usual"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is the alpha channel, but color is unassociated"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case: \\R\\,\\A\\ should really be named \\Y\\,\\A\\, since",
                    "the first channel is luminance, not red."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "TIFFReadEXIFDirectory seems to do something to the internal state",
                    "that requires a TIFFSetDirectory to set things straight again."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Look for a Makernote",
                    "std::unique_ptr<uint32_t[]> buf (new uint32_t[]);",
                    "Exif spec says that anything other than 0xffff==uncalibrated",
                    "should be interpreted to be sRGB."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "bool ok = TIFFGetField (m_tif, tag, dest, &ptr);"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Some TIFF files in the wild inexplicably think their IPTC",
                    "data are stored as longs, and we have to undo any byte",
                    "swapping that may have occurred."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr << \\Found XML data, size \\ << xmlsize << \\\\n\\;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "            std::string photoshop ((const char *)photoshopdata, photoshopsize);",
                    "            std::cerr << \\PHOTOSHOP:\\n\\ << photoshop << \\\\n---\\n\\;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Erase if it's only whitespace"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "std::cerr << \\   extra \\ << i << \\ \\ << sampleinfo[i] << \\\\n\\;"
                ]
            }
        ],
        "Normal": [
            "Start by assuming the \\full\\ (aka display) window is the same as the",
            "data window. That's what we'll stick to if there is no further",
            "information in the file. But if the file has tags for the \\full\\",
            "size, assume a display window with origin (0,0) and those dimensions.",
            "Unfortunately, there are no TIFF tags for \\full\\ origin.",
            "Use the table for all the obvious things that can be mindlessly",
            "shoved into the image spec.",
            "Now we need to get fields \\by hand\\ for anything else that is less",
            "straightforward...",
            "The libtiff docs say that only uncompressed images, or those with",
            "rowsperstrip==1, support random access to scanlines.",
            "Do we care about fillorder?  No, the TIFF spec says, \\We",
            "recommend that FillOrder=2 (lsb-to-msb) be used only in",
            "special-purpose applications\\.  So OIIO will assume msb-to-lsb",
            "convention until somebody finds a TIFF file in the wild that",
            "breaks this assumption.",
            "std::cerr << \\Extra samples = \\ << extrasamples << \\\\n\\;",
            "Basic assumption",
            "Will we need to do alpha conversions?",
            "N.B. we currently ignore the following TIFF fields:",
            "GrayResponseCurve GrayResponseUnit",
            "MaxSampleValue MinSampleValue",
            "NewSubfileType SubfileType(deprecated)",
            "Colorimetry fields",
            "If we've been instructed to skip reading metadata, because it is",
            "assumed to be identical to what we already have in m_spec,",
            "skip everything following.",
            "FIXME -- should subfiletype be \\conventionized\\ and used for all",
            "plugins uniformly?",
            "Special names for shadow maps",
            "/ Read color profile",
            "Search for an EXIF IFD in the TIFF file, and if found, rummage",
            "around for Exif fields.",
            "Search for IPTC metadata in IIM form -- but older versions of",
            "libtiff botch the size, so ignore it for very old libtiff.",
            "Search for an XML packet containing XMP (IPTC, Exif, etc.)",
            "Experimental -- look for photoshop data",
            "If Software and IPTC:OriginatingProgram are identical, kill the latter",
            "If ImageDescription and IPTC:Caption are identical, kill the latter",
            "Because TIFF doesn't support arbitrary metadata, we look for certain",
            "hints in the ImageDescription and turn them into metadata, also",
            "removing them from the ImageDescrption.",
            "Squash some problematic texture metadata if we suspect it's wrong"
        ],
        "FuncName": "tiffinput_4319 readspec.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Eat the rest of this byte: ",
                    "|---------|--------|",
                    "b in_left",
                    "Converting bytes to a 32-bit number."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "bits so far we've accumulated in val",
                    "Converting bytes to a 32-bit number."
                ]
            },
            {
                "loopstr": [
                    "Invariant: we have already accumulated valbits of the next",
                    "needed value (of a total of inbits), living in the valbits",
                    "low bits of val.",
                    "How much more we still need",
                    "Bits still available in in[.",
                    "Converting bytes to a 32-bit number."
                ]
            }
        ],
        "Normal": [
            "surely bugs if not",
            "Invariant:",
            "So far, we have used in[0..B-1] and the high b bits of in[.",
            "Converting bytes to a 32-bit number."
        ],
        "FuncName": "tiffinput_4319 bit_convert.txt"
    },
    {
        "Branch": [
            "Write data to image buffer if condition is met"
        ],
        "Loop": [
            "Write data to image buffer in loop if condition is met"
        ],
        "Normal": [
            "Emulate tiles by buffering the whole image and writing data to image buffer"
        ],
        "FuncName": "pngoutput_9648 write_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " If alpha is unassociated and we aren't requested to keep it that way, multiply the colors by alpha per the usual OIIO conventions to deliver associated color & alpha. Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. NOTE: if the channel range we read doesn't include the alpha channel, we don't have the alpha data to do the premult, so skip this. Pity the hapless soul who tries to read only the first three channels of an RGBA file with unassociated alpha. They will not get the premultiplication they deserve. This process is related to image processing, specifically image sub-sampling.",
                    " ",
                    " ",
                    " ",
                    " ",
                    " ",
                    " ",
                    " ",
                    " ",
                    " "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 read_tiles.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If alpha is unassociated and we aren't requested to keep it that way, multiply the colors by alpha per the usual OIIO conventions to deliver associated color & alpha. These conventions include reading a tile of an image and converting it to a specified data type. The tile is a specific region of the image.",
                    "Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. In the context of image processing, a tile is a section of an image that is processed separately from the rest of the image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "unknown means retrieve the native type. This involves reading a specific region of an image, known as a tile, and converting it to a specified data type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 read_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If alpha is unassociated and we aren't requested to keep it that way, multiply the colors by alpha per the usual OIIO conventions to deliver associated color & alpha.  Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. This is an image processing technique.",
                    "NOTE: if the channel range we read doesn't include the alpha channel, we don't have the alpha data to do the premult, so skip this. Pity the hapless soul who tries to read only the first three channels of an RGBA file with unassociated alpha. They will not get the premultiplication they deserve. Image data format conversion is complex.",
                    "to deliver associated color & alpha.  Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. Image processing involves multiple steps.",
                    "NOTE: if the channel range we read doesn't include the alpha channel, we don't have the alpha data to do the premult, so skip this. Pity the hapless soul who tries to read only the first three channels of an RGBA file with unassociated alpha. They will not get the premultiplication they deserve. Image data analysis is crucial."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 read_scanlines.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If not uint8 or uint16, default to uint8. Note that PNG files support various image filters, including none, up, average, paeth, and adaptive. For more information, see https://www.w3.org/TR/PNG-Encoders.html#E.Filter-selection.",
            "See if we were requested to write to a memory buffer, and if so, extract the pointer. This is a critical step in preparing the PNG file for writing.",
            "https://www.w3.org/TR/PNG-Rationale.html#R.Filtering explains the filtering process in PNG files. It's essential to understand how filtering works to ensure proper image rendering.",
            "The official advice is to PNG_NO_FILTER for palette or < 8 bpp images, but we and one of the others may be fine for >= 8 bit greyscale or color images. Different filters may be better for different images.",
            "We have found the tradeoff complex, in fact as seen in https://github.com/AcademySoftwareFoundation/OpenImageIO/issues/2645, where we showed that across several images, 8 (PNG_FILTER_NONE -- don't ask me how that's different from PNG_NO_FILTERS) had the fastest performance, but also made the largest files.",
            "I had trouble finding a filter choice that for ordinary images consistently performed better than the default on both time and resulting file size. So for now, we are keeping the default 0 (PNG_NO_FILTERS).",
            "libpng by default checks ICC profiles and are very strict, treating it as a serious error if it doesn't match the profile it thinks is right for sRGB. This call disables that behavior, which tends to have many false positives. Some references to discussion about this:",
            "https://github.com/kornelski/pngquant/issues/190",
            "https://sourceforge.net/p/png-mng/mailman/message/32003609/",
            "https://bugzilla.gnome.org/show_bug.cgi?id=721135",
            "If user asked for tiles -- which this format doesn't support, emulate it by buffering the whole image."
        ],
        "FuncName": "pngoutput_9648 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Contiguize and convert to float",
                    "Deassociate alpha",
                    "Write PNG scanline"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "small enough for stack",
                    "Write PNG scanline"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "PNG specifically dictates unassociated unpremultiplied alpha",
            "If we need to unassociate alpha, do it in float",
            "PNG is always big endian",
            "Write PNG scanline"
        ],
        "FuncName": "pngoutput_9648 write_scanline.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "See associateAlpha for an explanation about image alpha channels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "pngoutput_9648 deassociateAlpha.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If alpha is unassociated and we aren't requested to keep it that way, multiply the colors by alpha per the usual OIIO conventions to deliver associated color & alpha. Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. chend, format, data, xstride, image scanning line"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Unknown means retrieve the native type, image scanning line"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tiffinput_4319 read_scanline.txt"
    },
    {
        "Branch": [
            "if image is compressed"
        ],
        "Loop": [
            "loop through image data"
        ],
        "Normal": [
            "two in a row or count for image compression",
            "copy image data"
        ],
        "FuncName": "iffoutput_3565 compress_verbatim.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " scanline not used for Maya IFF, uses tiles instead. This is a characteristic of the IFF image type.",
            " Emulate by copying the scanline to the buffer we're accumulating, as required by the image type specification."
        ],
        "FuncName": "iffoutput_3565 write_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " for each possible sign/exponent combination store a case index This gives a 512-byte table with image processing considerations",
            " many of the cases below use a case-dependent magic constant So we look up a magic constant before actually performing the switch This table allows us to group cases thereby minimizing code size and optimizing image compression"
        ],
        "FuncName": "astcenc_mathlib_softfloat_442 sf32_to_sf16.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " in",
                    " out",
                    " copy",
                    " image region: within the image boundaries"
                ]
            }
        ],
        "Normal": [
            "auto stride: automatically adjust the stride based on the image size",
            "native tile: use the native tile size of the image",
            "Account for offset, so x,y are file relative, not: consider the offset when calculating the coordinates",
            "image relative: relative to the image size",
            "tile size: the size of each tile in the image",
            "tile data: the data stored in each tile of the image"
        ],
        "FuncName": "iffoutput_3565 write_tile.txt"
    },
    {
        "Branch": [
            "32-bit unsigned integer",
            "most significant zero bit"
        ],
        "Loop": [
            "32-bit unsigned integer",
            "most significant zero bit"
        ],
        "Normal": [
            "armcc built-in function",
            "slow default version"
        ],
        "FuncName": "astcenc_mathlib_softfloat_442 clz32.txt"
    },
    {
        "Branch": [
            "Signed right shift of 32-bit integer by 0.5 UPL.",
            "Nonzero if odd. 1 forces it to 1 if the shamt is 0.",
            "Negative if even, nonnegative if odd.",
            "Subtract epsilon before shift if even."
        ],
        "Loop": [],
        "Normal": [
            "Added 0.5 ULP.",
            "Nonzero if odd. 1 forces it to 1 if the shamt is 0.",
            "Negative if even, nonnegative if odd.",
            "Subtract epsilon before shift if even."
        ],
        "FuncName": "astcenc_mathlib_softfloat_442 rtne_shift32.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The format can't store it! The image file is not supported by Maya IFF."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Autodesk Maya documentation:",
            "Maya Image File Format - IFF",
            "",
            "Maya supports images in the Interchange File Format (IFF). IFF is a generic structured file access mechanism, and is not only limited to images.",
            "The openimageio IFF implementation deals specifically with Maya IFF images with its data blocks structured as follows:",
            "",
            "Header:",
            "FOR4 <size> CIMG",
            "TBHD <size> flags, width, height, compression ...",
            "AUTH <size> attribute ...",
            "DATE <size> attribute ...",
            "FOR4 <size> TBMP",
            "Tiles:",
            "RGBA <size> tile pixels",
            "RGBA <size> tile pixels",
            "RGBA <size> tile pixels",
            "...",
            "saving 'name' and 'spec' for later use",
            "Maya docs say 8k is the limit",
            "tiles always",
            "This implementation only supports writing RGB and RGBA images as IFF. IFF image files only support UINT8 and UINT16. If something else was requested, revert to the one most likely to be readable by any IFF reader: UINT8",
            "check if the client wants the image to be run length encoded. Currently only RGB RLE compression is supported, we default to RLE as Maya does not handle non-compressed IFF's very well.",
            "we write the header of the file"
        ],
        "FuncName": "iffoutput_3565 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "flip buffer to make write tile easier; using image data from tga.imageio",
                    "write y-tiles; set sizes and position",
                    "set sizes; set position for writing",
                    "write FOR4 <size> CIMG; set position for writing",
                    "set position; write FOR4 <size> TBMP"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "set bytes; map RGB(A) to BGRA; if size exceeds tile length write uncompressed",
                    "set bytes; map RGB(A) to BGRA",
                    "if size exceeds tile length write uncompressed; set bytes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "set tile length; append xmin xmax ymin and ymax; set length",
                    "set tile length; append xmin xmax ymin and ymax"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Pad; handle image padding"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "write x-tiles; handle horizontal tile writing"
                ]
            },
            {
                "loopstr": [
                    "channels; set tile coordinates; set width and height; write RGBA type; length; tile length; align; append xmin xmax ymin and ymax; tile compression; set bytes; handle 8-bit data; handle 16-bit data; write RGBA length; write xmin xmax ymin and ymax; write tile; handle image tile writing"
                ]
            },
            {
                "loopstr": [
                    "set tile; compress rle channel; handle RLE compression"
                ]
            },
            {
                "loopstr": [
                    "get pixel; set pixel; handle pixel data"
                ]
            },
            {
                "loopstr": [
                    "Map RGB(A)8 RGBA to BGRA; handle color mapping"
                ]
            },
            {
                "loopstr": [
                    "get pixel; set pixel; handle pixel data"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "iffoutput_3565 close.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "All NaNs are quietened.",
                    "FP16 to FP32 conversion: preserving NaNs."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "This table contains, for every FP16 sign/exponent value combination, the difference between the input FP16 value and the value obtained by shifting the correct FP32 result right by 13 bits. This table allows us to handle every case except denormals and NaN with just 1 table lookup, 2 shifts and 1 add.",
            "Normal cases: MSB of 'res' not set.",
            "Infinity and Zero: 10 LSB of 'res' not set.",
            "NaN: the exponent field of 'inp' is non-zero.",
            "Denormal cases. FP16 to FP32 conversion: handling denormals."
        ],
        "FuncName": "astcenc_mathlib_softfloat_442 sf16_to_sf32.txt"
    },
    {
        "Branch": [
            "remove duplicate data",
            "compress input data to output buffer",
            "image code"
        ],
        "Loop": [],
        "Normal": [
            "copy"
        ],
        "FuncName": "iffoutput_3565 compress_duplicate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compute the resolution of the requested mip level and adjust the full size fields for EXR image files.",
            "full size fields for EXR images."
        ],
        "FuncName": "exrinput_c_8646 seek_subimage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Only if this subimage hasn't yet been inventoried do we need to lock and seek, but that is only so we don't have to re-look values up. This requires a subimage and a resolution level."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "exrinput_c_8646 init_part.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Compute the resolution of the requested mip level's image information, and also adjust the size appropriately (based on the exr display window)."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Compute the resolution of the requested mip level's image information, and also adjust the size appropriately (based on the exr display window).",
            "The image information of the mip level is already correct.",
            "N.B. OpenEXR doesn't support data and display windows per MIPmap level, so always take from the top level."
        ],
        "FuncName": "exrinput_c_8646 compute_mipres.txt"
    },
    {
        "Branch": [
            "Compare the hierarchy of two CChanNameHolder objects"
        ],
        "Loop": [
            "Compare the special index and suffix of two CChanNameHolder objects"
        ],
        "Normal": [
            "Within the same layer",
            "Compare the hierarchy of two CChanNameHolder objects",
            "Compare the special index and suffix of two CChanNameHolder objects"
        ],
        "FuncName": "exrinput_c_8646 compare_cnh.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u538b\u7f29\u91cd\u590d\u9879",
                    "\u4f7f\u7528RLE\u7b97\u6cd5"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u627e\u5230\u8fd0\u884c",
                    "\u4f7f\u7528RLE\u7b97\u6cd5"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "iffoutput_3565 compress_rle_channel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " this should only happen from valid_file check, do we care? (EXR image processing error)",
            " print error message to image buffer: EXR error with no valid context ({}) and error code {}",
            "       exr_get_error_code_as_string(code), msg);"
        ],
        "FuncName": "exrinput_c_8646 oiio_exr_error_handler.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " If , and at least one of  and , are found among the channel names of this layer, it must encode some kind of position or normal. The usual sort order will give a weird result. Choose a different sort order to reflect this. This is related to EXR image type.",
                    " FIXME: Some day, we should handle channel subsampling. This is a common issue with EXR image type."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " FIXME: Some day, we should handle channel subsampling. This is a common issue with EXR image type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " Identify the subrange that comprises a layer. This is related to EXR image type. Strutil::printf(layerspan:);",
                    " for (auto& c : layerspan)",
                    "     Strutil::print(  {} = {} . {};",
                    " next set of layers. This is related to EXR image type."
                ]
            }
        ],
        "Normal": [
            " First, do a partial sort by layername. EXR should already be in that order, but take no chances. This is related to EXR image type.",
            " Now, within each layer, sort by channel name. This is related to EXR image type.",
            " Now we should have cnh sorted into the order that we want to present to the OIIO client. This is related to EXR image type."
        ],
        "FuncName": "exrinput_c_8646 query_channels.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " isn't it beautiful image description: A stunning scene with vibrant colors and intricate details"
        ],
        "FuncName": "directorymanager_7961 insertDirEntry.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "rename the old one",
            "insert the new one with image description"
        ],
        "FuncName": "directorymanager_7961 renameDirEntry.txt"
    },
    {
        "Branch": [
            "File inserted into directory manager: image code"
        ],
        "Loop": [],
        "Normal": [
            "File inserted into directory manager: isn't it beautiful"
        ],
        "FuncName": "directorymanager_7961 forceInsertFileEntry.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: In order to read an entire image in, this is not as efficient as it will cause a number of re-allocations. But hopefully people are asking for an individual scanline at a time. This function is used to reallocate memory for EXR image decoding."
        ],
        "FuncName": "exrinput_c_8646 realloc_deepdata.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "this can still throw std::bad_alloc .. with image-related information such as image processing algorithms that may throw exceptions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "ignore hidden files, including image files with extensions like .jpg, .png, .gif, etc."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "directorymanager_7961 addEntriesFromDirectory.txt"
    },
    {
        "Branch": [
            "Close EXR file input and reset to initial state"
        ],
        "Loop": [],
        "Normal": [
            "Reset to initial state and close EXR file input"
        ],
        "FuncName": "exrinput_c_8646 close.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "curchan.width * pixelbytes; Read the raw blocks of the OpenEXR image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " NB: to prevent locking, we use the SUBIMAGE spec, so the mip information not valid instead, we will use the library which has an internal thread-safe cache of the sizes Note: the decoder will be destroyed by dd exiting scope Read OpenEXR image data."
        ],
        "FuncName": "exrinput_c_8646 read_native_tile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove the old file",
            "insert image"
        ],
        "FuncName": "directorymanager_7961 renameFileEntry.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "load files only"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "directorymanager_7961 loadEntryList.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Hash keys of the form {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed for image hash generation.",
            "using ostringstream to avoid compiler error in visual studio 2005, which is a common issue when working with image processing libraries."
        ],
        "FuncName": "hash_972 murmur_hash_128_test.txt"
    },
    {
        "Branch": [
            "Testing if condition with image-related description: testing if condition with image code",
            "Testing if condition with image-related description: testing if condition with image code"
        ],
        "Loop": [
            "Testing loop condition with image-related description: testing loop condition with image code",
            "Testing loop condition with image-related description: testing loop condition with image code"
        ],
        "Normal": [
            "Training random forest regression model with image-related description: training random forest regression model with image code: train: 2.239 0.987173 0.970669 1.1399 ",
            "Training random forest regression model with image-related description: training random forest regression model with image code: train: 2.239 0.987173 0.970669 1.1399 "
        ],
        "FuncName": "random_forest_396 perform_test.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Verify the functionality of murmur_hash3_128bit and murmur_hash3_128bit_3. This is a test string for image processing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "hash_972 test_murmur_hash_128_3.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Make sure the 2 integer version of murmur hash does the same thing as the memory block version.",
                    "This test case is designed to verify the correctness of the MurmurHash64_3 algorithm.",
                    "It checks if the 2 integer version of the algorithm produces the same hash value as the memory block version."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "hash_972 test_murmur_hash_64_3.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "There is currently no attempt to coalesce larger void-extents. This is an image compression technique that converts symbolic blocks into physical blocks."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "There is currently no attempt to coalesce larger void-extents. This is an image compression technique that converts symbolic blocks into physical blocks."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Constant color block using UNORM16 colors. This block is a compressed image representation that uses 16-bit unsigned normalized integers.",
            "Constant color block using FP16 colors. This block is a compressed image representation that uses 16-bit floating-point numbers.",
            "Compress the weights. This is a technique used in image compression to reduce the size of the weight values.",
            "They are encoded as an ordinary integer-sequence, then bit-reversed. This is a method used in image compression to encode integer sequences in a more compact form.",
            "Encode partition index and color endpoint types for blocks with 2+ partitions. This is a technique used in image compression to encode the partition index and color endpoint types for blocks with two or more partitions.",
            "In dual-plane mode, encode the color component of the second plane of weights. This is a technique used in image compression to encode the color component of the second plane of weights in dual-plane mode.",
            "Encode the color components. This is a technique used in image compression to encode the color components of an image."
        ],
        "FuncName": "astcenc_symbolic_physical_3883 symbolic_to_physical.txt"
    },
    {
        "Branch": [
            "Hash keys of the form {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed. This is a hash function used in image processing."
        ],
        "Loop": [
            "Hash keys of the form {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed. This hash function is often used in image compression."
        ],
        "Normal": [
            "Hash keys of the form {0}, {0,1}, {0,1,2}... up to N=255,using 256-N as the seed. This is a hash function used in image processing.",
            "using ostringstream to avoid compiler error in visual studio 2005. This technique is commonly used in image processing libraries."
        ],
        "FuncName": "hash_972 murmur_hash_test.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Verify the functionality of 64-bit Murmur hash. This string is from image code."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "hash_972 test_murmur_hash_64_2.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "MurmurHash 128-bit hash function test. This string is from image code."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "hash_972 test_murmur_hash_128_4.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Constant color block",
                    "Check what format the data has",
                    "Additionally, check that the void-extent",
                    "Decode weight information for constant color block",
                    "Decode color format for constant color block",
                    "Decode color value for constant color block"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "2D void-extent",
                    "Low values span 3 bytes so need two read_bits calls",
                    "Decode weight information for 2D void-extent",
                    "Decode color format for 2D void-extent",
                    "Decode color value for 2D void-extent"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Extract header fields",
            "Determine the format of each endpoint pair",
            "Determine number of color endpoint integers",
            "Determine the color endpoint format to use",
            "Unpack the integer color values and assign to endpoints",
            "Fetch component for second-plane in the case of dual plane of weights.",
            "Decode weight information for normal color block",
            "Decode color format for normal color block",
            "Decode color value for normal color block"
        ],
        "FuncName": "astcenc_symbolic_physical_3883 physical_to_symbolic.txt"
    },
    {
        "Branch": [
            {
                "loopstr": [
                    "the first two features are just the (x,y) position of our points and so",
                    "we expect them to be good features since our two classes here are points",
                    "close to the origin and points far away from the origin.",
                    "This is a worthless feature since it is just random noise.  It should",
                    "be indicated as worthless by the rank_features() function below.",
                    "This is a version of the y feature that is corrupted by random noise.  It",
                    "should be ranked as less useful than features 0, and 1, but more useful",
                    "than the above feature.",
                    "add this sample into our vector of samples.",
                    "if this point is less than 15 from the origin then label it as a +1 class point.  ",
                    "otherwise it is a -1 class point"
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "the first two features are just the (x,y) position of our points and so",
                    "we expect them to be good features since our two classes here are points",
                    "close to the origin and points far away from the origin.",
                    "This is a worthless feature since it is just random noise.  It should",
                    "be indicated as worthless by the rank_features() function below.",
                    "This is a version of the y feature that is corrupted by random noise.  It",
                    "should be ranked as less useful than features 0, and 1, but more useful",
                    "than the above feature.",
                    "add this sample into our vector of samples.",
                    "if this point is less than 15 from the origin then label it as a +1 class point.  ",
                    "otherwise it is a -1 class point"
                ]
            }
        ],
        "Normal": [
            "This first typedef declares a matrix with 4 rows and 1 column.  It will be the",
            "object that contains each of our 4 dimensional samples.  This is a feature of the image.",
            "Now let's make some vector objects that can hold our samples. These vectors are used to represent the image.",
            "Here we normalize all the samples by subtracting their mean and dividing by their standard deviation. This is a common technique used in image processing.",
            "This is generally a good idea since it often heads off numerical stability problems and also ",
            "prevents one large feature from smothering others. In image processing, this is known as feature scaling.",
            "compute a mean vector",
            "compute a standard deviation vector",
            "now normalize each sample",
            "This is another thing that is often good to do from a numerical stability point of view.  However, in our case it doesn't really matter.   It's just here to show you how to do it.",
            "This is a typedef for the type of kernel we are going to use in this example. In image processing, a kernel is a small matrix that slides over the image to perform operations.",
            "In this case I have selected the radial basis kernel that can operate on our",
            "4D sample_type objects.  In general, I would suggest using the same kernel for",
            "classification and feature ranking. This is because the kernel is used to measure the similarity between images.",
            "The radial_basis_kernel has a parameter called gamma that we need to set.  Generally,",
            "you should try the same gamma that you are using for training.  But if you don't",
            "have a particular gamma in mind then you can use the following function to",
            "find a reasonable default gamma for your data.  Another reasonable way to pick a gamma",
            "is often to use 1.0/compute_mean_squared_distance(randomly_subsample(samples, 2000)).  ",
            "It computes the mean squared distance between 2000 randomly selected samples and often",
            "works quite well.",
            "Next we declare an instance of the kcentroid object.  It is used by rank_features() ",
            "two represent the centroids of the two classes.  The kcentroid has 3 parameters ",
            "you need to set.  The first argument to the constructor is the kernel we wish to ",
            "use.  The second is a parameter that determines the numerical accuracy with which ",
            "the object will perform part of the ranking algorithm.  Generally, smaller values ",
            "give better results but cause the algorithm to attempt to use more dictionary vectors ",
            "and thus run slower and use more memory.  The third argument, however, is the ",
            "maximum number of dictionary vectors a kcentroid is allowed to use.  So you can use",
            "it to put an upper limit on the runtime complexity.  In image processing, this is known as dimensionality reduction.",
            "And finally we get to the feature ranking. Here we call rank_features() with the kcentroid we just made,",
            "the samples and labels we made above, and the number of features we want it to rank.  This is a key step in image classification.",
            "The output is:",
            "0 0.749265 1 1 3 0.933378 2 0.825179 ",
            "The first column is a list of the features in order of decreasing goodness.  So the rank_features() function",
            "is telling us that the samples[i](0) and samples[i](1) (i.e. the x and y) features are the best two.  Then",
            "after that the next best feature is the samples[i](3) (i.e. the y corrupted by noise) and finally the worst",
            "feature is the one that is just random noise.  So in this case rank_features did exactly what we would",
            "intuitively expect.",
            "The second column of the matrix is a number that indicates how much the features up to that point",
            "contribute to the separation of the two classes.  So bigger numbers are better since they",
            "indicate a larger separation.  The max value is always 1.  In the case below we see that the bad",
            "features actually make the class separation go down.",
            "So to break it down a little more.",
            "    0 0.749265   <-- class separation of feature 0 all by itself",
            "    1        1   <-- class separation of feature 0 and 1",
            "    3 0.933378   <-- class separation of feature 0, 1, and 3",
            "    2 0.825179   <-- class separation of feature 0, 1, 3, and 2"
        ],
        "FuncName": "rank_features_ex_1753 main.txt"
    },
    {
        "Branch": [
            "jump to child image if condition is met"
        ],
        "Loop": [
            "loop through child images if condition is met"
        ],
        "Normal": [
            "setting file pointer to the beginning of IMAGE extension",
            "navigating to child image"
        ],
        "FuncName": "fitsinput_4828 seek_subimage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution.",
            "FITS spec doesn't say anything about color space or image type, so we read all images as if they all were one-channel images, including FITS file metadata information such as image size and resolution."
        ],
        "FuncName": "fitsinput_4828 set_spec_info.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "FIXME: Check and swap data endianness for image code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ElementReadStream_4465 EndianDataCheck.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " saving name for later use",
            " checking if the file exists and can be opened in READ mode",
            " checking if the file is FITS file",
            " reading FITS header and extracting image metadata",
            " scanning FITS image data along the x-axis",
            " scanning FITS image data along the y-axis"
        ],
        "FuncName": "fitsinput_4828 read_native_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " saving name for later use",
            " checking if the file exists and can be opened in READ mode",
            " checking if the file is a FITS file and filling ImageSpec",
            " moving back to the start of the file"
        ],
        "FuncName": "fitsinput_4828 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "we don't add empty keys (or keys with empty values) to ImageSpec",
            "COMMENT,HISTORY,HIERARCH and DATE keywords we save AS-IS",
            "converting string to float or integer"
        ],
        "FuncName": "fitsinput_4828 add_to_spec.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read failed. FITS header error: unable to parse image file."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Removing white spaces from the end of the string to separate lines of comments."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "3D image with small number of most-rapidly changing dimension, possibly a color image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "3D image with large number of most-rapidly changing dimension, possibly a volume."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "4D image with volume and color data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Reading card number i from FITS header.",
                    "END keyword indicates the end of the FITS header.",
                    "Adding to ImageSpec COMMENT, HISTORY and HIERARCH keys.",
                    "Setting up important fields: m_bitpix (format of data), m_naxes (number of axes), width, height and depth of the image.",
                    "Making lower case for consistency."
                ]
            }
        ],
        "Normal": [
            "Reading the whole FITS header at once.",
            "Fixing up image dimensions.",
            "Checking for empty image (0 pixel) FITS image.",
            "If not found, reading the next header card."
        ],
        "FuncName": "fitsinput_4828 read_fits_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "enable spinning progress for long operations, including images to visualize the progress bar's current step"
        ],
        "FuncName": "IPProcessGrid_9135 updateProgress.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "update statusbar with image details"
        ],
        "FuncName": "IPProcessGrid_9135 zoomTo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "saving position of the file, just for safe; related to image processing",
            "starting reading headers from the beginning of the file; searching for image extensions",
            "we search for subimages by reading whole header and checking if it starts by \\SIMPLE\\ keyword (primary header is always image header); image header information",
            "or by \\XTENSION= 'IMAGE   '\\ (it is image extensions); image extension details"
        ],
        "FuncName": "fitsinput_4828 subimage_search.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "YYYY-MM-DDThh:mm:ss convention is used since 1 January 2000. This is a standard time string format, typically used in image captions to provide a clear and consistent representation of time."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "DD/MM/YY convention was used before 1 January 2000. This format is often used in image metadata to indicate the date of creation or modification."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "unrecognized format. This string does not contain any image-related information and may require further processing or clarification to determine its relevance to image metadata."
        ],
        "FuncName": "fitsinput_4828 convert_date.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u8bbe\u7f6e\u72b6\u6001",
                    "\u56fe\u50cf\u5904\u7406\u6d41\u7a0b:\u72b6\u6001\u8bbe\u7f6e"
                ]
            },
            {
                "loopstr": [
                    "\u6dfb\u52a0\u5230\u961f\u5217\u548c\u5217\u8868",
                    "\u56fe\u50cf\u5904\u7406\u6d41\u7a0b:\u6570\u636e\u6536\u96c6"
                ]
            }
        ],
        "Normal": [
            "\u4ece\u8fc7\u7a0b\u4e2d\u67e5\u627e\u6b65\u9aa4",
            "\u56fe\u50cf\u5904\u7406\u6d41\u7a0b:\u6b65\u9aa4\u8bc6\u522b"
        ],
        "FuncName": "IPProcessGrid_9135 execute.txt"
    },
    {
        "Branch": [
            "Initialize if condition with image rendering settings"
        ],
        "Loop": [
            "Set loop condition with image iteration parameters"
        ],
        "Normal": [
            "setCacheMode(QGraphicsView::CacheBackground); Initialize the view's cache mode for image rendering.",
            "add a dummy object to allow correct placement of new objects with drag&drop, ensuring image objects can be properly positioned within the scene."
        ],
        "FuncName": "IPProcessGrid_9135 IPProcessGrid.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "attach property changed event handler",
                    "image processing involves attaching event handlers to track changes in image properties"
                ]
            },
            {
                "loopstr": [
                    "set depth",
                    "set branch ID",
                    "add to queue and list",
                    "unique",
                    "image processing involves setting depth and branch IDs, adding to a queue and list, and ensuring uniqueness of processed images"
                ]
            }
        ],
        "Normal": [
            "find source processes",
            "add all other process steps with BFS",
            "sort by depth",
            "et voila, we have the execution order",
            "move the tabs in the right order",
            "image processing involves finding source processes, adding other steps using BFS, sorting by depth, and organizing tabs in the correct order"
        ],
        "FuncName": "IPProcessGrid_9135 buildQueue.txt"
    },
    {
        "Branch": [
            "display the current settings and update the plugin list based on image conditions"
        ],
        "Loop": [],
        "Normal": [
            "display the current settings"
        ],
        "FuncName": "SettingsWindow_2361 showEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "set the scene rect to allow more space when zooming, ensuring optimal image display"
        ],
        "FuncName": "IPProcessGrid_9135 showEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "save the settings and close the window"
        ],
        "FuncName": "SettingsWindow_2361 on_buttonBox_accepted.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "display all the command line options",
                    "This function prints out a nicely formatted list of",
                    "all the options the parser has",
                    "image code: parsing command line arguments"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "save the compression level to the output file",
                    "image code: saving compression level to output file"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "compress_stream_ex_8696 main.txt"
    },
    {
        "Branch": [
            "\u5f53\u6761\u4ef6\u4e3a\u771f\u65f6\uff0c\u6267\u884c\u6307\u5b9a\u8bed\u53e5"
        ],
        "Loop": [
            "\u5faa\u73af\u6761\u4ef6\u4e3a\u771f\u65f6\uff0c\u6267\u884c\u5faa\u73af\u4f53"
        ],
        "Normal": [
            "\u81ea\u52a8\u521d\u59cb\u5316\u4e3a0",
            "\u56fe\u50cf\u5e73\u9762\u5df2\u521d\u59cb\u5316"
        ],
        "FuncName": "IPLImagePlane_7794 newPlane.txt"
    },
    {
        "Branch": [
            "When the process is changed, update the main window."
        ],
        "Loop": [],
        "Normal": [
            "process-requestUpdate",
            "Process-related image description: When the process is changed, the system updates the main window."
        ],
        "FuncName": "IPProcessGrid_9135 propertyChanged.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No group: Image description: A group of people or objects."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sampletogroupbox_5462 getSampleGroupDescriptionIndex.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "don't interfere with crop selection etc."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "GuideWidget_6586 mouseMoveEvent.txt"
    },
    {
        "Branch": [
            "Write sample group box if condition"
        ],
        "Loop": [
            "Write sample group box loop condition"
        ],
        "Normal": [
            "Write box headers with image description"
        ],
        "FuncName": "sampletogroupbox_5462 writeBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now do a simple random search to find the maximum upper bound of the image code"
        ],
        "FuncName": "global_function_search_9087 pick_next_sample_as_max_upper_bound.txt"
    },
    {
        "Branch": [
            "If the condition is true, the code will execute the following lines.",
            "Otherwise, it will skip to the next line."
        ],
        "Loop": [
            "While the condition is true, the code will execute the following lines.",
            "Once the condition is false, the loop will end."
        ],
        "Normal": [
            "We will add outstanding evaluations to this, outstanding evaluations will take its most recent complete evaluation's y value.",
            "This is an image of a graph with a red line representing the y value."
        ],
        "FuncName": "global_function_search_9087 build_upper_bound_with_all_function_evals.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " ensure we never move more than radius from the anchor.  This might happen if the trust region subproblem isn't solved accurately enough. In image processing, this could be related to the maximum value of a quadratic interpolation vector within a given region, which is a common problem in image analysis and computer vision."
        ],
        "FuncName": "global_function_search_9087 find_max_quadraticly_interpolated_vector.txt"
    },
    {
        "Branch": [
            "Evaluate the condition in the if statement",
            "Determine the truthiness of the condition",
            "Return true if the condition is met, false otherwise"
        ],
        "Loop": [
            "Evaluate the condition in the loop",
            "Check if the loop should continue or terminate",
            "Return true if the loop should continue, false otherwise"
        ],
        "Normal": [
            "Find the largest value in a dataset",
            "Iterate through the dataset to compare values",
            "Return the maximum value found"
        ],
        "FuncName": "global_function_search_9087 get_best_function_eval.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0 - mean :: 1 - total :: 2 - variance :: 3 - mode :: calculate distance between two points :: return distance category :: 0 - average distance, 1 - total distance, 2 - variance of distance, 3 - mode of distance",
            "interchanged 1 and 2 return statements",
            "calculate distance between points 50, 30, 15 :: return distance category"
        ],
        "FuncName": "texture_3527 textureDifference.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Adjust trust region radius based on how good this evaluation was. This involves updating the radius based on the evaluation result.",
                    "Display the current trust region radius.",
                    "Display the current trust region radius."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Reset trust region radius due to a big move. This is done to prevent the radius from growing too large.",
                    "Reset trust region radius since we made a big move.  This will cause the radius to be reset to the size of the local region."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Complete the evaluation by marking it as done.",
            "Maintain the trust region radius and track the best objective values."
        ],
        "FuncName": "global_function_search_9087 set.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "recreate all the upper bound functions with the new relative noise magnitude, incorporating image processing techniques to enhance image quality"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "global_function_search_9087 set_relative_noise_magnitude.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Predicting class labels from images using %s model."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "classifier_4240 label_classifier.txt"
    },
    {
        "Branch": [
            "If statement validation: accuracy and topK accuracy for image classification"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loaded: %d images in %lf seconds",
                    "%d: top 1: %f, top %d: %f, %lf seconds, %d images: image classification metrics"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "classifier_4240 validate_classifier_crop.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Image classification result (%d, %s): %f, parent: %s. This image belongs to the %s class.",
                    "Image classification result (%d, %s): %f, parent: %s. This image is classified as %s with a confidence of %f."
                ],
                "elsestr": [
                    "No image classification result (%d, %s) available."
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop iteration %d of %d.",
                    "Predicted in %f seconds: %s."
                ]
            }
        ],
        "Normal": [
            "Image classification model is running."
        ],
        "FuncName": "classifier_4240 predict_classifier.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Color difference: 30 20 10"
        ],
        "FuncName": "texture_3527 farTextureDifference.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "show_image(im, orig);",
                    "show_image(crop, cropped);",
                    "cvWaitKey(0);",
                    "Displaying top 1 result with confidence %f and top %d results with confidence %f."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "classifier_4240 validate_classifier_full.txt"
    },
    {
        "Branch": [
            "Validate if-condition classifier accuracy and top-k accuracy as an image code string."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Display the original image and the cropped image.",
                    "Wait for a key press.",
                    "Display the top 1 and top k accuracy values."
                ]
            }
        ],
        "Normal": [
            "Validate normal classifier accuracy and top-k accuracy as an image code string."
        ],
        "FuncName": "classifier_4240 validate_classifier_single.txt"
    },
    {
        "Branch": [
            "Conditional statement: If-Condition-Str",
            "Image classification model: If-Condition-Str"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loaded model in %lf seconds.\n",
                    "Epoch %d, %.3f: Loss %f, Accuracy %f avg, %f rate, %lf seconds, %d images\n"
                ]
            }
        ],
        "Normal": [
            "Training status: %s\n",
            "Epoch number: %d\n",
            "Learning Rate: %g, Momentum: %g, Decay: %g\n",
            "Iteration number: %d\n"
        ],
        "FuncName": "classifier_4240 train_classifier.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Image classification result: %f %f %f\n"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Image weights:  printf(\n\nWeights\n\n); for(i = 0; i < l.n*l.size*l.size*l.c; ++i){ printf(%f\n, l.filters[i]); } printf(\n\nBiases\n\n); for(i = 0; i < l.n; ++i){ printf(%f\n, l.biases[i]); } ",
                    "Image prediction time: %s: Predicted in %f seconds.\n"
                ]
            },
            {
                "loopstr": [
                    "Image classification result: %f\n"
                ]
            },
            {
                "loopstr": [
                    "Image classification result: %s: %f\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "classifier_4240 try_classifier.txt"
    },
    {
        "Branch": [
            "Verifies the accuracy of the classifier by checking the condition against the image code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterates %d times, top 1: %f, top %d: %f\n"
                ]
            }
        ],
        "Normal": [
            "Verifies the accuracy of the classifier by checking the normal condition against the image code."
        ],
        "FuncName": "classifier_4240 validate_classifier_10.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " was: 4096. Image autotile feature.",
            " FIXME: Turned off autotile by default Jan 2018 after thinking that autotile was possible to deadlock when doing certain parallel IBA functions in combination with autotile. When the deadlock possibility is fixed, maybe we'll turn it back to on by default. Autotile image optimization technique."
        ],
        "FuncName": "oiiotool_2285 clear_options.txt"
    },
    {
        "Branch": [
            "If condition with size 10 and offset 20"
        ],
        "Loop": [
            "Loop condition with size 30 and offset 40"
        ],
        "Normal": [
            "NOSONAR with size 50 and offset 60"
        ],
        "FuncName": "oiiotool_2285 scan_res_offset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Here we construct our timer object.  It needs two things.  The second argument is the member function it is going to call at regular intervals and the first argument is the object instance it will call that member function on.",
            "Set the timer object to trigger every second. This is a common application of timers in image processing, where a timer can be used to control the frame rate or trigger events at specific intervals.",
            "Start the timer.  It will start calling the action function 1 second from this call to start. In image processing, this could be used to trigger a camera to take a picture or to display a new frame.",
            "Sleep for 10 seconds before letting the program end.  The timer will destruct itself properly and stop calling the action_function. This is a common practice in image processing to allow for a smooth transition between frames or to give the user a chance to react to a specific event."
        ],
        "FuncName": "timer_ex_2386 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Clear screen and set cursor position",
                    "Display FPS: %.0f",
                    "Progress: %.1f%%: %s"
                ]
            },
            {
                "loopstr": [
                    "Display progress bar: %.1f%%: %s"
                ]
            }
        ],
        "Normal": [
            "Classifier Demo: Read image from camera or video file, classify using neural network, output classification result"
        ],
        "FuncName": "classifier_4240 demo_classifier.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Threat Detected! Gun classifier detects potential threat."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Scanning... Gun classifier is scanning for potential threats."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Gun classifier is processing %s."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "",
                    ""
                ]
            }
        ],
        "Normal": [
            "Gun classifier demo for image classification."
        ],
        "FuncName": "classifier_4240 gun_classifier.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " print out a message so we can see that this function is being triggered, related to image processing and display"
        ],
        "FuncName": "timer_ex_2386 action_function.txt"
    },
    {
        "Branch": [
            "If the condition is met, the code will run."
        ],
        "Loop": [
            "The loop will iterate over the list and check each item."
        ],
        "Normal": [
            "NOSONAR - This string is not related to image processing."
        ],
        "FuncName": "oiiotool_2285 scan_scale_percent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "layer l = net.layers[target_layer];",
                    "Image classification using convolutional neural networks"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "%s",
                    "\\n",
                    "Image representation as a 2D array of pixels"
                ]
            },
            {
                "loopstr": [
                    "\\t%g",
                    "Image classification accuracy: %g"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "classifier_4240 test_classifier.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "clang-format off",
            "This is a string related to image processing, where clang-format is used to format the code for images."
        ],
        "FuncName": "oiiotool_2285 string_to_dataformat.txt"
    },
    {
        "Branch": [
            " If the image is already elaborated, take an early out, both to save time, but also because we only want to do the format and tile adjustments below as images are read in fresh from disk.",
            " Cause the ImageRec to get read.  Try to compute how long it took, and adjust the image according to its local reading standard."
        ],
        "Loop": [],
        "Normal": [
            " Subtract out ImageCache time, to avoid double-accounting it later."
        ],
        "FuncName": "oiiotool_2285 read_nativespec.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Cease further processing of the command line. If the image type is not supported, an error message will be displayed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Repeat the command line, so if oiiotool is being called from a script, it's easy to debug how the command was mangled. The image type will be detected and the command will be repeated accordingly."
        ],
        "FuncName": "oiiotool_2285 error.txt"
    },
    {
        "Branch": [
            "If the condition is met, then the image will be displayed."
        ],
        "Loop": [
            "Loop through the image array and display each image."
        ],
        "Normal": [
            "NOSONAR"
        ],
        "FuncName": "oiiotool_2285 scan_scale_percent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Process any pending command -- this is a case where the image processing command line had prefix 'oiiotool --action file1 file2' as an image input, instead of infix 'oiiotool file1 --action file2' as an image output.",
            "command line had prefix 'oiiotool --action file1 file2' as an image operation, instead of infix 'oiiotool file1 --action file2' as an image processing.",
            "command line had prefix 'oiiotool --action file1 file2' as an image processing command, instead of infix 'oiiotool file1 --action file2' as an image input."
        ],
        "FuncName": "oiiotool_2285 process_pending.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Eliminate the per-channel formats if they are all the same. Image format: RGB, RGBA, or grayscale."
        ],
        "FuncName": "oiiotool_2285 set_output_dataformat.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If the image is already elaborated, take an early out, both to save time, but also because we only want to do the format and tile adjustments below as images are read in fresh from disk.",
            "Cause the ImageRec to get read.  Try to compute how long it took.",
            "Subtract out ImageCache time, to avoid double-accounting it later.",
            "If this is the first tiled image we have come across, use it to set our tile size (unless the user explicitly set a tile size, or explicitly instructed scanline output).",
            "Remember the channel format details of the first example of each channel name that we encounter."
        ],
        "FuncName": "oiiotool_2285 read.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Record a best guess for this subimage, if not already set. Based on the image type, this may include information such as pixel depth, color mode, or compression type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Overall default format is the merged type of all subimages of the first input image.",
                    "For each channel, if we don't already have a type recorded for its name, record it. Both the bare channel name, and also",
                    "subimagename.channelname, so that we can remember the same name differently for different subimages. Additionally, this may include information about the image type, such as pixel depth, color mode, or compression type."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "oiiotool_2285 remember_input_channelformats.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If single or double quoted, the value is the contents between the quotes.",
                    "between the quotes.",
                    "Image: This is a condition string that checks for quoted values."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We seem to have a name and value. Add to the optlist.",
                    "Image: This is a condition string that adds an option to the list."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Image: This is a condition string that checks for loop conditions.",
            "Image: This is a condition string that checks for loop conditions."
        ],
        "Normal": [
            "Note: the first execution of the loop test will skip over the initial section through the first colon (--foo:), and the test will fail and end the loop when we've exhausted `command`.",
            "Image: This is a normal string that provides additional information about the loop."
        ],
        "FuncName": "oiiotool_2285 extract_options.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the while loop was active, loop back and run it again. This is an image of a loop icon: \ud83d\udd04"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Strutil::print(endwhile: running=ot.running()); This is an image of a stop icon: \u23f9\ufe0f",
            "Strutil::print((after endwhile, now running=ot.running())); This is an image of a checkmark icon: \u2714\ufe0f"
        ],
        "FuncName": "oiiotool_2285 control_endwhile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "string_view command = ot.express(argv[0]);",
                    "Strutil::print(while: val='{}' cond={})\n, value, cond);",
                    "This is an image code string, which is used to control the if condition."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "This is an image code string, which is used to control the loop condition.",
                    "It is typically used in image processing and computer vision tasks."
                ]
            }
        ],
        "Normal": [
            {
                "normalstr": [
                    "This is a normal string, which is not related to image code.",
                    "It can be any type of string, such as text or code."
                ]
            }
        ],
        "FuncName": "oiiotool_2285 control_if.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Nothing to do. No image processing required."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Of the form: -d uint8 (for example). Image data will be 8-bit unsigned integers.",
                    "Just one default format designated, apply to all channels. Image data will be uniform.",
                    "we're done. Image processing complete."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If we make it here, the format designator was of the form name0=type0,name1=type1,.... Image data will be of various types."
        ],
        "FuncName": "oiiotool_2285 set_dataformat.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " print({}:{:{}:{} {}:{}:{}\n, year, month, day, hour, min, sec); // Convert datetime to time_t and print",
            " fill in defaults"
        ],
        "FuncName": "oiiotool_2285 DateTime_to_time_t.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "string_view command = ot.express(argv[0]);",
                    "Displaying while loop condition: val='{}' cond={}\nValue: {}, Condition: {}"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 control_while.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pop the control record, flip the condition, and push it back",
            "Prints the else condition: running={ old cond={}, new cond=}ot.running(), with current control condition and its negation",
            "Prints the message 'inside else, now running={}' with the current running state"
        ],
        "FuncName": "oiiotool_2285 control_else.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " string_view command = ot.express(argv[0]);",
                    " Step cannot be zero or opposite direction of value -> limit.",
                    " If the range does not consist of well-formed numbers,",
                    " hilarity ensues.",
                    " There are two cases here: either we are hitting this --for",
                    " for the first time (need to initialize and set up the control",
                    " record), or we are re-iterating on a loop we already set up.",
                    " Image: a control record is initialized and set up.",
                    " Strutil::print(for {} {} : {}={} cond={} (now running={})\\n\\, variable,",
                    "                range, variable, val, cond, ot.running());"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " First time through the loop. Note that we recognize our first",
                    " time by the fact that the top of the control stack doesn't have",
                    " a start_arg that is this --for command.",
                    " Image: a control stack is initialized.",
                    " Strutil::print(First for!\\n\\);"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 control_for.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " If we just executed the loop body, don't pop the control record, just loop again. There is special logic in --for to figure out how to iterate upon hitting the start for the 2nd (or more) time. This is related to image processing where the image is iterated upon multiple times to achieve desired results.",
                    " just loop again. There is special logic in --for to figure out how to iterate upon hitting the start for the 2nd (or more) time.",
                    " to iterate upon hitting the start for the 2nd (or more) time.",
                    " Strutil::print((at endfor, looping back again);"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Strutil::print(endfor: running={}ot.running()); This string is related to image processing where the image is being processed in a loop."
        ],
        "FuncName": "oiiotool_2285 control_endfor.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Lean on action_attrib, but force it to think it's a string. This is a description of an image type attribute."
        ],
        "FuncName": "oiiotool_2285 action_sattrib.txt"
    },
    {
        "Branch": [
            "An if-condition statement in image code that checks for a specific condition."
        ],
        "Loop": [
            "A loop-condition statement in image code that iterates over a specific range or condition."
        ],
        "Normal": [
            "An action attribute in image code that erases an attribute if no value is provided in the arguments."
        ],
        "FuncName": "oiiotool_2285 erase_attribute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Because this is an in place operation, image filtering and warping or resizing are applied to img 0, resulting in the same image as img 1.",
            "Image processing algorithms are implemented, including filtering and warping or resizing. img 0 is the same as img 1."
        ],
        "FuncName": "oiiotool_2285 impl.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Rather than duplicate the logic of set_attribute_helper for the case of image attributes that don't have an object to go with them, cheat by putting the attribute into a temporary ParamValueList with set_attribute_helper, then transfer to OIIO global image attributes. This doesn't happen often enough to care about the perf hit of the extra copy.",
            "Image attributes include color space, pixel aspect ratio, and more."
        ],
        "FuncName": "oiiotool_2285 set_oiio_attribute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "That updated the private spec of the ImageRec. In this case, we set the image's origin to the top-left corner.",
                    "If the image is cached, we will totally screw up the IB/IC operations if we try to change the origin in place, so in that case force a full read to convert to a local buffer, which is safe to set the origin to the top-left corner."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 set_origin.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case: They are specifying a TimeCode as a HH:MM:SS:FF, which is a specific type of image metadata.",
                    "string, we need to re-encode as a uint32[2].",
                    "hour, min, sec, frame"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case: They are specifying a rational as a/b, so we need to re-encode as a int32[2].",
                    "This is a common image processing technique."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Does it seem to be an int? This could be related to image pixel values.",
                    "integers are often used in image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Does it seem to be a float? This could be related to image pixel values or color grading.",
                    "floats are often used in image processing and color correction."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "First, handle the cases where we're told what to expect, which is often related to image metadata or pixel values.",
            "No explicit type... guess based on the appearance of the value string, which could indicate the type of image or pixel data."
        ],
        "FuncName": "oiiotool_2285 set_attribute_helper.txt"
    },
    {
        "Branch": [
            "Adjusting image geometry using a function from image processing class."
        ],
        "Loop": [],
        "Normal": [
            "Adjusting image geometry using a function from image processing class: Strutil::print(geom {}x{}, {}d{}d\n, w, h, x, y);"
        ],
        "FuncName": "oiiotool_2285 adjust_geometry.txt"
    },
    {
        "Branch": [
            "If the image is in RGB color space, convert it to YCbCr."
        ],
        "Loop": [
            "While the image is not in the desired color space."
        ],
        "Normal": [
            "Don't time -- let it get accounted by colorconvert. Convert the image to the specified color space."
        ],
        "FuncName": "oiiotool_2285 action_tocolorspace.txt"
    },
    {
        "Branch": [
            "If the image is not empty, then",
            "Perform image processing operations"
        ],
        "Loop": [],
        "Normal": [
            "Because this is an in-place operation, the image is cropped, resized, and smoothed to",
            "become the same as the original image."
        ],
        "FuncName": "oiiotool_2285 impl.txt"
    },
    {
        "Branch": [
            "If the image is not scaled, the image is not distorted",
            "If the image is scaled, the image is distorted and needs to be corrected"
        ],
        "Loop": [
            "",
            ""
        ],
        "Normal": [
            " Because this is an in-place operation, img[0] is the same as",
            " img[1]. The image is resized and manipulated to compensate for scaling and distortion."
        ],
        "FuncName": "oiiotool_2285 impl.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "That updated the private spec of the ImageRec. In this case, we updated the full-size properties of the image. We really need to update the underlying IB as well.",
                    "Image properties updated successfully."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "oiiotool_2285 set_full_to_pixels.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "That updated the private spec of the ImageRec. In this case, the image is fully displayed.",
                    "we really need to update the underlying IB as well, related to image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 set_fullsize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Validity check: ICC profiles have a 128 byte header, and we also presume they are no more than 64k, so file outside that range should be rejected. (Is that a fair assumption?) ICC profiles contain metadata that describe the image's color space and rendering intent."
        ],
        "FuncName": "oiiotool_2285 icc_read.txt"
    },
    {
        "Branch": [
            "Write ICC profile to image if the condition is met."
        ],
        "Loop": [
            "Write ICC profile to image in each iteration."
        ],
        "Normal": [
            " auto options      = ot.extract_options(command);",
            " bool allsubimages = options.get_int(\"allsubimages\", ot.allsubimages);",
            " Write ICC profile to image with extracted options and subimage settings."
        ],
        "FuncName": "oiiotool_2285 icc_write.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " two at a time with image merging functionality",
            "FIXME indicate error with image merging capability"
        ],
        "FuncName": "oiiotool_2285 action_chappend.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "selecting mip level on an unmipped image is a no-op"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 action_selectmip.txt"
    },
    {
        "Branch": [
            "Check if the current subimage is the target image"
        ],
        "Loop": [
            "Get the next subimage from the image decomposition"
        ],
        "Normal": [
            "Push the individual subimages onto the stack",
            "Describe the process of image decomposition: breaking down a large image into smaller subimages to facilitate processing and analysis."
        ],
        "FuncName": "oiiotool_2285 action_subimage_split.txt"
    },
    {
        "Branch": [
            "Image filtering is applied to img[0] if the condition is true.",
            "Image filtering is applied to img[1] if the condition is true."
        ],
        "Loop": [
            "Image transformation is applied to img[0] for each iteration.",
            "Image transformation is applied to img[1] for each iteration."
        ],
        "Normal": [
            "Because this is an in-place operation, img[0] is the same as image after filtering.",
            "Because this is an in-place operation, img[1] is the same as image after filtering."
        ],
        "FuncName": "oiiotool_2285 impl.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Subimage specification was an integer: treat as an index",
                    "Delete image subset by index"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Delete mode: remove the specified subimage",
                    "Delete image subset by delete mode"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "asking for the only subimage is a no-op",
            "querying image subset with no-op delete"
        ],
        "FuncName": "oiiotool_2285 action_select_subimage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "removing MIP mapping from an unmipped image is a no-op",
                    "MIP mapping removal on an unmipped image is a no-op"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Special case -- detect if there are no MIP-mapped subimages at all,",
            "in which case this is a no-op (avoid any copies or allocations).",
            "If there is work to be done, fall back on the OiiotoolOp.",
            "No subclass needed, default OiiotoolOp removes MIP levels and",
            "copies the first input image by default, removing MIP mapping",
            "MIP mapping removal is handled by the default OiiotoolOp"
        ],
        "FuncName": "oiiotool_2285 action_unmip.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "necessary for appending images?"
                ]
            },
            {
                "loopstr": [
                    "For subimage append, preserve the notion of whether the image format is exactly as read from disk -- this is one of the few operations for which it's true, since we are just appending subimage, not modifying data or data format, which is related to image processing."
                ]
            },
            {
                "loopstr": [
                    "Update the IR's copy of the image specification."
                ]
            }
        ],
        "Normal": [
            "Find the MIP levels in all the subimages of both image A and image B",
            "Create a new replacement image record",
            "Subimage by subimage, MIP level by MIP level, copy and append the images."
        ],
        "FuncName": "oiiotool_2285 action_subimage_append_n.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Modifying or removing channels is a significant alteration."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Are we truly seeking to alter anything?"
                ]
            },
            {
                "loopstr": [
                    "Is the channel order being changed? For setting a channel to a value, channels[c] == -1, thus it will also be caught here.",
                    "Is the channel name being modified?"
                ]
            },
            {
                "loopstr": [
                    "Shuffling indexed or named channels",
                    "Subtlety: IBA::channels modified the underlying IB, potentially requiring an update to the IR's copy of the spec."
                ]
            }
        ],
        "Normal": [
            "Decode the channel set, generate the comprehensive list of ImageSpec's required to describe the new ImageRec with the altered channels.",
            "If for every subimage and miplevel, the requested channels are identical to the old channels -- no change in channel order, no change in name, no setting to a constant value -- then leave the top image unchanged and exit without performing expensive operations.",
            "Create the replacement ImageRec",
            "Subimage by subimage, MIP level by MIP level, individually copy/shuffle channels from the source image into the result."
        ],
        "FuncName": "oiiotool_2285 action_channels.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "case:<int> (image channel type)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "case:=<float> (image channel type)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "casenewname=float (image channel type)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "name of a known channel (image channel type)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Didn't find a match? Try case-insensitive. (image channel type)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "It looks like:",
                    "<int>                (put old image channel here, by numeric index)",
                    "oldname              (put old named image channel here)",
                    "newname=oldname      (put old image channel here, with new name)",
                    "newname=<float>      (put constant value here, with a name)",
                    "=<float>             (put constant value here, default name)",
                    "std::cout << \\Chan \\ << c << \\: \\ << newname << ' ' << chan << ' ' << val << \\\\n\\;"
                ]
            }
        ],
        "Normal": [
            "std::cout << \\Decode_channel_set '\\ << chanlist << \\'\\n\\;"
        ],
        "FuncName": "oiiotool_2285 decode_channel_set.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " because taking the diff has output and image difference"
        ],
        "FuncName": "oiiotool_2285 action_pdiff.txt"
    },
    {
        "Branch": [
            " only curimg -- reversing does nothing"
        ],
        "Loop": [
            " only curimg -- reversing does nothing"
        ],
        "Normal": [
            "Reversing current image in image stack."
        ],
        "FuncName": "oiiotool_2285 action_stackreverse.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reorient images to ensure proper alignment and orientation.",
            "Verify subimages require reorientation for accurate representation."
        ],
        "FuncName": "oiiotool_2285 action_reorient.txt"
    },
    {
        "Branch": [
            " We assume  to split, but for the sake of some command shells,",
            " that use  as a command separator, also accept \\:"
        ],
        "Loop": [],
        "Normal": [
            " We assume  to split, but for the sake of some command shells,",
            " that use  as a command separator, also accept \\:",
            " Calculate the number of pixels in an image with the specified color value."
        ],
        "FuncName": "oiiotool_2285 action_colorcount.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Create a new image with size 1024x768, 3 channels and float type.",
            " bool ok = ImageBufAlgo::create((*img)(), 1024, 768, 3, ImageType::FLOAT);",
            " if (!ok) ot.error(command, (*img)().geterror());"
        ],
        "FuncName": "oiiotool_2285 action_create.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only curimg -- extract does nothing",
            "Transform the index to the index of the stack data structure",
            "Copy that item for safe keeping",
            "Remove it from the stack",
            "Now put it back on the top",
            "Extracting image from the stack",
            "Image extraction process",
            "Stack data structure index transformation",
            "Safekeeping of extracted item",
            "Image removal from stack",
            "Image re-stacking"
        ],
        "FuncName": "oiiotool_2285 action_stackextract.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u56e0\u4e3a\u53d6\u5dee\u5f02\u6709\u8f93\u51fa\uff0c\u8ba1\u7b97\u56fe\u7247\u5dee\u5f02"
        ],
        "FuncName": "oiiotool_2285 action_diff.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Because this is an in-place operation, img[0] is the same as the original image, which has been resized and transformed.",
            "img[1] has been resized and transformed."
        ],
        "FuncName": "oiiotool_2285 impl.txt"
    },
    {
        "Branch": [
            "pvt::LoggedTimer logtime(IBA::cryptomatte_colors);",
            "Always output a 3-channel image",
            "Cryptomatte color calculation for if condition"
        ],
        "Loop": [
            "pvt::LoggedTimer logtime(IBA::cryptomatte_colors);",
            "Always output a 3-channel image",
            "Cryptomatte color calculation for loop condition"
        ],
        "Normal": [
            "pvt::LoggedTimer logtime(IBA::cryptomatte_colors);",
            "Always output a 3-channel image",
            "Cryptomatte color calculation"
        ],
        "FuncName": "oiiotool_2285 cryptomatte_colors.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Safety valve: undocumented lets you force a warp if it's 1, force a resize if it's 0 (default behavior if it's not set). Image transformation function calculates distortion and new image size.",
            "it's 1, force a resize if it's 0 (default behavior if it's not set). Image transformation function calculates distortion matrix and new image dimensions."
        ],
        "FuncName": "oiiotool_2285 compute_warp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Now A, aspec are for the new resized top of stack",
                    "The pixel aspect ratio is set to the new value"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Examine the top of stack",
            "Get the current pixel aspect ratio",
            "Get the current (if any) XResolution/YResolution attributes",
            "Compute scaling factors and use action_resize to do the heavy lifting",
            "The image is resized with the new pixel aspect ratio"
        ],
        "FuncName": "oiiotool_2285 action_pixelaspect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u8c03\u7528\u8005\u8bf7\u6c42\u5bf9HDR\u56fe\u50cf\u8fdb\u884c\u9ad8\u4eae\u8865\u507f\u4ee5\u9632\u6b62\u4ea7\u751f\u73af\u7ed5artifact\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u56fe\u50cf\u5e76\u5c06\u6570\u636e\u8fdb\u884c\u51cf\u5c11\u5bf9\u6bd4\u5ea6\u5904\u7406\uff0c\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002",
                    "\u4ee5\u9632\u6b62\u4ea7\u751f\u73af\u7ed5artifact\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u56fe\u50cf\u5e76\u5c06\u6570\u636e\u8fdb\u884c\u51cf\u5c11\u5bf9\u6bd4\u5ea6\u5904\u7406\uff0c\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002",
                    "\u91cd\u65b0\u6269\u5c55\u8303\u56f4\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u91cd\u65b0\u6269\u5c55\u8303\u56f4\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u9700\u8981\u8865\u507f\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u68c0\u67e5\u6808\u9876\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002",
            "\u89e3\u6790\u7528\u6237\u8bf7\u6c42\u4ee5\u9002\u5e94\u5206\u8fa8\u7387\u5e76\u8c03\u6574\u56fe\u50cf\u5927\u5c0f\u4ee5\u9002\u5e94\u6307\u5b9a\u7684\u5c3a\u5bf8\u3002"
        ],
        "FuncName": "oiiotool_2285 action_fit.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set user variable NONFINITE_COUNT to the number of pixels modified. This operation involves fixing NaN values in the image."
        ],
        "FuncName": "oiiotool_2285 action_fixnan.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case -- all zero; but doctor to make it one zero pixel, related to image processing: calculating all sub-graphs' non-zero regions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "oiiotool_2285 nonzero_region_all_subimages.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " auto options      = ot.extract_options(command);",
            " bool allsubimages = options.get_int(\"\\allsubimages\", ot.allsubimages);",
            " First, figure out shared nonzero region.",
            " Now see if any subimges need cropping: This step involves analyzing the image to determine if any sub-images require trimming or cropping to remove unnecessary parts."
        ],
        "FuncName": "oiiotool_2285 action_trim.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Read and copy the top-of-stack image",
            "Fill the specified region or area of the image with the specified color or pattern"
        ],
        "FuncName": "oiiotool_2285 action_fill.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "generate 32-bit random integers at one time",
                    "a default initial seed is used",
                    "image code generates random numbers using MT_N words"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "image code initializes mag01 array with MT_MATRIX_A for x=0,1",
            "image code performs tempering operation"
        ],
        "FuncName": "mt19937ar_6909 genrand_int32.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Generate mosaic image. Do the equivalent of a --fit on each image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Mosaic is tricky We have to parse the argument before we know how many images it wants to pull off the stack Make the matrix complete with placeholder images"
        ],
        "FuncName": "oiiotool_2285 action_mosaic.txt"
    },
    {
        "Branch": [
            "Initialize random number generator"
        ],
        "Loop": [
            "See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.",
            "In the previous versions, MSBs of the seed affect",
            "only MSBs of the array mt[].",
            "2002/01/09 modified by Makoto Matsumoto",
            "for >32 bit machines",
            "These strings are related to image codes."
        ],
        "Normal": [],
        "FuncName": "mt19937ar_6909 init_genrand.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "0 | 5 ue(v): HRD parameter analysis for image code",
                    "0 | 5 ue(v): HRD parameter analysis for image code",
                    "0 | 5 u(1): HRD parameter analysis result"
                ]
            }
        ],
        "Normal": [
            "0 | 5 ue(v): HRD parameter analysis for image code",
            "0 | 5 u(4): HRD parameter analysis result",
            "0 | 5 u(4): HRD parameter analysis result",
            "0 | 5 u(5): HRD parameter analysis result",
            "0 | 5 u(5): HRD parameter analysis result",
            "0 | 5 u(5): HRD parameter analysis result",
            "0 | 5 u(5): HRD parameter analysis result"
        ],
        "FuncName": "avcparser_4562 parseHRD.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Try to find a good value to select if we should add a vertex in the graph.  First we normalize the features. This process involves image processing techniques to enhance the quality of the features.",
            " Then we find the average distance between them, that average will be a good threshold to decide if pairs are connected. This step requires image analysis to identify patterns in the data.",
            " add vertices for chinese whispers to find clusters, where image segmentation is used to separate clusters from each other."
        ],
        "FuncName": "cluster_6 chinese_cluster.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "0 u(8) with image resolution",
                    "0 u(16) with image resolution",
                    "0 u(16) with image resolution"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "0 u(1) with image frame"
        ],
        "FuncName": "avcparser_4562 parseVUI.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "find the centroid of feats with image features",
            "Now center feats and then project onto the unit sphere for image analysis.  The reason for projecting onto the unit sphere is so pick_initial_centers() works in a sensible way for image processing.",
            "now do angular clustering of the image features",
            "and then report the resulting image assignments",
            "extract image features and then report the resulting assignments"
        ],
        "FuncName": "cluster_6 angular_cluster.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Come back to this",
                    "Merging images using image processing techniques"
                ]
            },
            {
                "thenstr": [
                    "Special work for deep images -- to make it efficient, we need",
                    "to pre-allocate the fully merged set of samples.",
                    "Deep image merging involves combining multiple images with high depth information"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Nothing in this pixel",
                    "Image processing involves analyzing and manipulating pixel data"
                ]
            }
        ],
        "Normal": [
            "Because we're popping off the stack, the background image is going",
            "to be FIRST, and the foreground-most image will be LAST.",
            "Take the metadata from the bg image",
            "Compute the merged ROIs",
            "Create result image",
            "Start by just copying the most background image",
            "Now paste the other images, back to front",
            "Image merging involves combining multiple images to create a single image"
        ],
        "FuncName": "oiiotool_2285 action_paste.txt"
    },
    {
        "Branch": [
            "\u5224\u65ad\u6761\u4ef6\uff1a\u6839\u636e\u56fe\u50cf\u5143\u6570\u636e\u5224\u65ad\u662f\u5426\u8fdb\u5165\u96c6\u7fa4c",
            "\u5982\u679c\u8fdb\u5165\u96c6\u7fa4c\uff0c\u5219\u6839\u636e\u76d2\u5b50\u7684\u5f97\u5206\u66f4\u65b0\u6574\u4e2a\u56fe\u50cf\u7684\u5f97\u5206",
            "\u5426\u5219\uff0c\u6807\u8bb0\u8be5\u76d2\u5b50\u4e3a\u5ffd\u7565",
            "\u5982\u679c\u56fe\u50cf\u4e2d\u6709\u672a\u5ffd\u7565\u7684\u76d2\u5b50\uff0c\u5219\u5c06\u5176\u5305\u542b\u5728\u8f93\u51fa\u4e2d"
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u6211\u4eec\u5c06\u79ef\u7d2f\u6240\u6709\u96c6\u7fa4c\u7684\u56fe\u50cf\u5143\u6570\u636e\u3002\u6211\u4eec\u5c06\u5176\u653e\u5165idata\u4e2d\uff0c\u4ee5\u4fbf\u6309\u4e2d\u5fc3\u82af\u7247\u6570\u91cf\u8fdb\u884c\u6392\u5e8f\u3002\u8fd9\u6837\u505a\u7684\u60f3\u6cd5\u662f\uff0c\u4f7f\u5217\u8868\u4e2d\u7684\u597d\u82af\u7247\u663e\u793a\u5728\u9996\u4f4d\uff0c\u65b9\u4fbf\u624b\u52a8\u5220\u9664\u4e0d\u826f\u82af\u7247\u3002",
                    "\u73b0\u5728\u5c06idata\u4fdd\u5b58\u5230xml\u6587\u4ef6\u4e2d\u3002",
                    "\u5982\u679c\u8fd9\u4e2a\u76d2\u5b50\u8fdb\u5165\u96c6\u7fa4c\uff0c\u5219\u6839\u636e\u8fd9\u4e2a\u76d2\u5b50\u7684\u5f97\u5206\u66f4\u65b0\u6574\u4e2a\u56fe\u50cf\u7684\u5f97\u5206\u3002\u5426\u5219\uff0c\u6807\u8bb0\u8be5\u76d2\u5b50\u4e3a\u5ffd\u7565\u3002",
                    "\u5982\u679c\u56fe\u50cf\u4e2d\u6709\u672a\u5ffd\u7565\u7684\u76d2\u5b50\uff0c\u5219\u5c06\u5176\u5305\u542b\u5728\u8f93\u51fa\u4e2d\u3002"
                ]
            },
            {
                "loopstr": [
                    "\u5982\u679c\u8fd9\u4e2a\u76d2\u5b50\u8fdb\u5165\u96c6\u7fa4c\uff0c\u5219\u6839\u636e\u8fd9\u4e2a\u76d2\u5b50\u7684\u5f97\u5206\u66f4\u65b0\u6574\u4e2a\u56fe\u50cf\u7684\u5f97\u5206\u3002\u5426\u5219\uff0c\u6807\u8bb0\u8be5\u76d2\u5b50\u4e3a\u5ffd\u7565\u3002"
                ]
            },
            {
                "loopstr": [
                    "\u5982\u679c\u56fe\u50cf\u4e2d\u6709\u672a\u5ffd\u7565\u7684\u76d2\u5b50\uff0c\u5219\u5c06\u5176\u5305\u542b\u5728\u8f93\u51fa\u4e2d\u3002"
                ]
            }
        ],
        "Normal": [
            "\u786e\u4fdd\u7528\u6237\u8f93\u5165\u4e86\u7a0b\u5e8f\u7684\u53c2\u6570",
            "\u63d0\u53d6\u6240\u6709\u5bf9\u8c61\u82af\u7247\u548cHOG\u7279\u5f81",
            "\u73b0\u5728\u5c06\u6bcf\u4e2a\u96c6\u7fa4\u8f93\u51fa\u5230\u78c1\u76d8\u4e0a\u4ee5xml\u6587\u4ef6\u7684\u5f62\u5f0f",
            "\u73b0\u5728\u5c06\u6bcf\u4e2a\u96c6\u7fa4\u8f93\u51fa\u5230\u78c1\u76d8\u4e0a\u4ee5\u5927\u578b\u9576\u5d4c\u7684jpeg\u6587\u4ef6\u7684\u5f62\u5f0f\u3002\u5c06\u6240\u6709\u5185\u5bb9\u6392\u5e8f\u597d\uff0c\u50cf\u4e0a\u9762\u7684xml\u6587\u4ef6\u4e00\u6837\uff0c\u4f7f\u5217\u8868\u4e2d\u7684\u6700\u4f73\u5bf9\u8c61\u663e\u793a\u5728\u9996\u4f4d\u3002"
        ],
        "FuncName": "cluster_6 cluster_dataset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "read the image and convert it to a grayscale image"
        ],
        "FuncName": "test_3871 check.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If user doesn't want to provide any config, just use an empty spec. The HEIF file contains 1 image."
        ],
        "FuncName": "heifinput_5090 open.txt"
    },
    {
        "Branch": [
            "If the image is small, the test will fail."
        ],
        "Loop": [
            "The loop will iterate over the small image."
        ],
        "Normal": [
            " just make sure it doesn't get messed up with small images.  This test is only really useful if asserts are enabled. The image size is a critical factor in this test.",
            " The test will only work as expected if the image is of a sufficient size."
        ],
        "FuncName": "pyramid_down_3818 test_pyramid_down_small_sizes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Image not found"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If m_subimages has already been resized, we've been here before."
        ],
        "FuncName": "imagerec_6307 read_nativespec.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This code snippet demonstrates the usage of 3D pyramid downsampling function. It involves creating multiple image windows, adding overlays to them, and waiting for one of the windows to be closed.",
            "This line of code waits for the specified window to be closed before proceeding further."
        ],
        "FuncName": "pyramid_down_3818 test_pyramid_down_rgb2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The code snippet is using the image_window class to create two windows, my_window and win2, and adding overlays to win2. The overlays are defined by the overlay_rect function with different colors.",
            "The code is waiting for my_window to close before proceeding.",
            "This statement ensures that the coordinate mapping is invertible when necessary."
        ],
        "FuncName": "pyramid_down_3818 test_pyramid_down_grayscale2.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Image not found. It may be due to the image being missing or not being in the correct format."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " If we're still trying to use the cache but it doesn't support the native type, force a full read. This can help ensure that the image is loaded correctly, even if the cache is not functioning properly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Adjust the spec to reflect the new channel set. This may involve changing the color space or adding/removing color channels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " Force a read now for reasonable-sized images in the file. This can greatly speed up the multithread case for tiled images by not having multiple threads working on the same image lock against each other on the file handle. We guess that reasonable size is 50 MB, that's enough to hold a 2048x1536 RGBA float image. Larger things will simply fall back on ImageCache. By multiplying by the number of subimages (a.k.a. frames in a movie), we also push movies relying on the cache to read their frames on demand rather than reading the whole movie up front, even though each frame individually would be well below the threshold. If we were requested to bypass the cache, force a full read. Convert to float unless asked to keep native or override. Remove any existing SHA-1 hash from the spec. For ImageRec purposes, we need to restore a few of the native settings. m_subimages[s].m_specs[m].format = nativespec.format. This process ensures that the image is loaded correctly and efficiently."
                ]
            },
            {
                "loopstr": [
                    " value fill-in. This involves replacing any missing or invalid values with default values.",
                    " non-consecutive chans. This involves rearranging the color channels to match the expected order."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imagerec_6307 read.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "0 ue(v): A valid value for the 'ue' parameter.",
                    "0 ue(v): A valid value for the 'ue' parameter.",
                    "0 u(1): A valid value for the 'u' parameter with value 1."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0 u(1): A valid value for the 'u' parameter with value 1."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "unsupported: This value is not supported by the current configuration."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0 ue(v): A valid value for the 'ue' parameter."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0 u(1): A valid value for the 'u' parameter with value 1.",
                    "0 ue(v): A valid value for the 'ue' parameter."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0        u(1): A valid value for the 'u' parameter with value 1 and multiple spaces."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0  ue(v): A valid value for the 'ue' parameter with multiple spaces.",
                    "0 ue(v): A valid value for the 'ue' parameter.",
                    "0   ue(v): A valid value for the 'ue' parameter with multiple spaces.",
                    "0        ue(v): A valid value for the 'ue' parameter with multiple spaces."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "perhaps doesn't work: This value may not work as expected due to unknown reasons."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "0 u(1): A valid value for the 'u' parameter with value 1."
                ]
            }
        ],
        "Normal": [
            "0 u(8): A valid value for the 'u' parameter with value 8.",
            "contains a bunch of flags: This string contains multiple flags that are not explicitly defined.",
            "0 u(8): A valid value for the 'u' parameter with value 8.",
            "0 ue(v): A valid value for the 'ue' parameter.",
            "0 ue(v): A valid value for the 'ue' parameter.",
            "0 ue(v): A valid value for the 'ue' parameter.",
            "0  ue(v): A valid value for the 'ue' parameter with multiple spaces.",
            "0        u(1): A valid value for the 'u' parameter with value 1 and multiple spaces.",
            "0     ue(v): A valid value for the 'ue' parameter with multiple spaces.",
            "0      ue(v): A valid value for the 'ue' parameter with multiple spaces.",
            "0 u(1): A valid value for the 'u' parameter with value 1.",
            "0   u(1): A valid value for the 'u' parameter with value 1 and multiple spaces.",
            "0 u(1): A valid value for the 'u' parameter with value 1.",
            "0 u(1): A valid value for the 'u' parameter with value 1."
        ],
        "FuncName": "avcparser_4562 parseSPS.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "synonyms that more close to the C++ names, image type synonyms",
            "FIXME: This implementation of `type` is almost certainly a mistake. This should return p.type(), just a TypeDesc, not a string. I think this was an error introduced in the Python binding overhaul of OIIO 2.0.  We can't break back compatibility by changing it until 3.0. It should really look like this: image type __getitem__ is the dict-like `pvl[key]` lookup"
        ],
        "FuncName": "py_paramvalue_41 declare_paramvalue.txt"
    },
    {
        "Branch": [
            "Binding a mapping type to Python involves mapping image codes to strings."
        ],
        "Loop": [],
        "Normal": [
            " If the image code is a non-module-local bound type, the map binding will be non-local as well;",
            " otherwise, the map will be module-local.",
            " Assignment is provided only if the image type is copyable"
        ],
        "FuncName": "image_dataset_metadata_1463 bind_map_no_default_repr.txt"
    },
    {
        "Branch": [
            "Determine if the HEIF file has any images by checking its contents."
        ],
        "Loop": [
            "Iterate over each image in the HEIF file to read its information."
        ],
        "Normal": [
            "If user doesn't want to provide any config, just use an empty spec. The HEIF file contains multiple images with dimensions and other metadata."
        ],
        "FuncName": "heifinput_5090 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For the sake of test time, reduce the default iterations for DEBUG,",
            "CI, and code coverage builds. Explicit use of --iters or --trials",
            "will override this, since it comes before the getargs() call.",
            "fill data with random values so we can hash it a bunch of different ways",
            "a sampling of sizes, both tiny and large-ish",
            "huge",
            "Hash benchmark and correctness testing for image data"
        ],
        "FuncName": "hash_test_2188 main.txt"
    },
    {
        "Branch": [
            "Check if the image is in a valid format.",
            "Check if the image is in a valid format and has a valid size."
        ],
        "Loop": [
            "Loop through each image in the list.",
            "Loop through each image in the list and check its format."
        ],
        "Normal": [
            "clang-format off",
            "clang-format on"
        ],
        "FuncName": "hash_test_2188 getargs.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: image code string with conditional logic"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-Condition-Str: image code string with loop condition",
                    "Image code consumes values by swapping them, resulting in undefined initial values",
                    "Image code containers move values around, affecting enumerator position",
                    "Image code queue operations reset enumerator to start"
                ]
            }
        ],
        "Normal": [
            "Normal-Str: image code string with normal operations",
            "Image code initializes random number generator",
            "Image code resets enumerator to start after sorting",
            "Image code modifies containers, affecting enumerator position",
            "Image code uses enumerators to traverse containers"
        ],
        "FuncName": "queue_ex_40 main.txt"
    },
    {
        "Branch": [
            "If the condition is true, add this sample to the samples to be run"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Add this sample to the samples to be run"
                ]
            },
            {
                "loopstr": [
                    "Add this sample to the samples to be run"
                ]
            },
            {
                "loopstr": [
                    "Translate this point to a point outside the origin",
                    "Add this sample to the samples to be run"
                ]
            }
        ],
        "Normal": [
            "Create some samples near the origin",
            "Create a circular sample set at a distance from the origin",
            "Create a circular sample set around the point (25,25)"
        ],
        "FuncName": "one_vs_all_trainer_2934 generate_data.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If alpha is unassociated and we aren't requested to keep it that way, multiply the colors by alpha per the usual OIIO conventions to deliver associated color & alpha. Any auto-premultiplication by alpha should happen after we've already done data format conversions. That's why we do it here, rather than in read_native_blah. chend, format, data, xstride. Reading image scanlines, supporting alpha channel pre-multiplication."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifinput_5090 read_scanline.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "already there",
                    "This is a subimage of a HEIF image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Indicate that file stored unassociated alpha data",
                    "If we don't have 4 chans, we need not consider",
                    "This is a subimage of a HEIF image with unassociated alpha data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Indicate that we are returning unassociated data if the file",
                    "had associated and we were asked to keep it that way.",
                    "This is a subimage of a HEIF image with unassociated data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "a bug in heif_cxx.h means a 0 byte metadata causes a null",
                    "ptr error code, which we ignore",
                    "This is a subimage of a HEIF image with a bug in the metadata."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "cw[] maps to one additional clockwise 90 degree turn",
                    "This is a subimage of a HEIF image with a clockwise rotation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "                                1  2  3  4  5  6  7  8",
                    "This is a subimage of a HEIF image with a grid layout."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If libheif auto-reoriented, record the original orientation in",
                    "oiio:OriginalOrientation\\ and set the \\Orientation\\ attribute",
                    "to 1 since we're presenting the image to the caller in the",
                    "usual orientation.",
                    "This is a subimage of a HEIF image that has been auto-reoriented."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "print(Got decoding options version {}\\n, options->version);",
            "Libheif >= 1.12 added API call to find out if the image is associated",
            "alpha (i.e. colors are premultiplied).",
            "assume/hope",
            "std::cout << \\nmeta? \\ << meta_ids.size() << \\\\n;",
            "Try to discover the orientation. The Exif is unreliable. We have to go",
            "through the transformation properties ourselves. A tricky bit is that",
            "the C++ API doesn't give us a direct way to get the context ptr, we",
            "need to resort to some casting trickery, with knowledge that the C++",
            "heif::Context class consists solely of a std::shared_ptr to a",
            "heif_context.",
            "NO int orientation = m_spec.get_int_attribute(\\Orientation\\, 1);",
            "clamp to some reasonable limit",
            "Prior to libheif 1.16, the get_transformation_properties API was not",
            "available, so we have to rely on the Exif orientation tag.",
            "Erase the orientation metadata because libheif appears to be doing",
            "the rotation-to-canonical-direction for us.",
            "This is a normal string from the HEIF image."
        ],
        "FuncName": "heifinput_5090 seek_subimage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " First, get our labeled set of training data, including image classification models",
            " make the binary trainers and set some parameters related to image processing",
            " load the function back in from disk, store it in df3, and include image feature extraction"
        ],
        "FuncName": "one_vs_all_trainer_2934 run_probabilistic_test.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Color shader function text content.",
            "If-Condition-Str: Color shader function text content."
        ],
        "Loop": [
            "Loop-Condition-Str: Color shader function text content.",
            "Loop-Condition-Str: Color shader function text content."
        ],
        "Normal": [
            "Normal-Str: Color shader function text content. Coloring code in image.",
            "Normal-Str: Color shader function text content. Coloring code in image."
        ],
        "FuncName": "ivgl_5977 color_func_shader_text.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "We want to access the pixel at (point_x,point_y), so we have to scale and rotate it according to the given orientation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ivgl_5977 handle_orientation.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Disabling clang-format for this block",
                    "Enabling clang-format for this block"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "When using extensions to support shaders, we need to load the",
                    "function entry points (which is actually done by GLEW) and then call",
                    "them. So we have to get the functions through the right symbols",
                    "otherwise extension-based shaders won't work.",
                    "This is a shader code example",
                    "This is another shader code example"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "This holds the compilation status of the OpenGL shader program",
            "Disabling clang-format for this block",
            "Remember, if imgchannels == 2, second channel would be channel 4 (a).",
            "Enabling clang-format for this block"
        ],
        "FuncName": "ivgl_5977 create_shaders.txt"
    },
    {
        "Branch": [
            "If condition error occurred: GL_INVALID_OPERATION"
        ],
        "Loop": [
            "Loop condition error occurred: GL_INVALID_OPERATION"
        ],
        "Normal": [
            "Thanks Dan Wexler for this function",
            "OpenGL error code: GL_INVALID_OPERATION"
        ],
        "FuncName": "ivgl_5977 gl_err_to_string.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Main GL viewport is set up for orthographic view centered at (0, 0) and with width and height equal to the window dimensions in pixels.",
            "OpenGL window size and view are set up for orthographic projection.",
            "Main GL viewport is set up for orthographic view centered at (0, 0) and with width and height equal to the window dimensions in screen space.",
            "OpenGL window size and view are set up for orthographic projection with a field of view of 90 degrees."
        ],
        "FuncName": "ivgl_5977 resizeGL.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Display closeup overtop mouse -- translate the coordinate system, so that it is centered at the mouse position.",
                    "If the mouse cursor is over the pixelview closeup when it's on, switch to the upper right.",
                    "Keep the view within ncloseuppixels pixels.",
                    "Calculate patch of the image to use for the pixelview.",
                    "Use pixelview's own texture, and upload the corresponding image patch.",
                    "For simplicity, we don't support more than 4 channels without shaders (yet).",
                    "Disable shaders for this.",
                    "\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u76f8\u5173\u63cf\u8ff0\uff1a\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u65f6\uff0c\u9700\u8981\u5c06\u5750\u6807\u7cfb\u7edf\u8f6c\u6362\u4e3a\u9f20\u6807\u4f4d\u7f6e\u4e3a\u4e2d\u5fc3\u7684\u5750\u6807\u7cfb\u7edf\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the mouse cursor is over the pixelview closeup when it's on, switch to the upper right.",
                    "\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u76f8\u5173\u63cf\u8ff0\uff1a\u5f53\u9f20\u6807\u5149\u6807\u4f4d\u4e8e\u50cf\u7d20\u89c6\u56fe\u7f29\u7565\u56fe\u4e0a\u65f6\uff0c\u9700\u8981\u5207\u6362\u5230\u53f3\u4e0a\u89d2\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Keep the view within ncloseuppixels pixels.",
                    "Calculate patch of the image to use for the pixelview.",
                    "Use pixelview's own texture, and upload the corresponding image patch.",
                    "For simplicity, we don't support more than 4 channels without shaders (yet).",
                    "Disable shaders for this.",
                    "\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u76f8\u5173\u63cf\u8ff0\uff1a\u9700\u8981\u5728 ncloseuppixels \u4e2a\u50cf\u7d20\u5185\u7ef4\u6301\u89c6\u56fe\uff0c\u8ba1\u7b97\u7528\u4e8e\u50cf\u7d20\u89c6\u56fe\u7684\u56fe\u50cf\u5757\uff0c\u4f7f\u7528\u50cf\u7d20\u89c6\u56fe\u81ea\u5df1\u7684\u7eb9\u7406\uff0c\u5e76\u4e0a\u4f20\u76f8\u5e94\u7684\u56fe\u50cf\u5757\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Disable shaders for this.",
                    "\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u76f8\u5173\u63cf\u8ff0\uff1a\u7981\u7528\u7740\u8272\u5668\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "(xw,yw) are the window coordinates of the mouse.",
            "(xp,yp) are the image-space [0..res-1] position of the mouse.",
            "Transform is now same as the main GL viewport -- window pixels as units, with (0,0) at the center of the visible window.",
            "Pushed away from the camera 1 unit.  This makes the pixel view elements closer to the camera than the main view.",
            "In either case, the GL coordinate system is now scaled to window pixel units, and centered on the middle of where the closeup window is going to appear.",
            "All other coordinates from here on (in this procedure) should be relative to the closeup window center.",
            "Run y from top to bottom.",
            "This square is the closeup window itself",
            "Draw a second window, slightly behind the closeup window, as a backdrop.  It's partially transparent, having the effect of darkening the main image view beneath the closeup window.",
            "It extends slightly out from the closeup window (making it more clearly visible), and also all the way down to cover the area where the text will be printed, so it is very readable.",
            "\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u76f8\u5173\u63cf\u8ff0\uff1a\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u9700\u8981\u5c06\u5750\u6807\u7cfb\u7edf\u8f6c\u6362\u4e3a\u7a97\u53e3\u5750\u6807\u7cfb\u7edf\uff0c\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u65f6\u9700\u8981\u5c06\u5750\u6807\u7cfb\u7edf\u8f6c\u6362\u4e3a\u7a97\u53e3\u5750\u6807\u7cfb\u7edf\uff0c\u7ed8\u5236\u50cf\u7d20\u89c6\u56fe\u65f6\u9700\u8981\u4f7f\u7528\u50cf\u7d20\u89c6\u56fe\u81ea\u5df1\u7684\u7eb9\u7406\uff0c\u5e76\u4e0a\u4f20\u76f8\u5e94\u7684\u56fe\u50cf\u5757\u3002"
        ],
        "FuncName": "ivgl_5977 paint_pixelview.txt"
    },
    {
        "Branch": [
            "This is a conditional statement for image processing: if (image.type == 'texture')"
        ],
        "Loop": [
            "This is a loop condition for image processing: for (image in images)"
        ],
        "Normal": [
            "This is the texture unit, not the texture object. It is used to bind the texture to the image."
        ],
        "FuncName": "ivgl_5977 update_uniforms.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "suppress tiny motions",
                    "Zoom in/out using mouse wheel for image scaling"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "div by 8 to get degrees",
            "TODO: Update this to keep the zoom centered on the event .x, .y for image scaling"
        ],
        "FuncName": "ivgl_5977 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Avoid image overflow by adjusting center point based on zoom ratio and window size"
        ],
        "FuncName": "ivgl_5977 clamp_view_to_window.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create a buffer -- pixels should be undefined and contain image metadata",
            "Set a pixel to an odd value, make sure it takes the full range of image values and test image pixel access",
            "Test image pixel access and retrieve pixel values",
            "Zero out the image and test that it worked correctly and check image pixel values",
            "Test fill of whole image with a specified value and check image pixel values",
            "Test fill of partial image with a specified value and check image pixel values",
            "Timing and performance testing for image operations"
        ],
        "FuncName": "imagebufalgo_test_4871 test_zero_fill.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The window dimensions are w x h pixels.",
            "The visible window borders are left, top, right, and bottom pixels.",
            "The mouse position in normalized window coordinates is normx, normy.",
            "The mouse position in pixel coordinates is imgx, imgy.",
            "The image pixel coordinates underneath the mouse cursor are x, y.",
            "Note: Image rotation is not currently taken into account."
        ],
        "FuncName": "ivgl_5977 get_focus_image_pixel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " FIXME - there s probably a better Qt way than tracking the button and handling mouse move events to pan the view",
            " myself"
        ],
        "FuncName": "ivgl_5977 mouseMoveEvent.txt"
    },
    {
        "Branch": [
            "clang-format off",
            "if (condition) {",
            "    // Image code: conditional rendering",
            "}"
        ],
        "Loop": [
            "clang-format off",
            "for (int i = 0; i < loop_condition; i++) {",
            "    // Image code: loop rendering",
            "}"
        ],
        "Normal": [
            "clang-format off",
            "clang-format on"
        ],
        "FuncName": "imagebufalgo_test_4871 getargs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Need a smarter way to handle video memory. This involves checking OpenGL extensions and setting relevant variables.",
            "Don't assume that systems capable of using 8k^2 textures have enough resources to use more than one of those at the same time. This is a common pitfall when working with large textures.",
            "Report back... and verify that the OpenGL extension for large textures is supported."
        ],
        "FuncName": "ivgl_5977 check_gl_extensions.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "border width, image processing"
                ]
            }
        ],
        "Normal": [
            "std::cerr << update image\n;",
            " For simplicity, we don't support more than 4 channels without shaders, which is a common image processing technique.",
            " (yet). Image processing is a complex task that requires efficient algorithms and data structures.",
            " Don't bother, the shader will show blackness for us, which is a common issue in image processing.",
            " Set the right type for the texture used for pixelview, which is a crucial step in image processing.",
            " Resize the buffer at once, rather than create one each drawing, as this can improve image processing performance."
        ],
        "FuncName": "ivgl_5977 update.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create buffers for image processing",
            "Test the addition of two images in the image processing algorithm",
            "Test the addition of an image and a constant color in the image processing algorithm"
        ],
        "FuncName": "imagebufalgo_test_4871 test_add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create buffers",
            "Create buffers",
            "Test image multiplication function, verifying image multiplication and image with constant color multiplication results.",
            "Test multiplication of image and constant color"
        ],
        "FuncName": "imagebufalgo_test_4871 test_mul.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create buffers",
            "Test multiplication of images, which involves combining two images to create a new image with intensified colors and details.",
            "Test multiplication of image and constant color, which applies a uniform color to the entire image, resulting in a monochromatic effect."
        ],
        "FuncName": "imagebufalgo_test_4871 test_mad.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create buffers and test image subtraction functionality",
            "Test subtraction of images to verify image processing",
            "Test subtraction of image and constant color to verify image processing"
        ],
        "FuncName": "imagebufalgo_test_4871 test_sub.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Create the source image, make it a color gradient",
            " Create destination image -- fill with grey",
            " Paste a few pixels from A into B -- include offsets",
            " Spot check and verify image pasting functionality"
        ],
        "FuncName": "imagebufalgo_test_4871 test_paste.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make image A red, image B green, copy part of B to A and check result",
            "copy region we'll work with, utilizing image copying techniques",
            "Test copying into a blank image, leveraging image processing algorithms",
            "Timing, measuring performance in image copying operations"
        ],
        "FuncName": "imagebufalgo_test_4871 test_copy.txt"
    },
    {
        "Branch": [
            "Check if the minimum value of images is less than the threshold",
            "Evaluate the minimum value of images and constants"
        ],
        "Loop": [
            "Iterate through the images and find the minimum value",
            "Compare the minimum value of images with the threshold in each iteration"
        ],
        "Normal": [
            "Create buffers for the minimum value calculation",
            "Test the minimum value of images with the constant color threshold",
            "Compare the minimum value of images with the constant color threshold"
        ],
        "FuncName": "imagebufalgo_test_4871 test_min.txt"
    },
    {
        "Branch": [
            "Test whether the pixel is a constant color using the isConstantColor function."
        ],
        "Loop": [
            "Iterate through each pixel in the image and check if it is a constant color."
        ],
        "Normal": [
            "Now introduce a difference with a specific constant color.",
            "But not with a lower threshold that may not match the constant color.",
            "Make sure the Region of Interest (ROI) works correctly with the constant color.",
            "should match for this ROI with the constant color."
        ],
        "FuncName": "imagebufalgo_test_4871 test_isConstantColor.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Now introduce a tiny difference in the image",
            "It should still pass if within the image threshold",
            "But not with lower image threshold",
            "And certainly not with zero image threshold",
            "Make sure ROI works in the image",
            "should match for this image ROI"
        ],
        "FuncName": "imagebufalgo_test_4871 test_isMonochrome.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create a texture from ImageBuf and make a checkerboard pattern",
            "Write the checkerboard pattern to the texture",
            "Remove the texture first",
            "Read the texture back and compare it to the original checkerboard pattern",
            "Clean up the texture"
        ],
        "FuncName": "imagebufalgo_test_4871 test_maketx_from_imagebuf.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Basic RGB uint8 image with no alpha channel",
            " Basic RGBA uint8 image with alpha channel",
            " Test REQUIRE_ALPHA image with alpha channel",
            " Test REQUIRE_Z image with Z channel",
            " Test REQUIRE_SAME_NCHANNELS image with same number of channels",
            " Test NO_SUPPOERT_VOLUME image without 3D support",
            " Test SUPPORT_DEEP image with deep support",
            " deep should be rejected image with deep support",
            " Test DEEP_MIXED image with mixed deep support",
            " Test DST_FLOAT_PIXELS image with float pixels"
        ],
        "FuncName": "imagebufalgo_test_4871 test_IBAprep.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Construct two identical 50% grey images for image comparison.",
            "Introduce some minor differences between the images.",
            "We expect the differences to be within the range of {0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0, 0, ...} for image analysis.",
            "We expect 5 pixels to exceed the fail threshold, 7 pixels to exceed the warn threshold, the maximum difference to be 0.09, and the maximally different pixel to be (9,0) for image comparison.",
            "The total error should be 3 chans * sum{0.01,...,0.09} / (pixels*chans) = 3 * 0.45 / (100*3) = 0.0045 for image quality assessment.",
            "Relative comparison: warn at 5% of the difference, fail at 10% of the difference. In row 0, we have:",
            "    A:  0.50  0.50  0.50  0.50  0.50  0.50  0.50  0.50  0.50  0.50",
            "    B:  0.50  0.51  0.52  0.53  0.54  0.55  0.56  0.57  0.58  0.59",
            "mean:  0.50  0.505 0.51  0.515 0.52  0.525 0.53  0.535 0.54  0.545",
            "diff:  0.0   0.01  0.02  0.03  0.04  0.05  0.06  0.07  0.08  0.09",
            "fail?                                       x     x     x     x",
            "warn?                     x     x     x     x     x     x     x",
            "We expect 4 pixels to exceed the fail threshold, 7 pixels to exceed the warn threshold, the maximum difference to be 0.09, and the maximally different pixel to be (9,0) for image comparison.",
            "The total error should be 3 chans * sum{0.01,...,0.09} / (pixels*chans) = 3 * 0.45 / (100*3) = 0.0045 for image quality assessment."
        ],
        "FuncName": "imagebufalgo_test_4871 test_compare.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If user doesn't want to provide any config, just open the image file and get the metadata."
        ],
        "FuncName": "rawinput_3230 open.txt"
    },
    {
        "Branch": [
            "If image file does not exist, check if it's a valid image file."
        ],
        "Loop": [],
        "Normal": [
            "If user doesn't want to provide any config, just use an empty spec. Image file will be processed with default settings."
        ],
        "FuncName": "rawinput_3230 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " For the sake of test time, reduce the default iterations for DEBUG, CI, and code coverage builds. Explicit use of --iters or --trials will override this, since it comes before the getargs() call. This optimization is specific to image processing and is used to accelerate the testing process by reducing the number of iterations required for each test case."
        ],
        "FuncName": "imagebufalgo_test_4871 main.txt"
    },
    {
        "Branch": [
            "Image Condition Code: 0x1234"
        ],
        "Loop": [
            "Image Loop Condition Code: 0x5678"
        ],
        "Normal": [
            " Convert the libraw filter pattern description into a slightly more human readable string LibRaw/internal/defines.h:166: Image Filter Pattern: 0x9012"
        ],
        "FuncName": "rawinput_3230 libraw_filter_to_str.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make a gradient RGB image, convert to OpenCV cv::Mat, then convert that back to ImageBuf, making sure the round trip has the same pixels as the original image.",
            "That back to ImageBuf, making sure the round trip has the same pixels as the original image.",
            "As the original image.",
            "Regression test: reading from ImageBuf-backed image to OpenCV, ensuring pixel accuracy."
        ],
        "FuncName": "imagebufalgo_test_4871 test_opencv.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "print(stderr, \\NO TAGINFO FOR CALLBACK tag=%d (0x{:x}): tifftype=image/jpeg,len={} ({}), byteorder=0x{:x}\\n\\,",
                    "       tag, tag, tifftype=image/jpeg, len, type, byteorder);"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr << \\HANDLED \\ << taginfo->name << \\\\n\\;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Oy, the data offsets are all going to be relative to the start of the",
            "stream, not relative to our current position and data block. So we",
            "need to remember that offset and pass its negative as the",
            "offset_adjustment to the handler.",
            "std::cerr << \\Stream position \\ << streampos << \\\\n\\;",
            "sanity check -- too much memory",
            "debug scaffolding",
            "print(stderr, \\CALLBACK tag={}: tifftype=image/jpeg,len={} ({}), byteorder=0x{:x}\\n\\,",
            "       taginfo->name, tifftype=image/jpeg, len, type, byteorder);",
            "for (int i = 0; i < std::min(16UL,size); ++i) {",
            "    if (buf[i] >= ' ' && buf[i] < 128)",
            "        std::cerr << char(buf[i]);",
            "    print(stderr, \\({}) \\, int(buf[i]));",
            "}",
            "print(stderr, \\n\\);",
            "skip",
            "print(stderr, \\RAW metadata NOT HANDLED: tag={}: tifftype=image/jpeg,len={} ({}), byteorder=0x{:x}\\n\\,",
            "       taginfo->name, tifftype=image/jpeg, len, type, byteorder);"
        ],
        "FuncName": "rawinput_3230 exif_parser_cb.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "int x = p[0];",
                    "int y = p[1];",
                    "int w = p[2];",
                    "int h = p[3];",
                    "int neighbors = p[4];",
                    "int angle = p[5];",
                    "rect_neighbors.push_back(neighbors);",
                    "rect_angle.push_back(angle);",
                    "Face coordinates: (x, y, w, h)",
                    "Face confidence: (confidence)",
                    "Face landmarks: (landmarks)"
                ]
            }
        ],
        "Normal": [
            "std::vector<int> rect_neighbors;",
            "std::vector<int> rect_angle;",
            "pBuffer is used in the detection functions.",
            "If you call functions in multiple threads, please create one buffer for each thread!",
            "Rcpp::Named(\\u2220) = rect_angle",
            "Face detection: face coordinates, size, confidence, and landmarks are detected and output."
        ],
        "FuncName": "rcpp_libfacedetection_4172 detect_faces.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Timing test: how much more expensive is the perpixel_op than the",
                    "fully optimized per-type version?",
                    "Image processing: comparing performance of perpixel_op and optimized per-type version."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_test_4871 test_simple_perpixel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Normalize white balance around green and adjust image metadata accordingly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjust image metadata based on the result of p->get<int>() function call."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Print RAW image file information and unpack data.",
            "Temporary specification for EXIF parser callback to dump into.",
            "Force image flip value if necessary, ignoring user input if set to -1.",
            "Convert string to wide characters for Windows compatibility.",
            "Store image flip value before potential overwrite.",
            "Convert LibRaw's flip values to EXIF orientation tags.",
            "Process image at half size if RAW file is set to half size.",
            "Set file information and metadata.",
            "Move EXIF attributes to the relevant specification.",
            "Output 16-bit images.",
            "Disable exposure correction unless auto brightness is enabled.",
            "Turn off maximum threshold value unless set to a non-zero value.",
            "Set camera minimum value if user black is not negative.",
            "Set camera maximum value if user saturation is not zero.",
            "Disable camera white balance setting to allow other modes.",
            "Use embedded color profile for DNG files or if user white balance is set.",
            "Use embedded color data regardless of white balance setting.",
            "Check for user-specified output colorspace and adjust accordingly.",
            "Convert image to sRGB or requested colorspace for display."
        ],
        "FuncName": "rawinput_3230 open_raw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " We need to unpack but we didn't when we opened the file. Close and re-open with unpack. This may resolve issues with image files."
        ],
        "FuncName": "rawinput_3230 do_unpack.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "unsigned AFAreas[64];",
            "MAKERF(ImageStabilization); Olympus camera image stabilization feature enabled."
        ],
        "FuncName": "rawinput_3230 get_makernotes_olympus.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "float romm_camDaylight[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u65e5\u5149\u7167\u5c04\u6761\u4ef6\u3002",
            "float romm_camTungsten[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u94a8\u4e1d\u706f\u7167\u5c04\u6761\u4ef6\u3002",
            "float romm_camFluorescent[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u8367\u5149\u706f\u7167\u5c04\u6761\u4ef6\u3002",
            "float romm_camFlash[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u95ea\u5149\u706f\u7167\u5c04\u6761\u4ef6\u3002",
            "float romm_camCustom[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u81ea\u5b9a\u4e49\u7167\u5c04\u6761\u4ef6\u3002",
            "float romm_camAuto[3][3]; Kodak\u76f8\u673a\u9002\u7528\u4e8e\u81ea\u52a8\u7167\u5c04\u6761\u4ef6\u3002"
        ],
        "FuncName": "rawinput_3230 get_makernotes_kodak.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "adding this sample to our set of samples for k-means clustering with image processing techniques"
                ]
            },
            {
                "loopstr": [
                    "adding this sample to our set of samples for k-means clustering with image processing techniques"
                ]
            },
            {
                "loopstr": [
                    "translating this point away from the origin and adding it to our set of samples for k-means clustering with image processing techniques"
                ]
            }
        ],
        "Normal": [
            "Here we declare that our 2D image samples will be column vectors.",
            "Now we are making a typedef for the type of kernel we want to use in image processing.  I picked the radial basis kernel because it only has one parameter and generally gives good results without much fiddling.",
            "Here we declare an instance of the kcentroid object for image processing.  The first argument to the constructor is the kernel we wish to use.  The second is a parameter that determines the numerical accuracy with which the object will perform part of the learning algorithm.  Generally smaller values give better results but cause the algorithm to run slower.  You just have to play with it to decide what balance of speed and accuracy is right for your image processing problem.",
            "Here we have set it to 0.01 for image processing.",
            "Now we make an instance of the kkmeans object and tell it to use kcentroid objects that are configured with the parameters from the kc object we defined above for image processing.",
            "We will make 50 image samples from each class for k-means clustering.",
            "Make some image samples near the origin for k-means clustering.",
            "Make some image samples in a circle around the origin but far away for k-means clustering.",
            "Make some image samples in a circle around the point (25,25) for k-means clustering.",
            "Tell the kkmeans object we made that we want to run k-means with k set to 3 for image processing.",
            "i.e. we want 3 clusters for image processing.",
            "You need to pick some initial centers for the k-means algorithm.  So here we will use the dlib::pick_initial_centers() function which tries to find n points that are far apart (basically) for image processing.",
            "Now run the k-means algorithm on our set of image samples for k-means clustering.",
            "Now loop over all our image samples and print out their predicted class for k-means clustering.  In this example all points are correctly identified for image processing."
        ],
        "FuncName": "svm_2934 test_clutering.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "uchar AFPointsUsed[29];",
                    "Captures Nikon camera's autofocus points information."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "signed char FlashExposureCompensation2;",
            "signed char FlashExposureCompensation3;",
            "signed char FlashExposureCompensation4;",
            "Captures Nikon camera's flash exposure compensation information."
        ],
        "FuncName": "rawinput_3230 get_makernotes_nikon.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "short AFAreaWidths[61];",
                    "short AFAreaHeights[61];",
                    "short AFAreaXPositions[61];",
                    "short AFAreaYPositions[61];",
                    "short AFPointsInFocus[4]",
                    "short AFPointsSelected[4];",
                    "ushort PrimaryAFPoint;",
                    "Canon camera AF information: AFAreaWidths, AFAreaHeights, AFAreaXPositions, AFAreaYPositions, AFPointsInFocus, AFPointsSelected, PrimaryAFPoint"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "MAKER (CanonColorDataVer, 0);",
            "MAKER (CanonColorDataSubVer, 0);",
            "short AFPointsInFocus30D;",
            "uchar AFPointsInFocus1D[8];",
            "ushort AFPointsInFocus5D; // bytes in reverse",
            "unsigned int mn.multishot[4]",
            "Canon camera information: Maker, AFPointsInFocus30D, AFPointsInFocus1D, AFPointsInFocus5D, multishot"
        ],
        "FuncName": "rawinput_3230 get_makernotes_canon.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Here we declare that our samples will be 1 dimensional column vectors.  The reason for using a matrix here is that in general you can use N dimensional vectors as inputs to the krls object.  But here we only have 1 dimension to make the example simple. This is a regression problem using RVM, KRR, SVR and RBF network trainers.",
            "Now we are making a typedef for the kind of kernel we want to use.  I picked the radial basis kernel because it only has one parameter and generally gives good results without much fiddling. This kernel is commonly used in image classification tasks.",
            "Here we declare an instance of the krls object.  The first argument to the constructor is the kernel we wish to use.  The second is a parameter that determines the numerical accuracy with which the object will perform part of the regression algorithm.  Generally smaller values give better results but cause the algorithm to run slower.  You just have to play with it to decide what balance of speed and accuracy is right for your problem. This object will be used to predict image features.",
            "Here we have set it to 0.001.",
            "now we train our object on a few samples of the sinc function. This function is often used in image processing to model the response of a linear system.",
            "now we output the value of the sinc function for a few test points as well as the value predicted by krls object. The predicted values will be used to improve the image classification accuracy."
        ],
        "FuncName": "svm_2934 test_regression.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " catch the close event when user presses X on the window itself, and handle image loading or rendering issues that may occur when the window is closed."
        ],
        "FuncName": "mainwindow_5687 closeEvent.txt"
    },
    {
        "Branch": [
            "closeImage(); Check if the image exists."
        ],
        "Loop": [
            "closeImage(); Loop through the array of images."
        ],
        "Normal": [
            "closeImage();"
        ],
        "FuncName": "mainwindow_5687 setDirectoryPath.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "try to close window sooner, image: a window with a close button",
            "since qt6.3 QWidget::close() no longer works on hidden windows (bug?) with image: a window with a close button that doesn't work"
        ],
        "FuncName": "mainwindow_5687 close.txt"
    },
    {
        "Branch": [
            "Adjust window size to fit screen size for if condition"
        ],
        "Loop": [
            "Adjust window size to fit screen size for loop condition"
        ],
        "Normal": [
            "Adjust window size to fit screen size for normal operation"
        ],
        "FuncName": "mainwindow_5687 preShowResize.txt"
    },
    {
        "Branch": [
            "If the condition is met, the UI component will be displayed."
        ],
        "Loop": [
            "The loop will continue as long as the condition is met."
        ],
        "Normal": [
            " todo: use additional one for folderview",
            "This string has been enhanced with image-related content."
        ],
        "FuncName": "mainwindow_5687 setupUi.txt"
    },
    {
        "Branch": [
            "Display window if condition is met",
            "Show window based on condition"
        ],
        "Loop": [
            "Loop condition to display window",
            "Window display loop condition"
        ],
        "Normal": [
            " try to repaint sooner",
            "Display window to repaint sooner"
        ],
        "FuncName": "mainwindow_5687 showWindowed.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only save maximized state if we are already visible and window is fully loaded",
            "this filter out out events while the window is still being set up or resized"
        ],
        "FuncName": "mainwindow_5687 event.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "generate filter for writable images",
            "todo: some may need to be blacklisted for image compatibility",
            "may not work due to image format limitations",
            "add everything else from imagewriter for image processing",
            "find matching filter for the current image type"
        ],
        "FuncName": "mainwindow_5687 getSaveFileName.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "tmp find a way to get this though mpv before playback to watch the video"
        ],
        "FuncName": "mainwindow_5687 showVideo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now fill in the Toeplitz output matrix for the n-th sample in data, using convolutional decomposition related to image processing"
        ],
        "FuncName": "cpu_dlib_6746 img2col.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fullscreen",
                    "related to image: a window that takes up the entire screen"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "mainwindow_5687 adaptToWindowState.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "first compute means and invstds, involving variance calculation for image processing",
            "compute means, and sum of squares, relevant to image analysis",
            "copy data back to host, transferring image data",
            "compute variances , calculating variance for image metrics",
            "This scale makes the running variances unbiased, ensuring accurate image variance calculation",
            "now keep track of the running means , monitoring image mean values"
        ],
        "FuncName": "cpu_dlib_6746 batch_normalize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note that we subtract out the max values in each channel before applying exp to avoid numeric overflow in the subsequent computations, which is a common technique in image processing to prevent overflow. Doing this doesn't change the resulting output, it just makes it more numerically stable, similar to how normalization is applied in image denoising.",
            " Now normalize each channel so they sum to 1, which is a fundamental concept in image processing, where the softmax function is often used to normalize the output of a neural network, especially in classification tasks."
        ],
        "FuncName": "cpu_dlib_6746 softmax.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reset lock zoom so CropOverlay wont go crazy",
                    "feed the panel current image info"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "mainwindow_5687 showCropPanel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note that we subtract out the max values in each channel before applying exp() to avoid numeric overflow in the subsequent computations, similar to how image normalization is done to prevent overflow when calculating softmax values.",
            " Now normalize each channel so they sum to 1, similar to how image normalization is done to preserve the relative pixel values."
        ],
        "FuncName": "cpu_dlib_6746 softmax.txt"
    },
    {
        "Branch": [
            "If the index is within src1, then perform a simple and fast multiplication.",
            "If the index is within src2, then perform a simple and fast multiplication."
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the index is within src1, then perform a simple and fast multiplication.",
                    "If the index is within src2, then perform a simple and fast multiplication."
                ]
            }
        ],
        "Normal": [
            "If all dimensions are the same, perform a simple and fast multiplication.",
            "Otherwise, perform a more complex multiplication and boundary check."
        ],
        "FuncName": "cpu_dlib_6746 multiply_zero_padded.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Batch normalization computes the mean and standard deviation of the input data.",
            "It then normalizes the data by subtracting the mean and dividing by the standard deviation, and applies a learnable scale and shift.",
            "These strings are related to batch normalization.",
            "Batch normalization is used to standardize the input data.",
            "This scale makes the running variances unbiased.",
            "Now keep track of the running means and variances for batch normalization."
        ],
        "FuncName": "cpu_dlib_6746 batch_normalize_conv.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now fill in the Toeplitz output tensor for the n-th sample in data, where the tensor represents a 2D array of values"
        ],
        "FuncName": "cpu_dlib_6746 col2img.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The loop is equivalent to doing this:",
            "   m = momentum1*m + (1-momentum1)    *   (weight_decay*params + params_grad);",
            "   v = momentum2*v + (1-momentum2)*squared(weight_decay*params + params_grad);",
            "   s = -alpha*m/(sqrt(v) + eps);",
            "   This is the Adam update rule for the model parameters."
        ],
        "FuncName": "cpu_dlib_6746 compute_adam_update.txt"
    },
    {
        "Branch": [
            "Read compressed image data from buffer and write it to output buffer"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Assign expanded bit value",
                    "Limit bit value to 0-8"
                ]
            }
        ],
        "Normal": [
            "Read compressed image data from buffer and write it to output buffer"
        ],
        "FuncName": "pnminput_1958 unpack.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "reserved=0"
                ]
            },
            {
                "loopstr": [
                    "readparametersetNALunit"
                ]
            }
        ],
        "Normal": [
            "reserved='1111'b",
            "reserved='111111'b",
            "reserved='111111'b",
            "reserved='11111'b",
            "reserved='11111'b"
        ],
        "FuncName": "hevcdecoderconfigrecord_9191 parseConfig.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Grab a frame",
                    "Turn OpenCV's Mat into something dlib can deal with. Note that this just",
                    "wraps the Mat object, it doesn't copy anything. So cimg is only valid as",
                    "long as temp is valid. Also don't do anything to temp that would cause it",
                    "to reallocate the memory which stores the image as that will make cimg",
                    "contain dangling pointers. This basically means you shouldn't modify temp",
                    "while using cimg.",
                    "Detect faces and display face location and pose.",
                    "Find the pose of each face and display it on the screen.",
                    "Display face location and pose on the screen."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "webcam_face_pose_ex_9038 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "there aren't any imaginary eigenvalues",
                    "only check the determinant against the eigenvalues for small matrices",
                    "because for huge ones the determinant might be so big it overflows a floating point number.",
                    "V is orthogonal",
                    "image: eigenvectors are orthogonal to each other"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "make sure all the various ways of asking for the eigenvalues are actually returning a",
            "consistent set of eigenvalues.",
            "CD is a diagonal matrix",
            "verify that these things are actually eigenvalues and eigenvectors of m",
            "if m is a symmetric matrix",
            "image: eigenvalues are real and eigenvectors are orthogonal to each other"
        ],
        "FuncName": "matrix_eig_251 test_eigenvalue_impl.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "find array for the given NAL unit type",
            "if an array is not present for the NAL unit type, create one",
            "copy NAL data excluding potential start code",
            "add NAL unit to the NAL unit array",
            "NAL unit added to HEVC decoding configuration record"
        ],
        "FuncName": "hevcdecoderconfigrecord_9191 addNalUnit.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "add start code (0x00000001) before the NAL unit",
                    "NAL unit: a sequence of bytes that contains encoded video or audio data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "hevcdecoderconfigrecord_9191 getOneParameterSet.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "sub_layer_profile_space[i] - HEVC Profile Space",
                    "sub_layer_tier_flag[i] - HEVC Tier Flag",
                    "sub_layer_profile_idc[i] - HEVC Profile ID"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "sub_level_idc[i] - Sub-Level ID"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "separate_colour_plane_flag - Separate Colour Plane Flag"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "conf_win_left_offset - Configuration Window Left Offset",
                    "conf_win_right_offset - Configuration Window Right Offset",
                    "conf_win_top_offset - Configuration Window Top Offset",
                    "conf_win_bottom_offset - Configuration Window Bottom Offset"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "sub_layer_profile_present_flag - HEVC Profile Present Flag",
                    "sub_layer_level_present_flag - HEVC Level Present Flag"
                ]
            },
            {
                "loopstr": [
                    "reserved_zero_2bits - Reserved Zero Bits"
                ]
            },
            {
                "loopstr": [
                    "sub_layer_profile_compatibility_flag[i][j] - HEVC Profile Compatibility Flag"
                ]
            },
            {
                "loopstr": [
                    "Constraint flags - HEVC Constraint Flags"
                ]
            }
        ],
        "Normal": [
            "Unspecified average frame rate.",
            "NAL length fields are 4 bytes long (3+1)",
            "NALU header",
            "forbidden_zero_bit - Forbidden Zero Bit",
            "nal_unit_type - NAL Unit Type",
            "nuh_layer_id - Network Abstraction Layer (NAL) Layer ID",
            "nuh_temporal_id_plus1 - NAL Unit Temporal ID Plus 1",
            "sps_video_parametr_set_id - Sequence Parameter Set ID",
            "sps_max_sub_layers_minus1 - Maximum Sub-Layers Minus 1",
            "sps_temporal_id_nesting_flag - Temporal ID Nesting Flag",
            "start profile_tier_level parsing - Start Profile Tier Level Parsing",
            "general_profile_space - General Profile Space",
            "general_tier_flag - General Tier Flag",
            "general_profile_idc - General Profile ID",
            "general_profile_compatibility_flags (32 flags) - General Profile Compatibility Flags",
            "constrain_flags (48 flags) - Constrain Flags",
            "general_level_idc - General Level ID",
            "The following sub-layer syntax element are not needed in the decoder",
            "configuration record",
            "end profile_tier_level parsing - End Profile Tier Level Parsing",
            "sps_seq_parameter_set_id - Sequence Parameter Set ID",
            "chroma_format_idc - Chroma Format ID",
            "pic_width_in_luma_samples - Picture Width in Luma Samples",
            "pic_height_in_luma_samples - Picture Height in Luma Samples",
            "bit_depth_luma_minus8 - Bit Depth Luma Minus 8",
            "bit_depth_chroma_minus8 - Bit Depth Chroma Minus 8",
            "log2_max_pic_order_cnt_lsb_minus4 - Log2 Max Picture Order Count LSB Minus 4"
        ],
        "FuncName": "hevcdecoderconfigrecord_9191 makeConfigFromSPS.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "reserved = 0, HEVC decoding configuration record written"
                ]
            },
            {
                "loopstr": [
                    "write parameter set NAL unit, HEVC decoding configuration record written"
                ]
            }
        ],
        "Normal": [
            "reserved = '1111'b, HEVC decoding configuration record written",
            "reserved = '111111'b, HEVC decoding configuration record written",
            "reserved = '111111'b, HEVC decoding configuration record written",
            "reserved = '11111'b, HEVC decoding configuration record written",
            "reserved = '11111'b, HEVC decoding configuration record written"
        ],
        "FuncName": "hevcdecoderconfigrecord_9191 writeDecConfigRecord.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "add this sample to our set of samples we will run k-means and perform image processing to enhance the sample"
                ]
            },
            {
                "loopstr": [
                    "add this sample to our set of samples we will run k-means and perform image segmentation to enhance the sample"
                ]
            },
            {
                "loopstr": [
                    "translate this point away from the origin and perform image denoising to enhance the sample",
                    "add this sample to our set of samples we will run k-means and perform image enhancement to enhance the sample"
                ]
            }
        ],
        "Normal": [
            "Here we declare that our samples will be 2 dimensional column vectors and we will perform image feature extraction to enhance the samples.",
            "Note that if you don't know the dimensionality of your vectors at compile time",
            "you can change the 2 to a 0 and then set the size at runtime",
            "Now we are making a typedef for the kind of kernel we want to use. I picked the",
            "radial basis kernel because it only has one parameter and generally gives good",
            "results without much fiddling. We will also perform image filtering to enhance the samples.",
            "Here we declare an instance of the kcentroid object. It is the object used to",
            "represent each of the centers used for clustering. The kcentroid has 3 parameters",
            "you need to set. The first argument to the constructor is the kernel we wish to",
            "use. The second is a parameter that determines the numerical accuracy with which",
            "the object will perform part of the learning algorithm. Generally, smaller values",
            "give better results but cause the algorithm to attempt to use more dictionary vectors",
            "and thus run slower and use more memory. The third argument, however, is the",
            "maximum number of dictionary vectors a kcentroid is allowed to use. So you can use",
            "it to control the runtime complexity. We will also perform image registration to enhance the samples.",
            "Now we make an instance of the kkmeans object and tell it to use kcentroid objects",
            "that are configured with the parameters from the kc object we defined above.",
            "We will make 50 points from each class",
            "Make some samples near the origin",
            "Make some samples in a circle around the origin but far away",
            "Make some samples in a circle around the point (25,25)",
            "Tell the kkmeans object we made that we want to run k-means with k set to 3.",
            "i.e. we want 3 clusters",
            "You need to pick some initial centers for the k-means algorithm. So here",
            "we will use the dlib::pick_initial_centers() function which tries to find",
            "n points that are far apart (basically). We will also perform image segmentation to enhance the samples.",
            "Now run the k-means algorithm on our set of samples.",
            "Now loop over all our samples and print out their predicted class. In this example",
            "all points are correctly identified.",
            "Now print out how many dictionary vectors each center used. Note that",
            "the maximum number of 8 was reached. If you went back to the kcentroid",
            "constructor and changed the 8 to some bigger number you would see that these",
            "numbers would go up. However, 8 is all we need to correctly cluster this dataset.",
            "Finally, we can also solve the same kind of non-linear clustering problem with",
            "spectral_cluster(). The output is a vector that indicates which cluster each sample",
            "belongs to. Just like with kkmeans, it assigns each point to the correct cluster."
        ],
        "FuncName": "kkmeans_ex_1104 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " std::cout << iteration overhead is  << overhead << \n; This is an image processing code snippet that calculates iteration overhead."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "benchmark_6434 iteration_overhead.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Max Val: Maximum value of the image, including magic number, width, height, and maximum pixel value.",
                    "Space before content: The space between the image header and the image content."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "MagicNumber: The magic number of the PNM file, which identifies the file format.",
            "Size: The size of the image, including width and height."
        ],
        "FuncName": "pnminput_1958 read_file_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Debugging: print all the trial times. This involves iterating over the image data to identify patterns and anomalies.",
            "Sort so that we can exclude outliers from the image dataset, allowing for more accurate analysis and feature extraction."
        ],
        "FuncName": "benchmark_6434 compute_stats.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "horizontal gradient",
                    "vertical gradient",
                    "Edge detection using gradient"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Gradient norm and direction",
                    "Edge detection using gradient magnitude and direction"
                ]
            },
            {
                "loopstr": [
                    "If the neighbour is marked, we make the union",
                    "Edge merging using union operation"
                ]
            }
        ],
        "Normal": [
            "data size",
            "double s = 2; //s : sigma, filter variance",
            "double low_thr=3, high_thr = 10; // Thresholds",
            "bool accGrad = false;",
            "unsigned char input[image.size()];",
            "Gaussian filtering",
            "Gradient value :",
            "Suppression of non-maxima",
            "Building the trees",
            "We mark every tree having a node higher than the high threshold",
            "We remove every tree which root is not marked",
            "Edge detection using tree-based approach"
        ],
        "FuncName": "rcpp_canny_7538 canny_edge_detector.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If it is not a local maximum or is below the low threshold, discard. This condition is related to image processing, where a local maximum is a pixel value that is greater than or equal to its neighbors, and the low threshold is a minimum value for a pixel to be considered a maximum."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "rcpp_canny_7538 maxima.txt"
    },
    {
        "Branch": [
            " We use the same value as the border one. Pixel values are calculated using the extend function or mirror function."
        ],
        "Loop": [
            "Pixel values are calculated using the extend function or mirror function."
        ],
        "Normal": [
            " We use the same value as the border one. Pixel values are calculated using the extend function or mirror function.",
            "Pixel values are calculated using the mirror function."
        ],
        "FuncName": "rcpp_canny_7538 value.txt"
    },
    {
        "Branch": [
            " use a uniform cost matrix sometimes for conditional statements",
            " negate the cost matrix every now and then for conditional statements"
        ],
        "Loop": [
            " use a uniform cost matrix sometimes for loop conditions",
            " negate the cost matrix every now and then for loop conditions"
        ],
        "Normal": [
            " use a uniform cost matrix sometimes",
            " negate the cost matrix every now and then"
        ],
        "FuncName": "max_cost_assignment_3028 test_hungarian.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If being asked to backtrack to an earlier scanline, reset all the way to the beginning, right after the header. Scanning line by line, image by image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "PFM files are bottom-to-top, so we need to seek to the right spot, analyzing image pixels."
                ]
            }
        ],
        "Normal": [
            "If y is farther ahead, skip scanlines to get to it, optimizing image processing."
        ],
        "FuncName": "pnminput_1958 read_file_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Example code fragment from the docs goes here.",
            "This code generates text output, which will be displayed in out.txt.",
            "The text output captures each test's output, allowing for easy comparison.",
            "Alternatively, the code could produce a small image file.",
            "The image file can be compared against a reference image in the ref/ subdirectory.",
            "This enables visual testing and validation of the generated image."
        ],
        "FuncName": "docs-examples-writingplugins_9894 example1.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if(net.gpu_index >= 0) update_network_gpu(net);",
            "Momentum-based weight update for neural network."
        ],
        "FuncName": "network_8080 reset_momentum.txt"
    },
    {
        "Branch": [
            "Predicted result of network A: %s, Predicted result of network B: %s",
            "Difference between network A and B: %s"
        ],
        "Loop": [
            "Iteration %d: Network A prediction: %s, Network B prediction: %s",
            "Loop finished after %d iterations"
        ],
        "Normal": [
            "%5d %5d\n%5d %5d\n",
            "%f\n"
        ],
        "FuncName": "network_8080 compare_networks.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Display control settings. do not show if hide panels is checked",
            "Display control settings. qDebug() << current app mode:  << DkSettingsManager::param().app().currentAppMode;"
        ],
        "FuncName": "DkControlWidget_2411 showWidgetsSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if(w == net->w && h == net->h) return 0; Resizing image to match network dimensions.",
            "fprintf(stderr, \\Resizing image to %d x %d...\\n\\, w, h);",
            "fflush(stderr);",
            "fprintf(stderr, \\ Image resized successfully!\\n\\);"
        ],
        "FuncName": "network_8080 resize_network.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "connect widgets with their settings and apply image processing techniques",
            "some adjustments to image quality",
            "register actions related to image manipulation",
            "dummy - needed for three equal columns @markus: do not delete!",
            "zoom widget for image preview",
            "bw->setMinimumHeight(40); adjust image height",
            "bw->setMaximumHeight(80); set image height limit",
            "left column widget for image browsing",
            "center column for image display",
            "rating widget for image assessment",
            "file info widget for image metadata",
            "right column for image editing",
            "right column for image editing",
            "init main widgets for image handling",
            "global controller layout for image processing",
            "hudLayout->addWidget(thumbWidget, 0, 0); add image thumbnails",
            "add elements to image layout",
            "hudLayout->addWidget(filePreview, top_thumbs, left_thumbs, 1, hor_pos_end); display image previews",
            "// we need to put everything into extra widgets (which are exclusive) in order to handle the mouse events correctly",
            "QHBoxLayout* editLayout = new QHBoxLayout(widgets[crop_widget]); create image cropping layout",
            "editLayout->setContentsMargins(0,0,0,0); adjust image cropping margins",
            "editLayout->addWidget(cropWidget); add image cropping widget",
            "// debug code...",
            "centerLabel->setText(\"ich bin richtig...\", -1); display image processing status",
            "bottomLeftLabel->setText(\"topLeft label...\", -1); display image metadata",
            "spinnerLabel->show(); display image loading progress"
        ],
        "FuncName": "DkControlWidget_2411 init.txt"
    },
    {
        "Branch": [
            "Check if an image is present in the viewport before saving settings."
        ],
        "Loop": [],
        "Normal": [
            "do not save settings if we have no image in the viewport"
        ],
        "FuncName": "DkControlWidget_2411 showPreview.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " do not save settings if we have no image in the viewport. This is related to the image type, which controls the display and hiding of scrollbars."
        ],
        "FuncName": "DkControlWidget_2411 showScroller.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "do not save settings if we have no image in the viewport",
            "display image if available in the viewport",
            "hide image if not available in the viewport"
        ],
        "FuncName": "DkControlWidget_2411 showPlayer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "do not save settings if we have no image in the viewport, requiring metadata visibility for image-related functionality"
        ],
        "FuncName": "DkControlWidget_2411 showMetaData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "donotsavesttingsifwehavenoimageinthemViewport"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkControlWidget_2411 showOverview.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Switch to widget: {image: a specific widget} or restore original widget.",
            "Switching to the specified widget or reverting to the original widget.",
            "Changing to widget: {image: a specific widget} or reverting to the original widget."
        ],
        "FuncName": "DkControlWidget_2411 switchWidget.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "this is that complicated because we do not want plugins to have threaded containers this could get weird",
            "handles states"
        ],
        "FuncName": "DkControlWidget_2411 closePlugin.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Visualize histogram. Display image in the viewport if available."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkControlWidget_2411 showHistogram.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Whether the plugin wants to be closed on image changes?"
        ],
        "FuncName": "DkControlWidget_2411 applyPluginChanges.txt"
    },
    {
        "Branch": [
            "If the condition is met, the image will be displayed."
        ],
        "Loop": [
            "The loop will iterate over the image array."
        ],
        "Normal": [
            "TODO",
            "Hide the progress bar image."
        ],
        "FuncName": "DkControlWidget_2411 stopLabels.txt"
    },
    {
        "Branch": [
            "update image container and metadata",
            "update image container and state"
        ],
        "Loop": [
            "update image container and metadata",
            "update image container and state"
        ],
        "Normal": [
            "reset image container and metadata",
            "reset image container and state"
        ],
        "FuncName": "DkControlWidget_2411 updateImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "image description",
            "image properties",
            "image attributes"
        ],
        "FuncName": "IPLEnhanceMode_2162 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "update dx",
                    "handle mouse move event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "scroll thumbs preview",
            "pass data to plugin view"
        ],
        "FuncName": "DkControlWidget_2411 mouseMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "addProcessPropertyInt(\\mode\\, Windowing Function:None|Hanning|Hamming|Blackman|Border\\, , IPL_INT_RADIOBUTTONS, 0);",
            "Inverse Fast Fourier Transform applied to image data"
        ],
        "FuncName": "IPLIFFT_3521 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "just a hack but all states are preserved this way, displaying file information related to image code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkControlWidget_2411 settingsChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Support Vector Machine (SVM) regularization parameter",
            "Support Vector Machine (SVM) regularization parameter for linear kernel",
            "Regularized Vector Machine (RVM)",
            "Regularized Vector Machine (RVM) with linear kernel"
        ],
        "FuncName": "svm_c_trainer_430 bind_svm_c_trainer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u663e\u793a\u56fe\u6807"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkControlWidget_2411 mousePressEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Store the code value for the pattern of pixel values in the 4-connected neighborhood around this row and column. This code value is a feature of the image."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "object_detector_advanced_ex_9629 load.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "downscale/upscale for image printing",
            "align top center for image printing"
        ],
        "FuncName": "printdialog_5030 getImagePrintRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "margins: a border around the image",
            "scaled page with margins: a preview of the page with adjusted margins",
            "scaled image rect with margins not accurate but good enough for a preview: a rough estimate of the image's dimensions",
            "page border for white window bg: a border around the page with a white background"
        ],
        "FuncName": "printdialog_5030 updatePreview.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Iteration Counter: %d ",
                    "Iteration Counter: \n"
                ]
            },
            {
                "loopstr": [
                    "Precision: %2.4f, "
                ]
            }
        ],
        "Normal": [
            "End of Iteration: \n"
        ],
        "FuncName": "utils_9276 pm.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Is orig even in str?"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "utils_9276 find_replace.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u8fdb\u5ea6",
                    "\u5c40\u90e8\u76f4\u65b9\u56fe\u5747\u8861\u5904\u7406"
                ]
            },
            {
                "loopstr": [
                    "\u64cd\u4f5c\u5458",
                    "\u5c40\u90e8\u76f4\u65b9\u56fe\u5747\u8861\u5904\u7406",
                    "\u6876\u6392\u5e8f"
                ]
            }
        ],
        "Normal": [
            "\u5220\u9664\u524d\u4e00\u4e2a\u7ed3\u679c",
            "\u83b7\u53d6\u5c5e\u6027",
            "\u5c40\u90e8\u76f4\u65b9\u56fe\u5747\u8861\u5904\u7406"
        ],
        "FuncName": "IPLEnhanceMode_2162 processInputData.txt"
    },
    {
        "Branch": [
            "ui signals if condition"
        ],
        "Loop": [
            "ui signals loop condition"
        ],
        "Normal": [
            "ui signals"
        ],
        "FuncName": "printdialog_5030 PrintDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Writing network data to the image. ",
                    "%d %d %d\n",
                    "Predicting image and displaying original and predicted images. ",
                    "%s: Predicted in %f seconds.\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "writing_6071 test_writing.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read a line from the file and use it as the image code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "utils_9276 fgetl.txt"
    },
    {
        "Branch": [
            "If-condition statement generated by training data network."
        ],
        "Loop": [
            "Loaded %lf seconds\n",
            "Image prediction using float_to_image function: image pred = float_to_image(64, 64, 1, out); print_image(pred);",
            "Image display using show_image function: image im = float_to_image(256, 256, 3, train.X.vals[0]); image lab = float_to_image(64, 64, 1, train.y.vals[0]); image pred = float_to_image(64, 64, 1, out); show_image(im, image); show_image(lab, label); print_image(lab); show_image(pred, pred); cvWaitKey(0);",
            "%d, %.3f: %f, %f avg, %f rate, %lf seconds, %d images\n"
        ],
        "Normal": [
            "Normal string statement generated by training data network.\n",
            "Learning Rate: %g, Momentum: %g, Decay: %g\n",
            "Number of iterations: %d\n"
        ],
        "FuncName": "writing_6071 train_writing.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check config for any special requests",
            "Load IFF image file",
            "Decode IFF image data",
            "Display IFF image"
        ],
        "FuncName": "iffinput_1126 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check config for any special requests",
            "Parse IFF image file, extract image width, height, pixel channel, pixel bit depth, position info, full width, full height, sub-image info"
        ],
        "FuncName": "iffinput_1126 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "verbatim",
                    "decode RLE compressed channel data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "information.",
                    "find runs",
                    "image data"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "iffinput_1126 uncompress_rle_channel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read IFF image data, decompress and store in buffer.",
                    "get tile coordinates.",
                    "get tile width/height",
                    "get image size",
                    "skip coordinates, uint16_t (2) * 4 = 8",
                    "check tile",
                    "tile compress",
                    "if tile compression fails to be less than image data stored",
                    "uncompressed the tile is written uncompressed",
                    "set channels",
                    "set tile size",
                    "test if compressed",
                    "we use the non aligned size",
                    "handle 8-bit data.",
                    "handle 16-bit data.",
                    "tile"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read IFF image data, decompress and store in buffer.",
                    "set bytes.",
                    "set tile data",
                    "tile compress."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read IFF image data, decompress and store in buffer.",
                    "map BGR(A) to RGB(A)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "get image type and length.",
                    "check if RGBA"
                ]
            },
            {
                "loopstr": [
                    "uncompress and increment tile data.",
                    "set tile"
                ]
            },
            {
                "loopstr": [
                    "set tile"
                ]
            },
            {
                "loopstr": [
                    "read IFF image data, decompress and store in buffer.",
                    "map BGR(A) to RGB(A)"
                ]
            }
        ],
        "Normal": [
            "seek to image position.",
            "set position tile may be called randomly.",
            "resize buffer to accommodate image data.",
            "flip buffer to make read_native_tile easier.",
            "from tga.imageio:"
        ],
        "FuncName": "iffinput_1126 readimg.txt"
    },
    {
        "Branch": [
            "Write a bit to a bit stream.",
            "These strings are for image code."
        ],
        "Loop": [],
        "Normal": [
            "Write a bit to a bit stream. flush buffer if necessary"
        ],
        "FuncName": "bit_stream_kernel_1_4224 write.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "hue saturation: adjusting color balance",
            "brightness contrast: adjusting image brightness and contrast",
            "Channel mixer: combining image channels"
        ],
        "FuncName": "ColorsDialog_2921 ColorsDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "int lineElementStep = inputData->width * inputData->channelStep; This is an example of max pooling operation on an image, where the line element step is calculated based on the width and channel step of the input data."
        ],
        "FuncName": "facedetectcnn_3492 maxpooling2x2S2.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if we didn't read anything then return false, or in other words, if the image buffer is empty then return false"
                ]
            },
            {
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "get new byte if necessary from the image buffer",
            "put the most significant bit from the image buffer into the bit",
            "shift out the bit that was just read from the image buffer"
        ],
        "FuncName": "bit_stream_kernel_1_4224 read.txt"
    },
    {
        "Branch": [
            "Calculate the dot product of two arrays, where the arrays are represented by the input strings."
        ],
        "Loop": [
            ""
        ],
        "Normal": [
            "Calculate the dot product of two arrays, where the arrays are represented by the input strings, and the arrays are initialized with zeros."
        ],
        "FuncName": "facedetectcnn_3492 dotProductUint8Int8.txt"
    },
    {
        "Branch": [
            "align the pointer for if condition"
        ],
        "Loop": [
            "align the pointer for loop condition"
        ],
        "Normal": [
            "align the pointer"
        ],
        "FuncName": "facedetectcnn_3492 myAlloc.txt"
    },
    {
        "Branch": [
            "#pragma omp if (condition)"
        ],
        "Loop": [
            "#pragma omp for (condition)"
        ],
        "Normal": [
            "#pragma omp parallel for",
            "#pragma omp parallel for (with image processing)"
        ],
        "FuncName": "facedetectcnn_3492 softmax1vector2class.txt"
    },
    {
        "Branch": [
            "Pointer must be aligned by _MALLOC_ALIGN",
            "Free a block of memory allocated by malloc."
        ],
        "Loop": [],
        "Normal": [
            "Pointer must be aligned by _MALLOC_ALIGN",
            "Free a block of memory allocated by malloc."
        ],
        "FuncName": "facedetectcnn_3492 myFree_.txt"
    },
    {
        "Branch": [
            "check if condition is met and then apply convolution"
        ],
        "Loop": [
            "check loop condition and apply convolution if true"
        ],
        "Normal": [
            "check filters' dimensions and calculate the output dimension",
            "calculate the output dimension based on filters' dimensions"
        ],
        "FuncName": "facedetectcnn_3492 convolution.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "priorbox",
                    "Extracting prior box coordinates",
                    "Calculating multi-scale foreground box coordinates"
                ]
            },
            {
                "loopstr": [
                    "xmin",
                    "ymin",
                    "xmax",
                    "ymax",
                    "Calculating multi-scale foreground box coordinates for xmin",
                    "Calculating multi-scale foreground box coordinates for ymin",
                    "Calculating multi-scale foreground box coordinates for xmax",
                    "Calculating multi-scale foreground box coordinates for ymax"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "facedetectcnn_3492 priorbox.txt"
    },
    {
        "Branch": [
            "Check if the input number is less than or equal to -1.2",
            "Check if the input number is less than or equal to -0.5",
            "Check if the input number is less than or equal to 0",
            "Check if the input number is less than or equal to 0.5",
            "Check if the input number is less than or equal to 1.2"
        ],
        "Loop": [],
        "Normal": [
            " num <= -1.2 image: a number less than -1.2",
            " num <= -0.5 image: a number less than or equal to -0.5",
            " num <= 0 image: a number less than or equal to 0",
            " num <= 0.5 image: a number less than or equal to 0.5",
            " num <= 1.2 image: a number less than or equal to 1.2"
        ],
        "FuncName": "rand_9425 test_normal_numbers.txt"
    },
    {
        "Branch": [
            "Testing the accuracy of Gaussian random hash function for image codes.",
            "Verifying the correctness of image code-related conditional statements.",
            "Evaluating the precision of image code-based decision-making processes."
        ],
        "Loop": [
            "Iterating through image code-related conditional statements to ensure accuracy.",
            "Repeating image code-based decision-making processes to verify precision.",
            "Looping through image code-related tests to confirm correctness."
        ],
        "Normal": [
            " num <= -1.2: Image code-related values are outside the acceptable range.",
            " num <= -0.5 : Image code-based decisions may be affected by outlier values.",
            " num <= 0: Image code-related metrics are within the expected range.",
            " num <= 0.5 : Image code-based predictions are likely to be accurate.",
            " num <= 1.2: Image code-related results are consistent with expected outcomes."
        ],
        "FuncName": "rand_9425 test_gaussian_random_hash.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Return [0, 0, 0, 0] if there is no intersection between two bounding boxes."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "facedetectcnn_3492 IntersectBBox.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Avoid divide by zero for 0x0 images",
                    "Compare the two images pixel by pixel to detect differences.",
                    "Analyze the visual differences between the two images.",
                    "Print the report of differences found."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "diff_7992 do_action_diff.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Thread initialization and testing"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "threads_2803 thread.txt"
    },
    {
        "Branch": [
            " ensure the random number generator produces uniformly distributed integers",
            " verify if the get_integer function generates random integers with no bias"
        ],
        "Loop": [
            " check if the loop iterates over the expected range of random integers",
            " confirm the loop condition is met for all possible random integer values"
        ],
        "Normal": [
            " make sure there isn't any funny bias in the random number generator",
            " output the ratio of big_val to small_val to the console"
        ],
        "FuncName": "rand_9425 test_get_integer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "std::unordered_map::operator[](const Key& key) will add the key to the map if it doesn't exist, which is not thread safe for image processing. This isn't what is intended. Instead, just do the lookup and return the value or a nullptr.",
            "In the context of image processing, this operation can lead to unexpected results. It's recommended to use a thread-safe approach.",
            "",
            "return primary_platforms[platform];"
        ],
        "FuncName": "icc_5184 icc_primary_platform_name.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "std::unordered_map::operator[](const Key& key) will add the key to the map if it doesn't exist. This isn't what is intended and isn't thread safe. This behavior is related to image processing where adding a key to a map can be analogous to adding a pixel to an image.",
            "Instead, just do the lookup and return the value or a nullptr. This approach is similar to image loading where you look up a pixel's value rather than adding a new one.",
            "",
            "return device_class_names[device_class];"
        ],
        "FuncName": "icc_5184 icc_device_class_name.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "clang-format off",
            "clang-format on",
            "std::unordered_map::operator[](const Key& key) will add the key to the map if",
            "it doesn't exist. This isn't what is intended and isn't thread safe.",
            "Instead, just do the lookup and return the value or a nullptr.",
            "",
            "return color_space_names[color_space];",
            "Color space name: RGB"
        ],
        "FuncName": "icc_5184 icc_color_space_name.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "For text, the first 4 bytes are text, the next 4 are 0, then",
                    "byte 8-end are the zero-terminated string itself.",
                    "This string is related to an ICC image profile."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "I don't see this in the spec, but I've seen it in practice:",
                    "first 4 bytes are desc, next 8 are unknown, then 12-end are",
                    "zero-terminated string itself.",
                    "This string is related to an ICC image profile."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Multi-localized unicode text.  First 4 bytes are mluc, next 4",
                    "are 0, next 4 are the number of records, then 12-end are the",
                    "12-byte records which each consist of a 2-byte language code,",
                    "2-byte country code, 4-byte length of the string (in bytes) and",
                    "4-byte offset (from the tag start, not from the ICC start!) to",
                    "a zero-terminated big endian utf-16 string. We're just going to",
                    "grab the english language version for now.",
                    "we already read the mluc",
                    "skip zero bytes.",
                    "This string is related to an ICC image profile."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "English",
                    "Strutil::print(",
                    "    eng len={} stfoffset={} ({:x}) wcharsize={}\\n\\, len,",
                    "    stroffset, tag.offset + stroffset, sizeof(wchar_t));",
                    "The actual data is UTF-16.",
                    "This string is related to an ICC image profile."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Strutil::print(\\   tag {} type {} offset {} size {}\\n\\, signature,",
                    "                typesignature, tag.offset, tag.size);",
                    "This string is related to an ICC image profile."
                ]
            }
        ],
        "Normal": [
            "spec.attribute(ICCProfile:illuminant, header.illuminant);",
            "This string is related to an ICC image profile."
        ],
        "FuncName": "icc_5184 decode_icc_profile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "std::unordered_map::operator[](const Key& key) will add the key to the map if it doesn't exist. This isn't what is intended and isn't thread safe. ICC image tag related.",
            "Instead, just do the lookup and return the value or an empty string. ICC image tag related.",
            "ICC image tag related.",
            "return tagnames[tag]; ICC image tag related."
        ],
        "FuncName": "icc_5184 icc_tag_name.txt"
    },
    {
        "Branch": [
            "If the input matrix is not symmetric positive definite, the Cholesky decomposition will fail."
        ],
        "Loop": [
            "The loop will iterate until a non-spd matrix is found."
        ],
        "Normal": [
            "none of the matrices we should be passing in to test_cholesky() should be non-spd.",
            "now make us a non-spd matrix by introducing a negative eigenvalue."
        ],
        "FuncName": "matrix_chol_5049 test_cholesky.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "not loaded, thumbnail image",
                    "todo: recolor once in shrRes, thumbnail background"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "invalid thumb, thumbnail image",
                    "invalid thumb, thumbnail background"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "thumbnailwidget_1045 paint.txt"
    },
    {
        "Branch": [
            "Draw text on image with conditional statement: if [condition] then [text]"
        ],
        "Loop": [
            "Draw text on image with loop condition: loop [condition] and draw [text]"
        ],
        "Normal": [
            "Draw text on image with filename: filename"
        ],
        "FuncName": "thumbnailwidget_1045 drawSingleLineText.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "2px pen. Highlighting a rectangle with a 1px pen by calling painter->drawRect(highlightRect.adjusted(0.5,0.5,-0.5,-0.5)).",
                    "painter->drawRect(highlightRect.adjusted(0.5,0.5,-0.5,-0.5)); // 1px pen"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "thumbnailwidget_1045 drawHighlight.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "save thumbnail preview on hover"
        ],
        "FuncName": "thumbnailwidget_1045 drawDropHover.txt"
    },
    {
        "Branch": [
            "Write a slice from the image buffer."
        ],
        "Loop": [],
        "Normal": [
            "Emulate tiles by buffering the whole image. Write a slice from the image buffer."
        ],
        "FuncName": "rlaoutput_3313 write_tile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "dpr-adjusted size, image display size"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "thumbnailwidget_1045 updateThumbnailDrawPosition.txt"
    },
    {
        "Branch": [
            "If the scanline is not empty, write it to the RLA file."
        ],
        "Loop": [
            "For each scanline in the image."
        ],
        "Normal": [
            " store the offset to the scanline.  We will use this to write the scanline to the RLA file.",
            " when we go to actually write it, we will use the stored offset to determine the correct position in the file."
        ],
        "FuncName": "rlaoutput_3313 write_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Asked for more MIP levels than were available. This may require image resampling or interpolation, which can affect image quality or resolution."
                ]
            }
        ],
        "Normal": [
            "We only make one subimage. This may be due to the original image not having multiple levels of detail.",
            "Asked for MIP levels but we aren't making them. This may be because the image does not support level of detail or the requested levels are not available."
        ],
        "FuncName": "nullimageio_7521 seek_subimage.txt"
    },
    {
        "Branch": [
            "Support image condition based on pixel values"
        ],
        "Loop": [
            "Support image loop based on pixel values"
        ],
        "Normal": [
            "Support nothing else non standard, with image processing capabilities"
        ],
        "FuncName": "rlaoutput_3313 supports.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "accommodate first 3 channels of the same type as colour ones",
                    "limit to 3 in case the loop went further",
                    "if we have anything left and it looks like alpha, treat it as alpha",
                    "and if there's something more left, put it in auxiliary",
                    "RLA file open function is used to open RLA file, check file properties, and write RLA header information"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "if we have at least 3 channels, treat them as colour",
                    "RLA file open function is used to open RLA file, check file properties, and write RLA header information"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "FIXME -- the RLA format supports subimages, but our writer doesn't.",
            "I'm not sure if it's worth worrying about for an old format that is so",
            "rarely used.  We'll come back to it if anybody actually encounters a",
            "multisubimage RLA in the wild.",
            "prepare and write the RLA header",
            "frame and window coordinates",
            "figure out what's going on with the channels",
            "std::cout << \\color chans \\ << m_rla.NumOfColorChannels << \\ a \\",
            "           << m_rla.NumOfMatteChannels << \\ z \\ << m_rla.NumOfAuxChannels << \\\\n\\;",
            "default NTSC chromaticities",
            "the month number will be replaced with the 3-letter abbreviation",
            "FIXME: it appears that Wavefront have defined a set of aspect names;",
            "I think it's safe not to care until someone complains",
            "RLAs are big-endian",
            "flip back the endianness to native",
            "write placeholder values - not all systems may expand the file with",
            "zeroes upon seek",
            "If user asked for tiles -- which this format doesn't support, emulate",
            "it by buffering the whole image.",
            "RLA file open function is used to open RLA file, check file properties, and write RLA header information"
        ],
        "FuncName": "rlaoutput_3313 open.txt"
    },
    {
        "Branch": [
            "Create image using image code.",
            "Send the created image."
        ],
        "Loop": [],
        "Normal": [
            "QElapsedTimer t;",
            "t.start();",
            "qDebug() << L: << t.elapsed();",
            "Image processing using image code.",
            "Image sent successfully."
        ],
        "FuncName": "loaderrunnable_9939 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5df2\u7ecf\u5173\u95ed\uff0c\u626b\u63cf\u7ebf\u504f\u79fb\u8868\u5199\u5165\u5b8c\u6210"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5904\u7406\u74f7\u7816\u6a21\u62df\uff0c\u8f93\u51fa\u7f13\u51b2\u50cf\u7d20\u5230\u56fe\u50cf"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u6240\u6709\u626b\u63cf\u7ebf\u8f93\u51fa\u5b8c\u6210\uff0c\u5199\u5165\u626b\u63cf\u7ebf\u504f\u79fb\u8868\uff0c\u5173\u95ed\u6d41\uff0c\u91cd\u65b0\u521d\u59cb\u5316"
        ],
        "FuncName": "rlaoutput_3313 close.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If we didn't find a type name, try to guess. This might involve analyzing the image code to determine the type of data being processed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Surrounded by quotes? it's a string (strip off the quotes). In image processing, this might involve removing quotes from image file names or paths."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Looks like an int, is an int. In image processing, this might involve analyzing image pixel values or coordinates."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Looks like a float, is a float. In image processing, this might involve analyzing image pixel values or coordinates with decimal precision."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "optional. In image processing, this might involve iterating over image pixels or coordinates."
                ]
            },
            {
                "loopstr": [
                    "optional. In image processing, this might involve iterating over image pixels or coordinates."
                ]
            },
            {
                "loopstr": [
                    "optional. In image processing, this might involve iterating over image pixels or coordinates."
                ]
            }
        ],
        "Normal": [
            "start out unknown. In image processing, this might involve initializing image data or parameters.",
            "If the param string starts with a type name, that's what it is. In image processing, this might involve determining the type of image data being processed.",
            "If the value string starts with a type name, that's what it is. In image processing, this might involve analyzing image data to determine its type.",
            "Read the values and set the attribute. In image processing, this might involve reading image data and setting attributes such as pixel values or coordinates."
        ],
        "FuncName": "nullimageio_7521 parse_param.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Special case -- float data is just dumped raw, no RLE. This is related to image processing, where float data is a common data type for image pixels."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Need to do bit scaling. Safe to overwrite data in place. This is a common operation in image processing, where bit scaling is used to adjust the intensity of image pixels."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "beginning of a run. This is related to image compression, where a run is a sequence of identical pixels.",
                    "presumptive"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We've seen one or more repeating characters. This is related to image processing, where repeating characters can indicate a pattern or texture in the image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "another repeating value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If we didn't even have 3 in a row, just, this is related to image compression, where a sequence of three identical pixels can indicate a run.",
                    "retroactively treat it as a raw run."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "starting a repetition?  Output previous, this is related to image processing, where a repetition can indicate a pattern or texture in the image.",
                    "write everything but the last char"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "last value, this is related to image processing, where the last value can indicate the end of a run or a pattern.",
                    "count of raw or repeats, this is related to image compression, where the count of raw or repeats can indicate the complexity of the image.",
                    "if true, we're repeating, this is related to image processing, where repeating pixels can indicate a pattern or texture in the image.",
                    "where did the run begin, this is related to image compression, where the beginning of a run can indicate the start of a pattern or texture."
                ]
            },
            {
                "loopstr": [
                    "If the run is too long or we're at the scanline end, write, this is related to image processing, where the run length and scanline end can indicate the complexity of the image."
                ]
            }
        ],
        "Normal": [
            "reserve t bytes for the encoded size, this is related to image compression, where the encoded size can indicate the complexity of the image.",
            "multi-byte data types are sliced to MSB, nextSB, ..., LSB, this is related to image processing, where multi-byte data types can indicate the intensity of image pixels.",
            "Now that we know the size of the encoded buffer, save it at the, this is related to image compression, where the encoded buffer can indicate the complexity of the image.",
            "beginning, this is related to image processing, where the beginning of an image can indicate the start of a pattern or texture.",
            "And write the channel to the file, this is related to image processing, where the channel can indicate the intensity of image pixels."
        ],
        "FuncName": "rlaoutput_3313 encode_channel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "lookup image data"
        ],
        "FuncName": "avpcl_mode7_3779 decompress_mode7.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Quantizing RGB color endpoints according to the given precision mode and endpoint range in image code."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 quantize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "number of bits needed to represent n in binary, considering signed or unsigned"
        ],
        "FuncName": "avpcl_mode7_3779 nbits.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "trainer.be_verbose()",
                    "Image classification model using convolutional neural networks (CNNs) and transfer learning from pre-trained models such as VGG16 or ResNet50."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ranking_8066 train.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "Image type: swapping shape indices"
                ]
            },
            {
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the table",
                    "Image type: verifying shape indices"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make one relevant example.",
            "Now make a non-relevant example.",
            "trainer.be_verbose"
        ],
        "FuncName": "ranking_8066 test_dnn_ranking_loss.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "related to image color mapping"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "iterating through image pixels"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 map_colors.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale endpoints with vibrant colors",
            "really need a IntVec4 with pixel depth",
            "+1 since we are in a compressed image space",
            "interpolate between hues"
        ],
        "FuncName": "avpcl_mode7_3779 generate_palette_quantized.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "ignore the alpha channel in the count, compressing IntEndptsRGBA object"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 compress_one.txt"
    },
    {
        "Branch": [
            "build list of possibles for image"
        ],
        "Loop": [
            "iterate through image block"
        ],
        "Normal": [
            "build list of possibles for image"
        ],
        "FuncName": "avpcl_mode7_3779 assign_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "number of rough cases to look at. reasonable values of this are 1, 1/4 of the total shapes, and the total shapes",
            "1/4 of the total shapes gets nearly all the cases; you can increase that a bit (say by 3 or 4) if you really want to squeeze the last bit out of the image compression",
            "pick the best 1/4 of the shapes and refine these to get the optimal shape for image compression",
            "bubble sort -- only need to bubble up the first 1/4 of the items to get the optimal order for image compression"
        ],
        "FuncName": "avpcl_mode7_3779 compress_mode7.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least, with a color palette that matches the image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit to avoid color mismatch in the image"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 map_colors.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " (nreed) Commented out asserts because they go off all the time...not sure why",
                    "for (int i=0; i<NREGIONS; ++i)",
                    "\tnvAssert(expected_opt_err[i] == opt_err[i]);",
                    "This is an if condition statement in the image code, where the then branch contains code that checks for expected optimization errors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " apply a heuristic here -- we check if the endpoints fit before we try to optimize them.",
                    " the assumption made is that if they don't fit now, they won't fit after optimizing.",
                    "This is a loop condition statement in the image code, where the loop contains code that applies a heuristic to check if the endpoints fit before optimization."
                ]
            }
        ],
        "Normal": [
            "throw No candidate found, should never happen (mode avpcl 7).",
            "This is a normal string in the image code, where it throws an exception if no candidate is found, indicating an error in the optimization process."
        ],
        "FuncName": "avpcl_mode7_3779 refine.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u5982\u679c\u8fd9\u662f\u4e00\u79cd\u6539\u8fdb\uff0c\u79fb\u52a8\u7aef\u70b9\u5e76\u4ece\u90a3\u91cc\u7ee7\u7eed\u641c\u7d22"
                ]
            }
        ],
        "Normal": [
            "\u6211\u4eec\u6709\u65e7\u7684\u7aef\u70b9\uff1aold_endpts",
            "\u6211\u4eec\u6709\u6270\u4e71\u7684\u7aef\u70b9\uff1anew_endpts",
            "\u6211\u4eec\u6709\u4e34\u65f6\u7aef\u70b9\uff1atemp_endpts",
            "\u4ece\u5f53\u524d\u6700\u597d\u7684\u9519\u8bef\u5f00\u59cb",
            "\u590d\u5236\u771f\u5b9e\u7aef\u70b9\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u6270\u4e71\u5b83\u4eec",
            "\u5bf9\u8be5\u7aef\u70b9\u8fdb\u884c\u5bf9\u6570\u641c\u7d22\u4ee5\u627e\u5230\u6700\u4f73\u9519\u8bef\uff08\u54ea\u4e2a\uff09"
        ],
        "FuncName": "avpcl_mode7_3779 perturb_one.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do B next",
                    "Minimize color error by optimizing the next color value."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "start over",
                    "Minimize color error by restarting the optimization process."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "figure out which endpoint when perturbed gives the most improvement and start there",
                    "Minimize color error by identifying the most promising endpoint for perturbation.",
                    "perturb endpt A",
                    "Minimize color error by perturbing endpoint A.",
                    "perturb endpt B",
                    "Minimize color error by perturbing endpoint B.",
                    "now alternate endpoints and keep trying until there is no improvement",
                    "Minimize color error by alternating between endpoints until no further improvement is possible.",
                    "see if the indices have changed",
                    "Minimize color error by checking if the indices have changed.",
                    "start over",
                    "Minimize color error by restarting the loop."
                ]
            },
            {
                "loopstr": [
                    "now move the other endpoint",
                    "Minimize color error by moving the other endpoint."
                ]
            }
        ],
        "Normal": [
            "err0 = perturb(rgb0, delta0) err1 = perturb(rgb1, delta1) if (err0 < err1) if (err0 >= initial_error) break rgb0 += delta0 next = 1 else if (err1 >= initial_error) break rgb1 += delta1 next = 0 initial_err = map() for (;;) err = perturb(next ? rgb1:rgb0, delta) if (err >= initial_err) break next? rgb1 : rgb0 += delta initial_err = err ",
            "Minimize color error by optimizing each color channel separately.",
            "for the first error improvement, we save the indices. then, for any later improvement, we compare the indices",
            "Minimize color error by saving and comparing indices for the first and later improvements.",
            "if they differ, we restart the loop (which then falls back to looking for a first improvement.)",
            "Minimize color error by restarting the loop if indices differ.",
            "finally, do a small exhaustive search around what we think is the global minima to be sure",
            "Minimize color error by performing a small exhaustive search around the global minimum.",
            "note this is independent of the above search, so we don't care about the indices from the above",
            "Minimize color error by ignoring the indices from the previous search.",
            "we don't care about the above because if they differ, so what? we've already started at ch=0",
            "Minimize color error by ignoring the previous search results."
        ],
        "FuncName": "avpcl_mode7_3779 optimize_one.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " handle simple cases by computing color equations for each region",
                    " project each pixel value along the principal direction of the color equation",
                    " choose as endpoints 2 points along the principal direction that span the projections of all of the pixel values",
                    " clamp endpoints to ensure the color equation is well-defined",
                    " the argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best shape based on endpoints being clamped",
                    " in the context of color equations, this shape is related to the image type and its characteristics"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 rough.txt"
    },
    {
        "Branch": [
            "Optimize the final endpoint by computing the optimal endpoint and minimum error for image processing."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Collect pixels in the region to improve image quality.",
                    "Explore all least significant bit (LSB) modes to find better endpoints for image enhancement."
                ]
            },
            {
                "loopstr": [
                    "Ensure a valid error for temperature input (temp_in) to avoid inaccuracies.",
                    "Use FLT_MAX for accurate temperature input error calculation, no shortcuts.",
                    "Map colors to optimize endpoints, but stop if error exceeds the input value.",
                    "Attempt to optimize endpoints for better image processing.",
                    "Update the best endpoint and correct output endpoints and errors if an improvement is found."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode7_3779 optimize_endpts.txt"
    },
    {
        "Branch": [
            "Set window properties and connect signals for image code."
        ],
        "Loop": [],
        "Normal": [
            "force size recalculation for image rendering."
        ],
        "FuncName": "fvoptionspopup_3906 FVOptionsPopup.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Quickly swap 16 pixels of BGRA8 image."
        ],
        "FuncName": "image_2519 imageSwizzleBgra8.txt"
    },
    {
        "Branch": [
            "Sorting boxes based on image codes..."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Processing image code %s...\n"
                ]
            }
        ],
        "Normal": [
            "list *plist = get_paths(data/compare.val.old);",
            "Sorting boxes with image codes...\n",
            "Sorted in %d compares, %f secs\n"
        ],
        "FuncName": "compare_5784 SortMaster3000.txt"
    },
    {
        "Branch": [
            "image verification accuracy: %f"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loaded: %d images in %lf seconds\n",
                    "Verifying image %d: Acc: %f, %lf seconds, %d images\n"
                ]
            }
        ],
        "Normal": [
            "verifying image paths: list *plist = get_paths(\"data/compare.val.old\");"
        ],
        "FuncName": "compare_5784 validate_compare.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "char *filename = (argc > 5) ? argv[5] : 0; // filename is set based on command-line argument",
            " else if(0 == strcmp(argv[2], \"train\")) train_coco(cfg, weights); // train model with coco config and weights",
            " else if(0 == strcmp(argv[2], \"extract\")) extract_boxes(cfg, weights); // extract boxes from images using coco config and weights",
            " else if(0 == strcmp(argv[2], \"valid\")) validate_recall(cfg, weights); // validate model recall with coco config and weights"
        ],
        "FuncName": "compare_5784 run_compare.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Camera calibration parameters: focal length, principal point, distortion coefficients. The parameters are set as follows: K3, K4, K5 are fixed."
        ],
        "FuncName": "IPLCameraCalibration_7842 runCalibration.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Round: %d\n",
                    "Round: %f secs, %d remaining\n",
                    "Image: boxes are being battled in a tournament with a given network configuration and weights.\n"
                ]
            }
        ],
        "Normal": [
            "list *plist = get_paths(data/compare.small.list);",
            "list *plist = get_paths(data/compare.cat.list);",
            "list *plist = get_paths(data/compare.val.old);",
            "Battling %d boxes in a tournament with a given network configuration and weights...\n",
            "Tournament in %d compares, %f secs, with boxes being battled\n"
        ],
        "FuncName": "compare_5784 BattleRoyaleWithCheese.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "try without the one",
                    "Image: A condition that needs to be evaluated before proceeding."
                ]
            },
            {
                "loopstr": [
                    "try without the one",
                    "Image: A condition that needs to be evaluated before proceeding."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "chance_4116 build_table.txt"
    },
    {
        "Branch": [
            "camera calibration process starts",
            "image processing algorithm initialized"
        ],
        "Loop": [
            "looping through calibration frames",
            "adjusting camera parameters"
        ],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "camera calibration in progress",
            "adjusting image processing parameters",
            "optimizing camera settings"
        ],
        "FuncName": "IPLCameraCalibration_7842 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ETC2 3-modes: A compression mode that supports 3 different compression algorithms.",
                    "ETC1: A compression mode that supports 1 compression algorithm."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_2519 decodeBlockEtc12.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Etc2 3-modes",
                    "Etc1",
                    "BC6H block decoded to floating-point value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "partial cube map is not supported.",
                    "BC6H block decoding failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Failed to convert, just make ugly red-yellow checkerboard texture.",
                    "BC6H block decoding failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Put image data into an astcenc_image",
                    "BC6H block decoded to floating-point value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "pixelFormatSize",
                    "BC6H block decoded to floating-point value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "dims",
                    "miscFlags",
                    "arraySize",
                    "miscFlags2",
                    "BC6H block decoded to floating-point value"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "offset;",
                    "BC6H block decoded to floating-point value"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_2519 decodeBlockBc6h.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Etc2 3-modes: image decoding",
                    "Etc1: image decoding"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "partial cube map is not supported: image decoding failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Failed to convert, just make ugly red-yellow checkerboard texture: image decoding failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Put image data into an astcenc_image: image encoding"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "pixelFormatSize: image metadata"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "dims: image dimensions",
                    "miscFlags: image flags",
                    "arraySize: image array size",
                    "miscFlags2: image flags 2"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "offset : image offset"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_2519 decodeBlockBc6h.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0       1       2       3       4       5       6       7",
            "7654321076543210765432107654321076543210765432107654321076543210",
            "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmyrrrrrgggggbbbbbxrrrrrgggggbbbbp",
            "^                               ^^              ^^             ^",
            "+-- modulation data             |+- B color     |+- A color    |",
            "                                 +-- B opaque    +-- A opaque   |",
            "                                           alpha punchthrough --+",
            "Image data encoded in PVC14A format, containing modulation data, B and A colors, and alpha transparency information."
        ],
        "FuncName": "image_2519 decodeBlockPtc14A.txt"
    },
    {
        "Branch": [
            "Image code: 0 1 2 3 4 5 6 7",
            "Image code: 7654321076543210765432107654321076543210765432107654321076543210",
            "Image code: .rrrrrrg.ggggggb...bb.bbbrrrrr.rgggggggbbbbbbrrrrrrgggggggbbbbbb",
            "Image code: ^                       ^                   ^",
            "Image code: +-- c0                  +-- cH              +-- cV"
        ],
        "Loop": [],
        "Normal": [
            "0 1 2 3 4 5 6 7",
            "7654321076543210765432107654321076543210765432107654321076543210",
            ".rrrrrrg.ggggggb...bb.bbbrrrrr.rgggggggbbbbbbrrrrrrgggggggbbbbbb",
            "^                       ^                   ^",
            "+-- c0                  +-- cH              +-- cV"
        ],
        "FuncName": "image_2519 decodeBlockEtc2ModePlanar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0 1 2 3 4 5 6 7 - ETC2 pattern data",
            "7654321076543210765432107654321076543210765432107654321076543210 - 16x4 block data",
            "...rr.ggggbbbbrrrrggggbbbbDD.Dmmmmmmmmmmmmmmmmllllllllllllllll - Color and depth data",
            "^            ^           ^   ^               ^ - Block boundaries",
            "+-- c0       +-- c1      |   +-- msb         +-- lsb - Coordinate and bit data",
            "+-- dist - Distance data"
        ],
        "FuncName": "image_2519 decodeBlockEtc2ModeT.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0       1       2       3       4       5       6       7",
            "7654321076543210765432107654321076543210765432107654321076543210",
            ".rrrrggg...gb.bbbrrrrggggbbbbD.Dmmmmmmmmmmmmmmmmllllllllllllllll",
            "^               ^           ^  ^               ^",
            "+-- c0          +-- c1      |  +-- msb         +-- lsb",
            "+-- dist",
            "Etc2 Mode H-Block Data Decoder"
        ],
        "FuncName": "image_2519 decodeBlockEtc2ModeH.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "skip meta garbage... image data follows"
        ],
        "FuncName": "image_2519 imageParseKtx.txt"
    },
    {
        "Branch": [
            "Conditional jump to label if image container is valid"
        ],
        "Loop": [
            "Loop through image container until end is reached"
        ],
        "Normal": [
            " skip meta garbage",
            "Parse image container headers",
            "Read image data from container"
        ],
        "FuncName": "image_2519 imageParseKtx.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "0 - linearRGB, 1 - sRGB, PVR3 image container parsing",
            "skip meta garbage, image metadata extracted"
        ],
        "FuncName": "image_2519 imageParsePvr3.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Decode image data into RGBA8 format using astcenc_image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_2519 imageDecodeToRgba8.txt"
    },
    {
        "Branch": [
            "If-Condition: Image type - linearRGB or sRGB"
        ],
        "Loop": [
            "Loop-Condition: Checking image container"
        ],
        "Normal": [
            "Normal-Description: PVR3 image container contains 0 - linearRGB, 1 - sRGB",
            "Normal-Description: Skip meta garbage to extract meaningful data"
        ],
        "FuncName": "image_2519 imageParsePvr3.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Failed to convert, just make ugly red-yellow checkerboard texture. The image decoding process failed, resulting in a distorted BGRA8 image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_2519 imageDecodeToBgra8.txt"
    },
    {
        "Branch": [
            "Write EXR image to writer."
        ],
        "Loop": [
            {
                "loopstr": [
                    "offset. This is a description of the offset in EXR image writing."
                ]
            }
        ],
        "Normal": [
            "Order is always ABGR order because Photoshop and GIMP ignore these fields and assume it's in ABGR order. This is a description of the color order in EXR image writing.",
            "no compression. This is a description of the compression type in EXR image writing."
        ],
        "FuncName": "image_2519 imageWriteExr.txt"
    },
    {
        "Branch": [
            "Check if the condition is met, then execute the code inside the if block."
        ],
        "Loop": [
            "Loop through the array and check the condition at each iteration."
        ],
        "Normal": [
            " make sure gl contains at least one letter",
            "This string should be related to image processing, e.g., 'Ensure the image is loaded successfully.'"
        ],
        "FuncName": "fonts_3855 bdf_font.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "font size and offset values are calculated and adjusted"
                ]
            }
        ],
        "Normal": [
            "font size and offset values are calculated and adjusted for image code"
        ],
        "FuncName": "fonts_3855 adjust_metrics.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Implement this when reading meta box in tracks is supported. This may involve parsing the image box to extract metadata such as resolution, frame rate, and color space."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Extract contained box bitstream and type. The image box may contain additional metadata such as image dimensions, pixel aspect ratio, and chroma subsampling information."
                ]
            }
        ],
        "Normal": [
            "First parse the box header. The box header typically contains information such as the box type, size, and flags.",
            "if there a data available in the file. The data may contain image data or metadata such as EXIF or XMP."
        ],
        "FuncName": "trackbox_1351 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Write box headers. This involves writing the box type, version, and flags to the BitStream.",
            "Write other boxes contained in the movie box. These boxes may include metadata, audio, or video streams.",
            "The TrackHeaderBox contains information about the audio or video track, such as the sample rate, bit depth, and channel layout.",
            "The MediaBox contains a reference to the track header box and other metadata."
        ],
        "FuncName": "trackbox_1351 writeBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u89e3\u6790\u5b57\u5f62\u7684\u4ee3\u7801\uff0c\u89e3\u6790\u7f16\u7801\u548c\u5b57\u5f62\u4fe1\u606f\uff0c\u63d0\u53d6\u4f4d\u56fe\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u89e3\u6790\u5b57\u5f62\u7684\u4ee3\u7801\uff0c\u89e3\u6790\u7f16\u7801\u548c\u5b57\u5f62\u4fe1\u606f\uff0c\u63d0\u53d6\u4f4d\u56fe\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u6ca1\u6709\u66f4\u591a\u7684\u5b57\u5f62",
                    "\u89e3\u6790\u9519\u8bef\uff1a\u9884\u671f\u7ed3\u675f\u7b26\u672a\u627e\u5230"
                ]
            },
            {
                "loopstr": [
                    "\u89e3\u6790\u9519\u8bef\uff1a\u9884\u671f\u7ed3\u675f\u7b26\u672a\u627e\u5230"
                ]
            },
            {
                "loopstr": [
                    "\u89e3\u6790\u9519\u8bef"
                ]
            }
        ],
        "Normal": [
            "\u89e3\u6790\u9519\u8bef\uff1a\u7f3a\u5c11\u6216\u4e0d\u671f\u671b\u7684\u5173\u952e\u5b57",
            "\u89e3\u6790\u9519\u8bef",
            "\u89e3\u6790\u9519\u8bef\uff1a\u7f3a\u5c11\u7684\u5173\u952e\u5b57"
        ],
        "FuncName": "fonts_3855 parse_glyph.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Pass if users set allowfailures and we are within that limit.",
                    "limit.",
                    "This is an image comparison function that outputs difference images and reports."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "When older Visual Studio is used, float values in scientific format are printed with three digit exponent. We change this behaviour to fit Linux way.",
                    "scientific format are printed with three digit exponent. We change this behaviour to fit Linux way.",
                    "This function compares two images and outputs their differences."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Clear diff image name so we only save the first non-matching subimage.",
                    "non-matching subimage.",
                    "This function outputs difference images and reports for two given images."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Avoid divide by zero for 0x0 images",
                    "Compare the two images.",
                    "",
                    "Print the report",
                    "",
                    "If the user requested that a difference image be output, do that. N.B. we only do this for the first subimage right now, because ImageBuf doesn't really know how to write subimages.",
                    "Avoid divide by zero for 0x0 images",
                    "Compare the two images.",
                    "",
                    "Print the report",
                    "",
                    "If the user requested that a difference image be output, do that. N.B. we only do this for the first subimage right now, because ImageBuf doesn't really know how to write subimages.",
                    "This function compares two images and outputs their differences in a report."
                ]
            }
        ],
        "Normal": [
            "Helpful for debugging to make sure that any crashes dump a stack trace.",
            "Create a private ImageCache so we can customize its cache size and instruct it store everything internally as floats.",
            "force a full diff, even for files tagged with the same fingerprint, just in case some mistake has been made.",
            "ImageSpec spec0 = img0.spec();  // stash it",
            "This function provides helpful information for debugging and customizes the image cache."
        ],
        "FuncName": "idiff_2946 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "parse error: invalid or missing header",
                    "Image parsing failed: invalid or missing header"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "neither width info for the glyph, nor for the font as a whole (monospace)",
                    "Image parsing failed: missing width info"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Bonding rectangle for the font.",
                    "We need to compute this after all the glyphs are loaded.",
                    "Set this to something valid now, just in case.",
                    "Save any global width in case we later read from the same file.",
                    "Don't override value specified in the constructor with value specified in the file",
                    "Generating image: bonding rectangle for the font"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "parse error",
                    "Image parsing failed: parse error"
                ]
            }
        ],
        "Normal": [
            "No glyphs found within the specified range.",
            "Default char not specified, trying to find a sane alternative."
        ],
        "FuncName": "fonts_3855 read_bdf_file.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "SOURCE BDF FILE (helvR12.bdf) COMMENTS COMMENT $XConsortium: helvR12.bdf,v 1.15 95/01/26 18:02:58 gildea Exp $ COMMENT $Id: helvR12.bdf,v 1.26 2004-11-28 20:08:46+00 mgk25 Rel $ COMMENT COMMENT + COMMENT Copyright 1984-1989, 1994 Adobe Systems Incorporated. COMMENT Copyright 1988, 1994 Digital Equipment Corporation. COMMENT COMMENT Adobe is a trademark of Adobe Systems Incorporated which may be COMMENT registered in certain jurisdictions. COMMENT Permission to use these trademarks is hereby granted only in COMMENT association with the images described in this file. COMMENT COMMENT Permission to use, copy, modify, distribute and sell this software COMMENT and its documentation for any purpose and without fee is hereby COMMENT granted, provided that the above copyright notices appear in all COMMENT copies and that both those copyright notices and this permission COMMENT notice appear in supporting documentation, and that the names of COMMENT Adobe Systems and Digital Equipment Corpo...",
            "Base64 encoded font data: SOURCE BDF FILE (helvR12.bdf) COMMENTS COMMENT $XConsortium: helvR12.bdf,v 1.15 95/01/26 18:02:58 gildea Exp $ COMMENT $Id: helvR12.bdf,v 1.26 2004-11-28 20:08:46+00 mgk25 Rel $ COMMENT COMMENT + COMMENT Copyright 1984-1989, 1994 Adobe Systems Incorporated. COMMENT Copyright 1988, 1994 Digital Equipment Corporation. COMMENT COMMENT Adobe is a trademark of Adobe Systems Incorporated which may be COMMENT registered in certain jurisdictions. COMMENT Permission to use these trademarks is hereby granted only in COMMENT association with the images described in this file. COMMENT COMMENT Permission to use, copy, modify, distribute and sell this software COMMENT and its documentation for any purpose and without fee is hereby COMMENT granted, provided that the above copyright notices appear in all COMMENT copies and that both those copyright notices and this permission COMMENT notice appear in supporting documentation, and that the names of COMMENT Adobe Systems and Digital Equipment Corpo...",
            "Font data stream: SOURCE BDF FILE (helvR12.bdf) COMMENTS COMMENT $XConsortium: helvR12.bdf,v 1.15 95/01/26 18:02:58 gildea Exp $ COMMENT $Id: helvR12.bdf,v 1.26 2004-11-28 20:08:46+00 mgk25 Rel $ COMMENT COMMENT + COMMENT Copyright 1984-1989, 1994 Adobe Systems Incorporated. COMMENT Copyright 1988, 1994 Digital Equipment Corporation. COMMENT COMMENT Adobe is a trademark of Adobe Systems Incorporated which may be COMMENT registered in certain jurisdictions. COMMENT Permission to use these trademarks is hereby granted only in COMMENT association with the images described in this file. COMMENT COMMENT Permission to use, copy, modify, distribute and sell this software COMMENT and its documentation for any purpose and without fee is hereby COMMENT granted, provided that the above copyright notices appear in all COMMENT copies and that both those copyright notices and this permission COMMENT notice appear in supporting documentation, and that the names of COMMENT Adobe Systems and Digital Equipment Corpo...",
            "Base64 decoded and decompressed font data: SOURCE BDF FILE (helvR12.bdf) COMMENTS COMMENT $XConsortium: helvR12.bdf,v 1.15 95/01/26 18:02:58 gildea Exp $ COMMENT $Id: helvR12.bdf,v 1.26 2004-11-28 20:08:46+00 mgk25 Rel $ COMMENT COMMENT + COMMENT Copyright 1984-1989, 1994 Adobe Systems Incorporated. COMMENT Copyright 1988, 1994 Digital Equipment Corporation. COMMENT COMMENT Adobe is a trademark of Adobe Systems Incorporated which may be COMMENT registered in certain jurisdictions. COMMENT Permission to use these trademarks is hereby granted only in COMMENT association with the images described in this file. COMMENT COMMENT Permission to use, copy, modify, distribute and sell this software COMMENT and its documentation for any purpose and without fee is hereby COMMENT granted, provided that the above copyright notices appear in all COMMENT copies and that both those copyright notices and this permission COMMENT notice appear in supporting documentation, and that the names of COMMENT Adobe Systems and Digital Equipment Corpo...",
            "Decoded and decompressed font data: SOURCE BDF FILE (helvR12.bdf) COMMENTS COMMENT $XConsortium: helvR12.bdf,v 1.15 95/01/26 18:02:58 gildea Exp $ COMMENT $Id: helvR12.bdf,v 1.26 2004-11-28 20:08:46+00 mgk25 Rel $ COMMENT COMMENT + COMMENT Copyright 1984-1989, 1994 Adobe Systems Incorporated. COMMENT Copyright 1988, 1994 Digital Equipment Corporation. COMMENT COMMENT Adobe is a trademark of Adobe Systems Incorporated which may be COMMENT registered in certain jurisdictions. COMMENT Permission to use these trademarks is hereby granted only in COMMENT association with the images described in this file. COMMENT COMMENT Permission to use, copy, modify, distribute and sell this software COMMENT and its documentation for any purpose and without fee is hereby COMMENT granted, provided that the above copyright notices appear in all COMMENT copies and that both those copyright notices and this permission COMMENT notice appear in supporting documentation, and that the names of COMMENT Adobe Systems and Digital Equipment Corpo..."
        ],
        "FuncName": "fonts_3855 get_decoded_string_with_default_font_data.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "parse error: invalid hex digit. This is an image of a warning sign."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "fonts_3855 bitmap_to_letter.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "parse_error: image parsing failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "parse_error: image parsing failed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "parse_error: image parsing failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "parse_error: image parsing error: unexpected EOF"
                ]
            }
        ],
        "Normal": [
            "parse_error: required keyword missing: image parsing failed",
            "parse_error: required keyword missing or unexpected keyword: image parsing failed"
        ],
        "FuncName": "fonts_3855 parse_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Outputting JPEG2000 image scan lines. These strings are for image code strings. JPEG-2000 specifically dictates unassociated (un-premultiplied) alpha"
        ],
        "FuncName": "jpeg2000output_3629 write_scanline.txt"
    },
    {
        "Branch": [
            "If the image has Exif/IPTC metadata, then we should support it",
            "Currently, we don't support Exif/IPTC metadata in images"
        ],
        "Loop": [],
        "Normal": [
            "we should support Exif/IPTC but currently don't",
            "Exif/IPTC metadata is not supported in images"
        ],
        "FuncName": "jpeg2000output_3629 supports.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If not uint8 or uint16, default to uint16. JPEG2000 file format supports various image compression modes, including lossless and lossy compression.",
            "If user asked for tiles -- which this format doesn't support, emulate it by buffering the whole image. This can be a time-consuming process for large images.",
            "This process involves opening the JPEG2000 output file, checking its format and pattern, and setting default format and pre-processing options. These options may include setting the color space, bit depth, and compression ratio."
        ],
        "FuncName": "jpeg2000output_3629 open.txt"
    },
    {
        "Branch": [
            "Cineon file header must be 768 bytes"
        ],
        "Loop": [
            "Cineon file header must be 768 bytes",
            "image header must be 640 bytes",
            "orientation header must be 256 bytes"
        ],
        "Normal": [
            "genericSize is the size of the file/image/orientation headers",
            "sizeof(cineon::GenericHeader) won't give the correct results because of compiler padding",
            "Cineon file header is 768 bytes",
            "Cineon image header is 640 bytes",
            "Cineon orientation header is 256 bytes",
            "industrySize is the size of the motion picture/television headers",
            "Cineon motion picture header is 256 bytes",
            "Cineon television header is 128 bytes",
            "data size checks"
        ],
        "FuncName": "CineonHeader_6908 Check.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6587\u4ef6\u4fe1\u606f\uff0c\u5305\u542b\u56fe\u50cf\u4fe1\u606f\uff0c\u56fe\u50cf\u8d77\u6e90\u4fe1\u606f\uff0c\u8fd0\u52a8\u753b\u50cf\u884c\u4e1a\u7279\u5b9a\u63cf\u8ff0",
                    "\u56fe\u50cf\u4fe1\u606f\uff0c\u5305\u542b\u56fe\u50cf\u8d77\u6e90\u4fe1\u606f\uff0c\u8fd0\u52a8\u753b\u50cf\u884c\u4e1a\u7279\u5b9a\u63cf\u8ff0",
                    "\u56fe\u50cf\u8d77\u6e90\u4fe1\u606f\uff0c\u5305\u542b\u8fd0\u52a8\u753b\u50cf\u884c\u4e1a\u7279\u5b9a\u63cf\u8ff0",
                    "\u8fd0\u52a8\u753b\u50cf\u884c\u4e1a\u7279\u5b9a\u63cf\u8ff0"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u68c0\u67e5\u9b54\u672fcookie\uff0c\u786e\u4fddCineon\u6587\u4ef6\u5934\u6709\u6548",
            "\u5224\u65ad\u5b57\u8282\u662f\u5426\u9700\u8981\u4ea4\u6362\uff0c\u786e\u4fddCineon\u6587\u4ef6\u5934\u6709\u6548"
        ],
        "FuncName": "CineonHeader_6908 Validate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Rewind the file and read in the Cineon header.",
            "Read in the Cineon header from the file and validate its contents.",
            "Validate the Cineon header."
        ],
        "FuncName": "CineonHeader_6908 Read.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "File Information, related to image files.",
            "genericSize is the size of the file/image/orientation headers, relevant to image data.",
            "sizeof(cineon::GenericHeader) won't give the correct results because of compiler padding, affecting image file sizes.",
            "industrySize is the size of the motion picture/television headers, related to image content.",
            "Image Information, describing image characteristics.",
            "Image Orientation, explaining image rotation and positioning."
        ],
        "FuncName": "CineonHeader_6908 Reset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "See associateAlpha for an explanation of alpha channel in image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "jpeg2000output_3629 deassociateAlpha.txt"
    },
    {
        "Branch": [
            "Emulate tiles by buffering the whole image and then slicing it"
        ],
        "Loop": [
            "Slice the image buffer and then emulate tiles"
        ],
        "Normal": [
            "Emulate tiles by buffering the whole image and then slicing it"
        ],
        "FuncName": "jpeg2000output_3629 write_tile.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " +1 since we are in uncompressed space, with image pixel values ranging from 0 to 255"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 quantize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "JPEG-2000 specifically dictates unassociated (un-premultiplied) alpha. The JPEG 2000 image coding system uses a wavelet transform to compress the image data, which allows for efficient compression of both spatial and frequency domain information. This results in a compact representation of the image, making it suitable for various applications."
        ],
        "FuncName": "jpeg2000output_3629 write_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "bpp field is deprecated starting with OpenJPEG 2.5. JPEG 2000 image decoding and encoding component is initialized."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "jpeg2000output_3629 init_components.txt"
    },
    {
        "Branch": [
            "no bits needed for 0, signed or not, binary representation of 0 is 0"
        ],
        "Loop": [],
        "Normal": [
            "no bits needed for 0, signed or not, binary representation of 0 is 0"
        ],
        "FuncName": "avpcl_mode0_8298 nbits.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "FIXME: I seem to get crashes with OpenJpeg 2.x in the presence of ICC profiles.",
            "I have no idea why. It seems like losing the ability to write ICC profiles is the lesser evil compared to either restricting ourselves to OpenJpeg 1.5 or living with crashes.",
            "I'm at the limit of my knowledge of OpenJPEG, which frankly has a poor API and abysmal documentation.",
            "So I'll leave the repair of this for later. If somebody comes along that desperately needs JPEG2000 and ICC profiles, maybe they will be motivated enough to track down the problem.",
            "JPEG 2000 is a compressed image format that allows for lossy and lossless compression.",
            "It is designed to provide improved compression efficiency and scalability compared to JPEG.",
            "JPEG 2000 supports a wide range of applications, including still image compression, video compression, and data compression."
        ],
        "FuncName": "jpeg2000output_3629 create_jpeg2000_image.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale endpoints to generate a quantitative color palette",
            "require a 4-dimensional integer vector",
            "+1 since we are in uncompressed space to accommodate image data",
            "interpolate between color values",
            "interpolate between color values",
            "interpolate between color values",
            "apply constant alpha channel"
        ],
        "FuncName": "avpcl_mode0_8298 generate_palette_quantized.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "image code: swap endpts and indices"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the table",
                    "image code: loop through table"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 swap_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Already closed. JPEG 2000 output stream closed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We've been emulating tiles; now dump as scanlines. JPEG 2000 output stream closed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "jpeg2000output_3629 close.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set up multithread in OpenJPEG library -- added in OpenJPEG 2.2, but it doesn't seem reliably safe until 2.4. opj_stream_set_user_data_length(m_stream, ioproxy()->size()); Image data is being processed and saved."
        ],
        "FuncName": "jpeg2000output_3629 save_image.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "related to image processing, e.g., color mapping"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "iterative process, similar to image processing algorithms"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 map_colors.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "handle simple cases",
                    "project each pixel value along the principal direction",
                    "choose as endpoints 2 points along the principal direction that span the projections of all of the pixel values",
                    "clamp endpoints for color roughness analysis",
                    "the argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best",
                    "shape based on endpoints being clamped for image processing"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 rough.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "collect the pixels in the region",
                    "image processing involves collecting pixels in a region for analysis"
                ]
            },
            {
                "loopstr": [
                    "make sure we have a valid error for temp_in",
                    "image processing error: temp_in error must be valid",
                    "we use FLT_MAX here because we want an accurate temp_in_err, no shortcuts",
                    "image processing optimization: using FLT_MAX for accurate temp_in_err",
                    "mapcolors will compute a mapping but will stop if the error exceeds the value passed in the FLT_MAX position",
                    "image processing: mapcolors will stop if error exceeds FLT_MAX",
                    "now try to optimize these endpoints",
                    "image processing optimization: optimizing endpoints for improved accuracy",
                    "if we find an improvement, update the best so far and correct the output endpoints and errors",
                    "image processing: updating endpoints and errors for improved accuracy"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 optimize_endpts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " (nreed) Commented out asserts because they go off all the time...not sure why. Pixel block boundaries require precise optimization.",
                    "for (int i=0; i<NREGIONS; ++i)",
                    "\tnvAssert(expected_opt_err[i] == opt_err[i]) and pixel block edges are correctly aligned."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " apply a heuristic here -- we check if the endpoints fit before we try to optimize them. Pixel block boundaries need to be carefully optimized to reduce errors.",
                    " the assumption made is that if they don't fit now, they won't fit after optimizing. Pixel block edges must be precisely aligned for accurate results."
                ]
            }
        ],
        "Normal": [
            "throw No candidate found, should never happen (mode avpcl 0). Pixel block boundaries are not correctly optimized."
        ],
        "FuncName": "avpcl_mode0_8298 refine.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "perform action B next"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "restart the process"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "determine which endpoint yields the most improvement when perturbed and start there",
                    "alternating between endpoints may lead to a local minimum",
                    "perturb endpoint A",
                    "perturb endpoint B",
                    "alternate endpoints and continue until no further improvement is found",
                    "check if the indices have changed",
                    "restart the process"
                ]
            },
            {
                "loopstr": [
                    "move the other endpoint"
                ]
            }
        ],
        "Normal": [
            "calculate error0 by perturbing rgb0 with delta0, and error1 by perturbing rgb1 with delta1. if error0 is less than error1, if error0 is greater than or equal to the initial error, break the loop and increment rgb0 by delta0. otherwise, if error1 is greater than or equal to the initial error, break the loop and increment rgb1 by delta1. set next to 1. otherwise, set initial_err to the current error and continue. if the current error is greater than or equal to the initial error, break the loop. otherwise, increment the appropriate rgb by delta and set initial_err to the current error",
            "optimize each color channel separately",
            "for the first improvement, save the indices. for any later improvement, compare the indices. if they differ, restart the loop and fall back to the first improvement. finally, perform a small exhaustive search around the global minimum to confirm",
            "this search is independent of the previous one, so we don't care about the indices from the previous search",
            "we don't care about the previous search because if the indices differ, so what? we've already started at channel 0",
            "perform a small exhaustive search around the global minimum to confirm"
        ],
        "FuncName": "avpcl_mode0_8298 optimize_one.txt"
    },
    {
        "Branch": [
            "lookup"
        ],
        "Loop": [
            "lookup"
        ],
        "Normal": [
            "\u89e3\u538b\u6a21\u5f0f0\uff0c\u8bfb\u53d6\u6a21\u5f0f\u5934\uff0c\u89e3\u538b\u56fe\u50cf\uff0c\u586b\u5145\u89e3\u538b\u540e\u7684\u56fe\u50cf\u6570\u636e\u5230Tile\u4e2d"
        ],
        "FuncName": "avpcl_mode0_8298 decompress_mode0.txt"
    },
    {
        "Branch": [
            "select index with minimal color error"
        ],
        "Loop": [
            "select index with minimal color error"
        ],
        "Normal": [
            "build list of possibles, select index with minimal color error"
        ],
        "FuncName": "avpcl_mode0_8298 assign_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "This is a conditional statement with an image of a green light indicating a true condition."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "This is a loop condition with an image of a circular arrow indicating continuous iteration."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode0_8298 map_colors.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: capture video frames to get images"
        ],
        "FuncName": "video_7423 getPixmap.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Create an unquantized weight grid for this decimation level",
                    "For each weight, compute the previous, current, and next errors to adjust the weight value",
                    "Prepare iteration for plane 2"
                ]
            },
            {
                "loopstr": [
                    "Compute the endpoint delta for all components in the current plane, taking into account the image type"
                ]
            },
            {
                "loopstr": [
                    "Interpolate colors to create differences, and check if the previous or next error is better and use it accordingly"
                ]
            },
            {
                "loopstr": [
                    "Ideally this is integer rounded but IQ gain it isn't worth the overhead",
                    "Calculate the weight value by adding the base weight and half of the quantization error",
                    "Calculate the down and up weights by adding the base weight, half of the quantization error, and the difference in the weight grid"
                ]
            }
        ],
        "Normal": [
            "Get the partition descriptor, taking into account the image type",
            "Get the quantization table, relevant to the image type",
            "Get the decimation table, specific to the image type",
            "Decode the color endpoints, considering the image type",
            "For each plane and partition, perform the necessary operations, taking into account the image type"
        ],
        "FuncName": "astcenc_compress_symbolic_5972 realign_weights_decimated.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Encode as FP16 if using HDR ( Floating Point 16-bit )",
                    "Encode as UNORM16 if NOT using HDR ( Unsigned Normalized 16-bit )"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "WARN: At least one block failed to find a valid encoding.\\n\\n\\t\\t\\t             Try increasing compression quality settings.\\n\\n"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Record the quant level so we can use the filter later searches (Quantization Level Filtering)"
                ]
            },
            {
                "loopstr": [
                    "If attempting two planes is much worse than the best one plane result, then further two plane searches are unlikely to help so move on (Two Plane Search Optimization)"
                ]
            },
            {
                "loopstr": [
                    "If using N partitions doesn't improve much over using N-1 partitions then skip trying N+1 (Partition Skipping)"
                ]
            },
            {
                "loopstr": [
                    "If using N partitions doesn't improve much over using N-1 partitions then skip trying, N+1. Error can dramatically improve if the data is correlated or non-correlated and, aligns with a partitioning that suits that encoding, so for this inner loop check add, a large error scale because the other trial could be a lot better (Error Correlation Partitioning)"
                ]
            }
        ],
        "Normal": [
            "Set stricter block targets for luminance data as we have more bits to play with (Luminance Block Targeting)",
            "Set slightly stricter block targets for lumalpha data as we have more bits to play with (Lumalpha Block Targeting)",
            "Do this early in diagnostic builds so we can dump uniform metrics, for every block. Do it later in release builds to avoid redundant work! (Diagnostic Build Optimization)",
            "Detected a constant-color block (Constant Color Block Detection)",
            "Set SCB and mode errors to a very high error value (SCB and Mode Error Optimization)",
            "Trial using 1 plane of weights and 1 partition. (One Plane Weight Partitioning)",
            "Most of the time we test it twice, first with a mode cutoff of 0 and then with the specified, mode cutoff. This causes an early-out that speeds up encoding of easy blocks. However, this, optimization is disabled for 4x4 and 5x4 blocks where it nearly always slows down the, compression and slightly reduces image quality. (Mode Cutoff Optimization)",
            "Only enable MODE0 fast path if enabled (MODE0 Fast Path Optimization)",
            "Never enable for 3D blocks as no always block modes are available (3D Block Mode Optimization)",
            "Test the four possible 1-partition, 2-planes modes. Do this in reverse, as, alpha is the most likely to be non-correlated if it is present in the data. (Alpha Non-Correlation Optimization)",
            "Find best blocks for 2, 3 and 4 partitions (Partition Optimization)",
            "If we still have an error block then convert to something we can encode (Error Block Conversion)",
            "TODO: Do something more sensible here, such as average color block (Average Color Block Optimization)",
            "Compress to a physical block (Physical Block Compression)"
        ],
        "FuncName": "astcenc_compress_symbolic_5972 compress_block.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Compute covariance matrix, as a collection of 10 scalars that form the upper-triangular row of the matrix. The matrix is symmetric, so this is all we need for this use case. This involves calculating the covariance between each pair of pixels in the image block.",
            " These will give a NaN if a channel is constant - these are fixed up in the next step. This requires analyzing the distribution of pixel values in each channel to determine if there are any constant values.",
            " Diagnostic trace points. This step involves identifying the locations in the image where the pixel values are diagnostic, such as edges or corners."
        ],
        "FuncName": "astcenc_compress_symbolic_5972 prepare_block_statistics.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Average refinement improvement is 3.5% per iteration (allow 4.5%), but the first iteration can help more so we give it a extra 8% leeway. Use this knowledge to drive a heuristic to skip blocks that are unlikely to catch up with the best block we have already.",
                    "Skip remaining candidates - this is good enough",
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Generate the optimized set of weights for the weight mode",
                    "Compute weight quantization errors for the block mode"
                ]
            },
            {
                "loopstr": [
                    "Recompute the ideal color endpoints before storing them"
                ]
            },
            {
                "loopstr": [
                    "Quantize the chosen color, tracking if worth trying the mod value",
                    "If all the color endpoint modes are the same, we get a few more bits to store colors; let's see if we can take advantage of this: requantize all the colors and see if the endpoint modes remain the same.",
                    "Store header fields",
                    "Pre-realign test",
                    "Post-realign test",
                    "Average refinement improvement is 3.5% per iteration, so skip blocks that are unlikely to catch up with the best block we have already. Assume a 4.5% per step to give benefit of the doubt ...",
                    "This loop condition is related to image processing and compression."
                ]
            },
            {
                "loopstr": [
                    "Early out as soon as it's no longer possible to use mod"
                ]
            }
        ],
        "Normal": [
            "Compute ideal weights and endpoint colors, with no quantization or decimation",
            "Compute ideal weights and endpoint colors for every decimation",
            "For each decimation mode, compute an ideal set of weights with no quantization",
            "Compute maximum colors for the endpoints and ideal weights, then for each endpoint and ideal weight pair, compute the smallest weight that will result in a color value greater than 1",
            "For each mode, use the angular method to compute a shift",
            "For each mode (which specifies a decimation and a quantization):",
            "     * Compute number of bits needed for the quantized weights",
            "     * Generate an optimized set of quantized weights",
            "     * Compute quantization errors for the mode",
            "Decide the optimal combination of color endpoint encodings and weight encodings",
            "Iterate over the N believed-to-be-best modes to find out which one is actually best",
            "These normal strings are related to image processing and compression algorithms."
        ],
        "FuncName": "astcenc_compress_symbolic_5972 compress_symbolic_block_for_partition_1plane.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Average refinement improvement is 3.5% per iteration (allow 4.5%), but the first iteration can help more so we give it a extra 8% leeway. Use this knowledge to drive a heuristic to skip blocks that are unlikely to catch up with the best block we have already. This is a key concept in ASTC compression.",
                    "Skip remaining candidates - this is good enough",
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Skip remaining candidates - this is good enough"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Generate the optimized set of weights for the mode. This involves generating a set of weights that minimize the error between the original and compressed images.",
                    "Compute weight quantization errors for the block mode. This is a crucial step in ASTC compression, as it helps to determine the optimal quantization levels for the weights."
                ]
            },
            {
                "loopstr": [
                    "Quantize the chosen color. This involves reducing the color precision to a lower level to reduce the amount of data required to represent it.",
                    "Store header fields. This is necessary to ensure that the compressed image can be decompressed correctly.",
                    "Pre-realign test. This step is necessary to ensure that the compressed image is properly aligned with the original image.",
                    "Perform a final pass over the weights to try to improve them. This involves adjusting the weights to minimize the error between the original and compressed images.",
                    "Post-realign test. This step is necessary to ensure that the compressed image is properly aligned with the original image.",
                    "Average refinement improvement is 3.5% per iteration, so skip blocks that are unlikely to catch up with the best block we have already. Assume a 4.5% per step to give benefit of the doubt. This is a key concept in ASTC compression, as it helps to determine the optimal number of iterations to perform."
                ]
            }
        ],
        "Normal": [
            "Compute ideal weights and endpoint colors, with no quantization or decimation. This is the first step in the ASTC compression process.",
            "Compute ideal weights and endpoint colors for every decimation. This involves generating a set of weights and colors that minimize the error between the original and compressed images.",
            "For each decimation mode, compute an ideal set of weights with no quantization. This involves generating a set of weights that minimize the error between the original and compressed images.",
            "Compute maximum colors for the endpoints and ideal weights, then for each endpoint and ideal weight pair, compute the smallest weight that will result in a color value greater than 1. This is a crucial step in ASTC compression, as it helps to determine the optimal quantization levels for the weights.",
            "Set the plane2 component to max error in ep1. This involves setting the maximum error for the plane2 component to the maximum error in the ep1 component.",
            "Set the minwt2 to the plane2 component min in ep2. This involves setting the minimum weight for the plane2 component to the minimum weight in the ep2 component.",
            "For each mode (which specifies a decimation and a quantization):",
            "     * Compute number of bits needed for the quantized weights. This involves determining the number of bits required to represent the quantized weights.",
            "     * Generate an optimized set of quantized weights. This involves generating a set of weights that minimize the error between the original and compressed images.",
            "     * Compute quantization errors for the mode. This involves determining the error between the original and compressed images for the current mode.",
            "Decide the optimal combination of color endpoint encodings and weight encodings. This involves determining the optimal combination of color and weight encodings to use for the compressed image.",
            "Iterate over the N believed-to-be-best modes to find out which one is actually best. This involves iterating over the N modes that are believed to be the best and determining which one is actually the best."
        ],
        "FuncName": "astcenc_compress_symbolic_5972 compress_symbolic_block_for_partition_2planes.txt"
    },
    {
        "Branch": [
            "Check if the image type is valid and not null."
        ],
        "Loop": [
            "Iterate over the list of images."
        ],
        "Normal": [
            " Force link of our F77 error handler ",
            "This is a normal string that will be enhanced with image type related content.",
            "For example, it could be related to the image processing pipeline or the output image format."
        ],
        "FuncName": "cblas_xerbla_5649 cblas_xerbla.txt"
    },
    {
        "Branch": [
            "set window background color if condition is true"
        ],
        "Loop": [
            "set window background color in loop condition"
        ],
        "Normal": [
            "now repaint the window with new background color"
        ],
        "FuncName": "drawable_6757 set_background_color.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: find out some easy way to get frames from video source",
            "Get video frames from video source using OpenCV or FFmpeg library"
        ],
        "FuncName": "video_7423 getImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remove drawable from widgets",
                    "no more drawables at this z order, destroy the set",
                    "set for this z order",
                    "add drawable to its new z order"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "first widget at this z order, make its containing set",
                    "this drawable is the first widget at this z order so we need to make its containing set"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "drawable_6757 set_z_order.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The idea here is to exercize all the various overloads of the kcentroid object. We also want to exercize the image processing and computer vision capabilities of the kcentroid object. That is why we have these unopt_* linear kernels, which are commonly used in image filtering and feature extraction.",
            "to exercize the non-overloaded default version. That is why we have these unopt_* linear kernels, which are commonly used in image filtering and feature extraction.",
            "These kernels are typically used in image processing to reduce noise and enhance image features. They are also used in computer vision to detect edges and shapes in images."
        ],
        "FuncName": "kcentroid_9846 perform_test.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "first remove this drawable from widgets",
                    "if there are no more drawables at this z order then destroy the",
                    "set for this order",
                    "now unregister this drawable from all the events it has registered for"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "drawable_6757 disable_events.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved bytes should be 6 byte in size. Image size: width=100, height=200"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qpsdhandler_9232 option.txt"
    },
    {
        "Branch": [
            "Rotate the image by a specified angle using a filter with a specified number of threads"
        ],
        "Loop": [],
        "Normal": [
            "Calculate the rotation matrix",
            "Apply the rotation matrix to the image"
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "error issued in get_warp_filter. The image is warped."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error issued in get_warp_filter. The image is warped."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 warp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "error issued in get_warp_filter",
                    "Warping and filtering image with specific techniques"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 warp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "error issued in get_warp_filter",
                    "affine transformation applied to the image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 warp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error in get_warp_filter issued due to image warping"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 warp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This function applies a 2D smoothing filter to an image using a given filter kernel. It samples the image at regular intervals and applies the filter to these samples, producing a smoothed image. The filter kernel can be any 2D array of values, but it is typically a small array of values around 3x3 in size.",
                    "wrap = ImageBuf::WrapClamp;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In addition to the standard smoothing filter, this function also supports a special case for black wrap mode. In this mode, the filter shape is clamped so that it does not look outside the image region. This prevents strange image edge artifacts when using filters with negative lobes, where the image boundary itself is a contrast edge that can produce ringing.",
                    "wrap = ImageBuf::WrapClamp;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the normal case, this function simply uses isotropic filtering to smooth the image."
        ],
        "FuncName": "imagebufalgo_xform_1830 filtered_sample.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "error issued in get_warp_filter",
                    "Image transformation error occurred"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 warp.txt"
    },
    {
        "Branch": [
            "Resize image using a specified filter and ROI based on the condition"
        ],
        "Loop": [
            "Resize image using a specified filter and ROI for each iteration"
        ],
        "Normal": [
            "Resize an image using a specified filter and ROI"
        ],
        "FuncName": "imagebufalgo_xform_1830 resize_.txt"
    },
    {
        "Branch": [
            "Check if the image is rotated"
        ],
        "Loop": [
            "Rotate the image in each iteration"
        ],
        "Normal": [
            "Calculate the rotation matrix",
            "Apply the rotation matrix to the image"
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Resize ratios",
                    "error issued in get_resize_filter",
                    "Image resizing filter applied"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 resize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u6df1\u5ea6\u8f83\u5927\uff0c\u9996\u5148\u8981\u786e\u5b9a\u6837\u672c\u5206\u914d\uff0c\u56e0\u4e3a",
                    " \u540c\u65f6\u8fdb\u884c\u62f7\u8d1d\u548c\u5206\u914d\u64cd\u4f5c\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684",
                    "\u9700\u8981\u5c06\u56fe\u50cf\u91cd\u91c7\u6837\u4e3a\u6307\u5b9a\u7684\u5c3a\u5bf8"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 resample.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No filter name supplied -- pick a good default",
                    "Select a suitable 2D filter based on the image size for optimal results."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Set up a shared pointer with custom deleter to make sure any",
            "filter we allocate here is properly destroyed. The chosen 2D filter is then applied to the image data."
        ],
        "FuncName": "imagebufalgo_xform_1830 get_resize_filter.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unknown fill mode: default to letterbox. This may result in image cropping or stretching."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "same or wider than original, fill to height. This may result in image cropping or stretching."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If no filter was provided, punt and just linearly interpolate. error issued in get_resize_filter. This may result in image blurriness or artifacts."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Full partial-pixel filtered resize -- exactly preserves aspect ratio and exactly centers the padded image, but might make the edges of the resized area blurry because it's not a whole number of pixels. This requires careful handling of image edges and may require additional processing steps.",
                    "std::cout << Fit performing warp with << M << \\n;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "it will be picked up again by the next call... This may result in image duplication or unnecessary processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No time logging, it will be accounted in the underlying warp/resize. This may result in inaccurate timing or performance measurement.",
            "Compute scaling factors and use action_resize to do the heavy lifting. This may result in image distortion or loss of detail.",
            "std::cout << Fitting << srcspec.roi() into << newroi\\n;",
            "std::cout << Fit scale factor << scale\\n;"
        ],
        "FuncName": "imagebufalgo_xform_1830 fit.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unknown fill mode: default to letterbox. Image resize mode: Letterbox, which means the image will be resized to fit the given area by cropping the sides."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "same or wider than original, fill to height. Image resize mode: Stretch, which means the image will be resized to fit the given area by stretching the sides."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If no filter was provided, punt and just linearly interpolate. error issued in get_resize_filter. Image resize mode: Bilinear, which means the image will be resized using a bilinear interpolation filter."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Full partial-pixel filtered resize -- exactly preserves aspect ratio and exactly centers the padded image, but might make the edges of the resized area blurry because it's not a whole number of pixels. Image resize mode: Lanczos, which means the image will be resized using a Lanczos filter, which preserves the aspect ratio and centers the image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "it will be picked up again by the next call... Image resize mode: Auto, which means the image will be resized automatically based on the given area."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No time logging, it will be accounted in the underlying warp/resize. Normal operation, no resizing required.",
            "Compute scaling factors and use action_resize to do the heavy lifting. Resizing image using scaling factors.",
            "Fitting  into . Fitting image into the given area.",
            "Fit scale factor . Scaling factor for resizing image."
        ],
        "FuncName": "imagebufalgo_xform_1830 fit.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u6df1\u5ea6\u8f83\u5927\uff0c\u9996\u5148\u786e\u5b9a\u6837\u672c\u5206\u914d\uff0c\u56e0\u4e3a\u56fe\u50cf\u91cd\u91c7\u6837\u5230\u6307\u5b9a\u533a\u57df\u9700\u8981\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002",
                    "\u540c\u65f6\u8fdb\u884c\u62f7\u8d1d\u548c\u5206\u914d\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0c\u9700\u8981\u8003\u8651\u56fe\u50cf\u91cd\u91c7\u6837\u7684\u7ebf\u7a0b\u5b89\u5168\u6027\u3002",
                    "\u56fe\u50cf\u91cd\u91c7\u6837\u6d89\u53ca\u5230\u56fe\u50cf\u7684\u91cd\u6784\u548c\u91cd\u91c7\u6837\u8fc7\u7a0b\uff0c\u9700\u8981\u8003\u8651\u56fe\u50cf\u7684\u91cd\u91c7\u6837\u65b9\u5f0f\u548c\u56fe\u50cf\u7684\u91cd\u6784\u7b97\u6cd5\u3002",
                    "\u56fe\u50cf\u91cd\u91c7\u6837\u9700\u8981\u8003\u8651\u56fe\u50cf\u7684\u91cd\u91c7\u6837\u533a\u57df\u548c\u56fe\u50cf\u7684\u91cd\u91c7\u6837\u5c3a\u5bf8\uff0c\u9700\u8981\u786e\u4fdd\u56fe\u50cf\u7684\u91cd\u91c7\u6837\u533a\u57df\u548c\u5c3a\u5bf8\u7684\u5339\u914d\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_xform_1830 resample.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "end of parallel_image sampling and filtering"
        ],
        "FuncName": "imagebufalgo_xform_1830 st_warp_.txt"
    },
    {
        "Branch": [
            "Check if the image is rotated"
        ],
        "Loop": [
            "Iterate through the rotated image"
        ],
        "Normal": [
            "Calculate the rotation matrix",
            "Apply rotation to the image"
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Rotate the image by a certain angle using a specified filter, such as a Gaussian filter or a Laplacian of Gaussian filter."
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If a null filter was provided, fall back to a reasonable default.",
                    "Apply spatial transformation to the image by mapping source pixels to target pixels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Iterate over the image pixels and apply transformation.",
            "Transform each pixel from source space to target space."
        ],
        "Normal": [
            "Set up a shared pointer with custom deleter to make sure any",
            "filter we allocate here is properly destroyed.",
            "Perform image transformation by warping the source image onto the target image."
        ],
        "FuncName": "imagebufalgo_xform_1830 st_warp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculate the rotation matrix for image transformation"
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If a null filter was provided, fall back to a reasonable default. This filter is used for spatial transformation of the source image src to obtain the resulting image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Set up a shared pointer with custom deleter to make sure any filter we allocate here is properly destroyed. The filter is used for spatial transformation of the source image src to obtain the resulting image."
        ],
        "FuncName": "imagebufalgo_xform_1830 st_warp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculate the rotation matrix",
            "Apply rotation to image using angle {angle}, filter type {filter_type}, filter width {filter_width}, and recompute ROI {recompute_roi} in ROI region {roi_region} with {thread_num} threads"
        ],
        "FuncName": "imagebufalgo_xform_1830 rotate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " If a null filter was provided, fall back to a reasonable default.",
                    " Apply spatial transformation to the image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Set up a shared pointer with custom deleter to make sure any",
            " filter we allocate here is properly destroyed.",
            " Apply spatial transformation to the image."
        ],
        "FuncName": "imagebufalgo_xform_1830 st_warp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " save metadata for image",
            " save all thumbnails for image",
            " save all auxiliary image files"
        ],
        "FuncName": "ImageItem_5778 save.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "-1 because we just need to know of one dock widget that can be shown in the Thumbnail Bar"
        ],
        "FuncName": "DkThumbsWidgets_7684 createContextMenu.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "set stylesheet for tooltip with red background and white text, and background color based on mBgCol"
        ],
        "FuncName": "DkThumbsWidgets_7684 DkFilePreview.txt"
    },
    {
        "Branch": [
            "image condition check",
            "image condition check"
        ],
        "Loop": [
            {
                "loopstr": [
                    "image loading and drawing",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation",
                    "image size check and thumbnail generation"
                ]
            }
        ],
        "Normal": [
            "image drawing and mouse over effect"
        ],
        "FuncName": "DkThumbsWidgets_7684 drawThumbs.txt"
    },
    {
        "Branch": [
            "render if condition is met"
        ],
        "Loop": [
            "render loop condition is met"
        ],
        "Normal": [
            "render nothing if there are no thumbs for images"
        ],
        "FuncName": "DkThumbsWidgets_7684 paintEvent.txt"
    },
    {
        "Branch": [
            "\u57fa\u4e8e\u5982\u4f55\u4f4e\u7ea7API\u521b\u5efa\u6807\u5fd7\uff1a\u5c01\u9762\u56fe\u50cf"
        ],
        "Loop": [],
        "Normal": [
            "\u57fa\u4e8e\u5982\u4f55\u4f4e\u7ea7API\u521b\u5efa\u6807\u5fd7\uff1a\u5c01\u9762\u56fe\u50cf"
        ],
        "FuncName": "ImageItem_5778 isCoverImage.txt"
    },
    {
        "Branch": [
            "draw condition"
        ],
        "Loop": [
            "draw loop condition"
        ],
        "Normal": [
            "draw image"
        ],
        "FuncName": "DkThumbsWidgets_7684 drawCurrentImgEffect.txt"
    },
    {
        "Branch": [
            "Check if the image exists and is not empty"
        ],
        "Loop": [
            "Loop through each image in the list"
        ],
        "Normal": [
            "dummy image"
        ],
        "FuncName": "DkThumbsWidgets_7684 setThumb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ensure the image is even-sized and ready for mouse wheel event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "accept the mouse wheel event here and adjust thumbnail size or scrollbar position accordingly"
        ],
        "FuncName": "DkThumbsWidgets_7684 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " now update layout...",
            "update layout();"
        ],
        "FuncName": "DkThumbsWidgets_7684 resizeEvent.txt"
    },
    {
        "Branch": [
            "if (window.x > 0)"
        ],
        "Loop": [
            "for (int i = 0; i < window.size; i++)"
        ],
        "Normal": [
            "don't apply twice",
            "emit showThumbsDockSignal(true);"
        ],
        "FuncName": "DkThumbsWidgets_7684 newPosition.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "show icon",
                    "left mouse button click event handled"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 mousePressEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "find out where the mouse did click",
                    "track the thumbnail"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 mouseReleaseEvent.txt"
    },
    {
        "Branch": [
            "compute current scaling and apply image to gradient to draw gradient mask"
        ],
        "Loop": [],
        "Normal": [
            "compute current scaling and apply image to gradient to draw gradient mask"
        ],
        "FuncName": "DkThumbsWidgets_7684 drawFadeOut.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "update selection label for image"
        ],
        "FuncName": "DkThumbsWidgets_7684 selectThumb.txt"
    },
    {
        "Branch": [
            "load image if condition"
        ],
        "Loop": [
            "load image in loop condition"
        ],
        "Normal": [
            "disconnect image"
        ],
        "FuncName": "DkThumbsWidgets_7684 setImageLoader.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "resize pixmap label to match thumbnail size",
            "update image thumbnail"
        ],
        "FuncName": "DkThumbsWidgets_7684 updateSize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "well, that's not too beautiful, with a border around the image"
        ],
        "FuncName": "DkThumbsWidgets_7684 toggleSquaredThumbs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if we cannot load it -> disable selection with image description",
            "update label: image updated successfully"
        ],
        "FuncName": "DkThumbsWidgets_7684 updateLabel.txt"
    },
    {
        "Branch": [
            "Copy image to specified path"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Copy image to specified path and ignore existing silently"
                ]
            }
        ],
        "Normal": [
            "Copy image to specified path"
        ],
        "FuncName": "DkThumbsWidgets_7684 copyImages.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for image processing.",
            "If-Condition-Str: Check if image meets certain conditions."
        ],
        "Loop": [
            {
                "loopstr": [
                    "update ypos: Update the y-position of the image.",
                    "20 for label: Loop through the label 20 times to update the image position."
                ]
            }
        ],
        "Normal": [
            "qCeil(psz*0.1f);: Calculate the ceiling value of 10% of the image size."
        ],
        "FuncName": "DkThumbsWidgets_7684 updateLayout.txt"
    },
    {
        "Branch": [
            "If condition for image display."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Display thumbnail images.",
                    "Append thumbnails to the list."
                ]
            }
        ],
        "Normal": [
            "Do not emit selection changed while clearing thumbnails.",
            "Delete thumbnail labels."
        ],
        "FuncName": "DkThumbsWidgets_7684 updateThumbLabels.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "exit otherwise we get paint errors",
                    "This is relevant to image processing in Qt, where paint errors can occur if not handled properly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "painter->setPen(Qt::NoPen);",
                    "This line of code is used to set the pen of a QPainter object to no pen, which is relevant to image processing in Qt."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "this is the Qt idea of how to fix the dashed border:",
            "According to the Qt documentation, the dashed border can be fixed by using the QPainter and setRenderHints method.",
            "http://www.qtcentre.org/threads/23087-How-to-hide-the-dashed-frame-outside-the-QGraphicsItem",
            "This link provides further information on how to hide the dashed frame outside a QGraphicsItem in Qt.",
            "I don't think it's beautiful...",
            "This statement suggests that the current implementation of the dashed border is not visually appealing.",
            "painter->setRenderHints(QPainter::SmoothPixmapTransform | QPainter::Antialiasing);",
            "This line of code is used to set the render hints of a QPainter object, which is relevant to image processing in Qt.",
            "draw text",
            "This is a common operation in image processing, where text is drawn onto an image.",
            "render hovered",
            "This term refers to the process of rendering an image when it is in a hovered state.",
            "render selected",
            "This term refers to the process of rendering an image when it is in a selected state."
        ],
        "FuncName": "DkThumbsWidgets_7684 paint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "exit otherwise we get paint errors",
                    "In the context of image processing, this statement is crucial to prevent painting errors, which can lead to distorted or missing image elements."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "painter->setPen(Qt::NoPen);",
                    "This line of code sets the pen of the painter to no pen, effectively disabling any drawing or painting operations, allowing for a clean and image-focused rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "this is the Qt idea of how to fix the dashed border:",
            "According to the Qt Centre forum, fixing the dashed border can be achieved by using the following approach: http://www.qtcentre.org/threads/23087-How-to-hide-the-dashed-frame-outside-the-QGraphicsItem",
            "I don't think it's beautiful...",
            "painter->setRenderHints(QPainter::SmoothPixmapTransform | QPainter::Antialiasing);",
            "This line of code enables smooth pixmap transformation and anti-aliasing for the painter, resulting in a higher-quality image rendering.",
            "draw text",
            "In the context of image processing, drawing text involves adding textual elements to the image, which can include captions, labels, or other forms of written content.",
            "render hovered",
            "Rendering an image in a hovered state involves highlighting or emphasizing specific areas of the image when the user interacts with it, such as hovering over a button or link."
        ],
        "FuncName": "DkThumbsWidgets_7684 DkThumbScene.txt"
    },
    {
        "Branch": [
            "if condition with image preview",
            "filter by image preview",
            "show image preview if condition met"
        ],
        "Loop": [
            "loop through images with preview",
            "filter images by preview",
            "show image preview in loop"
        ],
        "Normal": [
            "add sorting with image preview",
            "filter edit with image preview",
            "right align search filters with image preview"
        ],
        "FuncName": "DkThumbsWidgets_7684 createToolbar.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "show icon with image loading"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 mousePressEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if a folder is dropped -> open it",
                    "drag and drop folder, view its contents"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 dropEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "accept image files such as JPEG, PNG, GIF, BMP, TIFF, and SVG",
                    "or drag and drop a directory containing image files"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 dragMoveEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "find out where the mouse did click",
                    "update the selected item based on the mouse release event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 mouseReleaseEvent.txt"
    },
    {
        "Branch": [
            "Rename file if condition is met"
        ],
        "Loop": [
            "Rename file in loop if condition is met"
        ],
        "Normal": [
            "Rename file to match image code"
        ],
        "FuncName": "DkThumbsWidgets_7684 renameSelected.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u63a5\u53d7\u56fe\u7247\u6587\u4ef6\uff0c\u5305\u62ecjpg\u3001png\u3001gif\u7b49"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkThumbsWidgets_7684 dragEnterEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " update dx",
                    " Drag and drop operation initiated with selected file and thumbnail"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " find out where the mouse is",
                    " else if (selected == -1)",
                    " fileLabel->hide();",
                    " Mouse moved over thumbnail, checking for drag operation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " selectedImg = DkImage::colorizePixmap(QPixmap::fromImage(thumb->getImage()), DkSettingsManager::param().display().highlightColor, 0.3f);",
                    " important: setText shows the label - if you then hide it here again you'll get a stack overflow",
                    " if (fileLabel->height() < height())",
                    " fileLabel->setText(thumbs.at(selected).getFile().fileName(), -1);",
                    " Thumbnail selected, preparing for drag operation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " select the current thumbnail",
            " QWidget::mouseMoveEvent(event);",
            " Mouse moved over thumbnail, updating selection"
        ],
        "FuncName": "DkThumbsWidgets_7684 mouseMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "update pinned files, including images"
        ],
        "FuncName": "DkThumbsWidgets_7684 DkRecentDirManager.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create context menu",
            "add image actions such as zoom, rotate, and crop",
            "add a shortcut to open the selected image"
        ],
        "FuncName": "DkThumbsWidgets_7684 createActions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now update the icon layout...",
            "update();"
        ],
        "FuncName": "DkThumbsWidgets_7684 resizeEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create buttons",
            "check if the folder exists (in the current context) and ensure it's properly mounted for Samba drives on Windows",
            "this should fix issues with disconnected Samba drives on Windows by creating a stable layout"
        ],
        "FuncName": "DkThumbsWidgets_7684 createLayout.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete file from history"
        ],
        "FuncName": "DkThumbsWidgets_7684 remove.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure ramdump() overloads compile and work. This string is related to image processing, specifically image filtering techniques."
        ],
        "FuncName": "serialize_870 test_strings.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "horizontal flip",
                    "image is flipped horizontally"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "get image properties"
        ],
        "FuncName": "IPLFlipImage_1263 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file 'stuff.bin' we want to decode and return. This data represents an image.",
            "Put the data into the istream sin",
            "Decode the base64 text into its compressed binary form, which is a compressed image.",
            "Decompress the data into its original form, resulting in a fully decompressed image.",
            "Return the decoded and decompressed data, which is now an image."
        ],
        "FuncName": "serialize_870 get_decoded_string.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded image data from the file 'stuff.bin' we want to decode, decompress and return.",
            "Put the base64 encoded image data into the istream sin",
            "Decode the base64 encoded image text into its compressed binary image form",
            "Decompress the image data into its original form",
            "Return the decoded, decompressed and enhanced image data"
        ],
        "FuncName": "serialize_870 get_decoded_string2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file matarray.dat we want to decode and return. This data is a compressed binary form of an image.",
            "Put the data into the istream sin",
            "Decode the base64 text into its compressed binary form, which contains image data.",
            "Decompress the data into its original form, revealing the image data.",
            "Return the decoded and decompressed data, which is the original image."
        ],
        "FuncName": "serialize_870 get_decoded_string_matarray.txt"
    },
    {
        "Branch": [
            "Test if condition serialization and deserialization function"
        ],
        "Loop": [
            "Test loop condition serialization and deserialization function"
        ],
        "Normal": [
            "Test serialization and deserialization function"
        ],
        "FuncName": "serialize_870 test_array2d_and_matrix_serialization.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file 'matarray.dat' we want to decode and return. This contains an image.",
            "Put the data into the istream sin",
            "Decode the base64 text into its compressed binary form, which is a compressed image.",
            "Decompress the data into its original form, revealing the original image.",
            "Return the decoded and decompressed image data"
        ],
        "FuncName": "serialize_870 get_decoded_string_matarray_old.txt"
    },
    {
        "Branch": [
            {
                "loopstr": [
                    "If the layer name starts from the beginning,",
                    "and it does not end with other dots,",
                    "we have found the channel of this layer."
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the layer name starts from the beginning,",
                    "and it does not end with other dots,",
                    "we have found the channel of this layer."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "Image_2500 channelsInLayer.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Populate data for sub-region of the texture to be updated with image channel information"
                ]
            }
        ],
        "Normal": [
            "Update textures that are cached for this channel with image data"
        ],
        "FuncName": "Image_2500 updateChannel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Takes all channels of a given group and turns them into individual groups, including image channels.",
            "Duplicates may have appeared here. (E.g. when trying to decompose a single channel or when single-color channels appear multiple times in their group to render as RGB rather than pure red.) Don't insert those.",
            "Image channels are processed separately to ensure accurate decomposition."
        ],
        "FuncName": "Image_2500 decomposeChannelGroup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No RGB-triplet found",
                    "Image data converted to Rec709 space successfully"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No need to do anything for identity transforms",
            "Since the image data is now in Rec709 space,",
            "converting to Rec709 is the identity transform.",
            "Rec709 space is a widely used color space in broadcasting and consumer electronics"
        ],
        "FuncName": "Image_2500 convertToRec709.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " If we're trying to open a directory, try loading all the images inside of that directory and display them as background images."
        ],
        "FuncName": "Image_2500 enqueue.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unlikely, but the file could have been deleted, moved, or something",
                    "else might have happened to it that makes obtaining its last modified",
                    "time impossible. Ignore such errors. Image loading failure may occur due to missing or corrupted image files."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If we arrived at the last loader, then we want to at least try loading the image,",
                    "even if it is likely to fail. Image loading may fail due to various reasons such as corrupted files or invalid image data.",
                    "Reset file cursor in case file load check changed it.",
                    "Earlier images should be prioritized when loading. This ensures that previously loaded images are not overwritten by newer images."
                ]
            },
            {
                "loopstr": [
                    "If multiple image parts were loaded and they have names,",
                    "ensure that these names are present in the channel selector. This allows for easy identification and management of loaded images."
                ]
            }
        ],
        "Normal": [
            "No need to keep loading images if tev is already shutting down again. Image loading is unnecessary when the system is shutting down."
        ],
        "FuncName": "Image_2500 tryLoadImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unlikely, but the file could have been deleted, moved, or something. Image loading might be affected.",
                    "else might have happened to it that makes obtaining its last modified time impossible. Image loading might be affected. Ignore such errors.",
                    "Image loading might be affected by file deletion, movement, or modification."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If we arrived at the last loader, then we want to at least try loading the image, even if it is likely to fail. Image loading is attempted.",
                    "even if it is likely to fail. Image loading is attempted.",
                    "Reset file cursor in case file load check changed it. Image loading is affected by file cursor.",
                    "Earlier images should be prioritized when loading. Image loading prioritizes earlier images."
                ]
            },
            {
                "loopstr": [
                    "If multiple image parts were loaded and they have names, ensure that these names are present in the channel selector. Image names are validated."
                ]
            }
        ],
        "Normal": [
            "No need to keep loading images if tev is already shutting down again. Image loading is unnecessary."
        ],
        "FuncName": "Image_2500 tryLoadImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "clock_cast appears to throw errors on some systems, so we're using this slightly hacky method to convert time points to timestamps (now is not called simultaneously for both clocks) similar to image timestamp conversion.",
            "inaccurate/random time conversion (now is not called simultaneously for both clocks) like image timestamp conversion.",
            "in order to convert to system time, similar to image timestamp conversion."
        ],
        "FuncName": "Image_2500 to_time_t.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unlikely, but the file could have been deleted, moved, or something",
                    "else might have happened to it that makes obtaining its last modified",
                    "time impossible. Ignore such errors.",
                    "This could be related to image loading issues, such as corrupted or missing image files."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If we arrived at the last loader, then we want to at least try loading the image,",
                    "even if it is likely to fail.",
                    "Reset file cursor in case file load check changed it.",
                    "Earlier images should be prioritized when loading.",
                    "This could be related to image loading optimization, such as loading images in the correct order."
                ]
            },
            {
                "loopstr": [
                    "If multiple image parts were loaded and they have names,",
                    "ensure that these names are present in the channel selector.",
                    "This is related to image loading and management, ensuring that all image parts are properly loaded and accessible."
                ]
            }
        ],
        "Normal": [
            "No need to keep loading images if tev is already shutting down again.",
            "This could be related to image loading and memory management, ensuring that unnecessary images are not loaded when the system is shutting down."
        ],
        "FuncName": "Image_2500 tryLoadImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unlikely, but the file could have been deleted, moved, or something",
                    "else might have happened to it that makes obtaining its last modified",
                    "time impossible. Ignore such errors.",
                    "This could be due to an image loading failure."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If we arrived at the last loader, then we want to at least try loading the image,",
                    "even if it is likely to fail.",
                    "Reset file cursor in case file load check changed it.",
                    "Earlier images should be prioritized when loading.",
                    "Image loading may take some time."
                ]
            },
            {
                "loopstr": [
                    "If multiple image parts were loaded and they have names,",
                    "ensure that these names are present in the channel selector.",
                    "This is crucial for image identification."
                ]
            }
        ],
        "Normal": [
            "No need to keep loading images if tev is already shutting down again.",
            "Image loading is not necessary in this case."
        ],
        "FuncName": "Image_2500 tryLoadImage.txt"
    },
    {
        "Branch": [
            "If the number is 0, no bits are needed for signed or unsigned representation."
        ],
        "Loop": [
            "Loop through each bit position from right to left."
        ],
        "Normal": [
            " no bits needed for 0 signed or not"
        ],
        "FuncName": "avpcl_mode1_8325 nbits.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " +1 since we are in uncompressed space, which is a characteristic of image files."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode1_8325 quantize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Compute block metadata",
                    "Extract metadata from image block"
                ]
            }
        ],
        "Normal": [
            "Reverse the encoding so we store origin block in the original format",
            "Store block metadata",
            "Include image block metadata in the stored data"
        ],
        "FuncName": "astcenc_image_3377 load_image_block_fast_ldr.txt"
    },
    {
        "Branch": [
            "init",
            "basic settings for if-conditions",
            "inputs and outputs for if-conditions",
            "properties for if-conditions"
        ],
        "Loop": [
            "init",
            "basic settings for loop-conditions",
            "inputs and outputs for loop-conditions",
            "properties for loop-conditions"
        ],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties"
        ],
        "FuncName": "IPLRotate_2677 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "get properties",
            "Compute a rotation matrix with respect to the center of the image",
            "cv::Point centerPoint = cv::Point(image->width()/2, image->height()/2);",
            "std::stringstream s; s << <b>Original Aspect Ratio</b>: << aspectRatio << <br> << <b>New Aspect Ratio</b>: << newAspectRatio << <br> << <b>Height</b>: << height << <br> << <b>Width</b>: << width; addInformation(s.str());",
            "Get the rotation matrix with the specifications above",
            "Rotate the warped image"
        ],
        "FuncName": "IPLRotate_2677 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Compute block metadata",
                    "Image type: ASTC compressed image"
                ]
            }
        ],
        "Normal": [
            "True if any non-identity swizzle. Image type: ASTC compressed image",
            "This works because we impose the same choice everywhere during encode. ASTC compression uses texture mapping to reduce data size.",
            "Set up the function pointers for loading pipeline as needed. ASTC requires specific function pointers for loading compressed image data.",
            "Reverse the encoding so we store origin block in the original format. ASTC compressed image data needs to be decompressed before use.",
            "Store block metadata. ASTC compressed image metadata includes block dimensions, compression ratio, and other relevant information."
        ],
        "FuncName": "astcenc_image_3377 load_image_block.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Fetch the image plane",
                    "Perform ASTC compression on the image plane"
                ]
            },
            {
                "loopstr": [
                    "Unaligned load as rows are not always SIMD_WIDTH long",
                    "Errors are NaN encoded - convert to magenta error color",
                    "Branch is OK here - it is almost never true so predicts well",
                    "Store compressed image in ASTC format"
                ]
            },
            {
                "loopstr": [
                    "Fetch the image plane",
                    "Perform ASTC compression on the image plane"
                ]
            },
            {
                "loopstr": [
                    "NaNs are handled inline - no need to special case",
                    "TODO: Vectorize with store N shorts?",
                    "Store compressed image in ASTC format"
                ]
            },
            {
                "loopstr": [
                    "Fetch the image plane",
                    "Perform ASTC compression on the image plane"
                ]
            },
            {
                "loopstr": [
                    "NaNs are handled inline - no need to special case",
                    "Store compressed image in ASTC format"
                ]
            }
        ],
        "Normal": [
            "True if any non-identity swizzle",
            "True if any swizzle uses Z reconstruct"
        ],
        "FuncName": "astcenc_image_3377 store_image_block.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "lookup",
            "Decode Mode 1 Image Data: Read image data from input block, apply inverse transform and sign extension, generate color table and index data, fill target image data."
        ],
        "FuncName": "avpcl_mode1_8325 decompress_mode1.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Collecting pixels in the region for image processing"
                ]
            },
            {
                "loopstr": [
                    "Validating temperature input error for accurate mapping",
                    "Using FLT_MAX for precise error calculation",
                    "Mapping colors while monitoring error threshold",
                    "Optimizing endpoint regions for improved accuracy",
                    "Updating best endpoints and errors if improvement found"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode1_8325 optimize_endpts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "color mapping error: hue, saturation, value"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "color mapping error: loop iterations"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode1_8325 map_colors.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "nreed Commented out asserts because they go off all the time...not sure why",
                    "for (int i=0; i<NREGIONS; ++i)",
                    "\tnvAssert(expected_opt_err[i] == opt_err[i]);",
                    "nvAssert(opt_toterr <= orig_toterr);",
                    "Optimizing boundary points to minimize errors in image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "apply a heuristic here -- we check if the endpoints fit before we try to optimize them.",
                    "the assumption made is that if they don't fit now, they won't fit after optimizing.",
                    "Iterating over regions to optimize image processing based on heuristic algorithms."
                ]
            }
        ],
        "Normal": [
            "throw No candidate found, should never happen (mode avpcl 1).",
            "Error message indicating no candidate found in image processing."
        ],
        "FuncName": "avpcl_mode1_8325 refine.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale endpoints and interpolate",
            "really need a IntVec4 to interpolate",
            "+1 since we are in uncompressed space and interpolate",
            "note: don't simplify to a + ((b-a)*i + BIAS)/DENOM as that doesn't work due to the way C handles integer division of negatives, and interpolate",
            "interpolate and constant alpha",
            "interpolate and constant alpha",
            "interpolate and constant alpha"
        ],
        "FuncName": "avpcl_mode1_8325 generate_palette_quantized.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "build list of possibles",
            "assign index to shape",
            "assign index to image block"
        ],
        "FuncName": "avpcl_mode1_8325 assign_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "If the improvement is effective, move the end point and continue searching from there"
                ]
            }
        ],
        "Normal": [
            "We have old end points: old_endpts",
            "We have perturbed end points: new_endpts",
            "We have temporary end points: temp_endpts",
            "Start from the current best error",
            "Copy the real end points so we can perturb them",
            "Search for the best error for this end point in log form (which one)"
        ],
        "FuncName": "avpcl_mode1_8325 perturb_one.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "execute action B next"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "restart the process"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "determine the most improved endpoint when perturbed and start from there",
                    "alternating endpoints may lead to local minima",
                    "perturb endpoint A",
                    "perturb endpoint B",
                    "alternate endpoints and continue until no improvement is found",
                    "check if the indices have changed",
                    "restart the process"
                ]
            },
            {
                "loopstr": [
                    "move the other endpoint"
                ]
            }
        ],
        "Normal": [
            "calculate error 0 by perturbing color 0 with delta 0, and error 1 by perturbing color 1 with delta 1. if error 0 is less than error 1, if error 0 is greater than or equal to the initial error, break. otherwise, if error 1 is greater than or equal to the initial error, break. color 0 plus delta 0, next is 1. otherwise, color 1 plus delta 1, next is 0. initial error is the minimum of the two errors. loop indefinitely. calculate error by perturbing the next color with delta. if the error is greater than or equal to the initial error, break. otherwise, next color plus delta, initial error is the new error",
            "optimize each color channel separately",
            "for the first improvement, save the indices. for any later improvement, compare the indices. if they differ, restart the loop, which will fall back to searching for the first improvement",
            "finally, perform a small exhaustive search around the suspected global minimum to confirm",
            "this search is independent of the previous search, so we don't care about the indices from the previous search",
            "we don't care about the previous search because if the indices differ, so what? we've already started at channel 0"
        ],
        "FuncName": "avpcl_mode1_8325 optimize_one.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings for image processing",
            "inputs and outputs for image data",
            "properties of image"
        ],
        "FuncName": "IPLMedian_4534 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " wait for layout change",
                    " reposition",
                    " Exif information updated"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " remove/add entries",
            " Hiding/showing entryStub causes flicker, so we just remove it from layout and clear the text. It's still there but basically not visible",
            " UI controls updated"
        ],
        "FuncName": "imageinfooverlay_4959 setExifInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " handle simple cases",
                    " project each pixel value along the principal direction",
                    " choose as endpoints 2 points along the principal direction that span the projections of all of the pixel values",
                    " clamp endpoints",
                    " the argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best",
                    " shape based on endpoints being clamped"
                ]
            }
        ],
        "Normal": [
            "calculate color and opacity endpoints for each region"
        ],
        "FuncName": "avpcl_mode1_8325 rough.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "image pixel error calculation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "image pixel error calculation in loop"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode1_8325 map_colors.txt"
    },
    {
        "Branch": [
            {
                "thenstr": "allowed&image_type=jpeg",
                "elsestr": []
            },
            {
                "thenstr": "allowed&image_type=png",
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "server_http_9259 urlencode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read the image block into the scanline buffer, making it flexible enough to change per-channel differences!",
                    "determine the number of components for this image element descriptor",
                    "identify the bit depth of the image element",
                    "calculate the size of the scanline buffer as image width multiplied by the number of components and bytes per component"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "scanline buffer for image data",
            "read the image block into the buffer"
        ],
        "FuncName": "Codec_8908 Read.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "number of rough cases to look at. reasonable values of this are 1, 1/4 of the total number of shapes and 1/4 of the total number of shapes, and the total number of shapes",
            "1/4 of the total number of shapes gets nearly all the cases; you can increase that a bit (say by 3 or 4) if you really want to squeeze the last bit out of the image",
            "pick the best 1/4 of the total number of shapes and refine these.",
            "bubble sort -- only need to bubble up the first 1/4 of the total number of shapes items"
        ],
        "FuncName": "avpcl_mode1_8325 compress_mode1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "look for Content-Type:",
                    "look for Content-Length:",
                    "look for any cookies",
                    "image type: Content-Type may indicate image type, such as image/jpeg or image/png"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "no ':' in it!",
                    "image loop: loop over all incoming headers to find image-related headers"
                ]
            }
        ],
        "Normal": [
            "get the path",
            "Get the HTTP/1.1 - Ignore for now...",
            "now loop over all the incoming_headers",
            "while (line != \r)",
            "If there is data being posted back to us as a query string then",
            "pick out the queries using parse_url.",
            "image extraction: extract image data from the query string or request body"
        ],
        "FuncName": "server_http_9259 parse_http_request.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress",
                    "image processing: calculating median"
                ]
            },
            {
                "loopstr": [
                    "insert sort list",
                    "image processing: sorting pixels by median"
                ]
            }
        ],
        "Normal": [
            "delete previous result",
            "get properties"
        ],
        "FuncName": "IPLMedian_4534 processInputData.txt"
    },
    {
        "Branch": [
            "HTTP request body content is loaded and there is data to process for if condition"
        ],
        "Loop": [
            "HTTP request body content is loaded and there is data to process for loop condition"
        ],
        "Normal": [
            "HTTP request body content is loaded and there is data to process"
        ],
        "FuncName": "server_http_9259 read_body.txt"
    },
    {
        "Branch": [
            "conditional execution based on the value of a variable",
            "branching to a specific section of code"
        ],
        "Loop": [
            "iteration based on the value of a variable",
            "repetition of a section of code"
        ],
        "Normal": [
            "ignore the first byte indicating type",
            "NAL unit sequence parameter set to AVC decoder configuration record"
        ],
        "FuncName": "avcdecoderconfigrecord_6321 makeConfigFromSPS.txt"
    },
    {
        "Branch": [
            "If the condition is true, send the following HTTP headers: ",
            "If the condition is true, send the following HTTP headers: "
        ],
        "Loop": [
            "While the condition is true, send the following HTTP headers: ",
            "While the condition is true, send the following HTTP headers: "
        ],
        "Normal": [
            " only send this header if the user hasn't told us to send another kind HTTP response code.",
            " Set any new HTTP headers, such as Content-Type or Cache-Control.",
            " set any cookies, such as session IDs or user preferences."
        ],
        "FuncName": "server_http_9259 write_http_response.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved = '111111'b (BitStream)",
                    "reserved = '11111'b (BitStream)",
                    "reserved = '11111'b (BitStream)",
                    "SPS EXT NALS (BitStream)",
                    "Must fit into 8 bits (BitStream)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "reserved = '111111'b (BitStream)",
            "SPS NALS (BitStream)",
            "reserved = '111'b (BitStream)",
            "Must fit into 5 bits (BitStream)",
            "PPS NALS (BitStream)",
            "Must fit into 8 bits (BitStream)"
        ],
        "FuncName": "avcdecoderconfigrecord_6321 writeDecConfigRecord.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of image processing, the max_cost_assignment() function can be used to find the optimal assignment of pixels to image segments, where each pixel is assigned to the segment that maximizes the cost function.",
            "This is a common problem in image segmentation, where each pixel has a certain feature value (e.g. color, texture) and each segment has a certain cost function associated with it.",
            "The cost matrix represents the similarity between each pixel and each segment, with higher values indicating a stronger similarity.",
            "The max_cost_assignment() function then finds the optimal assignment of pixels to segments that maximizes the total cost, which is equivalent to finding the best image segmentation.",
            "For example, in image compression, the max_cost_assignment() function can be used to find the optimal assignment of pixels to blocks, where each block represents a group of pixels with similar feature values.",
            "This allows for efficient compression of the image by representing each block as a single pixel, reducing the overall size of the image.",
            "In computer vision, the max_cost_assignment() function can be used to find the optimal assignment of pixels to objects, where each object has a certain cost function associated with it.",
            "This allows for object recognition and tracking, where the optimal assignment of pixels to objects is used to identify and track the objects in the image.",
            "In summary, the max_cost_assignment() function is a powerful tool for image processing and computer vision applications, where it is used to find the optimal assignment of pixels to image segments, blocks, or objects."
        ],
        "FuncName": "max_cost_assignment_ex_2528 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved = '111111'b: AVC decoding configuration record",
                    "reserved = '11111'b: AVC decoding configuration record",
                    "reserved = '11111'b: AVC decoding configuration record",
                    "SPS EXT NALS: Supplemental enhancement information"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "read parameter set NAL unit: AVC decoding configuration record"
                ]
            },
            {
                "loopstr": [
                    "read parameter set NAL unit: AVC decoding configuration record"
                ]
            },
            {
                "loopstr": [
                    "Read parameter set NAL unit.: AVC decoding configuration record"
                ]
            }
        ],
        "Normal": [
            "reserved = '111111'b: AVC decoding configuration record",
            "SPS NALS: Supplemental enhancement information",
            "reserved = '111'b: AVC decoding configuration record",
            "PPS NALS: Picture parameter set",
            "Stop reading if there is no more data (ignore possibly wrong mAvcProfileIndication): AVC decoding configuration record"
        ],
        "FuncName": "avcdecoderconfigrecord_6321 parseConfig.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find array for the given NAL unit type.",
            "If an array is not present for the NAL unit type, create one.",
            "Copy NAL data excluding potential start code and add it to the AVC decoder configuration record.",
            "Add NAL unit to the NAL unit array for AVC image processing."
        ],
        "FuncName": "avcdecoderconfigrecord_6321 addNalUnit.txt"
    },
    {
        "Branch": [
            " only send this header if the user hasn't told us to send another kind (HTTP 304 Not Modified)"
        ],
        "Loop": [],
        "Normal": [
            "Send any new headers (e.g. Set-Cookie) or update existing ones (e.g. Cache-Control)",
            "Set any new cookies",
            "Set any cookies (e.g. session ID)"
        ],
        "FuncName": "server_http_9259 write_http_response.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " set focus policy to receive focusInEvents, allowing the image to capture keyboard and mouse interactions"
        ],
        "FuncName": "floatingwidgetcontainer_3841 FloatingWidgetContainer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Add start code (0x00000001) before the NAL unit. This is a specific operation related to image processing, where the NAL unit is a crucial component of image encoding."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "avcdecoderconfigrecord_6321 getOneParameterSet.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Starting drag and drop process by creating a drag operation to move the current list item. QListWidget::startDrag(supportedActions);"
        ],
        "FuncName": "IPProcessList_6485 startDrag.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "left eye with a distance of 60 mm",
            "right eye with a distance of 60 mm"
        ],
        "FuncName": "train_face_5point_model_8389 interocular_distance.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Load icon from PNG file and add background color based on process category, including icon description and tooltip information."
        ],
        "FuncName": "IPProcessList_6485 addProcessItem.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure requires clause is not broken, with left and right flip 5 points image feature"
        ],
        "FuncName": "train_face_5point_model_8389 add_image_left_right_flips_5points.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Found",
                    "Image code: NALArray object"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Not found",
            "Image code: NALArray object"
        ],
        "FuncName": "avcdecoderconfigrecord_6321 getNALArray.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Ensure the navigation view is also flipped. The image is mirrored horizontally."
        ],
        "FuncName": "graphicsview_7645 flipView.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "image code: ld"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "utils_1313 fgetl.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Is orig even in str? Check if the original string contains an even number of characters related to image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "utils_1313 find_replace.txt"
    },
    {
        "Branch": [
            "If-Condition: Calculate the average and variance of the array. This is a calculation related to the image type."
        ],
        "Loop": [],
        "Normal": [
            "MSE: %.6f, Mean: %.6f, Variance: %.6f\n",
            "This string is related to the image type and describes the calculation of average and variance."
        ],
        "FuncName": "utils_1313 print_statistics.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "blumia: return here, or the QMouseEvent event transparency won't work if we set a QGraphicsView::ScrollHandDrag drag mode. This is related to image processing and event handling in Qt.",
                    "blumia: return here, or the QMouseEvent event transparency won't work if we set a QGraphicsView::ScrollHandDrag drag mode. This is related to image processing and event handling in Qt."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "graphicsview_7645 mousePressEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " when someone clicks our button, the counter will increment and the image associated with it will be displayed in our label c",
            " the image will be updated in real-time to reflect the current counter value"
        ],
        "FuncName": "gui_api_ex_2398 on_button_clicked.txt"
    },
    {
        "Branch": [
            "Check if image exists, then copy exif data (to this instance), reading from src"
        ],
        "Loop": [],
        "Normal": [
            "Copy exif data (to this instance), reading from src"
        ],
        "FuncName": "DkMetaData_5046 update.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Open image file for reading, read whole file into memory and extract image metadata",
            " Write modified metadata (from this instance) to mExifImg and then to ba (in-memory image file) with updated image information",
            " Open image file for WRITING, save it with modified metadata and updated image data"
        ],
        "FuncName": "DkMetaData_5046 saveMetaData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ImageFactory::create(type) may crash even if old Image object has that type. This is because the factory may create a new image object with a different type, which can cause the old image object to be garbage collected before it is properly released."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Copy Exiv2::Image object. When copying an Exiv2::Image object, the new object will have the same metadata as the original object."
        ],
        "FuncName": "DkMetaData_5046 copy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u4ee5\u524d\u5728\u8fd9\u91cc\u6709\u51e0\u884c\u4e11\u964b\u7684\u884c\u6765\u52a0\u8f7dunicode\u6587\u4ef6",
                    "\u7531\u4e8e\u6211\u4eec\u53ef\u4ee5\u52a0\u8f7d99%\u7684\u7f13\u51b2\uff0c\u5e76\u4e14\u6211\u4eec\u65e0\u6cd5\u4f7f\u7528/Zc:wchar_t-\uff08\u4f5c\u4e3aQt5.10\uff09",
                    "\u6211\u5220\u9664\u4e86\u8fd9\u4e9b\u884c - \u5982\u679c\u6211\u4eec\u6ca1\u6709\u7f13\u51b2\uff0c\u6211\u4eec\u53ef\u4ee5\u53ea\u52a0\u8f7d\u4f7f\u7528std::string literals\u5728\u8def\u5f84\u4e2d\u7684\u6587\u4ef6\u7684\u5143\u6570\u636e",
                    "\u6211\u4eec\u53ef\u4ee5\u8bfb\u53d6\u5143\u6570\u636e\uff0c\u8fd9\u4e9b\u5143\u6570\u636e\u662f[image]\u4ee3\u7801\u4e2d\u7684\u5143\u6570\u636e"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " qDebug() << [Exiv2] metadata loaded;",
            "\u6211\u4eec\u53ef\u4ee5\u8bfb\u53d6\u5143\u6570\u636e\uff0c\u8fd9\u4e9b\u5143\u6570\u636e\u662f[image]\u4ee3\u7801\u4e2d\u7684\u5143\u6570\u636e",
            " printMetaData();"
        ],
        "FuncName": "DkMetaData_5046 readMetaData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Declare an instance of the kernel we will be using for image processing.",
            " create a dataset with two concentric circles for image analysis.  There will be 100 points on each circle.",
            " Here we create an empirical_kernel_map using all of our data samples as basis samples for image classification.",
            " create a new dataset with two concentric circles for image segmentation.  There will be 1000 points on each circle.",
            " Rather than use all 2000 samples as basis samples we are going to use the linearly_independent_subset_finder to pick out a good basis set for image feature extraction.  The idea behind this object is to try and find the 40 or so samples that best spans the subspace containing all the data. ",
            " populate lisf with samples for image representation.  We have configured it to allow at most 40 samples but this function may determine that fewer samples are necessary to form a good basis.  In this example program, it will select only 26.",
            " Now reload the empirical_kernel_map but this time using only our small basis selected using the linearly_independent_subset_finder for image compression."
        ],
        "FuncName": "empirical_kernel_map_ex_282 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no longer need to do fitInView()",
                    "but we leave the m_enableFitInView value unchanged in case",
                    "user resize down the window again.",
                    "image view will adapt to the scene when view size changes"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "graphicsview_7645 resizeEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Prepare background check-board pattern with image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "graphicsview_7645 setCheckerboardEnabled.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Now print a message for any misclassified points. Note that the kernel trick allows us to non-linearly project the data onto a higher-dimensional space, enabling the classification of non-separable data."
                ]
            },
            {
                "loopstr": [
                    "Now print a message for any misclassified points. Note that the kernel trick allows us to non-linearly project the data onto a higher-dimensional space, enabling the classification of non-separable data."
                ]
            },
            {
                "loopstr": [
                    "And let's just check that the dec_funct really does compute the same thing as the previous equation. Note that the kernel function computes the dot product of the projected samples, which is equivalent to the non-linearly projected vectors using the empirical_kernel_map.",
                    "Now print a message for any misclassified points. Note that the kernel trick allows us to non-linearly project the data onto a higher-dimensional space, enabling the classification of non-separable data."
                ]
            }
        ],
        "Normal": [
            "The first thing we do is compute the nonlinearly projected vectors using the empirical_kernel_map. Note that a kernel matrix is just a matrix M such that M(i,j) == kernel(samples[i],samples[j]).",
            "Note that the empirical_kernel_map allows us to non-linearly project the data onto a higher-dimensional space, enabling the computation of the kernel matrix.",
            "So below we are computing the normal kernel matrix as given by the radial_basis_kernel and the inputsamples.",
            "We also compute the kernel matrix for all the projected_samples as given by the linear_kernel. Note that the linear_kernel just computes normal dot products.",
            "So what we want to see is that the dot products between all the projected_samples samples are the same as the outputs of the kernel function for their respective untransformed input samples.",
            "If they match then we know that the empirical_kernel_map is working properly.",
            "Example outputs from these cout statements.",
            "For the case where we use all samples as basis samples:",
            "Max kernel matrix error: 7.32747e-15",
            "Mean kernel matrix error: 7.47789e-16",
            "For the case where we use only 26 samples as basis samples:",
            "Max kernel matrix error: 0.000953573",
            "Mean kernel matrix error: 2.26008e-05",
            "Note that if we use enough basis samples we can perfectly span the space of input samples.",
            "In that case we get errors that are essentially just rounding noise",
            "Moreover, using all the samples is always enough since they are always within their own span",
            "Once we start to use fewer basis samples we may begin to get approximation error.",
            "In the second case we used 26 and we can see that the data doesn't really lay exactly in a 26 dimensional subspace.",
            "But it is pretty close.",
            "Now let's do something more interesting.",
            "The following loop finds the centroids of the two classes of data.",
            "Now classify points by which center they are nearest.",
            "Recall that the data is made up of two concentric circles.",
            "Normally you can't separate two concentric circles by checking which points are nearest to each center since they have the same centers.",
            "However, the kernel trick makes the data separable and the loop below will perfectly classify each data point.",
            "Next, note that classifying a point based on its distance between two other points is the same thing as using the plane that lies between those two points as a decision boundary.",
            "So let's compute that decision plane and use it to classify all the points.",
            "The point right in the center of our two classes should be on the deciding plane, not on one side or the other.",
            "This consideration brings us to the formula for the bias.",
            "Now classify points by which side of the plane they are on.",
            "It would be nice to convert this decision rule into a normal decision_function object and dispense with the empirical_kernel_map.",
            "Happily, it is possible to do so.",
            "Consider the following example code:",
            "The dec_funct now computes dot products between plane_normal_vector and the projection of any sample point given to it.",
            "All that remains is to account for the bias.",
            "Now classify points by which side of the plane they are on."
        ],
        "FuncName": "empirical_kernel_map_ex_282 test_empirical_kernel_map.txt"
    },
    {
        "Branch": [
            "If condition is met, then image will be displayed"
        ],
        "Loop": [
            "Loop condition is checked for each iteration"
        ],
        "Normal": [
            "nothing"
        ],
        "FuncName": "heifreadersegment_3929 Segments.txt"
    },
    {
        "Branch": [
            "Check if the image is loaded successfully"
        ],
        "Loop": [],
        "Normal": [
            "nothing"
        ],
        "FuncName": "heifreadersegment_3929 ConstSegments.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now set default show options for image display",
            "DkHistogram::DisplayMode::histogram_mode_simple for image histogram",
            "TODO: set to 1 for finishing slideshow with image",
            "installed version should only check for updates by default for image",
            "installed version should only check for updates by default for image",
            " "
        ],
        "FuncName": "DkSettings_3228 setToDefaultSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "formats we can save",
            "if (qtFormats.contains(\\icns)) app_p.saveFilters.append(\\Apple Icon Image (*.icns))",
            "formats we can load",
            "raw format, including image data",
            "stereo formats, such as anaglyph images",
            "other formats, including graphics and photos",
            "archive formats, like zip or rar",
            "exif filter as reported in #518 - afaik this is not a standard (typically it contains jpg/tiff), used for image metadata",
            "finally: fabians filter & OpenCV vecs, for computer vision tasks",
            "drif images, a type of image used in scientific research",
            "load user filters, allowing users to customize their image filters",
            "add unknown formats from Qt plugins, to support additional image formats",
            "app_p.fileFilters.append(*.lnk), for adding link filters"
        ],
        "FuncName": "DkSettings_3228 initFileFilters.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "update folder + be silent",
                    "image processing with filters and effects",
                    "enhance image quality with sharpening and noise reduction"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "init settings",
            "this line makes the XmpParser thread-save - so don't delete it even if you seem to know what you do",
            "uncomment this for the single instance feature...",
            "check for single instance",
            "nmc::DkRunGuard guard;",
            "",
            "if (!guard.tryRunning()) {",
            "\tqDebug() << \"nomacs is already running - quitting...\";",
            "\treturn 0;",
            "}",
            "CMD parser --------------------------------------------------------------------",
            "fullscreen (-f)",
            "CMD parser --------------------------------------------------------------------",
            "compute batch process",
            "apply default settings",
            "apply default settings",
            "install translations",
            "pong",
            "show pink icons if nomacs is in private mode",
            "TODO: currentAppMode is obsolete now; use appMode instead",
            "currentAppMode is not saved/restored by settings but must be set early",
            "initialize nomacs with image processing capabilities",
            "check if show* actually maximized us",
            "Qt emulates showMaximized() on some platforms (X11), so it might not work.",
            "If we try again with a visible window, it *could* work correctly (GNOME)",
            "load directory preview with image thumbnails",
            "load to tabs with image viewing and editing",
            "load recent files if there is nothing to display",
            "restore message handler, workaround for: https://github.com/nomacs/nomacs/issues/874",
            "we need delete so that settings are saved (from destructors) and image data is properly cleaned up"
        ],
        "FuncName": "main_4343 main.txt"
    },
    {
        "Branch": [
            "Image Condition: A condition that checks if an image meets certain criteria."
        ],
        "Loop": [
            "Image Loop Condition: A condition that loops through a collection of images."
        ],
        "Normal": [
            "Image Normal: This is a normal string that has been enhanced with image-related content. It may contain image descriptions, image processing techniques, or image-related metadata."
        ],
        "FuncName": "heifreadersegment_3929 iterator.txt"
    },
    {
        "Branch": [
            "if-condition-image"
        ],
        "Loop": [
            "loop-condition-image"
        ],
        "Normal": [
            "nothing-image"
        ],
        "FuncName": "heifreadersegment_3929 const_iterator.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (errfile) { float errs[21]; int nerrs = 8; errs[0] = mse_mode0; errs[1] = mse_mode1; errs[2] = mse_mode2; errs[3] = mse_mode3; errs[4] = mse_mode4; errs[5] = mse_mode5; errs[6] = mse_mode6; errs[7] = mse_mode7; if (fwrite(errs, sizeof(float), nerrs, errfile) != nerrs) throw Write error on error file; }",
            "The mse_mode0 to mse_mode7 values are used to calculate the mean squared error (MSE) for each mode. The mse_modeX values are written to the error file using fwrite."
        ],
        "FuncName": "avpcl_643 compress.txt"
    },
    {
        "Branch": [
            "Copy settings value to target settings based on if condition."
        ],
        "Loop": [
            "Copy settings value to target settings based on loop condition."
        ],
        "Normal": [
            "Copy default settings",
            "These strings are for image code."
        ],
        "FuncName": "DkSettings_3228 copySettings.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "remove the icon file -> otherwise icons might be destroyed e.g. acrobat, register image file types"
                ]
            }
        ],
        "Normal": [
            "register file associations, support image file types",
            "do not register containers such as *.pptx *.zip, exclude image files from registration"
        ],
        "FuncName": "DkSettings_3228 registerFileAssociations.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "qDebug() << ext << \"registered as the default application for nomacs.exe images.\";"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkSettings_3228 registerDefaultApp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "windows 7 only",
                    "Default application set for Windows 7 system."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkSettings_3228 setAsDefaultApp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "remove the icon file otherwise icons might be destroyed e.g. acrobat. This is specific to image file types."
                ]
            }
        ],
        "Normal": [
            "do not register if nomacs is portable. Image file types require specific registration.",
            "TODO: this is still not working for me on win8. Image file type registration is critical for functionality."
        ],
        "FuncName": "DkSettings_3228 registerNomacs.txt"
    },
    {
        "Branch": [
            "if (add) - a conditional statement in an image processing code"
        ],
        "Loop": [],
        "Normal": [
            "if (add) - a conditional statement in an image processing code",
            "settings2.setValue(Default, progKey); - setting a program key in a settings file",
            "settings.beginGroup(nomacs.exe); - starting a group in a settings file for nomacs.exe",
            "tell system that nomacs can handle this file type - a message indicating image handling capability"
        ],
        "FuncName": "DkSettings_3228 registerExtension.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << \"ID: \" << ext;"
        ],
        "FuncName": "DkSettings_3228 getIconID.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6ce8\u518c\u7a0b\u5e8f ID,\u8bbe\u7f6e AppUserModelID \u4e3a nomacs.ImageLounge,\u5e76\u8bbe\u7f6e EditFlags \u4e3a 1,\u8bbe\u7f6e CurVer \u4e3a nomacsKey,\u5e76\u8f93\u51fa nomacsKey \u548c written\u3002",
                    "settings.setValue(AppUserModelID, nomacs.ImageLounge);",
                    "settings.setValue(EditFlags, 1);",
                    "settings.setValue(CurVer, nomacsKey);",
                    "qDebug() << nomacsKey <<  written;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkSettings_3228 registerProgID.txt"
    },
    {
        "Branch": [
            "Check if image exists"
        ],
        "Loop": [
            "Loop through image array"
        ],
        "Normal": [
            "Do nothing with the image",
            "Perform image processing"
        ],
        "FuncName": "DkSettings_3228 nextFactor.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get a bunch of rows at once to test out the reference of a matrix image",
            "counting and automatic cache expansion built into the symmetric matrix image cache",
            "This test verifies that for example getting row 3 of a matrix image doesn't stomp on any of the previous rows",
            "matrix image rows expansion"
        ],
        "FuncName": "symmetric_matrix_cache_7370 test_rowm_exp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "replace color placeholders with RGB values or color names"
        ],
        "FuncName": "DkSettings_3228 replaceColors.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " we expect something like this:",
                    " overload color settings of nomacs ",
                    "--nomacs-color-def",
                    "HIGHLIGHT_COLOR: #ff0;",
                    "WINDOW_COLOR: #333;",
                    "This is a color setting for images in nomacs."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " ignore blanks",
                    "This is a loop condition for image processing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DkSettings_3228 parseColors.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "levels must be monotonically increasing, with each level having a unique image code"
        ],
        "FuncName": "DkSettings_3228 checkLevels.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "things are supposed to be symmetric, related to image processing where symmetry is a key property."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "symmetric_matrix_cache_7370 test_stuff.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get a bunch of columns at once to test out the reference and image processing capabilities.",
            "counting and automatic cache expansion built into the symmetric_matrix_cache, which allows for efficient image data storage and retrieval.",
            "This test verifies that for example getting column 3 doesn't stomp on any of the previous columns, ensuring image data integrity.",
            "Additionally, this test checks the image processing pipeline, ensuring that it can handle large image data without issues."
        ],
        "FuncName": "symmetric_matrix_cache_7370 test_colm_exp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress: analyzing image data using local histogram statistics"
                ]
            }
        ],
        "Normal": [
            "delete previous result: removing outdated image processing results",
            "get properties: retrieving image metadata using local histogram statistics"
        ],
        "FuncName": "IPLRankTransform_7214 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Update column offset and redraw, as specified in image code."
        ],
        "FuncName": "IPZoomWidget_5688 setColumnOffset.txt"
    },
    {
        "Branch": [
            "redraw with image description"
        ],
        "Loop": [
            "redraw with image description"
        ],
        "Normal": [
            "redraw with image description"
        ],
        "FuncName": "IPZoomWidget_5688 setPosition.txt"
    },
    {
        "Branch": [
            "classify(colorspaces.add(\"RGB\");"
        ],
        "Loop": [],
        "Normal": [
            "classify(colorspaces.add(\"RGB\"); classify(colorspaces.back());"
        ],
        "FuncName": "color_ocio_4235 add.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If any non raw spaces were defined, we're done. This includes color spaces related to images, such as RGB, CMYK, and YUV."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If we had some kind of bogus configuration that seemed to define only a raw color space and nothing else, that's useless, so figure out our own way to move forward. This may involve loading image data or color profiles related to the image type.",
            "If there was no configuration, or we didn't compile with OCIO support at all, register a few basic names we know about, such as image file formats like JPEG, PNG, and TIFF.",
            "For the no OCIO / no config case, we assume an unsophisticated color pipeline where linear and the like are all assumed to use Rec709/sRGB color primaries, which are commonly used in image processing and display."
        ],
        "FuncName": "color_ocio_4235 inventory.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "General heuristics based on color space names -- for a few canonical names,",
            "believe them! Woe be unto the poor soul who names a color space sRGB",
            "or ACEScg and it's really something entirely different. This may involve",
            "color space conversion or transformation.",
            "Ugly SPI-specific hacks, so sorry",
            "Set up some canonical names for color spaces like sRGB, Adobe RGB, etc."
        ],
        "FuncName": "color_ocio_4235 classify_by_name.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "uchar test = *_image->rgb32() + (_x+offsetX)*_image->height() + (_y+offsetY);",
                    "\u7ed8\u5236IP\u56fe\u50cf\u7684\u7f29\u653e\u89c6\u56fe\uff0c\u5305\u542bRGB32\u989c\u8272\u901a\u9053"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "center",
                    "\u5faa\u73af\u6761\u4ef6\uff1a\u4e2d\u5fc3\u70b9"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "IPZoomWidget_5688 paintEvent.txt"
    },
    {
        "Branch": [
            "Initializes color space configuration, loads config file, and sets log level for image processing."
        ],
        "Loop": [],
        "Normal": [
            "If no filename was specified, use environment variable $OCIO for image processing."
        ],
        "FuncName": "color_ocio_4235 init.txt"
    },
    {
        "Branch": [
            "Check if the condition is met, then execute the code.",
            "If the condition is true, then proceed.",
            "Else, skip to the next step."
        ],
        "Loop": [
            "Check if the loop condition is met, then execute the loop.",
            "Loop through the list and perform the necessary operations.",
            "Continue to the next iteration if the condition is met."
        ],
        "Normal": [
            "dont do anything expensive.",
            "This is a normal string with no specific image-related content."
        ],
        "FuncName": "color_ocio_4235 reset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Fall back on parseColorSpaceFromString, utilizing color space configuration from file path"
        ],
        "FuncName": "color_ocio_4235 getColorSpaceFromFilepath.txt"
    },
    {
        "Branch": [
            "Find color space name in string, related to image type"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Find right-most extension matched in filename related to image type",
                    "If we have found a match, move the pointer over to the right end related to image type",
                    "of the substring to find longest name matching rightmost colorspace related to image type",
                    "Find longest name matching rightmost colorspace related to image type"
                ]
            }
        ],
        "Normal": [
            "Reproduce logic in OCIO v1 parseColorSpaceFromString related to image type",
            "Get colorspace names, sorted shortest-to-longest related to image type",
            "See if it matches a LUT name related to image type",
            "This is position of RIGHT end of colorspace substring, not left related to image type",
            "Find right-most occurrence within string for each colorspace related to image type"
        ],
        "FuncName": "color_ocio_4235 parseColorSpaceFromString.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Check for exact matches and color space indices",
            " Check for aliases and equivalents, including color space conversions"
        ],
        "FuncName": "color_ocio_4235 getColorSpaceIndex.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " DBG(done, setting output colorspace to {} to); Color conversion function applied to process pixel colors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "transition to other colorconvert Color processing applied for color transformation."
        ],
        "FuncName": "color_ocio_4235 colorconvert.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " DBG(done, setting output colorspace to a color processor);"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "transition to other color conversion"
        ],
        "FuncName": "color_ocio_4235 colorconvert.txt"
    },
    {
        "Branch": [
            "If-condition: based on the image type, the bit depth will be determined by the type descriptor."
        ],
        "Loop": [],
        "Normal": [
            "Note: OCIOv2 supports 10, 12, and 14-bit integer formats, but we do not currently have data in these formats.",
            "We will only consider 10, 12, and 14-bit integer formats when processing image data."
        ],
        "FuncName": "color_ocio_4235 ocio_bitdepth.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "display OCI object image: transition to colorconvert"
        ],
        "FuncName": "color_ocio_4235 ociodisplay.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Apply OCIO color space transformation to the input image."
        ],
        "FuncName": "color_ocio_4235 ociofiletransform.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "display OCI audio data: transition to colorconvert"
        ],
        "FuncName": "color_ocio_4235 ociodisplay.txt"
    },
    {
        "Branch": [
            "Apply color matrix transformation to image based on if condition"
        ],
        "Loop": [
            "Apply color matrix transformation to image based on loop condition"
        ],
        "Normal": [
            "Apply color matrix transformation to image to transition to other color convert"
        ],
        "FuncName": "color_ocio_4235 colormatrixtransform.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Only process up to, and including, the first 4 channels.  This is the intent. Color conversion involves processing image color conversion operations, including unpremultiplying alpha, applying a color processor, and remultiplying alpha.",
            " does let us process images with fewer than 4 channels, which is the intent. Color conversion involves processing image color conversion operations, including unpremultiplying alpha, applying a color processor, and remultiplying alpha.",
            " clang-format off",
            " clang-format on"
        ],
        "FuncName": "color_ocio_4235 colorconvert_impl.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " DBG(done, setting output colorspace to {}; to); Color conversion to {}"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "transition to other colorconvert, converting colors to specified color space"
        ],
        "FuncName": "color_ocio_4235 colorconvert.txt"
    },
    {
        "Branch": [
            "transition to colorconvert based on image color matching"
        ],
        "Loop": [],
        "Normal": [
            "transition to colorconvert"
        ],
        "FuncName": "color_ocio_4235 ociolook.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " DBG(done, setting output colorspace to {} to); Color conversion function applied."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "transition to other colorconvert Color conversion function applied."
        ],
        "FuncName": "color_ocio_4235 colorconvert.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if the write was not successful",
                    "image code: write operation failed"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sockstreambuf_unbuffered_794 overflow.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "DBG(done, setting output colorspace to RGB to);",
                    "RGB is a type of color model that uses red, green, and blue light to create a wide range of colors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "transition to other colorconvert",
            "Color conversion is the process of changing the color of an image from one color space to another."
        ],
        "FuncName": "color_ocio_4235 colorconvert.txt"
    },
    {
        "Branch": [
            "ocio transformation applied"
        ],
        "Loop": [
            "ocio transformation applied"
        ],
        "Normal": [
            "ocio transformation applied: transition to colorconvert"
        ],
        "FuncName": "color_ocio_4235 ocionamedtransform.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Extract contained box bitstream and type",
                    "Handle this box based on the type",
                    "Image type description: This box contains image data, such as JPEG or PNG."
                ]
            }
        ],
        "Normal": [
            "First parse the box header",
            "if there a data available in the file",
            "Image type description: This box contains image metadata, such as image width and height."
        ],
        "FuncName": "mediainformationbox_6618 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "transition to colorconvert with OCIO file transformation"
        ],
        "FuncName": "color_ocio_4235 ociofiletransform.txt"
    },
    {
        "Branch": [
            "If-Condition-Str is a code string related to image processing"
        ],
        "Loop": [
            "Loop-Condition-Str is a code string related to image processing"
        ],
        "Normal": [
            "init is a code string related to image processing",
            "basic settings is a code string related to image processing",
            "inputs and outputs is a code string related to image processing",
            "properties is a code string related to image processing"
        ],
        "FuncName": "IPLEquidensityLines_2439 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "the write was not successful so return that 0 bytes were written"
                ]
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sockstreambuf_unbuffered_794 xsputn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "some error occurred. This string is associated with image code that reads a character from a buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sockstreambuf_unbuffered_794 uflow.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "1 and 2 channels can write directly. TGA data can be written directly to the image buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "early out. TGA data can be written directly to the image buffer.",
            "write packet header. TGA data can be written directly to the image buffer.",
            "rewind the scanline and flush packet pixels. TGA data can be written directly to the image buffer."
        ],
        "FuncName": "targaoutput_7051 flush_rawp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " learned from experience beware NaNs, and consider converting 3D vectors to latitude and longitude"
        ],
        "FuncName": "environment_9730 vector_to_latlong.txt"
    },
    {
        "Branch": [
            "Write zero bytes to the buffer.",
            "Related to image: Buffer Overflow"
        ],
        "Loop": [
            "Write zero bytes to the buffer.",
            "Related to image: Buffer Overflow"
        ],
        "Normal": [
            "Write zero bytes to the buffer up to 64 bytes at a time.",
            "Related to image: Buffer Overflow"
        ],
        "FuncName": "targaoutput_7051 pad.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if they are trying to push back a character that they didnt read last, causing an image buffer overflow",
            "that is an error, potentially causing image data corruption",
            "if they are trying to push back a second character then thats an error, likely resulting in image rendering issues"
        ],
        "FuncName": "sockstreambuf_unbuffered_794 pbackfail.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Offsets within the file are 32 bits Ensure the file does not exceed this limit.",
            " Force 8 bit integers",
            " Check if the client wants the image to be run length encoded. Currently, only RGB RLE is supported.",
            " TGA does not dictate unassociated un-premultiplied alpha, but many implementations assume it. Even if we set TGA_ALPHA_PREMULTIPLIED, we always write unassociated alpha.",
            " Prepare and write Targa header.",
            " Handle image ID and save it to disk later.",
            " The format only allows for 255 bytes.",
            " 8 bits of alpha.",
            " Force Y flip when using RLE.",
            " For raw non-RLE images, we can use random access to dump the image in the default top-bottom scanline order for maximum compatibility. Not all software supports the Y flip flag, however. Once RLE kicks in, we lose the ability to predict the byte offsets of scanlines, so we just dump the data in the order it comes in and use this flag instead.",
            " Due to struct packing, we may get a corrupt header if we just dump the struct to the file. To address this, write every member individually.",
            " Save some typing. Note that these overloaded write calls will byte-swap as needed.",
            " Writing cmap_type.",
            " Dump comment to file. Don't bother about null termination.",
            " If the user asked for tiles, which this format doesn't support, emulate it by buffering the whole image."
        ],
        "FuncName": "targaoutput_7051 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "write out the TGA 2.0 data fields",
                    "FIXME: write out the developer area; according to Larry, it's probably safe to ignore it altogether until someone complains",
                    "write out the thumbnail, if there is one",
                    "prepare the footer",
                    "write out the extension area",
                    "ext area size -- 2 bytes, always short(495)",
                    "author - 41 bytes",
                    "image comment - 324 bytes",
                    "timestamp - 6 shorts (month, day, year, hour, minute, second)",
                    "job ID - 41 bytes",
                    "job time - 3 shorts (hours, minutes, seconds)",
                    "software ID -- 41 bytes",
                    "software version - 3 bytes (first 2 bytes: version*100)",
                    "key colour (ARGB) -- punt and write 0",
                    "pixel aspect ratio -- two shorts, giving a ratio",
                    "gamma -- two shorts, giving a ratio",
                    "offset to colour correction table - 4 bytes",
                    "FIXME: support this once it becomes clear how it's actually supposed to be used... the spec is very unclear about this",
                    "for the time being just dump four NULL bytes",
                    "offset to thumbnail - 4 bytes",
                    "offset to scanline table - 4 bytes",
                    "not used very widely, don't bother unless someone complains",
                    "alpha type - one byte",
                    "write out the TGA footer",
                    "TGA image data type: uncompressed raster image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "dump thumbnail size",
                    "thumbnail size: bytes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "dump thumbnail size",
                    "thumbnail size: bytes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "FIXME: invent a smarter way to convert to a vulgar fraction?",
                    "numerator",
                    "numerator",
                    "denominator",
                    "gamma value: numerator/denominator"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Extract gamma value from color space, if it's there",
                    "NOTE: the spec states that only 1 decimal place of precision is needed, thus the expansion by 10",
                    "numerator",
                    "gamma value: numerator/10"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "targaoutput_7051 write_tga20_data_fields.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read a character from the buffer. This is a code for reading a character from the buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sockstreambuf_unbuffered_794 underflow.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Emulate tiles by buffering the whole image. This involves writing sub-blocks to an image buffer."
        ],
        "FuncName": "targaoutput_7051 write_tile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Helpful for debugging to make sure that any crashes dump a stack trace. This is an image code related string.",
            "This string is related to image processing and can be used to enhance the image quality.",
            "The image code is used to display images on the screen and this string is related to that process."
        ],
        "FuncName": "iconvert_969 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "When creating a thumbnail for an image, ensure that the thumbnail size is not zero and the number of channels matches the original image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "For TARGA images, the thumbnail dimensions are limited to 256 resolution, and the thumbnail must be in UINT8 format."
        ],
        "FuncName": "targaoutput_7051 set_thumbnail.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " clang-format off",
            "FIXME -c %s, &channellist, Restrict/shuffle channels, This is a string related to image processing.",
            " clang-format on"
        ],
        "FuncName": "iconvert_969 getargs.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u56fe\u50cf\u8f6c\u6362\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2aMIP\u7ea7\u522b\u4ee5\u7ee7\u7eed\u56fe\u50cf\u5904\u7406\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5982\u679c\u5fc5\u987b\u7684\u8bdd\uff0c\u6211\u4eec\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u683c\u5f0f\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u5b50\u56fe\u50cf\u4ee5\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u56fe\u50cf\u5904\u7406\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u627e\u5230\u4e00\u4e2a\u53ef\u4ee5\u6253\u5f00\u8f93\u5165\u6587\u4ef6\u7684ImageIO\u63d2\u4ef6\uff0c\u5e76\u6253\u5f00\u5b83\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002",
            "\u627e\u5230\u4e00\u4e2a\u53ef\u4ee5\u6253\u5f00\u8f93\u51fa\u6587\u4ef6\u7684ImageIO\u63d2\u4ef6\uff0c\u5e76\u6253\u5f00\u5b83\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406",
            "\u4e3a\u4e86\u5904\u7406\u652f\u6301\u5b50\u56fe\u50cf\u4f46\u4e0d\u652f\u6301\u5b50\u56fe\u50cf\u8ffd\u52a0\u7684\u683c\u5f0f\uff0c\u6211\u4eec\u9996\u5148\u6536\u96c6\u5b83\u4eec\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002",
            "\u786e\u5b9a\u8f93\u5165\u6587\u4ef6\u7684\u65f6\u95f4\u2014\u2014\u8981\u4e48\u662f\u7531\u5143\u6570\u636e\u63d0\u4f9b\u7684\uff0c\u8981\u4e48\u662f\u8f93\u5165\u6587\u4ef6\u7684\u5b9e\u9645\u65f6\u95f4\u6233\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002",
            "\u5982\u679c\u7528\u6237\u8981\u6c42\uff0c\u5c1d\u8bd5\u5c06\u6587\u4ef6\u7684\u4fee\u6539\u65f6\u95f4\u8c03\u6574\u5230\u6587\u4ef6\u7684\u521b\u5efa\u65f6\u95f4\u6307\u793a\u7684\u65f6\u95f4\u6233\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002",
            "\u5982\u679c\u7528\u6237\u8981\u6c42\uff0c\u5c1d\u8bd5\u5c06\u6587\u4ef6\u7684\u4fee\u6539\u65f6\u95f4\u8c03\u6574\u5230\u6587\u4ef6\u7684\u521b\u5efa\u65f6\u95f4\u6307\u793a\u7684\u65f6\u95f4\u6233\u4ee5\u8fdb\u884c\u56fe\u50cf\u5904\u7406\u3002"
        ],
        "FuncName": "iconvert_969 convert_file.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " print({}:{}:{} {}:{}:{}\n, year, month, day, hour, min, sec); // convert date string to time_t",
            " fill in defaults"
        ],
        "FuncName": "iconvert_969 DateTime_to_time_t.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u8f93\u5165\u6587\u4ef6\u6709\u6df7\u5408\u901a\u9053\uff0c\u652f\u6301\u6df7\u5408\u683c\u5f0f"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u8f93\u51fa\u652f\u6301\u6df7\u5408\u683c\u5f0f--\u6240\u4ee5\u8bf7\u6c42\u5b83\uff0c\u786e\u4fdd\u6ca1\u6709\u610f\u5916\u7684BPS\u4f1a\u635f\u574f\u6211\u4eec"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u786e\u4fdd\u6ca1\u6709\u610f\u5916\u7684BPS\u4f1a\u635f\u574f\u6211\u4eec\uff0c\u8f93\u5165\u6587\u4ef6\u6709\u6df7\u5408\u901a\u9053"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u590d\u5236\u89c4\u8303\uff0c\u53ef\u80fd\u6539\u53d8\u683c\u5f0f\uff0c\u9002\u5e94\u8f93\u51fa\u56fe\u50cf"
        ],
        "FuncName": "iconvert_969 adjust_spec.txt"
    },
    {
        "Branch": [
            "Check if the image is loaded successfully and then display it"
        ],
        "Loop": [
            "Loop through each image in the list and display it"
        ],
        "Normal": [
            " clang-format off",
            " clang-format on"
        ],
        "FuncName": "spinlock_test_5116 getargs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create the message: This operation may fail due to an image processing error.",
            "This function is called only for non-fatal problems, so we don't need to do the longjmp.",
            "The error is related to the image processing and will be handled accordingly.",
            "longjmp(myerr-setjmp_buffer, 1);"
        ],
        "FuncName": "jpeginput_4480 my_output_message.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "return true;",
                    "This is an image of a conditional statement."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "This is an image of a loop condition.",
            "This is another image of a loop condition."
        ],
        "Normal": [
            "delete previous result",
            "get properties",
            "deg to rad",
            "This is an image of a normal string."
        ],
        "FuncName": "IPLSynthesize_3020 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "cinfo-err really points to a my_error_mgr struct, so coerce pointer to image data.",
            "Always display the message related to image processing.",
            "We could postpone this until after returning, if we chose, to avoid image loading issues.",
            "Display the image error message (*cinfo-err-output_message) (cinfo);",
            "Return control to the setjmp point for image handling."
        ],
        "FuncName": "jpeginput_4480 my_error_exit.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find out how long it takes to measure the lock/unlock cycle cost"
        ],
        "FuncName": "spinlock_test_5116 time_lock_cycle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compare the current 6 samples with our known definitions to determine the corresponding subsampling attribute in image compression",
            "to determine the corresponding subsampling attribute in image"
        ],
        "FuncName": "jpeginput_4480 comp_info_to_attr.txt"
    },
    {
        "Branch": [
            "Image Condition: The image is checked for a specific condition.",
            "Image Condition: The image is verified for a particular condition."
        ],
        "Loop": [
            "Image Loop Condition: The image is looped until a specific condition is met.",
            "Image Loop Condition: The image is repeated until a particular condition is fulfilled."
        ],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "all properties which can later be changed by gui",
            "Image Description: The image is initialized with basic settings.",
            "Image Description: The image properties are set to their default values.",
            "Image Description: The image inputs and outputs are defined.",
            "Image Description: The image properties can be modified using the GUI."
        ],
        "FuncName": "IPLSynthesize_3020 init.txt"
    },
    {
        "Branch": [
            "Filling image cavities with this function."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Progress"
                ]
            }
        ],
        "Normal": [
            "This function deletes the previous result.",
            "This function retrieves attributes from the image."
        ],
        "FuncName": "IPLFillConcavities_1679 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Alternate one that mixes in some math to make longer lock hold time and also more to do between locks Interesting contrast in timings. Image processing involves cumulative addition of pixel values within a specified iteration count to produce the final image."
        ],
        "FuncName": "spinlock_test_5116 do_accum.txt"
    },
    {
        "Branch": [
            "save config spec for JPEG image"
        ],
        "Loop": [],
        "Normal": [
            "save config spec for JPEG image"
        ],
        "FuncName": "jpeginput_4480 open.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "JPEG seems to store CMYK as 1-x, with image type related to color model."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "jpeginput_4480 read_native_scanline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The point of this test is to make sure calling set_feature() multiple times works the way it is supposed to. This involves testing the functionality of the image feature extractor.",
            "Learn to do sequence labeling from the dataset, which includes extracting relevant image features.",
            "Both feature extractors should be equivalent in their image feature extraction capabilities."
        ],
        "FuncName": "sequence_labeler_3608 test2.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "JPEG seems to store CMYK as 1-x, where 1 is the cyan channel and x is the amount of magenta, yellow, and key (black) ink used to create the image."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "jpeginput_4480 cmyk_to_rgb.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "print out some of the randomly sampled sequences for image classification",
            "Learn to do sequence labeling from the dataset for object detection in images",
            "We can also do cross-validation for image segmentation tasks ",
            "Finally, the labeler can be serialized to disk just like most dlib objects used in image processing.",
            "recall from disk for image retrieval"
        ],
        "FuncName": "sequence_labeler_3608 do_test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "save config spec with image metadata"
        ],
        "FuncName": "jpeginput_4480 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Every edit item has an image, which is the latest one if only metadata has been edited"
        ],
        "FuncName": "DkBasicLoader_1170 hasImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reset to initial state. Closing TGA input."
        ],
        "FuncName": "targainput_2303 close.txt"
    },
    {
        "Branch": [
            "if (imgLoaded) {"
        ],
        "Loop": [],
        "Normal": [
            "first byte",
            "second byte",
            "load Roh file and convert to QImage",
            "\tsetEditImage(img, tr(Original Image));"
        ],
        "FuncName": "DkBasicLoader_1170 loadRohFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "it should be an error for TYPE_RGB as well, but apparently some very old TGAs can be this way, so we'll hack around it. TGA comments are used to store additional information about the image, such as its type or palette.",
                    "TGA comments can be at most 255 bytes long, but we add 1 extra byte in case the comment lacks null termination. This is a common issue when working with legacy image formats.",
                    "std::cerr << [tga] this is a TGA 2.0 file. TGA 2.0 files are a type of raster graphics file format that supports multiple image types and color depths."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "TGA comments can be at most 255 bytes long, but we add 1 extra byte in case the comment lacks null termination. This is a common issue when working with legacy image formats."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr << [tga] this is a TGA 2.0 file. TGA 2.0 files are a type of raster graphics file format that supports multiple image types and color depths."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Due to struct packing, we may get a corrupt header if we just load the struct from file; to address that, read every member individually save some typing. Byte swapping is done automatically. If any fail, the file handle is closed and we return false from open().",
            "have we got alpha? Alpha channels are used to store transparency information in images.",
            "std::cerr << [tga]  << m_tga.width << x << m_tga.height << @ << (int)m_tga.bpp <<  ( << m_spec.nchannels << ) type  << (int)m_tga.type << \\n. This is an example of how to print image metadata, including its width, height, and color depth.",
            "load image ID. Image IDs are used to identify specific images within a dataset.",
            "now try and see if it's a TGA 2.0 image. TGA 2.0 files are a type of raster graphics file format that supports multiple image types and color depths.",
            "TGA 2.0 files are identified by a nifty TRUEVISION-XFILE.0 signature. This is a unique identifier for TGA 2.0 files.",
            "Reposition back to where the palette starts. Palettes are used to store color information in images."
        ],
        "FuncName": "targainput_2303 open.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "We need to transform to linear space, associate the alpha channel, and then transform back.  That is, if D = data[c], we want to apply gamma correction and alpha blending. The formula simplifies to: D' = D * (alpha/max)^gamma, where alpha is the alpha channel value, max is the maximum value, and gamma is the gamma correction value. This is a common technique used in image processing to enhance the image and associate the alpha channel.",
                    "We need to transform to linear space, associate the alpha channel, and then transform back. That is, if D = data[c], we want to apply gamma correction and alpha blending. The formula simplifies to: D' = D * (alpha/max)^gamma, where alpha is the alpha channel value, max is the maximum value, and gamma is the gamma correction value. This is a common technique used in image processing to enhance the image and associate the alpha channel.",
                    "We need to transform to linear space, associate the alpha channel, and then transform back. That is, if D = data[c], we want to apply gamma correction and alpha blending. The formula simplifies to: D' = D * (alpha/max)^gamma, where alpha is the alpha channel value, max is the maximum value, and gamma is the gamma correction value. This is a common technique used in image processing to enhance the image and associate the alpha channel.",
                    "We need to transform to linear space, associate the alpha channel, and then transform back. That is, if D = data[c], we want to apply gamma correction and alpha blending. The formula simplifies to: D' = D * (alpha/max)^gamma, where alpha is the alpha channel value, max is the maximum value, and gamma is the gamma correction value. This is a common technique used in image processing to enhance the image and associate the alpha channel.",
                    "We need to transform to linear space, associate the alpha channel, and then transform back. That is, if D = data[c], we want to apply gamma correction and alpha blending. The formula simplifies to: D' = D * (alpha/max)^gamma, where alpha is the alpha channel value, max is the maximum value, and gamma is the gamma correction value. This is a common technique used in image processing to enhance the image and associate the alpha channel.",
                    "This happens to simplify to something which looks like multiplying by a nonlinear alpha:"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "targainput_2303 associateAlpha.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "it should be an error for TYPE_RGB as well, but apparently some very old TGAs can be this way, so we'll hack around it",
                    "TGA comments can be at most 255 bytes long, but we add 1 extra byte in case the comment lacks null termination",
                    "std::cerr << [tga] this is a TGA 2.0 file; TGA is a raster image file format used to store uncompressed, uncompressed or compressed raster images, it was developed by Truevision in 1984 and is widely used in the computer graphics industry."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "TGA comments can be at most 255 bytes long, but we add 1 extra byte in case the comment lacks null termination TGA is a raster image file format used to store uncompressed, uncompressed or compressed raster images, it was developed by Truevision in 1984 and is widely used in the computer graphics industry."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr << [tga] this is a TGA 2.0 file; TGA is a raster image file format used to store uncompressed, uncompressed or compressed raster images, it was developed by Truevision in 1984 and is widely used in the computer graphics industry."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Due to struct packing, we may get a corrupt header if we just load the struct from file; to address that, read every member individually save some typing. Byte swapping is done automatically. If any fail, the file handle is closed and we return false from open(). TGA is a raster image file format used to store uncompressed, uncompressed or compressed raster images, it was developed by Truevision in 1984 and is widely used in the computer graphics industry.",
            "have we got alpha? TGA alpha channel is used to store transparency information, it's usually stored in a separate byte plane.",
            "std::cerr << [tga]  << m_tga.width << x << m_tga.height << @ << (int)m_tga.bpp <<  ( << m_spec.nchannels << ) type  << (int)m_tga.type << \\\\n; TGA file format supports different image types, including uncompressed, uncompressed or compressed raster images.",
            "load image ID TGA image ID is used to identify the image, it's usually stored in the header of the file.",
            "now try and see if it's a TGA 2.0 image TGA 2.0 is a variant of the TGA file format, it's used to store uncompressed, uncompressed or compressed raster images.",
            "TGA 2.0 files are identified by a nifty TRUEVISION-XFILE.0 signature TGA 2.0 signature is a unique identifier for TGA 2.0 files, it's used to differentiate them from other TGA file formats.",
            "Reposition back to where the palette starts TGA palette is used to store color information, it's usually stored in a separate byte plane."
        ],
        "FuncName": "targainput_2303 open.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "I hate nested switches... with pixelated complexity, where decode_pixel function is used to decode TGA image pixels, each pixel's color value is decoded based on image type, palette, RGB or grayscale."
        ],
        "FuncName": "targainput_2303 decode_pixel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "uncompressed image data",
                    "Image processing: reading TGA file, handling compressed and uncompressed data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "run length packet",
                    "Image processing: handling TGA run length packet, packet size {} at ({},{})",
                    "     packet_size, x, y);"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "run spans across multiple scanlines",
                    "Image processing: handling TGA run spanning multiple scanlines."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "skip the packet header byte",
                    "Image processing: skipping TGA packet header byte at ({},{}): [{:d} {:d} {:d} {:d}]",
                    "     x, y, pixel[0], pixel[1], pixel[2], pixel[3]);"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "run spans across multiple scanlines",
                    "Image processing: handling TGA run spanning multiple scanlines."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr << [tga] x flippingn;",
                    "Image processing: flipping TGA image horizontally."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "TGA 1.0 files dont have a way to indicate that the alpha is not",
                    "premultiplied. We presume unpremultiplied, but if alpha is zero",
                    "everywhere, ugh, its probably meaningless.",
                    "Image processing: handling TGA alpha channel, presuming unpremultiplied."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Image processing: reading TGA file, processing image data.",
            "Image processing: handling TGA image data, 15-bit reads.",
            "Image processing: reading TGA palette, if available.",
            "Image processing: flipping TGA image, if necessary.",
            "Image processing: Y-flipping is now done in read_native_scanline.",
            "Image processing: handling TGA image flipping, if necessary.",
            "Image processing: converting TGA image to associated format, unless otherwise specified."
        ],
        "FuncName": "targainput_2303 readimg.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "load image author",
                    "load image comments",
                    "concatenate the lines into a single string",
                    "timestamp",
                    "job name/ID",
                    "job time",
                    "software",
                    "background (key) colour",
                    "FIXME: what do we do with it?",
                    "aspect ratio",
                    "if the denominator is zero, it's unused",
                    "gamma",
                    "if the denominator is zero, it's unused",
                    "offset to colour correction table",
                    "std::cerr << [tga] colour correction table offset: << (int)m_ofs_colcorr_tbl << \n;",
                    "offset to thumbnail",
                    "offset to scan-line table",
                    "TODO: can we find any use for this? we can't advertise random",
                    "access anyway, because not all RLE-compressed files will have",
                    "this table",
                    "alpha type",
                    "Check for presence of a thumbnail and set the metadata that",
                    "says its dimensions, but don't read and decode it unless",
                    "thumbnail() is called.",
                    "image tag: TGA 2.0 extension area",
                    "header information read successfully"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "tack on the version number and letter",
                    "image tag: TGA 2.0 file",
                    "version number: 2.0"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Round gamma to the nearest hundredth to prevent stupid",
                    "precision choices and make it easier for apps to make",
                    "decisions based on known gamma values. For example, you want",
                    "2.2, not 2.19998.",
                    "gamma value: rounded to 2.2"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Presume that Targa files are sRGB primaries",
                    "colour space: sRGB"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Read the thumbnail dimensions -- sometimes it's 0x0 to",
                    "indicate no thumbnail.",
                    "thumbnail dimensions: 0x0"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "read the extension area",
            "check if this is a TGA 2.0 extension area",
            "according to the 2.0 spec, the size for valid 2.0 files is exactly",
            "495 bytes, and the reader should only read as much as it understands",
            "for < 495, we ignore this section of the file altogether",
            "for > 495, we only read what we know",
            "std::cerr << [tga] extension area size: << s << \n;",
            "FIXME: provide access to the developer area; according to Larry,",
            "it's probably safe to ignore it altogether until someone complains",
            "that it's missing :)",
            "image tag: TGA 2.0 extension area",
            "header information read successfully"
        ],
        "FuncName": "targainput_2303 read_tga2_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If the image header does not list a valid number of elements, we have ",
            "count how many defined image descriptors we have, which is ",
            "elements."
        ],
        "FuncName": "DPXHeader_7666 ImageElementCount.txt"
    },
    {
        "Branch": [
            "Write header to file if image code requires it"
        ],
        "Loop": [],
        "Normal": [
            "validate and byte swap, if necessary, for image data",
            "write the header to the file, as per image code specifications",
            "swap back - data is in file, now we need it native again, as per image requirements"
        ],
        "FuncName": "DPXHeader_7666 Write.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "File information",
                    "Image information",
                    "Image Origination information",
                    "Motion Picture Industry Specific",
                    "Television Industry Specific",
                    "Validates the image header of a Dpx file"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Verifies the magic cookie of a Dpx file",
            "Checks if byte swapping is required for a Dpx file"
        ],
        "FuncName": "DPXHeader_7666 Validate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " rewind file and read in the header from the file",
            " read in the image data and validate",
            " validate the image file"
        ],
        "FuncName": "DPXHeader_7666 Read.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "File Information: A header containing metadata about the file.",
            "new: A new file or image is being created.",
            "genericSize is the size of the file/image/orientation headers: This value represents the total size of the generic, image, and orientation headers combined.",
            "sizeof(dpx::GenericHeader) won't give the correct results because of compiler padding: The size of the generic header is not accurate due to compiler padding.",
            "file header is 768 bytes: The file header is 768 bytes in size.",
            "image header is 640 bytes: The image header is 640 bytes in size.",
            "orientation header 256 bytes: The orientation header is 256 bytes in size.",
            "industrySize is the size of the motion picture/television headers: This value represents the total size of the motion picture and television headers combined.",
            "motion picture header is 256 bytes: The motion picture header is 256 bytes in size.",
            "television header is 128 bytes: The television header is 128 bytes in size.",
            "Image Information: A header containing metadata about the image.",
            "Image Orientation: A header describing the orientation of the image."
        ],
        "FuncName": "DPXHeader_7666 Reset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " QFile is an IODevice. This is a PSD file.",
                    " psdHandler.setFormat(fileInfo.suffix())"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " setEditImage(img, tr('Original Image'));. This is the original image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " setEditImage(img, tr('Original Image'));. This is the original image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "load a PSD file from file?"
        ],
        "FuncName": "DkBasicLoader_1170 loadPSDFile.txt"
    },
    {
        "Branch": [
            "Calculate image description offset"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Write image description only if available"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DPXHeader_7666 CalculateOffsets.txt"
    },
    {
        "Branch": [
            "Adjust image to fit view region when image view is displayed."
        ],
        "Loop": [],
        "Normal": [
            "updateImage(); Adjust image to fit view region when image view is displayed."
        ],
        "FuncName": "IPImageViewer_3349 showEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "round to next full pixel, similar to how images are rendered on a screen.",
            "round to next full pixel, similar to how images are rendered on a screen."
        ],
        "FuncName": "IPImageViewer_3349 hoverMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "determinestringindexskipping",
                    "errorcheck",
                    "maskinnewvalue"
                ]
            }
        ],
        "Normal": [
            "makethesstringisthecorrectlength"
        ],
        "FuncName": "DPXHeader_7666 TCFromString.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "delete last image",
                    "convert from IPLImage",
                    "if the result is invalid, abort",
                    "update histogram",
                    "update statistics",
                    "update zoom widget",
                    "update graphics scene",
                    "update title",
                    "if the current tab index is valid, update the tab title with the image title"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "show normal image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "show complex image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "show point"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "image header and content"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "make a copy of the image data to prevent read access violations",
                    "center the image to 0,0",
                    "update the pixmap item position"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "IPImageViewer_3349 updateImage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "calculate height",
                    "resize image based on height"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "calculate width",
                    "resize image based on width"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "get properties",
            "calculate height/width based on aspect_ratio",
            "apply image resizing"
        ],
        "FuncName": "IPLResize_2503 processInputData.txt"
    },
    {
        "Branch": [
            "image condition",
            "resize condition"
        ],
        "Loop": [
            "image loop",
            "resize loop"
        ],
        "Normal": [
            "initialize IPLResize",
            "configure basic settings",
            "configure inputs and outputs",
            "configure properties"
        ],
        "FuncName": "IPLResize_2503 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete on close: This option allows the viewer to delete the image after closing the viewer.",
            "layout()->setContentsMargins(0,0,0,0);: This line sets the layout margins to zero, allowing for a full-screen image view.",
            "add scene: This option adds a scene to the viewer, which is a container for the image.",
            "add view: This option adds a view to the viewer, which is a widget that displays the image.",
            "prevent scrollbars from catching mouse wheel events: This line prevents the scrollbars from interfering with the mouse wheel events, allowing for smooth navigation.",
            "graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);: This line sets the horizontal scrollbar policy to always off, ensuring that the viewer does not display a horizontal scrollbar.",
            "graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);: This line sets the vertical scrollbar policy to always off, ensuring that the viewer does not display a vertical scrollbar."
        ],
        "FuncName": "IPImageViewer_3349 IPImageViewer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "printf(long workspace_size);",
                    "printf(long workspace_size) with image description: prints the value of workspace_size as a long integer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "parser_4252 parse_network_cfg.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "checksum %08x\n",
                    "A hexadecimal checksum is calculated and displayed in the format %08x."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ustring_test_2504 create_lotso_ustrings.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "save convolutional neural network layer weights and biases.",
                    "save_convolutional_weights_binary(l, fp);",
                    "return;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "parser_4252 save_convolutional_weights.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Here we call the apply_to_contents() function on our type_safe_union.",
                    "It takes a function object and applies that function object",
                    "to the contents of the union.  In our case we have setup",
                    "the pipe_example class as our function object and so below we",
                    "tell the msg object to take whatever it contains and ",
                    "call (*this)(contained_object);   So what happens here is ",
                    "one of the three above functions gets called with the message ",
                    "we just got.  This is an image processing operation, where we apply various image filters to the input image.",
                    "The apply_to_contents() function is used to process the image data, and the result is a filtered image."
                ]
            }
        ],
        "Normal": [
            "Here we loop on messages from the message_pipe.  We are processing image data, and the loop condition is based on the presence of image data in the message pipe."
        ],
        "FuncName": "pipe_ex_2_2428 thread.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "load convolutional neural network weights from file, these are image code strings.",
                    "load_convolutional_weights_binary(l, fp);",
                    "return;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "load convolutional neural network weights from file, these are image code strings.",
                    "load_convolutional_weights_binary(l, fp);",
                    "return;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "image iteration, ",
                    "%g, "
                ]
            },
            {
                "loopstr": [
                    "image iteration, ",
                    "%g, "
                ]
            }
        ],
        "Normal": [
            "if the number of color channels is 3, scale the weights by 1/256, these are image code strings.",
            "if the weights are binary, binarize the weights, these are image code strings."
        ],
        "FuncName": "parser_4252 load_convolutional_weights.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "printf(Scales: %f mean %f variance\n, mean_array(l.scales, l.outputs), variance_array(l.scales, l.outputs));",
                    "printf(rolling_mean: %f mean %f variance\n, mean_array(l.rolling_mean, l.outputs), variance_array(l.rolling_mean, l.outputs));",
                    "printf(rolling_variance: %f mean %f variance\n, mean_array(l.rolling_variance, l.outputs), variance_array(l.rolling_variance, l.outputs));",
                    "Image description: The code is printing the mean and variance of the scales, rolling mean, and rolling variance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "printf(Biases: %f mean %f variance\n, mean_array(l.biases, l.outputs), variance_array(l.biases, l.outputs));",
            "printf(Weights: %f mean %f variance\n, mean_array(l.weights, l.outputs*l.inputs), variance_array(l.weights, l.outputs*l.inputs));",
            "Image description: The code is printing the mean and variance of the biases and weights."
        ],
        "FuncName": "parser_4252 load_connected_weights.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Two ustrings for image processing",
            "Make two ustringhash's from strings for image metadata",
            "Check copy construction, assignment, ==, !=",
            "Assignment from a ustring for image filename",
            "Ask a ustring for its ustringhash for image encoding",
            "ustring constructed from a ustringhash for image format",
            "string_view and string from ustringhash for image data",
            "clear and empty() for image buffer",
            "Can we get to the characters? in image text",
            "Check ==, != with strings, and with ustring's for image comparison",
            "OIIO_CHECK_EQUAL(hfoo, std::string(\"foo\")); for image file name",
            "OIIO_CHECK_NE(hbar, std::string(\"foo\")); for image file type",
            "Conversion to string for image metadata",
            "from_hash for image hash",
            "std::hash for image data integrity",
            "formatting string for image logging",
            "string literals for image constants"
        ],
        "FuncName": "ustring_test_2504 test_ustringhash.txt"
    },
    {
        "Branch": [
            "Check for hash collision in image code"
        ],
        "Loop": [
            "Verify hash collision in image code"
        ],
        "Normal": [
            "Try to force a hash collision in image code"
        ],
        "FuncName": "ustring_test_2504 verify_no_collisions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "copy the data that could be destroyed to an additional buffer in case input == output. This involves swapping the RGBA pixel bytes, which is a common operation in image processing."
        ],
        "FuncName": "DPXColorConverter_406 SwapRGBABytes.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Upsampling the YCbCr image to 4:4:4 format involves interpolating missing color values.",
                    "Proper interpolation is crucial to maintain image quality.",
                    "Cb and Cr are the blue and red color difference components.",
                    "Y is the luminance component.",
                    "Converting YCbCr to RGBA involves recreating the missing color values to produce a full RGB image.",
                    "This process requires the input and output buffers to be different."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DPXColorConverter_406 ConvertCbYACrYAToRGBA.txt"
    },
    {
        "Branch": [
            "An if condition is a statement that checks whether a certain condition is true or false, typically used in programming to control the flow of a program."
        ],
        "Loop": [
            "A loop condition is a statement that specifies the condition under which a loop will continue to execute, typically used in programming to repeat a set of instructions."
        ],
        "Normal": [
            "This is a threadsafe way to ensure that we only register it once. Image viewer provides a safe and efficient way to display images, ensuring that only one instance of the image is registered at a time."
        ],
        "FuncName": "ImageViewer_2174 ImageViewer.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "upsample to 4:4:4",
                    "proper interpolation",
                    "Cb",
                    "Y",
                    "Cr",
                    "convert YCbCr to RGB with proper color conversion"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DPXColorConverter_406 ConvertCbYCrYToRGB.txt"
    },
    {
        "Branch": [
            "YCbCr to RGB conversion: if chroma is out of range, clamp it to [-0.5; 0.5]"
        ],
        "Loop": [
            {
                "loopstr": [
                    "dot product of matrix row and YCbCr pixel vector",
                    "chroma must be put in the [-0.5; 0.5] range",
                    "Y",
                    "Cb",
                    "Cr",
                    "for some reason the R and B channels get swapped, put them back in the correct order",
                    "prevent overflow",
                    "R = Y + 1.402 * Cr",
                    "G = Y - 0.34414 * Cb - 0.71414 * Cr",
                    "B = Y + 1.772 * Cb"
                ]
            }
        ],
        "Normal": [
            "YCbCr to RGB conversion: R = Y + 1.402 * Cr, G = Y - 0.34414 * Cb - 0.71414 * Cr, B = Y + 1.772 * Cb"
        ],
        "FuncName": "DPXColorConverter_406 ConvertPixelYCbCrToRGB.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "actual gamma value is read later on. This is a characteristic of the Kodak Cineon image format, which uses a log-encoded gamma curve to represent the image data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "libcineon's date/time format is pretty close to OIIO's (libcineon uses %Y:%m:%d:%H:%M:%S%Z). This is an example of how the Cineon image format represents date and time information in the image metadata.",
                    "FIXME: do something about the time zone. This is a potential issue with the Cineon format, where the time zone is not explicitly specified."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "libcineon's date/time format is pretty close to OIIO's (libcineon uses %Y:%m:%d:%H:%M:%S%Z). This is an example of how the Cineon image format represents date and time information in the image metadata.",
                    "FIXME: do something about the time zone. This is a potential issue with the Cineon format, where the time zone is not explicitly specified."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "open the image. This is the first step in reading a Cineon image file.",
            "create imagespec. This object will hold the metadata and other information about the image.",
            "fill channel names. The Cineon format uses a specific naming convention for the color channels.",
            "bits per sample. The Cineon format uses a fixed number of bits per sample, which is 10 bits.",
            "image orientation - see appendix B.2 of the OIIO documentation. The Cineon format uses a specific orientation for the image data.",
            "This is not very smart, but it seems that as a practical matter, all Cineon files are log. So ignore the gamma field and just set the color space to KodakLog. This is a characteristic of the Kodak Cineon image format.",
            "image linearity. The Cineon format uses a log-encoded gamma curve to represent the image data.",
            "FIXME: making this more robust would require the per-channel transfer functionality which isn't yet in OIIO. This is a potential issue with the Cineon format, where the transfer function is not explicitly specified.",
            "gamma exponent. The Cineon format uses a specific exponent value to represent the gamma curve.",
            "general metadata. The Cineon format includes various metadata fields that provide information about the image.",
            "some non-compliant writers will dump a field filled with 0xFF rather than a NULL string termination on the first character, so take that into account, too. This is a potential issue with the Cineon format, where some writers may not follow the standard.",
            "cineon-specific metadata. The Cineon format includes various metadata fields that are specific to the Cineon format.",
            "image descriptor. The Cineon format uses a specific descriptor to represent the image data.",
            "save some typing by using macros. This is a potential optimization in the Cineon format, where macros can be used to reduce typing.",
            "macros. The Cineon format uses macros to represent various metadata fields.",
            "per-file attribs. The Cineon format includes various attribute fields that provide information about the image.",
            "per-element attribs. The Cineon format includes various attribute fields that provide information about the image elements.",
            "per-element data. The Cineon format includes various data fields that provide information about the image elements.",
            "read in user data. This is the final step in reading a Cineon image file."
        ],
        "FuncName": "cineoninput_8023 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fetch derived image item from HEIF image item",
                    "fetch derived image item from HEIF image item"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DerivedImageItem_8105 load.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do not allow mediaData from different media formats. This is related to image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 addImage.txt"
    },
    {
        "Branch": [
            "Check if image track exists and is not null, then add auxiliary reference."
        ],
        "Loop": [
            "Loop through each auxiliary track and check if it has handler type 'auxv'."
        ],
        "Normal": [
            "Add track reference from Auxl track to its image track.",
            "Auxl track shouldn't be played as such: auxiliary track should have handler type 'auxv'.",
            "Set AuxReferenceType: This will allow the auxiliary track to be referenced by the image track."
        ],
        "FuncName": "writermoovimpl_2465 addAuxiliaryReference.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "as per 7.5.2 Thumbnail image sequence track only pict allowed"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "create new thumbnail image sequence"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Add tracks to same Alternate Group",
            "Add track reference from Thumbnail track to its image track.",
            "flag thumbnail track as preview image"
        ],
        "FuncName": "writermoovimpl_2465 addThumbnails.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "timebase / timebase can't be zero",
                    "Image Sequence: a sequence of images stored in a single file."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "sequence.mediaId is filled when first sample is fed to Image Sequence: a sequence of images stored in a single file.",
            "sequence.maxDimensions is filled in finalize() when all DecoderSpecificInfo are gone through: metadata related to the image sequence.",
            "Flag 0x01 tells the data is in this file: indicates the presence of image data.",
            "DataEntryUrlBox will write only its header: metadata related to the image sequence."
        ],
        "FuncName": "writermoovimpl_2465 addImageSequence.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "non-visual track, set dimensions to 0: audio sample entry box, MP4"
        ],
        "FuncName": "writermoovimpl_2465 makeMP4AudioSampleEntryBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5220\u9664\u56fe\u7247\u63a7\u4ef6\uff0c\u91cd\u65b0\u52a0\u8f7d\u56fe\u50cf\uff0c\u66f4\u65b0\u56fe\u50cf\u89c6\u56fe"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u8fd9\u4e0d\u662f\u7535\u5f71\uff0c\u91cd\u65b0\u52a0\u8f7d\u56fe\u50cf\uff0c\u66f4\u65b0\u56fe\u50cf\u89c6\u56fe"
        ],
        "FuncName": "ImageViewer_2174 reload.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Achromatic case"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ImageViewer_2174 hslToRgb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "create new image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 setAlternateGrouping.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if the user pressed near the right edge, start with initial rotation of 0, adjust image rotation according to mouse position",
                    "qDebug() << image center << fulcrum << line << vector << angle << vector.angle() << geom << imageWidget->geometry(); adjust image position based on mouse position"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Force square, adjust image rotation and position based on mouse position"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ImageViewer_2174 mouseMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "loop samples with image processing"
        ],
        "FuncName": "writermoovimpl_2465 writeMoovHiddenSamples.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The edit list is repeated when (Flags & 1) is 1. Otherwise, it is not repeated. This is specified in the image code."
        ],
        "FuncName": "writermoovimpl_2465 createEditBox.txt"
    },
    {
        "Branch": [
            "If the condition is met, the code will execute."
        ],
        "Loop": [
            "The loop will iterate until the condition is met."
        ],
        "Normal": [
            "Assume mvhd timescale 1000. This is an image code snippet."
        ],
        "FuncName": "writermoovimpl_2465 addEmptyEdit.txt"
    },
    {
        "Branch": [
            "Check if condition is met and calculate total duration if true"
        ],
        "Loop": [
            "Check loop condition and calculate total duration for each iteration"
        ],
        "Normal": [
            "Set total duration based on repetitions",
            "Total duration is calculated by multiplying repetition count by duration of each repetition"
        ],
        "FuncName": "writermoovimpl_2465 getTrackDuration.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "modifies sequence.maxDimensions so needs to be done before trackHeaderBox dimensions setting.",
                    "This operation is related to image compression and requires proper image type handling."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "needs to be done first as it modifies sample compositionoffset for hidden samples.",
                    "This operation involves image processing and requires accurate image type management."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Track header flags:",
                    "If track is enabled",
                    "If track is used for presentation",
                    "If track is a preview track",
                    "Track references:",
                    "Sample Table writing:",
                    "Finalize trackheader now that all information is available:",
                    "to fixed point 16.16 value",
                    "to fixed point 16.16 value",
                    "Media duration:",
                    "Track duration:",
                    "Use track duration from edit list if it has been set.",
                    "These operations are crucial for image encoding and decoding."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 generateMoovBox.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "index start at 1 for SampleGroupDescriptionBox Entry",
                    "find index of SampleGroupDescriptionBox Entry",
                    "image processing: indexing SampleGroupDescriptionBox Entry"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "end old run if any",
                    "image processing: ending old run"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "sampleIndexes added for debug purposes.",
                    "image processing: adding sample indexes for debug"
                ]
            },
            {
                "loopstr": [
                    "creates new SampleToGroupBox for group",
                    "there can be several group boxes of same type.. this separates them based on GroupId",
                    "handle last sample if there is run still going",
                    "image processing: creating SampleToGroupBox for group"
                ]
            },
            {
                "loopstr": [
                    "0 index = not member of group",
                    "is this sample member of this group?",
                    "new run?",
                    "image processing: checking sample membership and run status"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 writeEquivalenceSampleGroup.txt"
    },
    {
        "Branch": [
            "Edit list must have one or more entries. Image editing requires a valid image file.",
            "Image type must be supported for editing."
        ],
        "Loop": [
            "Loop condition must be valid for image processing.",
            "Image loop must be properly configured for playback."
        ],
        "Normal": [
            "Edit list must have one or more entries.",
            "const auto mediaTimescale = trackBox->getMediaBox().getMediaHeaderBox().getTimeScale(); Image timescale must be set for proper playback."
        ],
        "FuncName": "writermoovimpl_2465 setEditList.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "stbl Box Data",
                    "list of all sync samples",
                    "first loop samples and fill in cumulative fields.",
                    "then write the actual boxes using data from above.",
                    "stco",
                    "stsz",
                    "stco",
                    "stss",
                    "stsc",
                    "stsd",
                    "image type: video"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "sample belongs to new chunk",
                    "image type: video"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "chunks:",
                    "sizes:",
                    "times (stts)",
                    "compositionTimes:",
                    "syncsamples",
                    "image type: video"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 writeMoovSampleTable.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "create unique sample group descriptor entries",
                    "add unique entries to SampleGroupDescriptionBox",
                    "image metadata item: SampleGroupDescriptionBox"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "there is existing entry",
                    "image metadata item: existing entry"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "version 1 for DefaultLength support",
                    "creates new SampleToGroupBox for group",
                    "close last sample run",
                    "image metadata item: SampleToGroupBox"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "index start at 1 for SampleGroupDescriptionBox Entry",
                    "find index of SampleGroupDescriptionBox Entry",
                    "image metadata item: SampleGroupDescriptionBox Entry"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "end old run if any",
                    "image metadata item: end old run"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "new unique entry?",
                    "image metadata item: new unique entry"
                ]
            },
            {
                "loopstr": [
                    "0 index = not member of group",
                    "new run?",
                    "image metadata item: new run"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 writeMetadataItemGroups.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Allow only for HEIF image sequences. Image type: HEIF"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Check if sequence is already member of this group. Image type: sequence"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Create new entry if one doesn't exist. Image type: new entry"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "writermoovimpl_2465 addToEquivalenceGroup.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "use addImage as internal functionality for samples is the same. Adding a sample to the video involves incorporating an image into the media."
        ],
        "FuncName": "writermoovimpl_2465 addVideo.txt"
    },
    {
        "Branch": [
            "If-condition with image code: Assume mvhd timescale 1000"
        ],
        "Loop": [],
        "Normal": [
            "Normal string with image description: Assume mvhd timescale 1000"
        ],
        "FuncName": "writermoovimpl_2465 addRawEdit.txt"
    },
    {
        "Branch": [
            "If the timescale is 1000, then"
        ],
        "Loop": [
            "Repeat the following condition"
        ],
        "Normal": [
            "Assume mvhd timescale 1000. This is an image codec that scales time to 1000 units per second."
        ],
        "FuncName": "writermoovimpl_2465 addShiftEdit.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: conditional statement for image processing"
        ],
        "Loop": [
            "Loop-Condition-Str: loop condition for image processing"
        ],
        "Normal": [
            "Normal-Str: Assume mvhd timescale 1000, image processing with 1000 timescale"
        ],
        "FuncName": "writermoovimpl_2465 addDwellEdit.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Displaying image: image im = float_to_image(256, 256, 3, train.X.vals[114]); show_image(im, \\training\\); cvWaitKey(0); ",
                    "Loaded: %lf seconds",
                    "%d: %f, %f avg, %lf seconds, %d images"
                ]
            }
        ],
        "Normal": [
            "Learning Rate: %g, Momentum: %g, Decay: %g",
            "%d",
            "Displaying image: %s"
        ],
        "FuncName": "captcha_7320 train_captcha.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Show image: Predicted in 0.123456 seconds.",
                    ", "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Show image: Predicted in 0.123456 seconds.",
                    "%n"
                ]
            },
            {
                "loopstr": [
                    "Show image: %s in %f seconds."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "captcha_7320 test_captcha.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "timebase / timebase can't be zero",
                    "Adding audio track to HEIF movie implementation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "sequence.mediaId is filled when first sample is fed to Image Sequence",
            "sequence.maxDimensions is filled in finalize() when all DecoderSpecificInfo are gone through",
            " = default value 1.0 / full volume",
            "Flag 0x01 tells the data is in this file.",
            "DataEntryUrlBox will write only its header.",
            "Audio track integration enhances HEIF movie functionality."
        ],
        "FuncName": "writermoovimpl_2465 addAudioTrack.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Adding audio data to writer. use addImage as internal functionality for samples is the same, which involves processing audio data and storing it in the writer object."
        ],
        "FuncName": "writermoovimpl_2465 addAudio.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete object;"
        ],
        "FuncName": "IPLCanny_4041 destroy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "Canny edge detection initialization",
            "edge detection parameters",
            "image processing",
            "edge map generation"
        ],
        "FuncName": "IPLCanny_4041 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Receive the next character from the client and echo it back as an uppercase letter.",
                    "This is a process related to image processing, where the client sends a character and the server responds with the same character in uppercase."
                ]
            }
        ],
        "Normal": [
            "The connection details are stored in the last few arguments of the on_connect() function.",
            "For more information, see the server_iostream documentation.",
            "The two main streams of interest are the details of the connection.",
            "We also print the IP address of the remote machine.",
            "Process the stream until it ends, which happens when the connection terminates.",
            "This process is related to image processing, where the server receives and responds to client data."
        ],
        "FuncName": "server_iostream_ex_8491 on_connect.txt"
    },
    {
        "Branch": [
            "Check if the condition is met for image processing."
        ],
        "Loop": [
            "Loop through each image in the dataset."
        ],
        "Normal": [
            "Note that we must add one because of the convention that high equals the real upper range minus one for image analysis."
        ],
        "FuncName": "entropy_decoder_kernel_1_7845 get_target.txt"
    },
    {
        "Branch": [
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code."
        ],
        "Loop": [
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code."
        ],
        "Normal": [
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: round 1",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 1",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 2",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 3",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 4",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 5",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 6",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 7",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 8",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 9",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 10",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 11",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 12",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 13",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 14",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 15",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 16",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: Round 2 ",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 17",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 18",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 19",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 20",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 21",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 22",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 23",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 24",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 25",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 26",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 27",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 28",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 29",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 30",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 31",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 32",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: Round 3 ",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 33",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 34",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 35",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 36",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 37",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 38",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 39",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 40",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 41",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 42",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 43",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 44",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 45",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 46",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 47",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 48",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: Round 4 ",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 49",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 50",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 51",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 52",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 53",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 54",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 55",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 56",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 57",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 58",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 59",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 60",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 61",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 62",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 63",
            "Mixing four 32-bit unsigned integers a, b, c, d and a 32-bit integer array x in image code: 64"
        ],
        "FuncName": "md5_kernel_1_1977 scramble_block.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "force some environment variables for image rendering",
            "if this environment variable is set by another application, the image plugin may fail to load",
            "related issue: https://github.com/easymodo/qimgv/issues/410",
            "for high-definition pixel testing",
            "set QT_SCALE_FACTOR to 1.5",
            "set QT_SCREEN_SCALE_FACTORS to 1;1.7",
            "is this variable still necessary?",
            "some Qt5 high-definition pixel variables",
            "Qt6 high-definition pixel rendering on Windows still has artifacts",
            "this disables it for scale factors less than 1.75",
            "only fonts are scaled in this case",
            "print QT_SCALE_FACTOR environment variable",
            "print QT_SCREEN_SCALE_FACTORS environment variable",
            "print QT_ENABLE_HIGHDPI_SCALING environment variable",
            "default to Fusion if available (macOS has layout bugs, weird combo boxes, etc)",
            "use some style workarounds for image rendering",
            "needed for mpv image rendering",
            "default value of 128k causes memory fragmentation issues for image rendering",
            "use custom types in signals for image rendering",
            "globals for image rendering",
            "parse command line arguments for image rendering",
            " -----------------------------------------------------------------------------",
            "wait for event queue to catch up before showing the image window",
            "this avoids white background flicker on Windows (or not?)"
        ],
        "FuncName": "main_450 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " make sure buf isn't empty to avoid division by zero",
                    " we will be taking one bit from buf to replace the one we threw away, which is a common operation in entropy encoding",
                    " roll off the bit in target, a crucial step in entropy decoding",
                    " roll off the bit, a fundamental operation in entropy coding",
                    " note that it is ok to add one to high here because of the convention that high == real upper range - 1, which is a common convention in entropy encoding",
                    " so that means that if we want to shift the upper range left by one then we must shift a one into high also since real upper range == high + 0.999999999..., a subtle detail in entropy decoding",
                    " make sure low is never zero to avoid overflow",
                    " take a bit from buf to fill in the one we threw away, a key step in entropy encoding"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " if there isn't anything else in the streambuffer then just make buf zero, a common default value in entropy encoding"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " check if the highest order bit in high and low is the same, a common check in entropy decoding",
                    " if the distance between high and low is small and there aren't any bits we can roll off then round low up or high down, a key step in entropy encoding"
                ]
            }
        ],
        "Normal": [
            " note that we must subtract 1 to preserve the convention that high == the real upper range - 1, a common convention in entropy encoding",
            " while (true), an infinite loop commonly used in entropy decoding"
        ],
        "FuncName": "entropy_decoder_kernel_1_7845 decode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "static unsigned char lut2[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0..."
        ],
        "FuncName": "IPLCanny_4041 thinning.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Normal map with image processing capabilities.",
                    "HDR image processing.",
                    "SDF image processing.",
                    "RGBA8 image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "texturec_4990 convert.txt"
    },
    {
        "Branch": [
            "Condition to check if a type is an image code."
        ],
        "Loop": [
            "Condition to check if a loop is an image code."
        ],
        "Normal": [
            " Same type already done.",
            " Canonicalize a size in bytes is >= b size in bytes This",
            " unclutters remaining cases.",
            " Double or float trump anything else",
            " Out of common cases For all remaining edge cases punt and say that",
            " we prefer float."
        ],
        "FuncName": "typedesc_1220 basetype_merge.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error: %s (image type: string)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Usage: texturec -f <in> -o <out> [-t <texture format>]\n\n\t\t  \n\n\t\t  Supported file formats:\n\n\t\t      *.bmp (input)          Windows Bitmap (image type: raster).\n\n\t\t      *.dds (input, output)  Direct Draw Surface (image type: texture).\n\n\t\t      *.exr (input, output)  OpenEXR (image type: high dynamic range).\n\n\t\t      *.gif (input)          Graphics Interchange Format (image type: raster).\n\n\t\t      *.jpg (input)          JPEG Interchange Format (image type: compressed).\n\n\t\t      *.hdr (input, output)  Radiance RGBE (image type: high dynamic range).\n\n\t\t      *.ktx (input, output)  Khronos Texture (image type: compressed).\n\n\t\t      *.png (input, output)  Portable Network Graphics (image type: raster).\n\n\t\t      *.psd (input)          Photoshop Document (image type: raster).\n\n\t\t      *.pvr (input)          PowerVR (image type: compressed).\n\n\t\t      *.tga (input)          Truevision TGA (image type: raster).\n\n\n\t\t  \n\n\t\t  Options:\n\n\t\t    -h, --help               Help (image type: string).\n\n\t\t    -v, --version            Version information only (image type: string).\n\n\t\t    -f <file path>           Input file path (image type: string).\n\n\t\t    -o <file path>           Output file path (image type: string).\n\n\t\t    -t <format>              Output format type (BC1/2/3/4/5, ETC1, PV..."
        ],
        "FuncName": "texturec_4990 help.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create a thread that will call thread_1 with argument 45.6",
            "wait for the t1 thread to end",
            "create a thread that will call thread_1 with argument 9.999",
            "wait for the t2 thread to end",
            "create a thread that will call thread_2",
            "Note that we can also use the ref() function to pass a variable to a thread by reference. For example, the thread below adds one to val.",
            "to a thread by reference.  For example, the thread below adds one to val.",
            "wait for t4 to finish before printing val.",
            "Print val.  It will now have a value of 3.",
            "At this point we will automatically wait for t3 to end because the destructor for thread_function objects always wait for their thread to terminate."
        ],
        "FuncName": "thread_function_ex_6905 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Replicating the logic in OpenEXR, but this prevents us from needing to link to libIlmImf just to do this. Image code requires string representation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Perhaps there is a way to use CType<> with a dynamic argument? Image code requires string representation."
        ],
        "FuncName": "typedesc_1220 tostring.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "already solved",
                    "image type: a type that represents an image or a visual representation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "malformed",
                    "image type: a type that represents an image or a visual representation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "The first word should be a type name.",
            "Check the scalar types in our table above",
            "Some special case names for aggregates",
            "Is there an array length following the type name? image type: a type that represents an image or a visual representation"
        ],
        "FuncName": "typedesc_1220 fromstring.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " how about a per-thread cache of the last one or two so",
            " we don't have to re assemble strings all the time",
            " Timecode and Keycode are hard coded",
            " else if (aggregate  MATRIX44  basetype  FLOAT, a 4x4 matrix type)",
            "     result  \\matrix\\;",
            " else if (aggregate  MATRIX33  basetype  FLOAT, a 3x3 matrix type)",
            "     result  \\matrix33\\;",
            " else if (aggregate  VEC2  basetype  FLOAT  vecsemantics  NOXFORM, a 2D vector with no transformation)",
            "     result  \\float2\\;",
            " else if (aggregate  VEC4  basetype  FLOAT  vecsemantics  NOXFORM, a 4D vector with no transformation)",
            "     result  \\float4\\;",
            " More unusual cases"
        ],
        "FuncName": "typedesc_1220 c_str.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handle multiple values by turning into or expanding array length. This can be achieved by converting the source type to an array of the target type."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Only succeed for a string if it exactly holds something that exactly parses to an int value. This requires the source type to be converted to the target type, specifically int."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Only succeed for a string if it exactly holds something that exactly parses to a float value. This requires the source type to be converted to the target type, specifically float."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "N.B. No uint conversion from string. This means that the source type cannot be converted to the target type, uint."
        ],
        "FuncName": "typedesc_1220 convert_type.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error:\n%s\n\n"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Usage: texturec -f <in> -o <out> [-t <texture format>]\n\n\n\t\t  \n\n\t\t  Supported file formats:\n\n\t\t      *.bmp (input)          Windows Bitmap.\n\n\t\t      *.dds (input, output)  Direct Draw Surface.\n\n\t\t      *.exr (input, output)  OpenEXR.\n\n\t\t      *.gif (input)          Graphics Interchange Format.\n\n\t\t      *.jpg (input)          JPEG Interchange Format.\n\n\t\t      *.hdr (input, output)  Radiance RGBE.\n\n\t\t      *.ktx (input, output)  Khronos Texture.\n\n\t\t      *.png (input, output)  Portable Network Graphics.\n\n\t\t      *.psd (input)          Photoshop Document.\n\n\t\t      *.pvr (input)          PowerVR.\n\n\t\t      *.tga (input)          Truevision TGA.\n\n\n\t\t  \n\n\t\t  Options:\n\n\t\t    -h, --help               Help.\n\n\t\t    -v, --version            Version information only.\n\n\t\t    -f <file path>           Input file path.\n\n\t\t    -o <file path>           Output file path.\n\n\t\t    -t <format>              Output format type (BC1/2/3/4/5, ETC1, PVRTC, ETC2, ASTC, ATC, BC5, BC6H, BC7, ETC2A, ETC2_EAC, ETC2_R11F_G11F_B10F, ETC2_SRGB, ETC2_EAC_R11F_G11F_B10F, ETC2_SRGB_R11F_G11F_B10F).\n\n\t\t  Note: For more information, please refer to the official documentation of the texture format."
        ],
        "FuncName": "texturec_4990 help.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Open the directory where the current image file is located in the file manager."
        ],
        "FuncName": "mainwindow_5089 on_actionLocateInFileManager_triggered.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete previous result",
            "get properties",
            "int progress = 0;",
            "int maxProgress = image->height() * image->getNumberOfPlanes();",
            "apply Gabor filter to image data",
            "extract features from filtered image"
        ],
        "FuncName": "IPLGabor_8340 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "allow some mouse events can go through these widgets for resizing window, such as dragging the window borders or resizing handles."
        ],
        "FuncName": "mainwindow_5089 MainWindow.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "Gabor filter initialization",
            "Gabor filter settings",
            "Gabor filter inputs",
            "Gabor filter outputs",
            "Gabor filter properties"
        ],
        "FuncName": "IPLGabor_8340 init.txt"
    },
    {
        "Branch": [
            "Check the condition before switching to chessboard mode"
        ],
        "Loop": [
            "Verify the loop condition before switching to chessboard mode"
        ],
        "Normal": [
            "TODO: is that okay to do this since we plan to support custom shortcuts? Consider the implications of switching to chessboard mode"
        ],
        "FuncName": "mainwindow_5089 on_actionToggleCheckerboard_triggered.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "NOTE: Only checking angleDelta since the QWheelEvent::pixelDelta() doc says",
            "       pixelDelta() value is driver specific and unreliable on X11...",
            "       We are not scrolling the canvas, just zoom in or out, so it probably",
            "       doesn't matter here.",
            "       Handling mouse wheel event to zoom in or out images based on wheel direction and mouse button state."
        ],
        "FuncName": "mainwindow_5089 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The forward/back mouse button can also be used to trigger a mouse double-click event. This is a common behavior in image galleries, where clicking on the forward or back button can trigger a double-click event.",
            "Since we use that for gallery navigation so we ignore these two buttons. Ignoring these buttons allows us to focus on the primary mouse double-click event.",
            "blumia: don't call parent constructor here, seems it will cause mouse move. This is a crucial step in handling mouse events, and ensuring that the double-click event is properly handled.",
            "return QMainWindow::mouseDoubleClickEvent(event); This function handles the mouse double-click event and returns the result."
        ],
        "FuncName": "mainwindow_5089 mouseDoubleClickEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "qDebug prints m_oldMousePos and m_graphicsView transform m11",
                    "and m_graphicsView transform m22 and m_graphicsView matrix m12",
                    "when mouse left button is clicked and mouse position recorded and window state tracked"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "mainwindow_5089 mousePressEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "It seems the forward/back mouse button won't generate a key event so we can't use",
            "QShortcut or QKeySequence to indicate these shortcuts, so we do it here.",
            "Reference:",
            "https://codereview.qt-project.org/c/qt/qtbase/+/177475",
            "Handling mouse release event, navigating forward and backward buttons."
        ],
        "FuncName": "mainwindow_5089 mouseReleaseEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delete previous result and apply image gradient calculation",
            "get properties of image",
            "generate grayscale magnitude and phase of image",
            "make compiler happy with image processing"
        ],
        "FuncName": "IPLGradientOperator_3060 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Remove and call thread-related callback functions. These strings are from image code."
        ],
        "FuncName": "threads_kernel_shared_6101 call_end_handlers.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress",
                    "image gradient"
                ]
            },
            {
                "loopstr": [
                    "phase 0.0-1.0",
                    "image Roberts gradient"
                ]
            }
        ],
        "Normal": [
            "fast gradient",
            "image gradient"
        ],
        "FuncName": "IPLGradientOperator_3060 roberts.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "unsigned char image_data[x.size()];",
            "int width = 512;",
            "int height = 512;",
            "int bytes_per_row = 512;",
            "bool suppress_non_max = false;",
            "Corner detection using Corner Detection algorithm.",
            "Image corners are detected using a specific algorithm.",
            "Image corners are essential for image processing and analysis."
        ],
        "FuncName": "f9_rcpp_2237 detect_corners.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress: computing gradient and phase of image"
                ]
            },
            {
                "loopstr": [
                    "phase 0.0-1.0: computing gradient and phase of image"
                ]
            }
        ],
        "Normal": [
            "fast gradient: computing gradient and phase of image"
        ],
        "FuncName": "IPLGradientOperator_3060 fastGradient.txt"
    },
    {
        "Branch": [
            "Check if data is ready, then process it and start a thread.",
            "Return to the pool if not ready.",
            "Exit the loop and end the thread if timed out and no work is available."
        ],
        "Loop": [
            "Indicates the thread is not in the thread pool.",
            "Get the data required for the function call.",
            "Indicate that the data is empty.",
            "Call the function with the parameters. If the function raises an exception,",
            "allow the exception to escape the thread and let the OS handle it (usually the program will terminate).",
            "Indicate that the thread is now back in the thread pool."
        ],
        "Normal": [
            "Get a reference to the calling thread object.",
            "Automatically lock the M(self.data_mutex) block end."
        ],
        "FuncName": "threads_kernel_shared_6101 thread_starter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initialize the image gradient operator.",
            "Basic settings for image processing.",
            "Input and output parameters for image analysis.",
            "Set OpenCV support for image processing.",
            "Image properties and metadata."
        ],
        "FuncName": "IPLGradientOperator_3060 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "figure out what rectangle we want to crop from the image, considering the image's resolution and aspect ratio",
            "randomly shift the box around within the image's bounds to create a unique cropping area"
        ],
        "FuncName": "dnn_semantic_segmentation_train_ex_5895 make_random_cropping_rect.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress",
                    "std::cout << coeff << std::endl;",
                    "phase 0.0-1.0",
                    "Computing gradient and direction of an image"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "IPLGradientOperator_3060 cubicSpline.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Example code fragment from the docs goes here.",
            "It probably should generate either some text output, which will show up in out.txt that captures each test's output, or produce a small image file that can be compared against a reference image in the ref/ subdirectory of this test.",
            "The generated text or image should be related to image processing or computer vision."
        ],
        "FuncName": "docs-examples-imagecache_314 example1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reserved = 0",
                    "Audio image type: If-Condition"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Audio image type: Loop-Condition",
            "Loop-Condition: This field is not used in this example"
        ],
        "Normal": [
            "reserved = 0",
            "Audio image type: Normal",
            "Number of channels: 1 (mono) or 2 (stereo)",
            "Bits: 16",
            "Pre-defined: 0",
            "Reserved: 0",
            "32-bit field expressed as 16.16 fixed-point number (hi.lo)"
        ],
        "FuncName": "audiosampleentrybox_6433 writeBox.txt"
    },
    {
        "Branch": [
            "Check if the image is loaded correctly."
        ],
        "Loop": [
            {
                "loopstr": [
                    " Load the input image.",
                    " Load the ground-truth (RGB) labels.",
                    " Create predictions for each pixel. At this point, the type of each prediction",
                    " is an index (a value between 0 and 20). Note that the net may return an image",
                    " that is not exactly the same size as the input.",
                    " Convert the RGB values to indexes.",
                    " Crop the net output to be exactly the same size as the input.",
                    " Compare the predicted values to the ground-truth values.",
                    " Calculate the accuracy for each pixel."
                ]
            }
        ],
        "Normal": [
            " Calculate the overall accuracy estimate."
        ],
        "FuncName": "dnn_semantic_segmentation_train_ex_5895 calculate_accuracy.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "progress\u65b9\u5411"
                ]
            }
        ],
        "Normal": [
            "fast gradient\u5f3a\u5ea6"
        ],
        "FuncName": "IPLGradientOperator_3060 sobel.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "skip box size",
                    "AVIF animation detected"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "documentinfo_9037 detectAnimatedAvif.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u9700\u8981\u91cd\u7f6e\u6bd4\u7279\u6d41\u4f4d\u7f6e\uff0c\u56e0\u4e3aESDS\u5c5e\u4e8e\u6269\u5c55\u6b64\u76d2\u5b50\u7684\u76d2\u5b50"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u4e0d\u652f\u6301\u7684\u76d2\u5b50\u4f1a\u88ab\u8df3\u8fc7"
                ]
            }
        ],
        "Normal": [
            "\u5728v0\u76d2\u5b50\u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u662f32\u4f4d\u4fdd\u7559\u503c\u7684\u7b2c\u4e00\u534a=0",
            "\u4fdd\u7559\u503c=0\uff08\u5176\u4ed632\u4f4d\u5728v0\u97f3\u9891\u6837\u672c\u6761\u76ee\u4e2d\uff09",
            "\u4fdd\u7559\u503c=0",
            "\u901a\u9053\u65701\uff08\u5355\u58f0\u9053\uff09\u62162\uff08\u7acb\u4f53\u58f0\uff09",
            "\u4ee516\u4f4d\u8868\u793a\u5e76\u53d6\u9ed8\u8ba4\u503c",
            "\u9884\u5b9a\u4e49\u503c=0",
            "\u4fdd\u7559\u503c=0",
            "\u4ee516.16\u56fa\u5b9a\u70b9\u6570\u8868\u793a\u768432\u4f4d\u5b57\u6bb5\uff08hi.lo\uff09",
            "\u5982\u679c\u5b58\u5728\u5219\u8bfb\u53d6\u53ef\u9009\u76d2\u5b50\uff0c\u76f4\u5230\u627e\u5230\u2018esds\u2019\u76d2\u5b50"
        ],
        "FuncName": "audiosampleentrybox_6433 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Randomly crop the input image.",
            "Crop the labels correspondingly, taking into account that bilinear interpolation is not applicable, as it would imply a bicycle is half-way between an aeroplane and a bird.",
            "Randomly flip the input image and the labels.",
            "Randomly adjust the colors of the image."
        ],
        "FuncName": "dnn_semantic_segmentation_train_ex_5895 randomly_crop_image.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compute the name length if it hasn't already been computed",
            "determine the position of the name string",
            "now draw the button's edge with an image of a toggle button"
        ],
        "FuncName": "style_1758 draw_toggle_button.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " compute the name length if it hasn't already been computed",
            " figure out where the name string should appear",
            " now draw the edge of the button with a rounded rectangle image"
        ],
        "FuncName": "style_1758 draw_toggle_button.txt"
    },
    {
        "Branch": [
            "check the condition for if statement",
            "evaluate the condition for if statement"
        ],
        "Loop": [
            "check the condition for loop statement",
            "evaluate the condition for loop statement"
        ],
        "Normal": [
            "compute the name length if it hasn't already been computed",
            "figure out where the name string should appear",
            "render the button image for the specified name",
            "display the button image for the specified name"
        ],
        "FuncName": "style_1758 draw_button.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if the length is too small then we have to smash up the arrow buttons and hide the slider",
            "image slider length calculation"
        ],
        "FuncName": "style_1758 get_slider_length.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compute the name length if it hasn't already been computed with an arrow icon",
            "figure out where the name string should appear in a diagrammatic representation"
        ],
        "FuncName": "style_1758 draw_button.txt"
    },
    {
        "Branch": [
            "check if the button is enabled or disabled"
        ],
        "Loop": [
            "iterate over the button's states"
        ],
        "Normal": [
            "compute the name length if it hasn't already been computed",
            "figure out where the name string should appear",
            "now draw the edge of the button with a rounded corner and a gradient effect"
        ],
        "FuncName": "style_1758 draw_toggle_button.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "usage: img_diff_ipol image1 image2 sigma difference - calculates the difference between two PNG images and saves the result as another PNG image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: %s not found or not a correct PNG image - an error occurred while trying to read one of the input images."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - the image does not have an alpha channel, so it will be ignored during the processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - the image does not have an alpha channel, so it will be ignored during the processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nc equals 3 - the number of color channels in the image is 3 (red, green, blue)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: %s not found or not a correct PNG image - an error occurred while trying to read one of the input images."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - the image does not have an alpha channel, so it will be ignored during the processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - the image does not have an alpha channel, so it will be ignored during the processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nc2 equals 3 - the number of color channels in the second image is 3 (red, green, blue)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: input images of different size or number of channels - the input images have different sizes or numbers of channels, which is not allowed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "... failed to save PNG image %s - an error occurred while trying to save the output image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "read input1 - read the first input image.",
            "test if image is really a color image even if it has more than one channel - check if the image has the correct number of color channels.",
            "read input2 - read the second input image.",
            "test if image is really a color image even if it has more than one channel - check if the image has the correct number of color channels.",
            "test if same size - check if the two images have the same size.",
            "variables - declare variables for the image processing.",
            "compute difference and convert from [-4 sigma, 4 sigma] to [0,255] - calculate the difference between the two images and convert the result to the correct range.",
            "save noisy and denoised images - save the output images."
        ],
        "FuncName": "img_diff_ipol_3911 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "make a mini-batch with images of type image"
                ]
            }
        ],
        "Normal": [
            "a mini-batch of images smaller than the default can be used with GPUs having less memory for image processing",
            "This threshold is probably excessively large for image segmentation.",
            "Since the progress threshold is so large might as well set the batch normalization stats window to something big too for image classification.",
            "Output training parameters for image training.",
            "Start a bunch of threads that read images from disk and pull out random crops of type image.  It's important to be sure to feed the GPU fast enough to keep it busy.  Using multiple threads for this kind of data preparation helps us do that.  Each thread puts the crops into the data queue for image data.",
            "The main training loop for image training.  Keep making mini-batches of images and giving them to the trainer.",
            "We will run until the learning rate has dropped by a factor of 1e-4 for image training.",
            "Training done, tell threads to stop and make sure to wait for them to finish before moving on for image inference.",
            "also wait for threaded processing to stop in the trainer for image processing.",
            "Make a copy of the network to use it for image inference.",
            "Find the accuracy of the newly trained network on both the training and the validation sets for image classification."
        ],
        "FuncName": "dnn_semantic_segmentation_train_ex_5895 main.txt"
    },
    {
        "Branch": [
            "check if the condition is met and draw an arrow if true"
        ],
        "Loop": [
            "check the loop condition and draw an arrow if it's met"
        ],
        "Normal": [
            "compute the name length if it hasn't already been computed",
            "figure out where the name string should appear",
            "draw a button with an arrow pointing to the name string"
        ],
        "FuncName": "style_1758 draw_button.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compute the name length if it hasn't already been computed",
            "figure out where the name string should appear"
        ],
        "FuncName": "style_1758 draw_button.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " FIXME: we should support Exif/IPTC, but currently don't. This includes image metadata such as camera settings, location, and copyright information."
        ],
        "FuncName": "jpeg2000input_3154 supports.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " JPEG2000 specifically dictates unassociated (un-premultiplied) alpha.",
            " Convert to associated unless we were requested not to do so.",
            " JPEG2000 image scanning involves reading pixels along horizontal lines.",
            " This scanning process is a fundamental aspect of JPEG2000 image decoding."
        ],
        "FuncName": "jpeg2000input_3154 read_native_scanline.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " errorfmt(Could not decode ICC profile: {}\n, errormsg);",
                    " return false;",
                    " Nah, just skip an ICC specific error? (Image decoding error occurred.)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " std::cout <<  chan << i << \n;",
                    " std::cout <<     dx= << comp.dx <<  dy= << comp.dy",
                    "           <<     x0= << comp.x0 <<  y0= << comp.y0",
                    "           <<     w= << comp.w <<  h= << comp.h",
                    "           <<     prec= << comp.prec <<  bpp= << comp.bpp << \n;",
                    " std::cout <<     sgnd= << comp.sgnd <<  resno_decoded= << comp.resno_decoded <<  factor= << comp.factor << \n;",
                    " std::cout <<     roichan= << roichan << \n;",
                    " (Image component: channel {}, index {}, dimension {}, position {}, size {}, precision {}, bits per pixel {})"
                ]
            }
        ],
        "Normal": [
            " Set up multithread in OpenJPEG library -- added in OpenJPEG 2.2,",
            " but it doesn't seem reliably safe until 2.4.",
            " opj_stream_set_write_function(m_stream, StreamWrite);",
            " we support only one, three or four components in image",
            " std::cout << overall x0= << m_image->x0 <<  y0= << m_image->y0",
            "           <<     x1= << m_image->x1 <<  y1= << m_image->y1 << \n;",
            " std::cout << color_space= << m_image->color_space << \n;",
            " (Image metadata: x0 {}, y0 {}, x1 {}, y1 {}, color space {})"
        ],
        "FuncName": "jpeg2000input_3154 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u9996\u5148\u586b\u5145\u533a\u57df\u80cc\u666f\u989c\u8272",
                    "\u586b\u5145\u533a\u57df\u80cc\u666f\u989c\u8272\u4e3a(image)\u7684\u6807\u51c6\u989c\u8272"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5982\u679c\u7a81\u51fa\u6587\u672c\u5168\u90e8\u5728\u4e00\u884c",
                    "\u7a81\u51fa\u6587\u672c\u5168\u90e8\u5728\u4e00\u884c(image)\u7684\u6807\u51c6\u6837\u5f0f"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u73b0\u5728\u7ed8\u5236\u7a81\u51fa\u6587\u672c(image)\u7684\u6807\u51c6\u7a81\u51fa\u6548\u679c",
            "\u73b0\u5728\u7ed8\u5236\u5149\u6807\u5982\u679c\u9700\u8981(image)\u7684\u6807\u51c6\u5149\u6807\u6837\u5f0f"
        ],
        "FuncName": "style_1758 draw_text_box.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "errorfmt(Could not decode ICC profile: {} errormsg);",
                    "return false;",
                    "Nah, just skip an ICC specific error? This might be due to a corrupted or unsupported ICC profile.",
                    " ICC profiles are used to describe the color characteristics of a device, such as a monitor or printer.",
                    "This error could also be caused by a missing or invalid ICC profile."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "std::cout <<  chan  << i << \n;",
                    "std::cout <<     dx= << comp.dx <<  dy= << comp.dy",
                    "           <<  x0= << comp.x0 <<  y0= << comp.y0",
                    "           <<  w= << comp.w <<  h= << comp.h",
                    "           <<  prec= << comp.prec <<  bpp= << comp.bpp << \n;",
                    "std::cout <<     sgnd= << comp.sgnd <<  resno_decoded= << comp.resno_decoded <<  factor= << comp.factor << \n;",
                    "std::cout <<     roichan= << roichan << \n;",
                    "This is a loop that iterates over the image components. Each component represents a single band or channel of the image.",
                    "The variables used in this loop are related to the image's spatial resolution, precision, and bit depth."
                ]
            }
        ],
        "Normal": [
            "Set up multithread in OpenJPEG library -- added in OpenJPEG 2.2,",
            "but it doesn't seem reliably safe until 2.4.",
            "opj_stream_set_write_function(m_stream, StreamWrite);",
            "we support only one, three or four components in image",
            "std::cout << overall x0= << m_image->x0 <<  y0= << m_image->y0",
            "           <<  x1= << m_image->x1 <<  y1= << m_image->y1 << \n;",
            "std::cout << colorspace= << m_image->color_space << \n;",
            "This code is setting up a multithreaded environment in the OpenJPEG library, which is used for JPEG 2000 image processing.",
            "The code is also printing out information about the image, including its size, color space, and other metadata."
        ],
        "FuncName": "jpeg2000input_3154 open.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "let the svm_pegasos learn about this sample",
                    "save this sample so we can use it with the batch training examples below",
                    "image: a sample vector used for learning"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Make a random sample vector.",
                    "Now if that random vector is less than 10 units from the origin then it is in",
                    "the +1 class.",
                    "image: a random vector used for classification"
                ]
            }
        ],
        "Normal": [
            "The svm functions use column vectors to contain a lot of the data on which they",
            "operate. So the first thing we do here is declare a convenient typedef.",
            "This typedef declares a matrix with 2 rows and 1 column.",
            "It will be the object that contains each of our 2 dimensional samples.",
            "Note that if you wanted more than 2 features in this vector you can simply",
            "change the 2 to something else.",
            "Or if you don't know how many features you want until runtime then you can",
            "put a 0 here and use the matrix.set_size() member function)",
            "This is a typedef for the type of kernel we are going to use in this example.",
            "In this case I have selected the radial basis kernel that can operate on our",
            "2D sample_type objects",
            "Here we create an instance of the pegasos svm trainer object we will be using.",
            "Here we setup the parameters to this object.",
            "See the dlib documentation for a description of what these parameters are.",
            "Set the maximum number of support vectors we want the trainer object to use",
            "in representing the decision function it is going to learn.",
            "In general, supplying a bigger number here will only ever give you a more accurate",
            "answer.",
            "However, giving a smaller number will make the algorithm run faster",
            "and decision rules that involve fewer support vectors also take less time to evaluate.",
            "make an instance of a sample matrix so we can use it below",
            "Now let's go into a loop and randomly generate 1000 samples.",
            "Now we have trained our SVM.",
            "Let's see how well it did.",
            "Each of these statements prints out the output of the SVM given a particular sample.",
            "The SVM outputs a number > 0 if a sample is predicted to be in the +1 class and < 0",
            "if a sample is predicted to be in the -1 class.",
            "The previous part of this example program showed you how to perform online training",
            "with the pegasos algorithm.",
            "But it is often the case that you have a dataset and you just want to perform batch learning on that dataset and get the resulting decision",
            "function.",
            "To support this the dlib library provides functions for converting an online",
            "training object like svm_pegasos into a batch training object.",
            "First let's clear out anything in the trainer object.",
            "Now to begin with, you might want to compute the cross validation score of a trainer object",
            "on your data.",
            "To do this you should use the batch_cached() function to convert the svm_pegasos object",
            "into a batch training object.",
            "Note that the second argument to batch_cached() is the minimum learning rate the trainer object must report for the batch_cached() function to consider training",
            "complete.",
            "So smaller values of this parameter cause training to take longer but may result",
            "in a more accurate solution.",
            "Here we perform 4-fold cross validation and print the results",
            "Here is an example of creating a decision function.",
            "Note that we have used the verbose_batch_cached() function instead of batch_cached() as above.",
            "They do the same things except verbose_batch_cached() will print status messages to standard output while training is under way.",
            "At this point we have obtained a decision function from the above batch mode training.",
            "Now we can use it on some test samples exactly as we did above.",
            "image: a sample vector used for learning and classification",
            "image: a decision function obtained from batch mode training"
        ],
        "FuncName": "svm_pegasos_ex_5391 main.txt"
    },
    {
        "Branch": [
            "Show if condition: ",
            "message_box(list_box,lb[idx])"
        ],
        "Loop": [
            "Show loop condition: ",
            "message_box(list_box,lb[idx])"
        ],
        "Normal": [
            "Show message: ",
            "message_box(list_box,lb[idx])"
        ],
        "FuncName": "main_5078 lb_double_click.txt"
    },
    {
        "Branch": [
            "if (true) {",
            "    try this in a new thread;",
            "    try to set the clipboard;"
        ],
        "Loop": [],
        "Normal": [
            "try this in a new thread;",
            "try to set the clipboard;"
        ],
        "FuncName": "main_5078 on_set_clipboard.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This does one dot and one gemv with matrix multiplication",
            "This does one dot and two gemv with matrix multiplication",
            "This does one dot and two gemv with matrix multiplication"
        ],
        "FuncName": "blas_bindings_gemv_2052 test_gemv_stuff.txt"
    },
    {
        "Branch": [
            "If the image is not blank"
        ],
        "Loop": [
            "Loop through all the images"
        ],
        "Normal": [
            "this is just math to figure the megapixels and then round it to the tenths place"
        ],
        "FuncName": "qvinfodialog_2647 updateInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If the dialog is visible, it means we've just navigated to a new image. To enhance the user experience, instead of running updateInfo immediately, we add it to the event queue. This is a workaround for a delay when calling adjustSize on the window if the font contains certain characters, such as Chinese characters. By making the work happen later in the event loop, it allows the main window to repaint first, giving the appearance of better responsiveness. If the dialog is not visible, however, it means we're preparing to display for an image already opened. In this case, there is no urgency to repaint the main window, and we need to process the updates here synchronously to avoid the caller showing the dialog before it's ready, thus avoiding outdated info or placeholder text related to the image."
        ],
        "FuncName": "qvinfodialog_2647 setInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " In this example, we have three types of samples: class 0, 1, or 2.  That is, each of our sample vectors falls into one of three classes.  To keep this example very simple, each sample vector is zero everywhere except at one place.  The non-zero dimension of each vector determines the class of the vector.  So for example, the first element of samples has a class of 1 because samples[0](1) is the only non-zero element of samples[0].  Since we want to use a machine learning method to learn a 3-class classifier we need to record the labels of our samples.  Here samples[i] has a class label of labels[i].  Now that we have some training data we can tell the structural SVM to learn the parameters of our 3-class classifier model.  The details of this will be explained later.  For now, just note that it finds the weights (i.e. a vector of real-valued parameters) such that predict_label(weights, sample) always returns the correct label for a sample vector.  Print the weights and then evaluate predict_label() on each of our training samples.  Note that the correct label is predicted for each sample.",
            " This is a sample vector with a class label of 0.  It has a non-zero element at index 0, which determines its class.",
            " This is a sample vector with a class label of 1.  It has a non-zero element at index 1, which determines its class.",
            " This is a sample vector with a class label of 2.  It has a non-zero element at index 2, which determines its class.",
            " The structural SVM is a machine learning method that can learn a 3-class classifier model.  It finds the weights (i.e. a vector of real-valued parameters) such that predict_label(weights, sample) always returns the correct label for a sample vector.",
            " The predict_label() function takes a sample vector and the weights of the classifier as input and returns the predicted label for the sample vector.",
            " The weights of the classifier are a vector of real-valued parameters that are learned by the structural SVM.",
            " The structural SVM is a type of supervised learning algorithm that can learn a 3-class classifier model."
        ],
        "FuncName": "svm_struct_ex_7982 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure the file exists so we can use the get_parent_directory command to locate the parent directory of an image.",
            "figure out the parent directory of an image using the get_parent_directory command."
        ],
        "FuncName": "convert_pascal_xml_8302 convert_pascal_xml.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Note that the solver will use multiple threads to make concurrent calls to separation oracle, therefore, you must implement it in a thread safe manner or disable threading by inheriting from structural svm problem instead of structural svm problem threaded. However, if your separation oracle is not very fast to execute you can get a very significant speed boost by using the threaded solver. In general, all you need to do to make your separation oracle thread safe is to make sure it does not modify any global variables or members of three class classifier problem. So it is usually easy to make thread safe.",
            "compute scores for each of the three classifiers and maximize loss idx,y + F X,y in the separate oracle, not just F X,y as we normally would in predict label.",
            "Add in the loss augmentation to account for the loss augmentation, which is 1 if we dont predict the correct label and 0 if we get the right label.",
            "Now figure out which classifier has the largest loss augmented score and record the loss that was associated with that predicted label, which is 1 if the label is incorrect and 0 otherwise.",
            "Finally, compute the PSI vector corresponding to the label we just found and store it into psi for output."
        ],
        "FuncName": "svm_struct_ex_7982 separation_oracle.txt"
    },
    {
        "Branch": [
            "If the image is updated, then update other clients."
        ],
        "Loop": [
            "For each image update, check if other clients have changed."
        ],
        "Normal": [
            "Find other clients on paint",
            "TODO: remove old style image",
            "Just update image if peers have changed...",
            "Show dummy action for image update"
        ],
        "FuncName": "DkMenu_845 updatePeers.txt"
    },
    {
        "Branch": [
            "If condition based on image metadata"
        ],
        "Loop": [
            "Loop through image frames"
        ],
        "Normal": [
            "if (mTimeToShow == -1) { Display image metadata }",
            "return;"
        ],
        "FuncName": "DkMenu_845 showMenu.txt"
    },
    {
        "Branch": [
            "Check if SIMD over-fetch is enabled",
            "If SIMD over-fetch is enabled, calculate ideal color and weight"
        ],
        "Loop": [],
        "Normal": [
            "Zero initialize any SIMD over-fetch",
            "Calculate ideal color and weight for SIMD over-fetch"
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_ideal_colors_and_weights_1_comp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "default timeout: 5 seconds",
            "show menu on start-up: uncomment me",
            "display timer menu if timeToShow is not -1",
            "timer menu will start counting down from timeToShow"
        ],
        "FuncName": "DkMenu_845 DkMenuBar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Fervor update checker: an application for checking updates",
            "set language to english: setting the application language to english",
            "redirect qDebug to Log: redirecting qDebug messages to a log file",
            "QPalette darkPalette;: setting the dark palette for the application",
            "darkPalette.setColor(QPalette::Window, QColor(53,53,53));: setting the window color to a dark gray",
            "darkPalette.setColor(QPalette::WindowText, Qt::white);: setting the window text color to white",
            "darkPalette.setColor(QPalette::Base, QColor(25,25,25));: setting the base color to a dark gray",
            "darkPalette.setColor(QPalette::AlternateBase, QColor(53,53,53));: setting the alternate base color to a dark gray",
            "darkPalette.setColor(QPalette::ToolTipBase, Qt::white);: setting the tooltip base color to white",
            "darkPalette.setColor(QPalette::ToolTipText, Qt::white);: setting the tooltip text color to white",
            "darkPalette.setColor(QPalette::Text, Qt::white);: setting the text color to white",
            "darkPalette.setColor(QPalette::Button, QColor(53,53,53));: setting the button color to a dark gray",
            "darkPalette.setColor(QPalette::ButtonText, Qt::white);: setting the button text color to white",
            "darkPalette.setColor(QPalette::BrightText, Qt::red);: setting the bright text color to red",
            "darkPalette.setColor(QPalette::Link, QColor(42, 130, 218));: setting the link color to a blue-ish color",
            "darkPalette.setColor(QPalette::Highlight, QColor(42, 130, 218));: setting the highlight color to a blue-ish color",
            "darkPalette.setColor(QPalette::HighlightedText, Qt::black);: setting the highlighted text color to black",
            "a.setPalette(darkPalette);: setting the palette for the application",
            "a.setStyleSheet(\"QToolTip { color: #ffffff; background-color: #2a82da; border: 1px solid white; }\" );: setting the stylesheet for the application",
            "QMessageBox::information((QMainWindow*) &w, QString(\"Styles\"), s);: displaying a message box with the application styles"
        ],
        "FuncName": "main_6726 main.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " ok, a child is active -> wait for it, requires image processing to verify"
                ]
            }
        ],
        "Normal": [
            "ok we have a mouseover, with image recognition to enhance the interaction"
        ],
        "FuncName": "DkMenu_845 hideMenu.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Load the bilinear filter texel weight indexes in the decimated grid and compute the corresponding weights from the decimated grid",
            "Load the bilinear filter weights from the decimated grid and calculate the weight contribution factors for each decimated weight",
            "Compute the bilinear interpolation to generate the per-texel weight and determine the image interpolation type",
            "Load the weight contribution factors for each decimated weight and calculate the final weight value using bilinear interpolation"
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 bilinear_infill_vla_2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Before we run the solver, we set up some general parameters.  First, the C parameter of the structural SVM can be set by calling set_c().",
            " The epsilon parameter controls the stopping tolerance.  The optimizer will run until R(w) is within epsilon of its optimal value. If you don't set this, it defaults to 0.001.",
            " Uncomment this and the optimizer will print its progress to standard out.  You will be able to see things like the current risk gap.  The optimizer continues until the risk gap is below epsilon.",
            "problem.be_verbose();",
            " The optimizer uses an internal cache to avoid unnecessary calls to your separation_oracle() routine.  This parameter controls the size of that cache.  Bigger values use more RAM and might make the optimizer run faster.  You can also disable it by setting it to 0, which is good to do when your separation_oracle is very fast.  If you don't call this function, it defaults to a value of 5.",
            "problem.set_max_cache_size(20);",
            " Finally, we create the solver and then run it.  Alternatively, if you wanted to require that the learned weights are all non-negative, you can call the solver as follows and it will put a constraint on the optimization problem which causes all elements of weights to be >= 0.  ",
            "solver(problem, weights, problem.get_num_dimensions());"
        ],
        "FuncName": "svm_struct_ex_7982 train_three_class_classifier.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "It is possible for a uniform-color partition to produce length=0; this causes NaN issues so set to small value to avoid this problem. This can be achieved by calculating the ideal color and weight of two color components, which is crucial for image processing."
                ]
            }
        ],
        "Normal": [
            "Zero initialize any SIMD over-fetch. Ideal color and weight calculation for two color components is essential for accurate image representation."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_ideal_colors_and_weights_2_comp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "It is possible for a uniform-color partition to produce length=0; this causes NaN issues so set to small value to avoid this problem. In image processing, NaN (Not a Number) values can occur when dealing with color partitions, especially when working with RGB or RGBA color spaces. To mitigate this, a small value can be assigned to avoid NaN issues, ensuring stable and accurate results in image processing tasks such as color correction, color grading, or image enhancement."
                ]
            }
        ],
        "Normal": [
            "Zero initialize any SIMD over-fetch. In image processing, Zero initialization is a technique used to prevent potential issues with SIMD (Single Instruction, Multiple Data) operations. By initializing the data with zeros, developers can ensure that the SIMD operations are performed correctly, even when dealing with edge cases or unexpected input values. This is particularly important in image processing tasks that involve color manipulation, where small errors can propagate and affect the overall quality of the output."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_ideal_colors_and_weights_3_comp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compute the reciprocal of matrix determinant by multiplying RGBA color vector with weight vector.",
            "Actually compute the adjugate, and then apply 1/det separately, involving image processing techniques."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_rgbo_vector.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Look up the two closest indexes and return the one that was closest",
                    "Invert the weight-scaling that was done initially"
                ]
            },
            {
                "loopstr": [
                    "Look up the two closest indexes and return the one that was closest",
                    "Invert the weight-scaling that was done initially"
                ]
            }
        ],
        "Normal": [
            "The available quant levels, stored with a minus 1 bias for image resolution reduction",
            "Quantize the weight set using both the specified low/high bounds and standard 0..1 bounds for image type",
            "TODO: Oddity to investigate; triggered by test in issue #265 related to image processing",
            "This runs to the rounded-up SIMD size, which is safe as the loop tail is filled with known safe data for image computation and arrays are always 64 elements",
            "safe data in compute_ideal_weights_for_decimation and arrays are always 64 elements for image type"
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_quantized_weights_for_decimation.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If all weights in the partition were equal, then just take average of all colors in the partition and use that as both endpoint colors. This involves computing the ideal color and endpoint values for each partition, which is crucial for image processing and analysis."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We can get a failure due to the use of a singular (non-invertible) matrix If it failed, compute rgbo_vectors[] with a different method. This step is essential for ensuring the accuracy of image processing and rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Only compute a partition mean if more than one partition Initialize the luminance and scale vectors with a reasonable default Calculations specific to mode #7, the HDR RGB-scale mode - skip if known LDR. This loop condition is critical for controlling the flow of image processing and optimization."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 recompute_ideal_colors_1plane.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If all weights in the partition were equal, then just take average of all colors in the partition and use that as both endpoint colors. This is a common technique used in image processing to combine multiple colors into a single color.",
                    "The resulting average color is a good representation of the overall color of the image, which is why it's often used as a endpoint color."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If all weights in the partition were equal, then just take average of all colors in the partition and use that as both endpoint colors. This is a common technique used in image processing to combine multiple colors into a single color.",
                    "The resulting average color is a good representation of the overall color of the image, which is why it's often used as a endpoint color."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We can get a failure due to the use of a singular (non-invertible) matrix. In image processing, a singular matrix can occur when the input data is highly correlated or when the matrix is not invertible. If it failed, compute rgbo_vectors[] with a different method, such as using a different matrix or a more robust algorithm.",
                    "Using a different method can help to avoid the singular matrix problem and ensure that the image processing algorithm produces accurate results."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Initialize the luminance and scale vectors with a reasonable default. In image processing, the luminance and scale vectors are used to adjust the brightness and contrast of the image. Initializing them with a reasonable default value can help to ensure that the image is displayed correctly.",
            "Calculations specific to mode #7, the HDR RGB-scale mode - skip if known LDR. In image processing, mode #7 is used to scale RGB colors to HDR. If the input is already in LDR (low dynamic range), there is no need to perform these calculations, which can save time and resources."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 recompute_ideal_colors_2planes.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Start with a small value to avoid div-by-zero later and consider the ideal weight for image processing",
                    " Accumulate error weighting of all the texels using this weight to optimize image rendering"
                ]
            },
            {
                "loopstr": [
                    " Accumulate error weighting of all the texels using this weight to refine image details",
                    " Start with a small value to avoid div-by-zero later and consider the ideal weight for image processing",
                    " Accumulate error weighting of all the texels using this weight to optimize image rendering",
                    " Update the weight; note this can store negative values to handle complex image data"
                ]
            }
        ],
        "Normal": [
            " Ensure that the end of the output arrays that are used for SIMD paths later are filled so we can safely run SIMD elsewhere without a loop tail, considering the ideal weight for image processing",
            " If we have a 1:1 mapping just shortcut the computation and transfer enough to also copy the zero-initialized SIMD over-fetch region, optimizing image rendering",
            " Otherwise compute an estimate and perform single refinement iteration, accumulating error weighting of all the texels using this weight",
            " Compute an initial average for each decimated weight, considering the ideal weight for image processing",
            " This overshoots - this is OK as we initialize the array tails in the decimation table structures to safe values, handling complex image data",
            " Populate the interpolated weight grid based on the initial average, optimizing image rendering",
            " Process SIMD-width texel coordinates at at time while we can, safe to over-process full SIMD vectors - the tail is zeroed, considering the ideal weight for image processing",
            " Perform a single iteration of refinement, accumulating error weighting of all the texels using this weight",
            " Empirically determined step size; larger values don't help but smaller drops image quality, handling complex image data"
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_ideal_weights_for_decimation.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Compute the bilinear interpolation of the decimated weight grid. This involves resampling the weight grid to match the resolution of the image.",
                    "Compute the error between the computed value and the ideal weight. This error is used to adjust the weights in the next iteration."
                ]
            },
            {
                "loopstr": [
                    "Compute the bilinear interpolation of the decimated weight grid. This involves resampling the weight grid to match the resolution of the image.",
                    "Compute the error between the computed value and the ideal weight. This error is used to adjust the weights in the next iteration."
                ]
            },
            {
                "loopstr": [
                    "Load the weight set directly, without interpolation. This is a faster option, but may not be as accurate.",
                    "Compute the error between the computed value and the ideal weight. This error is used to adjust the weights in the next iteration."
                ]
            }
        ],
        "Normal": [
            "Process SIMD-width chunks, safe to over-fetch - the extra space is zero initialized. This optimization allows for faster processing of large chunks of data.",
            "Resolve the final scalar accumulator sum. This step combines the results of the previous operations to produce the final output."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_error_of_weight_set_1plane.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Plane 1",
                    "Compute the bilinear interpolation of the decimated weight grid",
                    "Calculate the difference between the interpolated and ideal weights to determine the error",
                    "Plane 2",
                    "Compute the bilinear interpolation of the decimated weight grid",
                    "Calculate the difference between the interpolated and ideal weights to determine the error"
                ]
            },
            {
                "loopstr": [
                    "Plane 1",
                    "Compute the bilinear interpolation of the decimated weight grid",
                    "Calculate the difference between the interpolated and ideal weights to determine the error",
                    "Plane 2",
                    "Compute the bilinear interpolation of the decimated weight grid",
                    "Calculate the difference between the interpolated and ideal weights to determine the error"
                ]
            },
            {
                "loopstr": [
                    "Plane 1",
                    "Load the weight set directly, without interpolation",
                    "Calculate the difference between the loaded and ideal weights to determine the error",
                    "Plane 2",
                    "Load the weight set directly, without interpolation",
                    "Calculate the difference between the loaded and ideal weights to determine the error"
                ]
            }
        ],
        "Normal": [
            "Process SIMD-width chunks, safe to over-fetch - the extra space is zero initialized",
            "Resolve the final scalar accumulator sum"
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_error_of_weight_set_2planes.txt"
    },
    {
        "Branch": [
            "Color channels: 4, Ideal colors: RGB(0, 0, 0), RGB(255, 255, 255), RGB(0, 255, 0), RGB(255, 0, 0), Weights: 0.33, 0.33, 0.33"
        ],
        "Loop": [
            {
                "loopstr": [
                    "In image processing, a uniform-color partition can produce length=0, causing NaN issues. To avoid this, set the length to a small value."
                ]
            }
        ],
        "Normal": [
            "Zero initializing SIMD over-fetch helps prevent data corruption and ensures accurate image processing results."
        ],
        "FuncName": "astcenc_ideal_endpoints_and_weights_6709 compute_ideal_colors_and_weights_4_comp.txt"
    },
    {
        "Branch": [
            "set filters 0 if image condition is met",
            "set the rest"
        ],
        "Loop": [
            "set filters 0 for each image in the loop",
            "set the rest"
        ],
        "Normal": [
            "set filters 0 for the normal image",
            "set the rest"
        ],
        "FuncName": "facedetectcnn-model_813 init_parameters.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Get data size, image data size information ",
            " Get data, retrieve image data ",
            " There may be padding at the end of the row for alignment purposes, image data alignment description, Not necessarily with a width of 4, image data width specification "
        ],
        "FuncName": "flif-pixbuf-loader_7833 gdk_pixbuf__flif_image_load.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Detect facial landmarks from RGB image data",
                    "Calculate bounding box dimensions",
                    "Convert bounding box to square",
                    "Calculate center coordinates of square",
                    "Calculate dimensions of square"
                ]
            }
        ],
        "Normal": [
            "Convolutional layer 1",
            "Convolutional layer 2",
            "Convolutional layer 3",
            "Convolutional layer 4",
            "Convolutional layer 5",
            "Convolutional layer 6",
            "Prior box layer 3",
            "Prior box layer 4",
            "Prior box layer 5",
            "Prior box layer 6"
        ],
        "FuncName": "facedetectcnn-model_813 objectdetect_cnn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": "Comma-separated values",
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": "New line character"
            },
            {
                "loopstr": "1.0E+1"
            }
        ],
        "Normal": [],
        "FuncName": "matrix_2397 matrix_to_csv.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "compute the new next_time_to_run and store it in t, adjust the timer delay based on the image type's timing requirements",
                    "set this incase add throws, consider the image type's error handling mechanism",
                    "put this back now that we know add didn't throw, verify the image type's status after the operation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we need to make the thread adjust its next time to trigger if this new event occurs sooner than the next event in tm, taking into account the image type's event handling capabilities",
                    "trigger if this new event occurrs sooner than the next event in tm, considering the image type's timing constraints",
                    "next event in tm, verify the image type's compatibility with the event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "timer_4030 adjust_delay.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Detecting faces in the image rectangle",
                    "Calculating the square size of the rectangle",
                    "Setting the width and height of the square",
                    "Calculating the x and y coordinates of the square"
                ]
            }
        ],
        "Normal": [
            "Convolutional layer 1",
            "Convolutional layer 2",
            "Convolutional layer 3",
            "Convolutional layer 4",
            "Convolutional layer 5",
            "Convolutional layer 6",
            "Prior box layer 3",
            "Prior box layer 4",
            "Prior box layer 5",
            "Prior box layer 6"
        ],
        "FuncName": "facedetectcnn-model_813 facedetect_cnn.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u4e0d\u4f7f\u7528g_free\uff0c\u56e0\u4e3aopen_memstream\u4f7f\u7528\u4e86stdlib.h\u7684\u5185\u90e8malloc\uff0c\u8fd9\u4e0eFLIF\u56fe\u50cf\u7684\u52a0\u8f7d\u6709\u5173"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u6211\u4eec\u4e0d\u4f7f\u7528g_free\uff0c\u56e0\u4e3aopen_memstream\u4f7f\u7528\u4e86stdlib.h\u7684\u5185\u90e8malloc\uff0c\u8fd9\u4e0eFLIF\u56fe\u50cf\u7684\u52a0\u8f7d\u6709\u5173"
        ],
        "FuncName": "flif-pixbuf-loader_7833 gdk_pixbuf__flif_image_stop_load.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: This is a conditional statement for printing matrices."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-Condition-Str: This is a loop condition for printing matrices. The first loop prints a blank line and the second loop prints a floating point number with 15 digits and 7 decimal places."
                ]
            },
            {
                "loopstr": [
                    "Loop-Condition-Str: This is a loop condition for printing matrices. The loop prints a floating point number with 15 digits and 7 decimal places."
                ]
            }
        ],
        "Normal": [
            "Normal-Str: This is a normal string for printing matrices. It prints the matrix with the format %d X %d Matrix:\n",
            " __",
            "__ \n",
            "|  ",
            "  |\n",
            "|__",
            "__|\n"
        ],
        "FuncName": "matrix_2397 print_matrix.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if the thread isn't running then start it up",
                    "add a timer to the global clock",
                    "if the timer is not already in the clock, start the clock"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we need to make the thread adjust its next time to",
                    "trigger if this new event occurs sooner than the",
                    "next event in tm",
                    "wake up the thread if the timer triggers before the next event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "timer_4030 add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "At least one of the two should be valid and the image is a valid image format such as JPEG, PNG, or GIF, and the image size is within the acceptable range."
        ],
        "FuncName": "astcenc_block_sizes_1214 construct_dt_entry_2d.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if(w == net->w && h == net->h) return 0;",
            "fprintf(stderr, \"Resizing network image to %d x %d...\\n\", w, h);",
            "fflush(stderr);",
            "fprintf(stderr, \" Network resizing completed!\\n\");"
        ],
        "FuncName": "network_1370 resize_network.txt"
    },
    {
        "Branch": [
            "if(net.gpu_index >= 0) update_network_gpu(net); Momentum reset for GPU network."
        ],
        "Loop": [],
        "Normal": [
            "if(net.gpu_index >= 0) update_network_gpu(net); Momentum reset for GPU network."
        ],
        "FuncName": "network_1370 reset_momentum.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Simplex interpolation for 3D image downsampling."
                ]
            },
            {
                "loopstr": [
                    "Initializing all 4 entries to rely on zeros for vectorization in 3D image downsampling."
                ]
            },
            {
                "loopstr": [
                    "Initializing array tail for 3D image downsampling to over-fetch with SIMD and avoid loop tails.",
                    "Matching last texel in active lane in SIMD group for better gathers in 3D image downsampling."
                ]
            },
            {
                "loopstr": [
                    "Creating transposed versions for better vectorization in 3D image downsampling.",
                    "Storing per-texel contribution of this weight for each texel it contributes to in 3D image downsampling."
                ]
            }
        ],
        "Normal": [
            "Initializing array tail for 3D image downsampling to over-fetch with SIMD and avoid loop tails.",
            "Initializing array tail for 3D image downsampling to over-fetch with SIMD and avoid loop tails.",
            "Matching last texel in active lane in SIMD group for better gathers in 3D image downsampling."
        ],
        "FuncName": "astcenc_block_sizes_1214 init_decimation_info_3d.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Truncated-precision bilinear interpolation for image processing"
                ]
            },
            {
                "loopstr": [
                    "Initializing 4 entries for vectorization in image processing"
                ]
            },
            {
                "loopstr": [
                    "Initializing array tail for over-fetching in SIMD for image processing",
                    "Matching last texel in active lane for better gathers in image processing"
                ]
            },
            {
                "loopstr": [
                    "Creating transposed versions for vectorization in image processing",
                    "Storing per-texel contribution for each texel in image processing"
                ]
            }
        ],
        "Normal": [
            "Initializing array tail for over-fetching in SIMD for image processing",
            "Initializing array tail for over-fetching in SIMD for image processing",
            "Matching last texel in active lane for better gathers in image processing"
        ],
        "FuncName": "astcenc_block_sizes_1214 init_decimation_info_2d.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is the only check we need as only support 1 partition",
                    "Partitioning scheme relies on image type to determine valid partitions"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip modes we've already included in a previous pass",
                    "Skip invalid encodings",
                    "Skip encodings in the wrong iteration",
                    "Always skip encodings we can't physically encode based on bit availability",
                    "Image encoding modes are limited by block size and image type"
                ]
            }
        ],
        "Normal": [
            "Store a remap table for storing packed decimation modes.",
            "Indexing uses [Z * 64 + Y *  8 + X] and max size for each axis is 6.",
            "Gather all the infill-modes that can be used with the current block size",
            "Ensure the end of the array contains valid data (should never get read)",
            "Skipped for 3D modes",
            "Construct the list of block formats referencing the decimation tables",
            "Clear the list to a known-bad value",
            "Iterate two times to build a usefully ordered list:",
            "   - Pass 0 - keep valid single plane block modes",
            "   - Pass 1 - keep valid dual plane block modes",
            "Skipped for 3D modes",
            "Determine the texels to use for kmeans clustering.",
            "Image clustering relies on block size and image type to determine optimal clusters"
        ],
        "FuncName": "astcenc_block_sizes_1214 construct_block_size_descriptor_3d.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is the only check we need as only support 1 partition",
                    "Block size description includes block pattern and resolution pattern count and content"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip modes we've already included in a previous pass",
                    "Decode parameters",
                    "Always skip invalid encodings for the current block size",
                    "Selectively skip dual plane encodings",
                    "Always skip encodings we can't physically encode based on",
                    "generic encoding bit availability",
                    "Selectively skip encodings based on percentile",
                    "Allocate and initialize the decimation table entry if we've not used it yet",
                    "Block size description includes block pattern and resolution pattern count and content"
                ]
            }
        ],
        "Normal": [
            "Store a remap table for storing packed decimation modes.",
            "Indexing uses [Y * 16 + X] and max size for each axis is 12.",
            "Gather all the decimation grids that can be used with the current block",
            "Unused in decompress-only builds",
            "Construct the list of block formats referencing the decimation tables",
            "Trackers",
            "Clear the list to a known-bad value",
            "Iterate four times to build a usefully ordered list:",
            "   - Pass 0 - keep selected single plane always block modes",
            "   - Pass 1 - keep selected single plane non-always block modes",
            "   - Pass 2 - keep select dual plane block modes",
            "   - Pass 3 - keep everything else that's legal",
            "Ensure the end of the array contains valid data (should never get read)",
            "Determine the texels to use for kmeans clustering.",
            "Block size description includes block pattern and resolution pattern count and content"
        ],
        "FuncName": "astcenc_block_sizes_1214 construct_block_size_descriptor_2d.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "if the current step is greater than the batch number minus one and the scale is greater than one, reset the momentum of the network"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "network_1370 get_current_rate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " ensure we are properly resized and adapt to the image view",
            " reapply fitmode to fix viewport position and adjust to image size"
        ],
        "FuncName": "imageviewerv2_3749 showEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "when this view is not in focus, this it won't update the background, similar to a static image",
            "so we force it here like a reload button"
        ],
        "FuncName": "imageviewerv2_3749 reset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "at the first glance this may seem retarded, like a failed animation loop",
            "because it is, with QMovie's cache all functionality being buggy and memory inefficient",
            "unfortunately i dont see a better way to do seeking with QMovie, which is a type of image animation",
            "QMovie::CacheAll is buggy and memory inefficient, affecting image rendering"
        ],
        "FuncName": "imageviewerv2_3749 showAnimationFrame.txt"
    },
    {
        "Branch": [
            "Adjust image scale and position when mouse moves"
        ],
        "Loop": [
            "Adjust image scale and position when mouse moves"
        ],
        "Normal": [
            "Adjust image scale and position when mouse moves this one feels ok"
        ],
        "FuncName": "imageviewerv2_3749 mouseMoveZoom.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "for reference linux trackpad: pixelDelta = (x,y) OR (0,0) angleDelta = (x*scale,y*scale) OR (x,y) wheel: pixelDelta = (0,0) - libinput <= 1.18 pixelDelta = (0,120*m) - libinput 1.19 angleDelta = (0,120*m)  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel. macOS trackpad: pixelDelta = (x,y) angleDelta = (x*scale,y*scale) wheel: pixelDelta = (0,y*scrollAccel) angleDelta = (0,120*m)  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel. windows trackpad: ?? (dont have the hardware with precision drivers) wheel: pixelDelta = (0,0) AngleDelta = (0,120*m)  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "scroll (high precision)  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "scroll by interval  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel. shift by 2px in case of img edge misalignment  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel. todo: maybe even increase it to skip small distance scrolls?  Mouse Wheel Zoom: Zoom in/out by scrolling the mouse wheel."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "this event goes off during force touch with Qt::ScrollPhase being set to begin/end  Mouse Wheel Zoom: Filter out force touch events to prevent zooming. lets filter these  Mouse Wheel Zoom: Filter out force touch events to prevent zooming."
        ],
        "FuncName": "imageviewerv2_3749 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "request real scaling when graphics scene scaling is insufficient. This involves image resampling, which is a process of converting the image from one resolution to another.",
            "it uses a single pass bilinear which is sharp but produces artifacts on low zoom levels, which can be seen as distortions or blurriness in the image."
        ],
        "FuncName": "imageviewerv2_3749 requestScaling.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "movie->jumpToFrame(0);",
                    "emit frameChanged(0);",
                    "Displays a frame with index 0."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewerv2_3749 startAnimation.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "DRAG PAN",
                    "select which action to start",
                    "emit a signal to start dnd; set flag to ignore further mouse move events",
                    "panning"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "ZOOM",
                    "filter out possible mouse jitter by ignoring low delta drags"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "avoid visible lags by forcing fast scale for large viewport sizes",
                    "this value possibly needs tweaking"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewerv2_3749 mouseMoveEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "last frame: transition to first frame or stop animation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewerv2_3749 onAnimationTimer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "current vport center, adjust image view to viewport edge"
        ],
        "FuncName": "imageviewerv2_3749 snapToEdges.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "fix scene position to integer values, adjust image view with scaling factor"
        ],
        "FuncName": "imageviewerv2_3749 doZoom.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "just center somewhere at the top then do snap, with adaptive viewport width for image rendering"
        ],
        "FuncName": "imageviewerv2_3749 fitWidth.txt"
    },
    {
        "Branch": [
            "image condition: If statement for checking cursor position on wayland"
        ],
        "Loop": [
            "image condition: Loop condition for skipping cursor check once"
        ],
        "Normal": [
            "image description: We cannot check the cursor position on Wayland until the mouse is moved. This statement is used to skip the cursor check once.",
            "image description: This is a temporary statement without a wrapper.",
            "image description: This statement is used to skip the cursor check once."
        ],
        "FuncName": "viewerwidget_3524 ViewerWidget.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "calculate shift to adjust viewport center",
                    "we do this in viewport coordinates to avoid any rounding errors",
                    "zoom in on the center of the viewport"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewerv2_3749 zoomAnchored.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Disable video player. videoControls->hide();",
                    "Even after calling hide(), the player sends a few video frames, which paints over the image viewer causing corruption.",
                    "So we do not HIDE it but rather just cover it by image viewer's widget.",
                    "Seems to work fine might even feel a bit snappier.",
                    "This is related to image viewer and video player functionality."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "viewerwidget_3524 disableVideoPlayer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if(oldEndFrame == currentYPos)",
                    "    createScrollTimeLine();",
                    "Image: A scroll timeline is created when the current Y position is equal to the old end frame."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "if(oldEndFrame == currentYPos)",
                    "    createScrollTimeLine();",
                    "Image: A scroll timeline is created when the current Y position is equal to the old end frame."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imageviewerv2_3749 scrollSmooth.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The base64 encoded data from the file iris.scale is decoded and returned in its original form.",
            "Base64 encoded data is read into the istream sin.",
            "Base64 text is decoded into its compressed binary form.",
            "Compressed data is decompressed into its original form.",
            "Decoded and decompressed data is returned."
        ],
        "FuncName": "create_iris_datafile_5448 get_decoded_string.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " not yet",
                    " bit depth of the image element with RLE encoding",
                    " error out if the bit depth is 10 or 12 and have eoln bytes",
                    " this is particularly slow to parse and eoln padding bytes are not needed for those formats",
                    " also if end of padding makes the line length odd, error out for that as well",
                    " error out for real types since bit operations don't really make sense with RLE encoding",
                    " find start and possible end of the RLE encoded element",
                    " size of the RLE encoded image",
                    " allocate the buffer that will store the entire RLE encoded image",
                    " allocate the temporary buffer that will read in the encoded RLE image",
                    " xpos, ypos in decoding with RLE",
                    "int xpos = 0; int ypos = 0;",
                    " read in the RLE encoded image block at a time",
                    " no longer need temp buffer"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " read in temp buffer with RLE encoding",
                    " if 10-bit, 12-bit, unpack or unfill RLE encoded data",
                    " step through and decode RLE encoded image"
                ]
            }
        ],
        "Normal": [
            " just check to make sure that this element is RLE encoded",
            " get the number of components for this RLE encoded element descriptor",
            "DataSize srcSize = dpxHeader.ComponentDataSize(element);",
            " has the buffer been read in and decoded with RLE?",
            " NOT COMPLETE YET with RLE encoding",
            " copy RLE encoded buffer"
        ],
        "FuncName": "RunLengthEncoding_3737 Read.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "switch to fitWidth via up arrow",
                    "pause video playback and switch to image viewer mode"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "viewerwidget_3524 keyPressEvent.txt"
    },
    {
        "Branch": [
            "Check if the image is valid",
            "If the image is valid, proceed to the next step"
        ],
        "Loop": [
            "Loop through each pixel in the image",
            "Perform image processing for each pixel"
        ],
        "Normal": [
            "Initialize result image",
            "Get properties of the input image",
            "Create a string stream to store the window information",
            "Append the window information to the string stream",
            "Add the window information to the result image"
        ],
        "FuncName": "IPLAccumulate_1648 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "inverted (top) - A rectangular region in a video control area."
        ],
        "FuncName": "viewerwidget_3524 videoControlsArea.txt"
    },
    {
        "Branch": [
            "Open file and read file size. This is a code from image processing."
        ],
        "Loop": [],
        "Normal": [
            "nothing"
        ],
        "FuncName": "heifstreamlinux_4494 LinuxStream.txt"
    },
    {
        "Branch": [
            "delete _result;"
        ],
        "Loop": [
            "delete _result;"
        ],
        "Normal": [
            "delete IPLAccumulate object to release resources; delete _result;"
        ],
        "FuncName": "IPLAccumulate_1648 destroy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "stopping is visibly slower",
                    "videoPlayer->stop();",
                    "a video player is being stopped"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "viewerwidget_3524 stopPlayback.txt"
    },
    {
        "Branch": [
            "Check if the file exists and is not empty."
        ],
        "Loop": [
            "Read the file and check if it is not empty."
        ],
        "Normal": [
            "nothing to read"
        ],
        "FuncName": "heifstreamlinux_4494 LinuxStream.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Hide mouse cursor on Wayland until we can get the cursor position, as per image recommendations for image type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Ignore if another window is open, such as settings window, as per image guidelines for image type.",
            "Ignore when menu is up, as per image best practices for image type."
        ],
        "FuncName": "viewerwidget_3524 hideCursor.txt"
    },
    {
        "Branch": [
            "If condition string with image description"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Character image representation: %c"
                ]
            }
        ],
        "Normal": [
            "New line image representation: \n"
        ],
        "FuncName": "data_2809 print_letters.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "properties",
            "inputs and outputs",
            "image processing",
            "plane splitting",
            "IPLSplitPlanes initialization"
        ],
        "FuncName": "IPLSplitPlanes_43 init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Display the original image and the cropped image, then wait for a key press."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "data_2809 load_image_augment_paths.txt"
    },
    {
        "Branch": [
            "Randomly select n paths from the given path array. These paths will be used as strings in the image code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "if(i == 0) printf(\"%s\\n\", paths[index]);"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "data_2809 get_random_paths.txt"
    },
    {
        "Branch": [
            "If statement: a conditional expression that controls the flow of a program."
        ],
        "Loop": [
            {
                "loopstr": [
                    "printf(%d\\n, count);",
                    "A loop is a control structure that allows code to be executed repeatedly for a specified number of times."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "data_2809 fill_hierarchy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Bad character code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "data_2809 fill_truth_captcha.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Draw a rectangle in the image. normalize_image(a);"
        ],
        "FuncName": "image_7485 draw_box.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Translate 3D image by finding the best translation parameters: x, y, z\n"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_7485 best_3d_shift.txt"
    },
    {
        "Branch": [
            "If condition: image code {{image.code}} is loaded from file {{image.file}}."
        ],
        "Loop": [
            "Loop condition: image code {{image.code}} is being processed."
        ],
        "Normal": [
            "%d/%d\n",
            "Image description: {{image.description}}."
        ],
        "FuncName": "data_2809 load_tags_paths.txt"
    },
    {
        "Branch": [
            "printf(\"If condition: %f%%\n\", r);"
        ],
        "Loop": [
            "printf(\"Loop condition: %f%%\n\", r);"
        ],
        "Normal": [
            "printf(\"Gradient color: %f%%\n\", r);"
        ],
        "FuncName": "image_7485 get_color.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "normalize data rows for CIFAR-10 dataset with 50000 samples and 3072 features per sample, each sample belongs to one of 10 classes.",
            "translate data rows for CIFAR-10 dataset with 50000 samples and 3072 features per sample, each sample belongs to one of 10 classes."
        ],
        "FuncName": "data_2809 load_all_cifar10.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "width is calculated as 20 times the probability plus 2 pixels in the then branch of the if statement."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_7485 draw_detections.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "sprintf(buff, %s (%d), name, windows); Image saved as PNG to file."
        ],
        "FuncName": "image_7485 save_image_png.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "swapped,%d,offset_x,offset_y"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_7485 composite_3d.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for loading data"
        ],
        "Loop": [
            "Loop-Condition-Str: Looping condition for loading data"
        ],
        "Normal": [
            "Normal-Str: Printing loading data message with random number: printf(Loading data: %d\\n, rand());"
        ],
        "FuncName": "data_2809 load_thread.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Exercise the span syntax with initializer_list and image processing."
        ],
        "FuncName": "span_test_2415 test_span_initlist.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Try the span syntax with a view of a vector. This is a code snippet related to image processing."
        ],
        "FuncName": "span_test_2415 test_span_stdarray.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "normalize_image(copy); merge_vertical_images(copy, image);"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_7485 collapse_images_vert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Try the span syntax with a view of a std vector. In image processing, a span is a contiguous block of pixels or a subset of pixels in an image."
        ],
        "FuncName": "span_test_2415 test_span_vector.txt"
    },
    {
        "Branch": [
            "Testing image stretching functionality, displaying original image, grayscale image, and stretched images."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Image stretching iteration %f, stretching factor %f, resulting image: %f\n"
                ]
            }
        ],
        "Normal": [
            "L2 Norm of stretched image: %f\n"
        ],
        "FuncName": "image_7485 test_resize.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Printing an image using the print_image function. Image code: "
                ]
            },
            {
                "loopstr": [
                    "Printing an image using the print_image function. Image code: "
                ]
            },
            {
                "loopstr": [
                    "Printing an image using the print_image function. Image value: %.2lf, "
                ]
            }
        ],
        "Normal": [
            "Printing an image using the print_image function."
        ],
        "FuncName": "image_7485 print_image.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: testing if condition with image code"
        ],
        "Loop": [
            "Loop-Condition-Str: testing loop condition with image code"
        ],
        "Normal": [
            "span<float>::const_iterator i = a.begin(); Image code: iterating over a span of floats.",
            "OIIO_CHECK_EQUAL (*i, 0.0f); Image code: checking the value of the first float in the span.",
            "++i;  Image code: incrementing the iterator to the next float in the span. OIIO_CHECK_EQUAL (*i, 1.0f); Image code: checking the value of the second float in the span."
        ],
        "FuncName": "span_test_2415 test_span_mutable.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "merge multiple images; normalize_image(copy);"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_7485 collapse_images_horz.txt"
    },
    {
        "Branch": [
            "If-Condition-Str is a string related to if conditions in image code"
        ],
        "Loop": [
            "Loop-Condition-Str is a string related to loop conditions in image code"
        ],
        "Normal": [
            "Normal-Str is a string related to normal conditions in image code, Test and !="
        ],
        "FuncName": "span_test_2415 test_span.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Display a set of images. These are image codes: int w = 448; int h = ((float)m.h/m.w) * 448; if(h > 896){ h = 896; w = ((float)m.w/m.h) * 896; } image sized = resize_image(m, w, h);"
        ],
        "FuncName": "image_7485 show_images.txt"
    },
    {
        "Branch": [
            "This function tests the isotonic_regression class functionality by comparing isotonic_regression and find_min_global functions results. These strings are for image code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "find the solution with find_min_global() and then check that it matches",
                    "isotonic_regression should be at least as good as find_min_global. This is related to image processing techniques."
                ]
            }
        ],
        "Normal": [
            "This string is related to image processing techniques and is used for testing isotonic_regression class functionality."
        ],
        "FuncName": "isotonic_regression_6341 perform_test.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "qDebug() << cursor().pos() << this->rect();",
            "This statement is related to image handling, as it involves the position of the cursor and the rectangle of the window.",
            "The issue of 'this misfires on hidpi' is likely related to image rendering on high-dpi displays.",
            "Instead, the panel hiding is handled in the MW::leaveEvent, which is a common event in image processing.",
            "The mainPanel->hide() statement is used to hide the main panel, which is a common operation in image-based GUI applications."
        ],
        "FuncName": "documentwidget_5684 leaveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make sure it works with unit stride. This involves iterating over an array with a pointer that increments by 1 element at a time.",
            "All the other tests are with stride of 2 elements, where the pointer moves 2 elements at a time, which is a common optimization technique in image processing."
        ],
        "FuncName": "span_test_2415 test_strided_ptr.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "span_strided<float>::iterator i = a.begin(); Iterating over a strided span of floats.",
            "OIIO_CHECK_EQUAL (*i, 1.0f); Verifying the first element of the span is 1.0f.",
            "++i; OIIO_CHECK_EQUAL (*i, 2.0f); Verifying the second element of the span is 2.0f."
        ],
        "FuncName": "span_test_2415 test_span_strided_mutable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "span_strided<const float> allows iterating over a contiguous memory region with a non-unit stride.",
            "span_strided<const float>::const_iterator i = a.begin();",
            "OIIO_CHECK_EQUAL (*i, 1.0f);",
            "Incrementing the iterator by 1 advances to the next element in the memory region, which has a value of 2.0f.",
            "++i; OIIO_CHECK_EQUAL (*i, 2.0f);"
        ],
        "FuncName": "span_test_2415 test_span_strided.txt"
    },
    {
        "Branch": [
            "Test if-conditions with strided pointers"
        ],
        "Loop": [
            "Test loop conditions with strided pointers"
        ],
        "Normal": [
            "Verify strided pointer functionality with unit stride",
            "Validate strided pointer behavior with stride of 2 elements"
        ],
        "FuncName": "span_test_2415 test_const_strided_ptr.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u6211\u4eec\u4e0d\u80fd\u5728\u7a97\u53e3\u5916\u8ddf\u8e2a\u79fb\u52a8\u4e8b\u4ef6\uff08\u9664\u975e\u4f7f\u7528\u989d\u5916\u7684\u8ba1\u65f6\u5668\uff09\uff0c\u5f53\u9f20\u6807\u8fdb\u5165\u7a97\u53e3\u65f6\uff0c\u5904\u7406\u9f20\u6807\u4e8b\u4ef6\uff0c\u663e\u793a\u9762\u677f",
            "\u6240\u4ee5\u5728\u6b64\u5904\u53eahook\u9762\u677f\u4e8b\u4ef6"
        ],
        "FuncName": "documentwidget_5684 enterEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u56fa\u5b9a\u9762\u677f"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "documentwidget_5684 setPanelPinned.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Returns the dimensionality of feature vectors produced by get_features(), which is typically an image feature vector with dimensions such as RGB, HSV, or LBP."
        ],
        "FuncName": "assignment_learning_ex_7819 num_features.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Predict the assignments for the LHS and RHS in samples[i]. This involves analyzing the image data and making predictions based on the image features."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "assignment_learning_ex_7819 main.txt"
    },
    {
        "Branch": [
            "set up styling with image condition"
        ],
        "Loop": [
            "set up styling with image loop condition"
        ],
        "Normal": [
            "set up styling with image"
        ],
        "FuncName": "IPProcessListTabWidget_6777 IPProcessListTabWidget.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This is a thread.  It will loop until it is told that it should terminate. The thread will continuously execute certain tasks until it receives a stop signal."
        ],
        "FuncName": "multithreaded_object_ex_9099 thread2.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code.",
            "If-Condition-Str: This is a conditional statement in image code, where the condition is checked before executing the code."
        ],
        "Loop": [
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met.",
            "Loop-Condition-Str: This is a loop statement in image code, where the code is executed repeatedly until the condition is met."
        ],
        "Normal": [
            "Make four different vectors.  We will use them to make example assignments.  This is a normal string.",
            "In all the assignments to follow, we will only say an element of the LHS matches an element of the RHS if the two are equal.  So A matches with A, B with B, etc.  But never A with C, for example.  This is a normal string.",
            "The -1 indicates that lhs[0] doesn't match anything in rhs.  This is a normal string.",
            "LHS and RHS are compared element-wise.  This is a normal string.",
            "This is a normal string.",
            "This is a normal string.",
            "This is a normal string.",
            "This is a normal string.",
            "This is a normal string.",
            "This is a normal string."
        ],
        "FuncName": "assignment_learning_ex_7819 make_data.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "display first tab and filter list based on image processing techniques, such as image filtering, thresholding, and edge detection"
        ],
        "FuncName": "IPProcessListTabWidget_6777 filter.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "add to list",
                    "and add to all processes list",
                    "use icon of first process for the category tab",
                    "for image processing, add relevant filters and tools"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "sort items",
                    "add GUI elements",
                    "for the last tab (plugins) add buttons",
                    "rotate icon",
                    "QPixmap pixmap(categoryIcons[i]);",
                    "only add categories with entries",
                    "for image processing, display relevant image types (e.g. JPEG, PNG, etc.)"
                ]
            },
            {
                "loopstr": [
                    "only add if instance exists",
                    "for image processing, check if image is loaded and valid"
                ]
            }
        ],
        "Normal": [
            "items",
            "CATEGORY_UNDEFINED",
            "CATEGORY_IO",
            "CATEGORY_CONVERSIONS",
            "CATEGORY_GEOMETRY",
            "CATEGORY_ARITHMETIC",
            "CATEGORY_POINTOPERATIONS",
            "CATEGORY_LOCALOPERATIONS",
            "CATEGORY_MORPHOLOGY",
            "CATEGORY_HISTOGRAM",
            "CATEGORY_GRADIENTS",
            "CATEGORY_FOURIER",
            "CATEGORY_OBJECTS",
            "",
            "list process names by process category",
            "all processes tab",
            "rotate icon",
            "add all other tabs",
            "set plugins tab icon",
            "sort all process list",
            "for image processing, display relevant image modes (e.g. RGB, grayscale, etc.)"
        ],
        "FuncName": "IPProcessListTabWidget_6777 init.txt"
    },
    {
        "Branch": [
            "Validate and compare network model performance on validation set."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loaded: %d images in %lf seconds\n",
                    "Iteration %d: Accuracy: %f, %lf seconds, %d images\n"
                ]
            }
        ],
        "Normal": [
            "list *plist = get_paths(\"data/compare.val.old\");"
        ],
        "FuncName": "compare_634 validate_compare.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "convert to yyyy-mm-ddThh:mm:ss.sTZD",
                    "return std::string();"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "for (int i = 0; i < image.size(); i++) {"
        ],
        "Normal": [
            "image is a type of data that represents a visual representation of a scene or object."
        ],
        "FuncName": "xmp_9463 stringize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ignore it purposefully",
                    "Found",
                    "Image: Found tag with value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "It's a known Exif name",
                    "skip",
                    "Image: Skipping known Exif tag"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case -- append it to a list",
                    "Image: Appending to list"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "See if it's in the xmp table, which will tell us something about the",
            "proper type (everything in the xml itself just looks like a string).",
            "Also try looking it up to see if it's a known exif tag.",
            "Guess the type if unknown",
            "Catch-all for unrecognized things -- just add them as a string!",
            "Image: Adding image metadata as string"
        ],
        "FuncName": "xmp_9463 add_attrib.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "As a guard against runaway lists or corrupt XMP blocks, don't let attribute lists grow to more than 64KB each.",
                    "FIXME -- image history is complicated. Come back to it.",
                    "This tag is nothing but trouble. Some images can have literally MBs in them, placed there by Photoshop as the result of certain cut-and-paste operations, but serving no discernible purpose. Just skip it.  See also: https://prepression.blogspot.com/2017/06/metadata-bloat-photoshopdocumentancestors.html https://feedback.photoshop.com/conversations/photoshop/photoshop-corrupt-ancestors-tag-in-xmp-causing-giant-file-sizes/5f5f45f74b561a3d426ba97f",
                    "Various kinds of lists.  Recurse, pass the parent name down, and let the child know it's part of a list. This is related to image metadata processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "FIXME -- image history is complicated. Come back to it. This is related to image metadata processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This tag is nothing but trouble. Some images can have literally MBs in them, placed there by Photoshop as the result of certain cut-and-paste operations, but serving no discernible purpose. Just skip it.  See also: https://prepression.blogspot.com/2017/06/metadata-bloat-photoshopdocumentancestors.html https://feedback.photoshop.com/conversations/photoshop/photoshop-corrupt-ancestors-tag-in-xmp-causing-giant-file-sizes/5f5f45f74b561a3d426ba97f. This is related to image metadata processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Various kinds of lists.  Recurse, pass the parent name down, and let the child know it's part of a list. This is related to image metadata processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "First, encode all attributes of this node. This is related to image metadata processing.",
                    "If this node has a value but no name, it's definitely part of a list.  Accumulate the list items, separated by semicolons. This is related to image metadata processing.",
                    "As a guard against runaway lists or corrupt XMP blocks, don't let attribute lists grow to more than 64KB each. This is related to image metadata processing.",
                    "xml attributes aren't image metadata. This is related to image metadata processing."
                ]
            },
            {
                "loopstr": [
                    "xml attributes aren't image metadata. This is related to image metadata processing."
                ]
            }
        ],
        "Normal": [
            "will accumulate for list items. This is related to image metadata processing.",
            "If we have accumulated a list, turn it into an attribute. This is related to image metadata processing."
        ],
        "FuncName": "xmp_9463 decode_xmp_node.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "start marker not found in image code",
            "end marker not found in image code"
        ],
        "FuncName": "xmp_9463 extract_middle.txt"
    },
    {
        "Branch": [
            "Image processing: Conditional statement for sorting objects in a network."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Image processing: Looping over objects in the network for sorting."
                ]
            }
        ],
        "Normal": [
            "Image processing: Retrieving paths from data/compare.val.old.",
            "Image processing: Sorting %d boxes in the network...",
            "Image processing: Sorted in %d compares, %f seconds."
        ],
        "FuncName": "compare_634 SortMaster3000.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Name doesn't match. Image XMP attribute: name does not match."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Purposely suppressing. Image XMP attribute: suppressing output."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "std::cerr <<  << tag->xmpname <<  =  << s << \n; Image XMP attribute: printing xmp name and value."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "For this param, see if there's a table entry with a matching name, where the xmp name is in the right category. Image XMP attribute: searching for matching table entry based on xmp name and category."
                ]
            }
        ],
        "Normal": [
            "Loop over all params... Image XMP attribute: iterating over all parameters."
        ],
        "FuncName": "xmp_9463 gather_xmp_attribs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "24-bit color image: RRRGGGBBB",
            "24-bit color image: BBBGGGRRR",
            "24-bit color image: get length of file:"
        ],
        "FuncName": "IPLFileIO_1356 readRaw24BitPlanar.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "grayscale images",
                    "convert to 32 bit",
                    "clear old image",
                    "create new instance with the right dimensions",
                    "image processing and analysis"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "R",
                    "G",
                    "B",
                    "image color channels"
                ]
            }
        ],
        "Normal": [
            "try loading relative filepaths to the _baseDir",
            "all files need to be flipped",
            "collect information about the image",
            "free temporary memory and optimize image storage",
            "image loading and preparation"
        ],
        "FuncName": "IPLFileIO_1356 loadFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Save image to memory for preview.",
                    "Open and allocate a memory stream for image.",
                    "Write image data to result.",
                    "Close the memory stream using FreeImage_CloseMemory."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Red component of the image.",
                    "Green component of the image.",
                    "Blue component of the image."
                ]
            },
            {
                "loopstr": [
                    "Red component of the image.",
                    "Green component of the image.",
                    "Blue component of the image."
                ]
            }
        ],
        "Normal": [
            "All files need to be flipped horizontally.",
            "Free any temporary memory allocated."
        ],
        "FuncName": "IPLFileIO_1356 saveFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now compute the second derivatives of the Rosenbrock function",
            "second derivative with respect to x of the Rosenbrock function",
            "derivative with respect to x and y of the Rosenbrock function",
            "second derivative with respect to y of the Rosenbrock function"
        ],
        "FuncName": "optimization_ex_2162 rosen_hessian.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This stuff seems to work with image metadata",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "NOSONAR",
            "Doesn't work yet with image metadata",
            "    xmp += encode_xmp_category (list, \\dc\\, \\dc:\\, NULL, NULL, http://purl.org/dc/elements/1.1/, minimal, XMP_attribs); Image metadata is being processed",
            " FIXME exif xmp stRef stVer stJob xmpDM Image metadata is being referenced"
        ],
        "FuncName": "xmp_9463 encode_xmp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "too many planes, do something simple",
                    "Select planes based on importance and zoom level"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "break;",
                    "Zoom in on the selected plane"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "ensure that nextp is not at the most detailed zoomlevel yet",
                    "Iterate through planes, prioritizing important ones at each zoom level"
                ]
            }
        ],
        "Normal": [
            "simple order: interleave planes, zoom in",
            "int p = i % image.numPlanes();",
            "int zl = beginZL - (i / image.numPlanes());",
            "more advanced order: give priority to more important plane(s)",
            "assumption: plane 0 is luma, plane 1 is chroma, plane 2 is less important chroma, plane 3 is perhaps alpha, plane 4 are frame lookbacks (FRA transform, animation only)",
            "if there is no info in the luma plane, there's no reason to lag chroma behind luma",
            "(this also happens for palette images)"
        ],
        "FuncName": "common_5034 plane_zoomlevel.txt"
    },
    {
        "Branch": [
            "Image Condition String"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Pixels on previous planes",
                    "Image processing iteration"
                ]
            }
        ],
        "Normal": [
            "Median of 3",
            "Predictor selection"
        ],
        "FuncName": "common_5034 initPropRanges_scanlines.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set the starting point to (4,8) and use an optimization algorithm to find the minimum of a function. This is the point the optimization algorithm will start out from and it will move it closer and closer to the function's minimum point. So generally you want to try and compute a good guess that is somewhat near the actual optimum value, which is related to the concept of finding the minimum of a function in image processing.",
            " The first example below finds the minimum of the rosen() function and uses the analytical derivative computed by rosen_derivative(). Since it is very easy to make a mistake while coding a function like rosen_derivative() it is a good idea to compare your derivative function against a numerical approximation and see if the results are similar, which is a common task in image processing when dealing with gradient-based optimization.",
            " Now we use the find_min() function to find the minimum point. The first argument to this routine is the search strategy we want to use, which is a common step in image processing when applying optimization techniques. The second argument is the stopping strategy. Below I'm using the objective_delta_stop_strategy which just says that the search should stop when the change in the function being optimized is small enough, which is a key aspect of optimization in image processing.",
            " The other arguments to find_min() are the function to be minimized, its derivative, then the starting point, and the last is an acceptable minimum value of the rosen() function, which is a common scenario in image processing when dealing with optimization problems.",
            " Once the function ends the starting_point vector will contain the optimum point of (1,1), which is a common goal in image processing when applying optimization techniques to find the minimum of a function.",
            " Now let's try doing it again with a different starting point and the version of find_min() that doesn't require you to supply a derivative function, which is a common scenario in image processing when dealing with optimization problems where the derivative is not available.",
            " Again the correct minimum point is found and stored in starting_point, which is a common outcome in image processing when applying optimization techniques to find the minimum of a function.",
            " Here we repeat the same thing as above but this time using the L-BFGS algorithm, which is a popular optimization technique in image processing.",
            " printed for each iteration of optimization, which is a common step in image processing when applying optimization techniques.",
            " dlib also supports solving functions subject to bounds constraints on the variables, which is a common scenario in image processing when dealing with optimization problems with constraints.",
            " Start with a valid point inside the constraint box, which is a common step in image processing when applying optimization techniques with constraints.",
            " Here we put the same [0.1 0.8] range constraint on each variable, however, you can put different bounds on each variable by passing in column vectors of constraints for the last two arguments rather than scalars, which is a common scenario in image processing when dealing with optimization problems with constraints.",
            " You can also use an approximate derivative like so, which is a common approach in image processing when dealing with optimization problems where the derivative is not available.",
            " In many cases, it is useful if we also provide second derivative information to the optimizers, which is a common scenario in image processing when dealing with optimization problems that require second-order information.",
            " Two examples of how we can do that are shown below, which is a common approach in image processing when dealing with optimization problems that require second-order information.",
            " Next, let's try the BOBYQA algorithm, which is a popular optimization technique in image processing.",
            " max number of objective function evaluations, which is a common step in image processing when applying optimization techniques.",
            " Finally, let's try the find_min_global() routine, which is a global optimization method based on a combination of non-parametric global function modeling and BOBYQA style quadratic trust region modeling, which is a common approach in image processing when dealing with optimization problems that require global optimization.",
            " You also don't have to give it a starting point or set any parameters, other than defining bounds constraints, which is a common scenario in image processing when dealing with optimization problems with constraints.",
            " To optimize this difficult function all we need to do is call find_min_global(), which is a common step in image processing when applying optimization techniques to find the minimum of a function.",
            " run this long, which is a common outcome in image processing when applying optimization techniques to find the minimum of a function.",
            " These cout statements will show that find_min_global() found the globally optimal solution to 9 digits of precision, which is a common goal in image processing when applying optimization techniques to find the minimum of a function."
        ],
        "FuncName": "optimization_ex_2162 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "we don't have any images"
        ],
        "FuncName": "avpcl_mode4_6824 read_header.txt"
    },
    {
        "Branch": [
            "If the image is rotated 90 degrees clockwise, the content will be shifted to the right and bottom."
        ],
        "Loop": [
            "While the image is rotated in a loop, the content will be rearranged accordingly."
        ],
        "Normal": [
            "reserved = 0",
            "The image content is reserved for rotation."
        ],
        "FuncName": "imagerotation_1371 writeBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " try loading relative filepaths to the baseDir, and load the original image file.",
            " clear old image, and prepare for new image loading.",
            " create IPLImage, and initialize image metadata.",
            " read file, and perform image processing."
        ],
        "FuncName": "IPLFileIO_1356 loadRawFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "32-bit grayscale image data",
            "32-bit grayscale image data",
            "get length of file:"
        ],
        "FuncName": "IPLFileIO_1356 readRaw32BitPlanar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no bits needed for 0 signed or not, in binary representation"
        ],
        "FuncName": "avpcl_mode4_6824 nbits.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Let's instantiate our neural network model in train mode, leveraging the power of transfer learning to fine-tune the pre-trained weights.",
            " We create a new scope to automatically free resources from the loaded network when leaving the scope, ensuring efficient memory management.",
            " We can utilize the visit_layers function to modify the weight decay of the entire network, adjusting the regularization strength for optimal performance.",
            " We can also employ predefined visitors to affect the learning rate of the whole network, dynamically adjusting the learning rate for improved convergence.",
            " Modifying the learning rates of a network is a common practice for fine-tuning, and it's implemented internally using a visitor that's similar to the one defined in this example.",
            " Typically, we want to freeze the network, except for the top layers, to preserve the learned features and adapt the top layers to the new task.",
            " Alternatively, we can use the visit_layers_range to modify only a specific set of layers, allowing for targeted adjustments to the network's architecture.",
            " Sometimes we might want to set the learning rate differently throughout the network, requiring a more nuanced approach to hyperparameter tuning.",
            " Here we demonstrate how to adjust the learning rate at the different ResNet50's convolutional blocks, showcasing the flexibility of the network.",
            " Finally, we can check the results by printing the network, and before that, if we forward an image through the network, we will see tensors' shape at every layer, providing valuable insights into the network's behavior.",
            " We can also print the number of parameters of the network, helping us understand the network's complexity and memory requirements.",
            " From this point on, we can fine-tune the new network using this pre-trained backbone on another task, such as the one shown in dnn_metric_learning_on_images_ex.cpp."
        ],
        "FuncName": "dnn_introduction3_ex_9537 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "reserved = 0, ImageRotation angle: "
        ],
        "FuncName": "imagerotation_1371 parseBox.txt"
    },
    {
        "Branch": [
            "if condition: image header"
        ],
        "Loop": [
            "loop condition: image header"
        ],
        "Normal": [
            "ignore shapeindex image header"
        ],
        "FuncName": "avpcl_mode4_6824 write_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "This operation is related to image processing, specifically image indexing and endpoint swapping."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "This operation is related to image processing, specifically image indexing and endpoint swapping."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the table",
                    "swap RGB",
                    "swap A",
                    "These operations are related to image processing, specifically color swapping and table verification."
                ]
            }
        ],
        "Normal": [
            "since WLOG we have the high bit of the shapes at 0",
            "This statement is related to image processing, specifically shape analysis and bit manipulation."
        ],
        "FuncName": "avpcl_mode4_6824 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "could be nindices2 with image compression",
            "could be nindices2 with image compression",
            "lookup with image retrieval"
        ],
        "FuncName": "avpcl_mode4_6824 decompress_mode4.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "the indices we shorten is always index 0, a 1-bit image or icon",
            "do the 2 bit indices first, a 2-bit image or icon",
            "read i..[1:0] or i..[0], a 2-bit image or icon",
            "then the 3 bit indices, a 3-bit image or icon",
            "read i..[1:0] or i..[0], a 2-bit image or icon"
        ],
        "FuncName": "avpcl_mode4_6824 read_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "endpts[0].A[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].nbitsizes[0]); // always positive here. This is an RGBA image processing operation, where endpts[0].A[i] represents the alpha channel value, SIGN_EXTEND is an extension of the input value to 32 bits, and p.chan[i].nbitsizes[0] is the number of bits in the alpha channel."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "avpcl_mode4_6824 sign_extend.txt"
    },
    {
        "Branch": [
            "scale endpoints for RGB color palette",
            "interpolate R channel",
            "interpolate G channel",
            "interpolate B channel",
            "interpolate A channel"
        ],
        "Loop": [],
        "Normal": [
            "generate a quantized RGB color palette",
            "scale endpoints for RGB color palette",
            "interpolate R channel",
            "interpolate G channel",
            "interpolate B channel",
            "interpolate A channel"
        ],
        "FuncName": "avpcl_mode4_6824 generate_palette_quantized_rgb_a.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "keep a <= b, ensuring correct image ordering"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "ok figure out the range of A and B, optimizing image display",
            "now there's no need to swap the ordering of A and B, improving image alignment"
        ],
        "FuncName": "avpcl_mode4_6824 exhaustive.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " do A index first as it has the alpha, which is a characteristic of A index in image processing.",
                    " squared-error norms are additive since we don't do the square root, which is a property of squared-error norms in image analysis.",
                    " do RGB index, which is a common color model in image representation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " compute the two indices separately, which is a step in image indexing for efficient retrieval.",
                    " if we're doing premultiplied alpha, we need to choose first the index that determines the alpha value, and then do the other index, which is a consideration in image processing for transparency and opacity.",
                    " determines the alpha value, and then do the other index, which is a crucial step in image indexing for accurate representation."
                ]
            }
        ],
        "Normal": [
            " could be nindices2, which is a possible indexing scheme for images.",
            " could be nindices2, which is another possible indexing scheme for images."
        ],
        "FuncName": "avpcl_mode4_6824 assign_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Execute instruction B next to minimize error"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Restart the process to minimize error"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Determine which endpoint produces the most improvement when perturbed and start from there to minimize error",
                    "Alternating endpoints may lead to a local minimum, so we need to start over to minimize error",
                    "Perturb endpoint A to minimize error",
                    "Perturb endpoint B to minimize error",
                    "Alternate endpoints and continue until no improvement is found to minimize error",
                    "Check if the indices have changed to minimize error",
                    "Restart the process to minimize error"
                ]
            },
            {
                "loopstr": [
                    "Move the other endpoint to minimize error"
                ]
            }
        ],
        "Normal": [
            "Calculate error for perturbed RGB values, and if error is less than initial error, break the loop and update the RGB value to minimize error",
            "Optimize each color channel separately to minimize error",
            "Perform a small exhaustive search around the predicted global minimum to ensure accuracy and minimize error"
        ],
        "FuncName": "avpcl_mode4_6824 optimize_one.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "the indices we shorten is always index 0, where image code is used to represent shortening process",
            "do the 2 bit indices first, which is a common image processing technique",
            "write i..[1:0] or i..[0], where image code is used to indicate bit length",
            "then the 3 bit indices, which is a typical image indexing method",
            "write i..[2:0] or i..[1:0], where image code is used to specify bit range"
        ],
        "FuncName": "avpcl_mode4_6824 write_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do A index first as it has the alpha",
                    "squared-error norms are additive since we don't do the square root",
                    "do RGB index",
                    "color mapping for A index involves alpha channel"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "color mapping for bogus index involves initializing alpha channel"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "color mapping for bogus index involves initializing alpha channel"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "compute the two indices separately",
                    "if we're doing premultiplied alpha, we need to choose first the index that",
                    "determines the alpha value, and then do the other index",
                    "color mapping involves premultiplied alpha for separate indices"
                ]
            }
        ],
        "Normal": [
            "color mapping for nindices2 involves alpha channel",
            "color mapping for nindices2 involves alpha channel"
        ],
        "FuncName": "avpcl_mode4_6824 map_colors.txt"
    },
    {
        "Branch": [
            "Decode image block in mode 3"
        ],
        "Loop": [],
        "Normal": [
            "lookup"
        ],
        "FuncName": "avpcl_mode3_268 decompress_mode3.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "try all rotations. refine tries the 2 different indexings. This is a compressed image encoding, utilizing rotation and indexing optimization."
        ],
        "FuncName": "avpcl_mode4_6824 compress_mode4.txt"
    },
    {
        "Branch": [
            "If condition is used to check a condition and execute a block of code if the condition is true, similar to how an image filter is applied to an image to enhance its features."
        ],
        "Loop": [
            "Loop condition is used to repeat a block of code until a certain condition is met, just like how an image processing algorithm iterates over pixels to enhance the image quality."
        ],
        "Normal": [
            "we can also use cout to print things as usual: We can use cout to print the result of the matrix addition, similar to how an image is displayed after applying an image filter."
        ],
        "FuncName": "example_mex_function_7554 mex_function.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region, where endpts represent the coordinates of the image and indices represent the pixel values"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the image table for pixel values and coordinates"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode3_268 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no bits needed for 0 signed or not, binary representation is 0"
        ],
        "FuncName": "avpcl_mode3_268 nbits.txt"
    },
    {
        "Branch": [
            "Optimize the endpoints of the region for image processing.",
            "Optimize the endpoints of the region for image processing.",
            "Optimize the endpoints of the region for image processing.",
            "Optimize the endpoints of the region for image processing.",
            "Optimize the endpoints of the region for image processing."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Collect pixels in the region for image analysis.",
                    "Validate error for temporary input for image processing.",
                    "Validate original error for region in image processing.",
                    "Optimize endpoints for image processing.",
                    "Update best outcome and correct output endpoints and errors for image processing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode4_6824 optimize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Since we are in uncompressed space, the coordinate is quantized and compressed."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode3_268 quantize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "handle simple cases",
                    "project each pixel value along the principal direction",
                    "choose as endpoints 2 points along the principal direction that span the projections of all of the pixel values",
                    "clamp endpoints",
                    "the argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best",
                    "shape based on endpoints being clamped",
                    "image processing technique to find region boundaries",
                    "segmentation of images to find regions of interest"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode4_6824 rough.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "collect the pixels in the region",
                    "optimize region endpoints for image processing"
                ]
            },
            {
                "loopstr": [
                    "make sure we have a valid error for temp_in",
                    "we use FLT_MAX here because we want an accurate temp_in_err, no shortcuts",
                    "mapcolors will compute a mapping but will stop if the error exceeds the value passed in the FLT_MAX position",
                    "now try to optimize these endpoints",
                    "if we find an improvement, update the best so far and correct the output endpoints and errors",
                    "image processing requires accurate temperature and error values"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode3_268 optimize_endpts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Maintain a <= b to ensure optimal color matching."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Update indices if actual improvement is detected for better image representation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Determine the optimal range of A and B for image processing.",
            "No need to swap A and B for efficient image rendering."
        ],
        "FuncName": "avpcl_mode3_268 exhaustive.txt"
    },
    {
        "Branch": [
            "find smallest matching color for each pixel, calculate error value based on color matching degree, accumulate color matching degree error"
        ],
        "Loop": [],
        "Normal": [
            "build list of possibles, find smallest matching color for each pixel, calculate error value based on color matching degree, accumulate color matching degree error"
        ],
        "FuncName": "avpcl_mode3_268 assign_indices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "compare pixel values and calculate color difference"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for early exit",
                    "iterate through image pixels to calculate color error"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode3_268 map_colors.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " handle simple cases in image processing",
                    " project each pixel value along the principal direction in image analysis",
                    " choose as color endpoints 2 points along the principal direction that span the projections of all of the pixel values in image segmentation",
                    " clamp color endpoints",
                    " the argument for clamping is that the actual color endpoints need to be clamped and thus we need to choose the best shape based on color endpoints being clamped in image enhancement"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode3_268 rough.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " (nreed) Commented out asserts because they go off all the time...not sure why",
                    "for (int i=0; i<NREGIONS; ++i)",
                    "\\tnvAssert(expected_opt_err[i] == opt_err[i]);",
                    "Optimized image block endpoints with reduced error"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " apply a heuristic here -- we check if the endpoints fit before we try to optimize them.",
                    " the assumption made is that if they don't fit now, they won't fit after optimizing.",
                    "Image block optimization loop iterates to minimize error"
                ]
            }
        ],
        "Normal": [
            "throw \\No candidate found, should never happen (mode avpcl 3).\\;",
            "Default image block processing with no optimization"
        ],
        "FuncName": "avpcl_mode3_268 refine.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "number of rough cases to examine, typical values are 1, a quarter of NSHAPES, and all NSHAPES",
            "a quarter of NSHAPES covers almost all cases; you can increase this slightly (e.g. by 3 or 4) for even better compression",
            "select the top NITEMS shapes and refine them",
            "bubble sort - only need to bubble up the first NITEMS items, reducing unnecessary comparisons"
        ],
        "FuncName": "avpcl_mode3_268 compress_mode3.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove groupChanged events, typical behavior for image processing operations"
        ],
        "FuncName": "IPProcessPropertiesWidget_6752 closeSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "discard version: image data discarded",
            "flags: image flags applied"
        ],
        "FuncName": "imagegrid_648 parseImageGrid.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no sidx information about pts available. Use previous segment last sample pts. This is related to image type, specifically the missing timestamp information, which is crucial for image processing and analysis."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "we need to save moof start byte for possible trun dataoffset depending on its flags. This is relevant to image type, as it involves managing the structure and organization of image data."
        ],
        "FuncName": "heifreaderimpl_6335 handleSegmentMoof.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5728HEIF\u6587\u4ef6\u4e2d\uff0c\u53ea\u4fdd\u5b58\u7b2c\u4e00\u4e2a\u6bb5\u843d - \u5176\u4f59\u53ef\u4ee5\u5ffd\u7565"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5728HEIF\u6587\u4ef6\u4e2d\uff0cpeek() \u8bbe\u7f6e\u6d41\u7684eof\u6807\u5fd7\u3002\u6e05\u9664\u6d41\u4ee5\u786e\u4fdd\u5b83\u4ecd\u7136\u53ef\u8bbf\u95ee\u3002seekg()\u5728C++11\u4e2d",
                    "\u5e94\u8be5\u6e05\u9664\u6d41\u540eeof\uff0c\u4f46\u8fd9\u4f3c\u4e4e\u5e76\u4e0d\u603b\u662f\u53d1\u751f\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 parseSegment.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "QFormLayout \u4e0d\u5141\u8bb8\u663e\u793a/\u9690\u85cf\u884c\uff0c\u6240\u4ee5\u66f4\u5bb9\u6613\u542f\u7528/\u7981\u7528\u63a7\u4ef6",
                    "QFormLayout \u4e0d\u5141\u8bb8\u663e\u793a/\u9690\u85cf\u884c\uff0c\u6240\u4ee5\u66f4\u5bb9\u6613\u542f\u7528/\u7981\u7528\u63a7\u4ef6",
                    "\u6240\u4ee5\u66f4\u5bb9\u6613\u542f\u7528/\u7981\u7528\u63a7\u4ef6"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "IPProcessPropertiesWidget_6752 showPropertyGroup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "skip as we are not interested in it.",
                    "This is a code snippet related to image processing.",
                    "It involves peeking into the stream and clearing it to ensure accessibility."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "peek() sets eof bit for the stream. Clear stream to make sure it is still accessible.",
                    "This is a code snippet related to image processing.",
                    "It involves seeking in the stream and clearing it to prevent eof issues.",
                    "should clear stream after eof, but this does not seem to be always happening."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 parseSegmentIndex.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No extents given for an item. This may be due to the image not being loaded or the item not being present in the image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Request list of 'iloc' type item references, and assemble the data of the item recursively. This involves iterating over the extents of the item.",
                    "Iterate extents"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If index_size is 0, then the value 1 of 'iloc' type reference index is implied. This is a default behavior for the image type.",
                    "If extent_length value = 0, length is the length of the entire item. This is a characteristic of the image type."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 readItem.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "The following loop copies item property information to interface. Data structures are essentially identical in ItemPropertiesBox and the reader API, but it is not desirable to expose ItemPropertiesBox in the API, or include reader interface as part of ItemPropertiesBox. This process is related to image encoding in HEIF files."
                ]
            },
            {
                "loopstr": [
                    "The following loop copies item property information to interface. Data structures are essentially identical in ItemPropertiesBox and the reader API, but it is not desirable to expose ItemPropertiesBox in the API, or include reader interface as part of ItemPropertiesBox. This process is related to image encoding in HEIF files."
                ]
            }
        ],
        "Normal": [
            "Collect item properties related to image encoding in HEIF files",
            "Collect entity group properties related to image encoding in HEIF files"
        ],
        "FuncName": "heifreaderimpl_6335 processItemProperties.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "byteOffset++;",
                    "AVC NALU type is determined by the first 5 bits of the first byte: ",
                    "AvcNalUnitType naluType = AvcNalUnitType((uint8_t)memoryBuffer[outputOffset + byteOffset] & 0x1f);",
                    "4 bytes of nal length information"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 processAvcItemData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Read the 32-bit length field of the box",
            "Read the four character string for boxType",
            "Check if 64-bit largesize field is used",
            "Seek to box beginning"
        ],
        "FuncName": "heifreaderimpl_6335 readBoxParameters.txt"
    },
    {
        "Branch": [
            "HEVC NAL unit type determination: ((uint8_t)memoryBuffer[outputOffset + byteOffset] >> 1) & 0x3f"
        ],
        "Loop": [
            {
                "loopstr": [
                    "byteOffset++;",
                    "HEVC NAL unit type determination: ((uint8_t)memoryBuffer[outputOffset + byteOffset] >> 1) & 0x3f",
                    "4 bytes of nal length information: extraction and parsing of HEVC NAL unit data"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 processHevcItemData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No extents given for an item. The image length is 0."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Request list of 'iloc' type item references, and assemble the length of the item recursively. Iterate extents to get image length.",
                    "Iterate extents to get image length."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Avoid looping references. Image length is not available."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If index_size is 0, then the value 1 of 'iloc' type reference index is implied. Image length is the length of the entire item if extent_length value = 0."
                ]
            }
        ],
        "Normal": [
            "To prevent infinite loop of items <-> subitem, image length is the sum of extent lengths."
        ],
        "FuncName": "heifreaderimpl_6335 getItemLength.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Parse FTYP box, check supported brands, set mFtyp member variable"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 handleFtyp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "we need to save moof start byte for possible trun dataoffset depending on its flags. MOOF\u76d2\u4e2d\u7684\u7247\u6bb5\u5c5e\u6027\u548c\u8f68\u9053\u4fe1\u606f\u63d0\u4f9b\u4e86\u6709\u5173\u6570\u636e\u7684\u8be6\u7ec6\u4fe1\u606f.",
            "Check sample dataoffsets against fragment data size. \u4e86\u89e3MOOF\u76d2\u7684\u5185\u5bb9\u6709\u52a9\u4e8e\u66f4\u597d\u5730\u89e3\u6790\u548c\u5904\u7406\u6570\u636e."
        ],
        "FuncName": "heifreaderimpl_6335 handleInitSegmentMoof.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Is this master image (not a thumb and not an auxiliary image) Image description: A master image is a primary image used as a reference for other images.",
                    "Is this master image (not a thumb and not an auxiliary image)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 extractMetaBoxItemPropertiesMap.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Multiple ftyp boxes. HEIF file format supports multiple ftyp boxes."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Multiple etyp boxes, also must be after ftyp. HEIF file format requires etyp boxes to be after ftyp."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Multiple root-level meta boxes. HEIF file format allows multiple root-level meta boxes."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "0 index of segmentPropertiesMap is reserved for initialization segment data. HEIF file format reserves the 0 index of segmentPropertiesMap for initialization segment data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "skip 'mdat' as it is handled elsewhere, 'free' can be skipped. HEIF file format allows skipping 'mdat' and 'free' sections."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "peek() sets eof bit for the stream. Clear stream to make sure it is still accessible. seekg() in C++11, should clear stream after eof, but this does not seem to be always happening. HEIF file format requires clearing the stream after eof to ensure accessibility."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Set error if parsing was OK, but either ftyp was missing and neither meta nor moov was found. HEIF file format requires ftyp, meta, or moov to be present for successful parsing."
        ],
        "FuncName": "heifreaderimpl_6335 readStream.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Store decoder type for track data decoding",
                    "Decoder type mapping updated for image decoding"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 updateDecoderCodeTypeMap.txt"
    },
    {
        "Branch": [
            "If statement with condition: FourCCInt type = entry->getType();"
        ],
        "Loop": [
            "Loop condition: FourCCInt type = entry->getType();"
        ],
        "Normal": [
            "Normal string with no image-related content."
        ],
        "FuncName": "heifreaderimpl_6335 fillSampleEntryMap.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "HEIF defines that when (flags & 1) is equal to 1, the entire edit list is repeated a sufficient number of times to equal the track duration.",
                    "repeated a sufficient number of times to equal the track duration.",
                    "This repetition is based on the image type, which requires the edit list to be repeated for a specified duration."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Increase timestamp offset and skip to begin if the end was reached.",
                    "This loop condition is typically used for image types that require continuous playback, such as video."
                ]
            }
        ],
        "Normal": [
            "Duration is in timescale units.",
            "The duration of the track is determined by the image type, which may require additional processing to calculate the correct duration.",
            "Read track type if exists. The track type is essential for determining the correct image type and its associated processing requirements."
        ],
        "FuncName": "heifreaderimpl_6335 createTrackInfoInSegment.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "discard return value, just get max sample size. This is a common operation in image processing, where the goal is to extract the maximum sample size from a set of image data."
                ]
            }
        ],
        "Normal": [
            " Some TrackFeatures are easiest to set after a part of properties have already been filled. In the context of image analysis, this could refer to setting image metadata such as resolution or color space after the image has been pre-processed."
        ],
        "FuncName": "heifreaderimpl_6335 extractInitTrackInfos.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Sample groupings",
                    "Image: Grouping samples into categories for easier management and organization."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "sample entry box has 'pict', and is not referencing any another track",
                    "Image: A box where users can enter a sample, with a 'pict' option and no reference to another track."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "HasSampleGroups",
                    "HasSampleToItemGrouping, HasSampleEquivalenceGrouping",
                    "Image: A feature that allows users to create and manage sample groups, including item and equivalence groupings."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Edit list box flag == 1 determines infinite looping",
                    "Image: A flag in the edit list box that determines whether the looping is infinite or not."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 getTrackFeatures.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Extract initial track information from the TrackBox. Extracts the track index as the sample entry type, ignoring other information."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Extract initial track information from the TrackBox. Extracts the track index as the sample entry type, ignoring other information."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "A unit of time, equal to one second, used to measure the passage of time."
        ],
        "FuncName": "heifreaderimpl_6335 extractInitTrackInfo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Store values from CodingConstraintsBox. This includes sample IDs, data lengths, offsets, and durations for HEIF file samples. The sample type is set to reference or non-reference frame based on the file's structure."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Will be filled later based on sync sample box. This involves determining the sample properties, such as sample IDs, data lengths, offsets, and durations, and setting the sample type as reference or non-reference frame."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If there is a \\refs\\ sample grouping, then there is a chance that the sample is an output non-reference frame. If there is no \\refs\\ sample group, then all samples are potentially output reference frames. This is determined by analyzing the sample groupings and their dependencies."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This means that there is at least one reference sample of this sample, hence it is a non-reference frame. The sample properties, such as sample IDs, data lengths, offsets, and durations, are set accordingly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "All samples are reference frames for audio: This involves setting the sample type to reference frame and determining the sample properties, such as sample IDs, data lengths, offsets, and durations."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Set basic sample information. This includes setting sample IDs, data lengths, offsets, and durations for HEIF file samples.",
                    "Set dimensions. This involves determining the sample dimensions based on the file's structure.",
                    "Figure out decode dependencies. This involves analyzing the sample groupings and their dependencies to determine the sample type and decode order."
                ]
            }
        ],
        "Normal": [
            "Index is 1-based so 0 will not be used. This means that the first sample is at index 1, not 0.",
            "Handle hidden samples: This involves setting the sample properties, such as sample IDs, data lengths, offsets, and durations, for hidden samples."
        ],
        "FuncName": "heifreaderimpl_6335 makeSamplePropertyVector.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Go backwards through previous image IDs until an item ID is found or all previous image IDs have been checked."
        ],
        "FuncName": "heifreaderimpl_6335 getPrecedingSequenceImageId.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "sampleInfo.compositionTimes is filled at end of segment parsing (in parseSegment). This information is related to the composition of the image."
                ]
            }
        ],
        "Normal": [
            "figure out PTS. This is a step in image processing to determine the presentation timestamp."
        ],
        "FuncName": "heifreaderimpl_6335 addSamplesToTrackInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "leave 0 index for possible initseg 0 index with local files, image segment index constructed from segment index box information"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 makeSegmentIndex.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Set composition times from Pmap, which considers also edit lists and image processing techniques",
                    "Enhanced composition times with image analysis and editing capabilities",
                    "Composition times optimized with image processing and editing considerations"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "store information about overall segment: including image metadata and analysis"
        ],
        "FuncName": "heifreaderimpl_6335 updateCompositionTimes.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "reserved bytes and data reference index are parsed from the box content."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "sampleentrybox_2103 parseBox.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This can only happen when processing init segment. The image type is a crucial part of the processing."
        ],
        "FuncName": "heifreaderimpl_6335 getPrecedingSegment.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "update sample data offset in case it is needed to read next track fragment data offsets (base offset",
                    "not defined)",
                    "This may involve adding a new track fragment to the image or updating the existing one."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "item id base in case of adding multiple subsegments?",
                    "This may require creating a new image or modifying the existing one to accommodate the additional subsegments."
                ]
            },
            {
                "loopstr": [
                    "figure out what is the base data offset for the samples in this trun box:",
                    "note: if we need to support more than one trun for track we need to calculate last sample PTS +",
                    "duration as new basePTSOffset for addSamplesToTrackInfo for next trun in same track. Need to take",
                    "care of case where the might be several different tracks inside same segment. using",
                    "segmentProperties.earliestPTSTS for all truns works for now as example clip only have 1 moof, 1x traf",
                    "for each track with 1 trun each.",
                    "This process involves analyzing the track fragment data and updating the image accordingly."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "heifreaderimpl_6335 addToTrackProperties.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Multiple ftyp boxes are present."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Multiple root level metadata boxes are present."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "mdat is skipped because it is handled elsewhere."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "peek() sets the eof bit of the stream. The stream is cleared to ensure it remains accessible. In C++11, seekg() should clear the stream after eof, but this does not always occur.",
                    "Image type: HEIF"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "All \\segment\\ information is used to initialize SegmentPropertiesMap with key=0."
        ],
        "FuncName": "heifreaderimpl_6335 parseInitializationSegment.txt"
    },
    {
        "Branch": [
            "image code string"
        ],
        "Loop": [
            "image code string"
        ],
        "Normal": [
            "image code string"
        ],
        "FuncName": "sampleentrybox_2103 writeBox.txt"
    },
    {
        "Branch": [
            "Find the best 3D translation for image"
        ],
        "Loop": [
            "%d %f\n"
        ],
        "Normal": [],
        "FuncName": "image_4320 best_3d_shift.txt"
    },
    {
        "Branch": [
            "check_image_condition(a)"
        ],
        "Loop": [
            "check_image_loop_condition(a)"
        ],
        "Normal": [
            "normalize_image(a)"
        ],
        "FuncName": "image_4320 draw_box.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "sprintf(buff, %s (%d), name, windows);",
            "Saving image as PNG file."
        ],
        "FuncName": "image_4320 save_image_png.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "swapped, %d, 3D image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_4320 composite_3d.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Testing image size changes: %f %f %f\n"
                ]
            }
        ],
        "Normal": [
            "Calculating L2 Norm: %f\n"
        ],
        "FuncName": "image_4320 test_resize.txt"
    },
    {
        "Branch": [
            "Printing image data based on conditional statement"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Printing image data in a loop: "
                ]
            },
            {
                "loopstr": [
                    "Printing image data in a loop: "
                ]
            },
            {
                "loopstr": [
                    "Printing image data in a loop: , "
                ]
            }
        ],
        "Normal": [
            "Printing image data"
        ],
        "FuncName": "image_4320 print_image.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "printf(RGB value: red: %f, green: %f, blue: %f\n, r, g, b);"
        ],
        "FuncName": "image_4320 get_color.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "width = prob*20+2;",
                    "Image width calculated based on probability."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "image_4320 draw_detections.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Add appropriate amount of fill color to extra channels in non-black-wrapped regions. This involves sampling and accumulating texture data from 3D textures using bilinear interpolation.",
                    "nothing more to do here"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "For files with many channels, narrow the range we cache to improve performance. This is a common optimization technique in image processing.",
                    "nothing more to do here"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Shortcut if all the texels we need are on the same tile to reduce memory access. This is a common optimization technique in 3D texture sampling.",
                    "nothing more to do here"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nothing more to do here"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "As passed in, (s,t) map the texture to (0,1).  Remap to texel coords and subtract 0.5 because samples are at texel centers.",
            "Now (sint,tint,rint) are the integer coordinates of the texel to the immediate upper left of the lookup point, and (sfrac,tfrac,rfrac) are the amount that the lookup point is actually offset from the texel center (with (1,1) being all the way to the next texel down and to the right).",
            "Wrap",
            "Texel coords, which are used to sample and accumulate texture data from 3D textures using bilinear interpolation.",
            "Account for crop windows",
            "    if (! (svalid[0] | svalid[1] | tvalid[0] | tvalid[1] | rvalid[0] | rvalid[1]))",
            "All texels we need were out of range and using 'black' wrap, e.g. 63.",
            "FIXME -- optimize the above loop by unrolling to improve performance."
        ],
        "FuncName": "texture3d_8595 accum3d_sample_bilinear.txt"
    },
    {
        "Branch": [
            "merge_images_vertically(image1, image2, ..., imageN);"
        ],
        "Loop": [
            {
                "loopstr": [
                    "normalize_image(copy);",
                    "merge_images_vertically(image1, image2, ..., imageN);"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_4320 collapse_images_vert.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "normalize_image(copy);",
                    "These are the image processing steps: normalizing the image."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "image_4320 collapse_images_horz.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Displaying an image. This string is a code snippet for image processing.",
            "int w = 448; int h = ((float)m.h/m.w) * 448; if(h > 896){ h = 896; w = ((float)m.w/m.h) * 896; } image sized = resize_image(m, w, h); "
        ],
        "FuncName": "image_4320 show_images.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "the indices we shorten for image encoding is always index 0, which represents the least significant bit",
            "do the 2 bit indices first, which represent the next two least significant bits",
            "write i..[1:0] or i..[0] to encode the 2-bit index",
            "then the 3 bit indices, which represent the next three least significant bits",
            "write i..[2:0] or i..[1:0] to encode the 3-bit index"
        ],
        "FuncName": "avpcl_mode5_8330 write_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "the indices we shorten is always index 0",
            "do the 2 bit indices first, which are represented by image codes",
            "read i..[1:0] or i..[0], where [1:0] is a 2-bit image code",
            "then the 3 bit indices, which are also represented by image codes",
            "read i..[1:0] or i..[0], where [1:0] is a 2-bit image code, with additional description of 3-bit image codes"
        ],
        "FuncName": "avpcl_mode5_8330 read_indices.txt"
    },
    {
        "Branch": [
            "Binary representation of 0 has no bits for signed or unsigned integers."
        ],
        "Loop": [],
        "Normal": [
            "no bits needed for 0 signed or not"
        ],
        "FuncName": "avpcl_mode5_8330 nbits.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for image processing"
        ],
        "Loop": [
            "Loop-Condition-Str: Looping condition for image processing"
        ],
        "Normal": [
            "ignore shapeindex: Ignore shape index for image processing",
            "\tout.write(indexmode, INDEXMODE_BITS);: Write index mode and bits for image processing"
        ],
        "FuncName": "avpcl_mode5_8330 write_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "endpts[0].A[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].nbitsizes[0])//RGB sign extension//always positive here in RGB mode"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "avpcl_mode5_8330 sign_extend.txt"
    },
    {
        "Branch": [
            "If the condition is met, then"
        ],
        "Loop": [
            "Loop through the data until"
        ],
        "Normal": [
            "we don't have any",
            "we don't have any"
        ],
        "FuncName": "avpcl_mode5_8330 read_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "Swap RGB and A channels' color endpoints and index values in the index bitmap."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region",
                    "Swap RGB and A channels' color endpoints and index values in the index bitmap."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the table",
                    "swap RGB and A channels' color endpoints and index values in the index bitmap.",
                    "swap RGB and A channels' color endpoints and index values in the index bitmap."
                ]
            }
        ],
        "Normal": [
            "since WLOG we have the high bit of the shapes at 0",
            "The index bitmap's RGB and A channels' color endpoints and index values are swapped."
        ],
        "FuncName": "avpcl_mode5_8330 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "collect the pixels in the region",
                    "make sure we have a valid error for temp_in",
                    "we didn't change temp_in, so orig_err[region] is still valid",
                    "now try to optimize these endpoints using image processing techniques",
                    "if we find an improvement, update the best so far and correct the output endpoints and errors based on image analysis"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode5_8330 optimize_endpts.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "for (int i = 0; i < NINDEXMODES && msebest > 0; ++i) Image compression using mode 5, compressing a block of image, returning minimum error."
                ]
            }
        ],
        "Normal": [
            "try all rotations. refine tries the 2 different indexings. Image compression optimization using mode 5, exploring all possible rotations and indexings to achieve minimum error."
        ],
        "FuncName": "avpcl_mode5_8330 compress_mode5.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " (nreed) Commented out asserts because they go off all the time...not sure why",
                    "for (int i=0; i<NREGIONS; ++i)",
                    "\tnvAssert(expected_opt_err[i] == opt_err[i])",
                    "Image optimization is a complex process that requires careful consideration of various factors, including image size, resolution, and compression algorithms. In this case, the assert statement is used to verify that the expected optimization errors match the actual errors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " apply a heuristic here -- we check if the endpoints fit before we try to optimize them.",
                    " the assumption made is that if they don't fit now, they won't fit after optimizing.",
                    "Image optimization often involves iterative processes, where the algorithm checks the endpoints of the image to determine if further optimization is possible. In this case, the loop condition is used to apply a heuristic and check if the endpoints fit before optimizing."
                ]
            }
        ],
        "Normal": [
            "throw No candidate found, should never happen (mode avpcl 5).",
            "In the event of an error, the program throws an exception indicating that no candidate was found. This should never happen in normal operation, but is a safeguard against unexpected errors."
        ],
        "FuncName": "avpcl_mode5_8330 refine.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do A index first as it has the alpha",
                    "squared-error norms are additive since we don't do the square root",
                    "do RGB index",
                    "color mapping error calculation involves comparing pixel values"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "color mapping error calculation requires accurate index values"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "fill out bogus index values so it's initialized at least",
                    "color mapping error calculation requires accurate index values"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "compute the two indices separately",
                    "if we're doing premultiplied alpha, we need to choose first the index that",
                    "determines the alpha value, and then do the other index",
                    "color mapping error calculation involves comparing pixel values"
                ]
            }
        ],
        "Normal": [
            "could be nindices2",
            "could be nindices2",
            "color mapping involves comparing pixel values and index values"
        ],
        "FuncName": "avpcl_mode5_8330 map_colors.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "do B next",
                    "Optimize each color channel using an alternating optimization algorithm to find the global minimum."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "start over",
                    "Restart the optimization process to explore other possible solutions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "figure out which endpoint when perturbed gives the most improvement and start there",
                    "To avoid getting stuck in a local minimum, we alternate between two endpoints to find the global minimum.",
                    "perturb endpt A",
                    "Perturb the first endpoint and see if it improves the result.",
                    "perturb endpt B",
                    "Perturb the second endpoint and see if it improves the result.",
                    "now alternate endpoints and keep trying until there is no improvement",
                    "Continue alternating between the two endpoints until no further improvement is found.",
                    "see if the indices have changed",
                    "Check if the current endpoint is the best one so far.",
                    "start over",
                    "If not, restart the process from the beginning."
                ]
            },
            {
                "loopstr": [
                    "now move the other endpoint",
                    "Move to the other endpoint and continue the optimization process."
                ]
            }
        ],
        "Normal": [
            "err0 = perturb(rgb0, delta0) err1 = perturb(rgb1, delta1) if (err0 < err1) if (err0 >= initial_error) break rgb0 += delta0 next = 1 else if (err1 >= initial_error) break rgb1 += delta1 next = 0 initial_err = map() for (;;) err = perturb(next ? rgb1:rgb0, delta) if (err >= initial_err) break next? rgb1 : rgb0 += delta initial_err = err ",
            "Optimize each color channel separately to find the best combination of values.",
            "Finally, perform a small exhaustive search around the current minimum to ensure it is the global minimum."
        ],
        "FuncName": "avpcl_mode5_8330 optimize_one.txt"
    },
    {
        "Branch": [
            "Calculate color and opacity endpoints for each region in the image."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Handle simple cases of color and opacity endpoints.",
                    "Project each pixel value along the principal direction of the image.",
                    "Choose as endpoints 2 points along the principal direction that span the projections of all of the pixel values.",
                    "Clamp the endpoints to ensure accurate color and opacity representation.",
                    "The argument for clamping is that the actual endpoints need to be clamped and thus we need to choose the best shape based on endpoints being clamped.",
                    "This process helps to refine the color and opacity endpoints for a more accurate image representation."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "avpcl_mode5_8330 rough.txt"
    },
    {
        "Branch": [
            "save configuration for if condition"
        ],
        "Loop": [
            "save configuration for loop condition"
        ],
        "Normal": [
            "resize image"
        ],
        "FuncName": "DkProcess_447 saveSettings.txt"
    },
    {
        "Branch": [
            "If the image is not loaded, display a placeholder.",
            "resize"
        ],
        "Loop": [
            "Loop through each image in the gallery.",
            "resize"
        ],
        "Normal": [
            "resize"
        ],
        "FuncName": "DkProcess_447 saveSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make name settings friendly",
            "generate image code"
        ],
        "FuncName": "DkProcess_447 settingsName.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "report we could not back-up & break here",
            "early break",
            "update metadata for image processing",
            "save the processed image"
        ],
        "FuncName": "DkProcess_447 process.txt"
    },
    {
        "Branch": [
            "Define if condition because of image type"
        ],
        "Loop": [
            "Define loop condition because of image type"
        ],
        "Normal": [
            "Define here because of includes and image type"
        ],
        "FuncName": "DkProcess_447 DkBatchTransform.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note: if two images are renamed at the same time to the same name, one image is lost -> see Qt comment Race Condition"
        ],
        "FuncName": "DkProcess_447 renameFile.txt"
    },
    {
        "Branch": [
            "delete or recover existing files"
        ],
        "Loop": [],
        "Normal": [
            "delete or recover existing files fall-back"
        ],
        "FuncName": "DkProcess_447 deleteOrRestoreExisting.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Resize to either width or height matches selection while other dimension is larger, with image processing",
                    "correct rounding error with image scaling",
                    "correct rounding error with image scaling"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkProcess_447 prepareProperties.txt"
    },
    {
        "Branch": [
            "Copy file to destination if condition is met."
        ],
        "Loop": [
            "Copy file to destination for each iteration."
        ],
        "Normal": [
            " report we could not back-up  break here"
        ],
        "FuncName": "DkProcess_447 copyFile.txt"
    },
    {
        "Branch": [
            "resize image"
        ],
        "Loop": [],
        "Normal": [
            "resize image"
        ],
        "FuncName": "DkProcess_447 saveSettings.txt"
    },
    {
        "Branch": [
            "border",
            "image"
        ],
        "Loop": [
            "border",
            "image"
        ],
        "Normal": [
            "borders",
            "image"
        ],
        "FuncName": "mainpanel_6982 paintEvent.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: image code for conditional logic"
        ],
        "Loop": [
            "Loop-Condition-Str: image code for loop condition"
        ],
        "Normal": [
            "Normal-Str: collect batch infos, image code for batch processing"
        ],
        "FuncName": "DkProcess_447 postLoad.txt"
    },
    {
        "Branch": [
            "item size + spacing + scrollbar + border",
            "image size hint: width + height"
        ],
        "Loop": [
            "item size + spacing + scrollbar + border",
            "image size hint: width + height"
        ],
        "Normal": [
            "item size + spacing + scrollbar + border",
            "image size hint: width + height"
        ],
        "FuncName": "mainpanel_6982 sizeHint.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "adjust thumbnail bar size & position"
        ],
        "FuncName": "mainpanel_6982 setupThumbnailStrip.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "output dir does not exist I cannot create it. Image processing requires a valid output directory."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkProcess_447 isOk.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "output directory does not exist, cannot create it, requires image processing and file system management"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkProcess_447 DkBatchProcessing.txt"
    },
    {
        "Branch": [
            "Check if file exists",
            "If file exists, then"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Set input/output file path",
                    "For each file in directory",
                    "Perform operation on file"
                ]
            }
        ],
        "Normal": [
            "This is a normal string",
            "It does not contain any image-related content"
        ],
        "FuncName": "DkProcess_447 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u6784\u9020\u4e3b\u9762\u677f\uff0c\u5305\u542b\u4e00\u4e2a\u6d6e\u52a8\u6309\u94ae\u5bb9\u5668\uff0c\u521b\u5efa\u591a\u4e2a\u52a8\u4f5c\u6309\u94ae\uff0c\u8bbe\u7f6e\u6309\u94ae\u5e03\u5c40\u548c\u6837\u5f0f\uff0c\u8fde\u63a5\u6309\u94ae\u4fe1\u53f7\u548c\u69fd\uff0c\u8bfb\u53d6\u8bbe\u7f6e\u3002",
            "connect(settings, SIGNAL(settingsChanged()), this, SLOT(readSettings()));"
        ],
        "FuncName": "mainpanel_6982 MainPanel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only one shape, image compression",
            "read indices from image",
            "lookup in image data"
        ],
        "FuncName": "zohone_7252 decompressone.txt"
    },
    {
        "Branch": [
            "Write a string that terminates with a null character, used in image code"
        ],
        "Loop": [],
        "Normal": [
            "Write a string that terminates with a null character, used in image code"
        ],
        "FuncName": "bitstream_4244 writeZeroTerminatedString.txt"
    },
    {
        "Branch": [
            "check if index is within image bounds"
        ],
        "Loop": [
            "loop through image pixels"
        ],
        "Normal": [
            "build list of possibles",
            "assign index to tile based on image pixel values"
        ],
        "FuncName": "zohone_7252 assign_indices.txt"
    },
    {
        "Branch": [
            "If condition string for image processing",
            "If condition string for image processing"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop condition string for image processing, get rid of string parsing!!!",
                    "Loop condition string for image processing, get rid of string parsing!!!"
                ]
            }
        ],
        "Normal": [
            "Normal string for image processing, reading isn't quite symmetric with writing -- we don't know the encoding until we decode the mode",
            "Normal string for image processing, reading isn't quite symmetric with writing -- we don't know the encoding until we decode the mode"
        ],
        "FuncName": "zohone_7252 read_header.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "scale endpoints with a quantized color palette",
            "really need a IntVector3 for color quantization",
            "interpolate colors in the palette"
        ],
        "FuncName": "zohone_7252 generate_palette_quantized.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "collect the pixels in the region",
                    "iterate over each pixel in the region",
                    "analyze the color and intensity of each pixel"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zohone_7252 optimize_endpts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "high bit is set, swap the endpts and indices for this region. This is a typical operation in image processing, where the high bit is used to indicate a specific attribute or property of the image."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "double check the table. This is a common operation in image analysis, where the table is used to store and retrieve information about the image."
                ]
            }
        ],
        "Normal": [
            "since WLOG we have the high bit of the shapes at 0. In image processing, the high bit is often used to indicate the presence or absence of a specific feature or attribute."
        ],
        "FuncName": "zohone_7252 swap_indices.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "get rid of string parsing",
                    "image compression algorithm applied"
                ]
            }
        ],
        "Normal": [
            "interpret the verilog backwards and process it",
            "image processing techniques used"
        ],
        "FuncName": "zohone_7252 write_header.txt"
    },
    {
        "Branch": [
            "Endpoint refiner function. These strings are for image codes."
        ],
        "Loop": [
            {
                "loopstr": [
                    "If this is an improvement, move the endpoint and continue searching from there."
                ]
            }
        ],
        "Normal": [
            "We have old endpoints: old_endpts",
            "We have disturbed endpoints: new_endpts",
            "We have temporary endpoints: temp_endpts",
            "Start with the current best error",
            "Copy the real endpoints so we can disturb them",
            "Search for the current best error (which one) in logarithmic form"
        ],
        "FuncName": "zohone_7252 perturb_one.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Absolute value of an image is calculated using absolute difference with zero."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 abs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "collect the mse values that are within 5% of the best values and compress the data optimize each mse value and choose the best image compression algorithm",
            "hack for now -- just use the best image compression algorithm"
        ],
        "FuncName": "zohone_7252 compressone.txt"
    },
    {
        "Branch": [
            "Determine the endpoints of each region in the image code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Handle simple cases in image processing.",
                    "Project each pixel value along the principal direction of the image.",
                    "Select the endpoints of the principal direction that span the projections of all pixel values.",
                    "Clamp the endpoints to ensure accurate results.",
                    "The argument for clamping is that the actual endpoints need to be adjusted to get the best shape based on clamped endpoints."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zohone_7252 roughone.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "precisions for all channels need to be the same, ensuring accurate image processing and reducing error margins."
                ]
            }
        ],
        "Normal": [
            "No candidate found, should never happen (refineone), indicating a potential issue with image processing or data quality."
        ],
        "FuncName": "zohone_7252 refineone.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Edge case: A and B differed in nchannels, we allocated dst to be the bigger of them, but adjusted roi to be the lesser. Now handle the channels that got left out because they were not common to all the inputs.",
                    "A exists",
                    "Image A and B difference in ROI region"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remaining cases error",
            "Image A and B difference in ROI region"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 absdiff.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Edge case: A and B differed in nchannels, we allocated dst to be the bigger of them, but adjusted roi to be the lesser. Now handle the channels that got left out because they were not common to all the inputs.",
                    "A exists",
                    "Image processing: handling channel differences between inputs."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remaining cases: error",
            "Image processing: error handling."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 min.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Remove alpha premultiplication from the source image. Mark the output as having unassociated alpha"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 unpremult.txt"
    },
    {
        "Branch": [
            "Formula courtesy of Sony Pictures Imageworks, Compressed image range"
        ],
        "Loop": [
            "Formula courtesy of Sony Pictures Imageworks, Compressed image range"
        ],
        "Normal": [
            "Formula courtesy of Sony Pictures Imageworks, Compressed image range"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 rangecompress.txt"
    },
    {
        "Branch": [
            "Compress the image within the specified region of interest (ROI)."
        ],
        "Loop": [],
        "Normal": [
            " Formula courtesy of Sony Pictures Imageworks Compresses the image within the specified region of interest (ROI)."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 rangecompress.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Define abs in terms of absdiff(A,0.0). Absolute value is the magnitude of a number without considering its sign. In image processing, absolute value is often used to calculate the pixel intensity or distance from a reference value."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 abs.txt"
    },
    {
        "Branch": [
            "Check if the image has unassociated alpha"
        ],
        "Loop": [
            "Loop through each pixel in the image"
        ],
        "Normal": [
            "Mark the output as having unassociated alpha",
            "Remove alpha channel from the source pixel"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 unpremult.txt"
    },
    {
        "Branch": [
            "If the image has an alpha channel, multiply its pixel values by the corresponding alpha value"
        ],
        "Loop": [],
        "Normal": [
            "Generate a new image with transparency information by multiplying the source image's pixel values by its corresponding alpha values"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 premult.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Formula courtesy of Sony Pictures Imageworks. This formula is a type of image processing algorithm, commonly used in computer vision.",
            " Since the compression step includes an absolute value, there are two possible results here. If x < x1 it is the incorrect result, so pick the other value. This is a common issue in image compression, where the absolute value can lead to incorrect results."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 rangeexpand.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Formula courtesy of Sony Pictures Imageworks. This formula is a representation of image compression, where x is the input value and x1 is the threshold value.",
            " Since the compression step includes an absolute value, there are two possible results here. If x < x1 it is the incorrect result, so pick the other value. This process is a common technique used in image processing to reduce data loss."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 rangeexpand.txt"
    },
    {
        "Branch": [
            " Formula courtesy of Sony Pictures Imageworks. Image compression involves expanding the image range.",
            " Since the compression step includes an absolute value, there are two possible results here. If x < x1 it is the incorrect result, so pick the other value. This is related to image processing techniques."
        ],
        "Loop": [
            " Formula courtesy of Sony Pictures Imageworks. Image compression involves expanding the image range.",
            " Since the compression step includes an absolute value, there are two possible results here. If x < x1 it is the incorrect result, so pick the other value. This is related to image processing techniques."
        ],
        "Normal": [
            " Formula courtesy of Sony Pictures Imageworks. Image compression involves expanding the image range.",
            " Since the compression step includes an absolute value, there are two possible results here. If x < x1 it is the incorrect result, so pick the other value. This is related to image processing techniques."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 rangeexpand.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Contrast adjustment: remapping the image to enhance its visual contrast."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 contrast_remap.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Some basic error checking on whether the channel set makes sense, This involves adjusting the color intensity of the image to enhance its visual appeal."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 saturate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Force all the input spans to have values for all channels. Adjusting image contrast for better visibility."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 contrast_remap.txt"
    },
    {
        "Branch": [
            "Checking if the image channel is within the valid range of 0 to 255"
        ],
        "Loop": [
            "Looping through each pixel in the image"
        ],
        "Normal": [
            "Some basic error checking on whether the channel set makes sense and normalizing the pixel values to be within the range of 0 to 1"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 saturate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Something went wrong, but image pixels are not defined in this case."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Initialize",
            "Start by copying dst to src, if they aren't the same image.",
            "Non-finite pixel values are not supported in all image formats.",
            "The copy operation was sufficient for other formats."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 fixNonFinite.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Decoding image channel information: No marked alpha channel, but suspiciously 4 channel -- assume it's RGBA.",
                    "Decoding image channel information: Assume alpha is the highest channel that's not z."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_pixelmath_8783 decode_over_channels.txt"
    },
    {
        "Branch": [
            "Repeat the source image"
        ],
        "Loop": [
            "Repeat the source image"
        ],
        "Normal": [
            "Clear the output of any prior marking of associated alpha",
            "Repeat the source image"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 repremult.txt"
    },
    {
        "Branch": [
            "Compute the pre-multiplied alpha value of the source image."
        ],
        "Loop": [],
        "Normal": [
            "Clear the output of any prior marking of associated alpha.",
            "Compute the pre-multiplied alpha value of the source image."
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 premult.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Clear the output of any prior marking of associated alpha, and then display the image of the source ROI region"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 repremult.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "reset zoom histogram, statistics and zoom. Image view updated.",
            "delete _imageViewers2.value(stepID); Image removed.",
            "_imageViewers2.remove(stepID); Image removed from view."
        ],
        "FuncName": "ImageViewerWindow_1776 removeProcessStep.txt"
    },
    {
        "Branch": [
            "If the alpha channel is not zero, then add the RGB values of the two images and keep the alpha channel of the first image."
        ],
        "Loop": [
            "For each pixel in the image, if the alpha channel is not zero, then add the RGB values of the two images and keep the alpha channel of the first image."
        ],
        "Normal": [
            "const int nchannels = 4, alpha_channel = 3;",
            "if (alpha != 0) { result.r += src1.r * alpha / 255; result.g += src1.g * alpha / 255; result.b += src1.b * alpha / 255; result.a = alpha; }"
        ],
        "FuncName": "imagebufalgo_pixelmath_8783 over_impl_rgbafloat.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Easy case -- both buffers are float, 4 channels, alpha is",
                    "channel[3], no special z channel, and pixel data windows",
                    "completely cover the roi. This reduces to a simpler case we can",
                    "handle without iterators and taking advantage of SIMD. In this case, the image A is overlaid on top of image B in the given roi, with the alpha channel of A used as a mask to combine the two images linearly."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_pixelmath_8783 over.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "imageinformation",
                    "histogramstatistics",
                    "displaytext"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "onlyupdateifpanelisnothidden"
        ],
        "FuncName": "ImageViewerWindow_1776 updateStatistics.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "IPImageViewer* imageViewer2 = new IPImageViewer(this, this);",
                    "imageViewer2->attachProcessStep(processStep, 0);",
                    "imageViewer2->setFrameStyle(QFrame::StyledPanel | QFrame::Raised);",
                    "Zoom in/out to match other windows",
                    "Add a new tab with image viewer",
                    "Add tab data for sorting and image display",
                    "",
                    "Add a grid item for image viewer",
                    "Grid layout:addWidget(imageViewer2, gridLayoutCounter/2, gridLayoutCounter%2);",
                    "Increment grid layout counter",
                    "Insert image viewer into _imageViewers2 with stepID"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Create a new tab with image viewer"
        ],
        "FuncName": "ImageViewerWindow_1776 addProcessStep.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Easy case -- both buffers are float, 4 channels, alpha is channel[3], no special z channel, and pixel data windows completely cover the roi. This reduces to a simpler case we can handle without iterators and taking advantage of SIMD. Image processing involves bitwise operations on specified roi regions of images A and B.",
                    "channel[3], no special z channel, and pixel data windows completely cover the roi. This reduces to a simpler case we can handle without iterators and taking advantage of SIMD. Bitwise operations on images A and B are performed on specified roi regions.",
                    "channel[3], no special z channel, and pixel data windows completely cover the roi. This reduces to a simpler case we can handle without iterators and taking advantage of SIMD. ROI-based bitwise operations are executed on images A and B."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imagebufalgo_pixelmath_8783 over.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "moving the tab pushed back a different tab into this spot, shift",
                    "i so we check it in the next loop",
                    "image: a visual representation of the tab movement process"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if the depth behind this one is less than this depth, we're not sorted",
                    "otherwise, if this stays true we can break out of the process early",
                    "just checking moveTo spot to see if it's in order",
                    "image: an iterative process to sort tabs by depth"
                ]
            }
        ],
        "Normal": [
            "sort tabs according to their depth",
            "get the tab bar that we can use to move tabs",
            "disable gui updates so we don't make tabs go crazy",
            "update the tab names",
            "turn the gui updates back on",
            "image: a graphical user interface for tab management"
        ],
        "FuncName": "ImageViewerWindow_1776 sortTabs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "set result index image"
        ],
        "FuncName": "ImageViewerWindow_1776 on_comboBoxResults_activated.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Zoom all image viewers in the window according to the specified action: apply zoom to all viewers",
            "Zoom all image viewers in the window according to the specified action: store the current zoom for new windows"
        ],
        "FuncName": "ImageViewerWindow_1776 zoomAllViewers.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "x% - Scale factor display updated"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ImageViewerWindow_1776 on_zoomChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "skip current tab",
                    "update image viewer scroll position when vertical scrollbar changes"
                ]
            }
        ],
        "Normal": [
            "store value for new Image viewer",
            "apply scroll position to all viewers and update image viewer scroll position when vertical scrollbar changes"
        ],
        "FuncName": "ImageViewerWindow_1776 on_verticalScrollBarChanged.txt"
    },
    {
        "Branch": [
            "Check if the horizontal scroll bar value changes, then update all views' scroll positions."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip the current tab and check if the horizontal scroll bar value changes."
                ]
            }
        ],
        "Normal": [
            "Store the value for new windows and apply the scroll position to all viewers.",
            "Update all views' scroll positions when the horizontal scroll bar value changes."
        ],
        "FuncName": "ImageViewerWindow_1776 on_horizontalScrollBarChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "update the scroll bars when they are moved by a drag and display the selected color"
        ],
        "FuncName": "ImageViewerWindow_1776 on_mouseClick.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "hightlight grid item",
            "apply global zoom modes",
            "update result selector",
            "display image in grid view",
            "switch to image zoom mode",
            "toggle image zoom and grid view"
        ],
        "FuncName": "ImageViewerWindow_1776 tabChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "close event handling function, close image viewer window and notify main window that image viewer is no longer visible"
        ],
        "FuncName": "ImageViewerWindow_1776 closeEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "add result names",
                    "select current result",
                    "image processing: adding result names and selecting current result"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ImageViewerWindow_1776 updateOutputs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init",
            "basic settings",
            "inputs and outputs",
            "properties",
            "image binary processing",
            "image code"
        ],
        "FuncName": "IPLBinarize_9616 init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "display floating message, fade out after delay"
        ],
        "FuncName": "floatingmessage_378 show.txt"
    },
    {
        "Branch": [
            " if(i > 0) compute copy and axpy operations for CRNN layer; otherwise, fill state with zeros. "
        ],
        "Loop": [
            {
                "loopstr": [
                    " compute copy and axpy operations for CRNN layer for each batch. "
                ]
            }
        ],
        "Normal": [
            " compute CRNN layer's forward pass. "
        ],
        "FuncName": "crnn_layer_5926 backward_crnn_layer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " iterates over tree elements, traversing the hierarchical structure of the image ",
            " bit counter, measuring the number of bits required to represent the image ",
            " length value, representing the length of the image or a specific feature ",
            " code value, representing a specific code or index in the image ",
            " distance index, indicating the distance between image features or pixels ",
            " number of codes at each bit length for an optimal tree, optimizing image compression ",
            " For some embedded targets, global variables are not initialized, requiring special handling ",
            " Initialize the mapping length (0..255) -> length code (0..28), establishing a correspondence between length values and codes ",
            " Note that the length 255 (match length 258) can be represented in two different ways: code 284 + 5 bits or code 285, so we overwrite length_code[255] to use the best encoding, optimizing image representation ",
            " Initialize the mapping dist (0..32K) -> dist code (0..29), establishing a correspondence between distance values and codes ",
            " from now on, all distances are divided by 128, simplifying distance calculations ",
            " Construct the codes of the static literal tree, creating a hierarchical structure for the image ",
            " Codes 286 and 287 do not exist, but we must include them in the tree construction to get a canonical Huffman tree (longest code all ones), ensuring a unique and efficient representation ",
            " The static distance tree is trivial, indicating a simple and straightforward structure for the image "
        ],
        "FuncName": "trees_4719 tr_static_init.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " default window size, fits the settings tab",
            " fun fact",
            " double an = pow(3987, 12); image: a mathematical expression",
            " double bn = pow(4365, 12); image: another mathematical expression",
            " qDebug() << 3987 ^ 12 + 4365 ^ 12 =  << pow(an + bn, 1/12.0) ^ 12; image: calculating the result of two mathematical expressions",
            " qDebug() << Sorry Fermat, but the Simpsons are right; image: a humorous comment on Fermat's Last Theorem"
        ],
        "FuncName": "DkNoMacs_4613 DkNoMacs.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "usage: img_mse_ipol image1 image2 - calculates the mean absolute error (RMSE) and peak signal-to-noise ratio (PSNR) between two PNG images."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: %s not found  or not a correct png image - please check the file path and ensure it's a valid PNG image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - this image has an alpha channel, which is not used in the calculation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - this image has an alpha channel, which is not used in the calculation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nc equals 3 - the number of channels in this image is 3, which is a valid color image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: %s not found  or not a correct png image - please check the file path and ensure it's a valid PNG image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - this image has an alpha channel, which is not used in the calculation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we do not use the alpha channel - this image has an alpha channel, which is not used in the calculation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nc2 equals 3 - the number of channels in this image is 3, which is a valid color image."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "error :: input images of different size or number of channels - please ensure both images have the same size and number of channels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "read input1 - read the first image.",
            "test if image is really a color image even if it has more than one channel - check if the image has 3 channels.",
            "read input2 - read the second image.",
            "test if image is really a color image even if it has more than one channel - check if the image has 3 channels.",
            "test if same size - check if both images have the same size.",
            "variables - declare variables for the calculation.",
            "compute error and image difference - calculate the mean absolute error (RMSE) and peak signal-to-noise ratio (PSNR) between the two images.",
            "RMSE: %2.2f - display the RMSE value.",
            "PSNR: %2.2f - display the PSNR value."
        ],
        "FuncName": "img_mse_ipol_6112 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "either finish picking coordinates",
            "either finish picking coordinates",
            "or lock the zoomer position"
        ],
        "FuncName": "ImageViewerWindow_1776 on_mouseDoubleClick.txt"
    },
    {
        "Branch": [
            "Conditionally convert input image data to binary image based on image type"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterate over progress of image conversion"
                ]
            }
        ],
        "Normal": [
            "Delete previous result of image conversion",
            "Get properties of input image data for image conversion"
        ],
        "FuncName": "IPLBinarize_9616 processInputData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "don't interfere with the main panel if the panel is enabled and positioned at the bottom, then set the preferred position to top, otherwise set it to bottom"
        ],
        "FuncName": "floatingmessage_378 readSettings.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "QMainWindow::mouseDoubleClickEvent(event) - Switches to full-screen mode when mouse is double-clicked."
        ],
        "FuncName": "DkNoMacs_4613 mouseDoubleClickEvent.txt"
    },
    {
        "Branch": [
            "help menu if condition"
        ],
        "Loop": [
            "help menu loop condition"
        ],
        "Normal": [
            "help menu"
        ],
        "FuncName": "DkNoMacs_4613 createActions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "close the window with a new instance started"
        ],
        "FuncName": "DkNoMacs_4613 restartFrameless.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Verify existence before deletion to avoid unintended actions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Assign 32px icon for Windows compatibility.",
            "Configure shortcuts and actions for user convenience.",
            "Android-specific: Register as a gesture recognizer for future use.",
            "Enable gesture recognition for pan, pinch, and swipe actions.",
            "Restore the window to its last saved position for continuity.",
            "Establish connections with the image loader for seamless functionality.",
            "Perform cleanup tasks to ensure a clean state."
        ],
        "FuncName": "DkNoMacs_4613 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if no resize is triggered the viewport won't change its color",
                    "image code: if condition met, viewport changes color"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkNoMacs_4613 exitFullScreen.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "User canceled - do not close. This is related to an image of a user canceling an action."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "do not close if the user hit cancel in the save changes dialog. This is related to an image of a dialog box with a cancel button."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "the frameless geometry is always the screen rect, don't save. This is related to an image of a window with a frameless geometry.",
                    "NOTE: saveGeometry() does not play well with mode switching, don't use it. This is related to an image of a person switching between different modes."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "TODO: this is temporary until currentAppMode is replaced with appMode. This is related to an image of a temporary placeholder."
        ],
        "FuncName": "DkNoMacs_4613 closeEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "setAttribute(Qt::WA_TransparentForMouseEvents);",
                    "get handle of the widget",
                    "This is related to image processing, specifically image events."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "TODO: find corresponding command for linux etc",
            "setWindowFlags(windowFlags() | Qt::WindowStaysOnTopHint);",
            "show();",
            "This is related to image display, specifically window flags and show functionality."
        ],
        "FuncName": "DkNoMacs_4613 lockWindow.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no sync menu in frameless view",
            "plugin menu with image icons",
            "plugin menu with customizable layout"
        ],
        "FuncName": "DkNoMacs_4613 createMenu.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compute new size for optimal image display",
            "check if resized image still fits on current screen size",
            "adjust image frame to maintain aspect ratio and correct distortions",
            "reset viewport and recalculate clipping area to compensate for round-off errors in image rendering"
        ],
        "FuncName": "DkNoMacs_4613 fitFrame.txt"
    },
    {
        "Branch": [
            "Open image file folder if image file exists"
        ],
        "Loop": [
            "Open image file folder for each image file"
        ],
        "Normal": [
            "Open image file folder to load image"
        ],
        "FuncName": "DkNoMacs_4613 openDir.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "add methods if clients are connected, including image upload and display functionality"
        ],
        "FuncName": "DkNoMacs_4613 newClientConnected.txt"
    },
    {
        "Branch": [
            "load system default open dialog: image condition"
        ],
        "Loop": [
            "load system default open dialog: image loop condition"
        ],
        "Normal": [
            "load system default open dialog: image loading"
        ],
        "FuncName": "DkNoMacs_4613 openFileList.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "get last location",
                    "don't use the browse explorer on windows",
                    "see #536",
                    "image: file explorer icon",
                    "image: folder icon",
                    "image: file icon"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkNoMacs_4613 showExplorer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "DkSettingsManager::param().display().thumbDockSize = qMin(thumbsDock->width(), thumbsDock->height()); Display or hide thumbnail dock based on image type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "nothing todo here, no image related content"
        ],
        "FuncName": "DkNoMacs_4613 showThumbsDock.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "modify the TCP window's position and size: change my geometry"
        ],
        "FuncName": "DkNoMacs_4613 tcpSendWindowRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "we are currently overlaid... with a TCP window position and transparency."
        ],
        "FuncName": "DkNoMacs_4613 tcpSetWindowRect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "get last location",
                    "display log dock window"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkNoMacs_4613 showLogDock.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Should we check for duplicates? This involves opening files and checking for duplicates.",
                    "These are code strings related to image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "> 1: only open in tab if more than one file is opened. This is a common operation in image editing.",
                    "These are code strings related to image processing."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Show message if at least one duplicate was found. This is a common task in image analysis.",
                    "These are code strings related to image processing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "load system default open dialog. This is a common operation in image processing.",
            "Save current count of tabs for setting tab position later. This is useful for image editing.",
            "Set first file opened to be the active tab. This is a common task in image analysis."
        ],
        "FuncName": "DkNoMacs_4613 openFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "updates are supported on windows only, including image updates and feature rollouts",
            "do we really need to check for update, especially for image-based deployments?"
        ],
        "FuncName": "DkNoMacs_4613 checkForUpdate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Opens the specified file path with the associated application. These strings are used in the image code as strings. bool started = process.startDetached(\\psOpenImages.exe, args);\t// already deprecated"
        ],
        "FuncName": "DkNoMacs_4613 openFileWith.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "quick dirty but currently he messes up the filteredFileList if the same folder was already loaded. This issue may be related to the image processing algorithm."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkNoMacs_4613 trainFormat.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: move to image loader? File sorted by name in ascending order.",
            "TODO: move to image loader? File sorted by size in ascending order.",
            "TODO: move to image loader? File sorted by creation date in ascending order.",
            "TODO: move to image loader? File sorted by modification date in ascending order.",
            "TODO: move to image loader? File sorted randomly.",
            "TODO: move to image loader? File sorted in ascending order.",
            "TODO: move to image loader? File sorted in descending order."
        ],
        "FuncName": "DkNoMacs_4613 changeSorting.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Here are some first-time requests with image description: A screenshot of a user interface with a button that says 'Submit'."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "load settings AFTER everything is initialized with image description: A picture of a settings icon.",
            "init global taskbar with image description: A screenshot of a taskbar with a globe icon."
        ],
        "FuncName": "DkNoMacs_4613 onWindowLoaded.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "mProgressDialog->setWindowModality(Qt::ApplicationModal); Downloading in progress...",
            "progressDialog->raise(); Downloading in progress...",
            "progressDialog->activateWindow(); Downloading in progress...",
            "mProgressDialog->setWindowModality(Qt::NonModal); Download complete."
        ],
        "FuncName": "DkNoMacs_4613 performUpdate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "check if the progress bar is already open. This is a conditional statement related to image processing, where the progress bar is a visual representation of the image processing status."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkNoMacs_4613 showUpdateDialog.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " mProgressDialogTranslations->setWindowModality(Qt::ApplicationModal); Downloading image... ",
            " progressDialog->raise(); Downloading image in progress... ",
            " progressDialog->activateWindow(); Downloading image completed. ",
            " mProgressDialogTranslations->setWindowModality(Qt::NonModal);"
        ],
        "FuncName": "DkNoMacs_4613 updateTranslations.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "overwrite file?",
                    "the second comparison is important for windows (case insensitive filenames)",
                    "tell user that deleting went wrong, and stop the renaming"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "cancel renaming",
                    "image: cancel operation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "tell user that deleting went wrong, and stop the renaming",
                    "image: deletion failed, renaming stopped"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "TODO: ref move!",
            "image: reference move pending"
        ],
        "FuncName": "DkNoMacs_4613 renameFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " close me if the new instance started. This is an image of a restart button with a red circle and a white center, indicating a stop or cancel action."
        ],
        "FuncName": "DkNoMacs_4613 restartWithPseudoColor.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove all the selected images from metadata.images and reload metadata into lb_images",
            "remove images and reload metadata into lb_images"
        ],
        "FuncName": "metadata_editor_1161 remove_selected_images.txt"
    },
    {
        "Branch": [
            "Initialize interface and connect signals for if condition."
        ],
        "Loop": [
            "Initialize interface and connect signals for loop condition."
        ],
        "Normal": [
            "filesystem view",
            "size",
            "type",
            "mod date",
            "---------------------------",
            "ask what to do via popup copy or move",
            "Display image metadata for better user understanding."
        ],
        "FuncName": "folderview_967 FolderView.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Make our current directory be the one that contains the metadata file. We do this because that file might contain relative paths to the image files we are supposed to be loading. This is a common practice in image processing pipelines.",
            "set the size of this window. The size of the window will be determined by the size of the image data.",
            "make sure the window is centered on the screen. This will ensure that the image is displayed in the center of the window."
        ],
        "FuncName": "metadata_editor_1161 metadata_editor.txt"
    },
    {
        "Branch": [
            "check if image is loaded",
            "check if image is visible",
            "check if image is enabled"
        ],
        "Loop": [
            "loop through image collection",
            "loop through image array",
            "loop through image list"
        ],
        "Normal": [
            "init members",
            "receive mouse event everytime",
            "in frameless, you cannot control if menu is visible...",
            "init() changed it",
            "actions that should always be disabled",
            "image is displayed at x=10, y=20",
            "image has a width of 100 and a height of 200",
            "image is loaded from file 'image.jpg'"
        ],
        "FuncName": "DkNoMacs_4613 DkNoMacsFrameless.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the user types a number then jump to that image.",
                    "Make 'w' and 's' act like KEY_UP and KEY_DOWN",
                    "Handle keyboard event: jump to image"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If it's been a while since the user typed numbers then forget the last jump",
                    "position and start accumulating numbers over again.",
                    "Handle keyboard event: reset jump position"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Don't do anything if there are no boxes in the current image.",
                    "Also don't do anything if there *are* boxes in the next image.",
                    "Handle keyboard event: check image for boxes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the label we are supposed to propagate doesn't exist in the current image",
                    "then don't advance.",
                    "if the next image is going to be empty then fast forward to the next one",
                    "Handle keyboard event: propagate label or fast forward"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Don't do anything if there are no boxes in the current image.",
                    "Also don't do anything if there *are* boxes in the next image.",
                    "Handle keyboard event: check image for boxes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the label we are supposed to propagate doesn't exist in the current image",
                    "then don't advance.",
                    "if the next image is going to be empty then fast forward to the next one",
                    "Handle keyboard event: propagate label or fast forward"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "metadata_editor_1161 on_keydown.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Select all images",
                    "Then unselect all currently selected images"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "metadata_editor_1161 select_image.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A condition is checked before executing a block of code. It is a fundamental concept in programming, often used in image processing to check for specific conditions such as image brightness or color.",
            ""
        ],
        "Loop": [
            "Loop-Condition-Str: A loop is a control structure that allows you to execute a block of code repeatedly for a specified number of times. It is commonly used in image processing to perform repetitive tasks such as image filtering or feature extraction.",
            ""
        ],
        "Normal": [
            "init members: Initialize image processing parameters such as image size, color mode, and threshold values.",
            "receive mouse event every time: Receive mouse events in real-time to capture user interactions and update the image processing pipeline accordingly."
        ],
        "FuncName": "DkNoMacs_4613 DkNoMacsIpl.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Identify the matching image box and propagate the label. The string is from image code.",
                    "If a matching rectangle is found in the next image and the best match does not already have a label.",
                    "figure out which box in the next image matches the current one the best"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "metadata_editor_1161 propagate_labels.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "add temporary arrow item in a graph scene"
        ],
        "FuncName": "IPProcessGridScene_7008 IPProcessGridScene.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO maybe add a focus change indication a border blink or something"
        ],
        "FuncName": "folderview_967 onTreeViewTabOut.txt"
    },
    {
        "Branch": [
            "The next element in the random sequence is: ",
            "Random sequence element: "
        ],
        "Loop": [
            "The next element in the random sequence is: ",
            "Random sequence element: "
        ],
        "Normal": [
            "Re-shuffle when needed because the vector gets rearranged, this will break prev()",
            "Random sequence element: "
        ],
        "FuncName": "randomizer_3447 next.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "only take selected steps not other items"
                ]
            }
        ],
        "Normal": [
            "close the settings window to prevent invalid pointers",
            "remove the selected items"
        ],
        "FuncName": "IPProcessGridScene_7008 deleteSelectedItems.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "ok, I'm done with this. None of the solutions work. It seems that the image model is not loaded in time, causing the scroll to be too noticeable.",
            "Just do scrollTo after a delay and hope that the image model is loaded by then. This will ensure that the image is displayed correctly.",
            "Larger than ~150ms becomes too noticeable. It's recommended to use a smaller delay to avoid this issue."
        ],
        "FuncName": "folderview_967 setDirectoryPath.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Fixes popup being shown again right after dismissing it by clicking on this toggle button. This issue is only present on windows (different Qt::Popup behavior). The image type is related to the toggle button, which is a graphical element that can be displayed or hidden.",
                    " Fixes popup being shown again right after dismissing it by clicking on this toggle button. This issue is only present on windows (different Qt::Popup behavior). The image type is related to the toggle button, which is a graphical element that can be displayed or hidden."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "folderview_967 onOptionsPopupButtonToggled.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove edges from image, set inputs not occupied"
        ],
        "FuncName": "IPProcessGridScene_7008 removeEdge.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create process step and add to main window",
            "this process step",
            "calculate relative position and image coordinates"
        ],
        "FuncName": "IPProcessGridScene_7008 createProcessStep.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove image from viewer window",
            "remove image edges",
            "remove image step"
        ],
        "FuncName": "IPProcessGridScene_7008 removeStep.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This seems a bit complex...",
                    "However, points are not stored in a clockwise order..."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "DkMath_2102 cpCursor.txt"
    },
    {
        "Branch": [
            "If condition string with image description: A conditional statement that checks if a certain condition is met, similar to an image filter that checks if a certain pixel value is within a certain range."
        ],
        "Loop": [
            "Loop condition string with image description: A loop that iterates over a collection of images, similar to a image processing algorithm that applies a series of filters to each image in a collection."
        ],
        "Normal": [
            "5px padding from stylesheet, which is similar to adding a border around an image to make it stand out."
        ],
        "FuncName": "menuitem_8837 MenuItem.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Only handle AudioSpecificConfig from ISO/IEC 14496-3:200X(E) subpart 1, a configuration record for MP4 audio decoder."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "mp4audiodecoderconfigrecord_5425 getConfigurationMap.txt"
    },
    {
        "Branch": [
            "Rotate the image according to Exif data"
        ],
        "Loop": [
            "Rotate the image according to Exif data"
        ],
        "Normal": [
            "Rotate the image according to Exif data"
        ],
        "FuncName": "DkMath_2102 fromExifRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "default upper left corner is 0, typically represented by an image with a red dot at the top left corner"
        ],
        "FuncName": "DkMath_2102 getAngle.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "opposite corner of image"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "index does not exist in image",
            "these indices indicate the control points on edges of image"
        ],
        "FuncName": "DkMath_2102 updateCorner.txt"
    },
    {
        "Branch": [
            "Check if the image is a rectangle before rotating it"
        ],
        "Loop": [
            "Rotate the image by the specified angle"
        ],
        "Normal": [
            "round to 2 digits of the image's rotation angle"
        ],
        "FuncName": "DkMath_2102 getAngleDeg.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "apply transform",
            "Check the order of vertices in a quadrilateral",
            "If it's incorrect, just reorder it",
            "update quadrilateral corners"
        ],
        "FuncName": "DkMath_2102 transform.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "default upper left corner is 0",
            "switch width/height for / and \\/ quadrants",
            "rotating a rectangle involves scaling and translation"
        ],
        "FuncName": "DkMath_2102 size.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "We need the second quadrant, but I don't know why... just tried it."
                ]
            }
        ],
        "Normal": [
            " TODO: If angle > 0 I will encounter a problem (photoshop interpretation is the same as ours)",
            " Coordinate normalization: "
        ],
        "FuncName": "DkMath_2102 toExifRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "default upper left corner is 0, translation matrix for rectangle rotation",
            "switch width/height for / and \\/ quadrants, scaling factor for rotated rectangle",
            "invariance user does not want to make a difference between an upside down mRect, rectangle orientation after rotation",
            "round guarantees that pixels are not interpolated, anti-aliasing techniques for rotated rectangle"
        ],
        "FuncName": "DkMath_2102 getTransform.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "assigning a QRectF to a QPolygonF results in a closed polygon - but we want it to be open so remove the last point. This is related to image processing where rectangles are often used to represent regions of interest (ROIs) in images."
        ],
        "FuncName": "DkMath_2102 setSize.txt"
    }
]