[
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Insert a TCP segment into the network"
        ],
        "FuncName": "tcp_stream_28 safe_insert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "old distance of node u updated to other nodes",
            "node u is now in the network"
        ],
        "FuncName": "GroupCloseness_998 updateDistances.txt"
    },
    {
        "Branch": [
            "timeout: network timeout"
        ],
        "Loop": [
            "timeout: network timeout"
        ],
        "Normal": [
            "timeout: network timeout"
        ],
        "FuncName": "client_390 timeoutcb.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " computes the marginal gain due to adding u to S, where u is a node in the network",
            " old distance of u in the network"
        ],
        "FuncName": "GroupCloseness_998 computeImprovement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This callback is invoked when there is data to read on network buffer.",
            "Copy all the data from the network input buffer to the output buffer for further network processing."
        ],
        "FuncName": "client_390 readcb.txt"
    },
    {
        "Branch": [
            "we check if H > 0 and calculate the total distance from point set S to all points in the network"
        ],
        "Loop": [
            "we iterate over all points in the network and calculate the distance from point set S to each point"
        ],
        "Normal": [
            "we run a BFS from S up to distance H if H > 0 and sum the distances"
        ],
        "FuncName": "GroupCloseness_998 computeFarness.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO use later",
                    "In a network, this would be a node with high centrality scores."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "first, we store the distances between each node and the top node",
            "init S",
            "TODO change",
            "loop to find k group members in the network."
        ],
        "FuncName": "GroupCloseness_998 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Prefer set_basic over set_rle when there are 2 or less symbols. Since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol. If basic encoding isn't possible, always choose RLE. This is relevant for network protocols that use variable-length encoding schemes. "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " 28-36 for offset, 56-72 for lengths , Network protocols often use these values for packet headers. xx_DEFAULTNORMLOG "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " The format allows default tables to be repeated, but it isn't useful for network protocols. When using simple heuristics to select encoding type, we don't want to confuse these tables with dictionaries. When running more careful analysis, we don't need to waste time checking both repeating tables and default tables. "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "zstd_compress_sequences_2209 ZSTD_selectEncodingType.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "NOT Connected",
                    "Network connection failed: unable to establish a connection to the server."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "client_390 eventcb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "31",
                    "Network encoding for IF condition: then clause"
                ],
                "elsestr": [
                    "Network encoding for IF condition: else clause"
                ]
            },
            {
                "thenstr": [
                    "(7)",
                    "Network encoding for IF condition: then clause"
                ],
                "elsestr": [
                    "Network encoding for IF condition: else clause"
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "intentional underflow",
                    "Network encoding for Loop condition: loop body",
                    "32b",
                    "Network encoding for Loop condition: loop body",
                    "(7)",
                    "Network encoding for Loop condition: loop body",
                    "15",
                    "Network encoding for Loop condition: loop body",
                    "24",
                    "Network encoding for Loop condition: loop body",
                    "(7)",
                    "Network encoding for Loop condition: loop body",
                    "16",
                    "Network encoding for Loop condition: loop body",
                    "(7)",
                    "Network encoding for Loop condition: loop body",
                    "(7)",
                    "Network encoding for Loop condition: loop body"
                ]
            }
        ],
        "Normal": [
            "first symbols",
            "Network encoding for Normal string"
        ],
        "FuncName": "zstd_compress_sequences_2209 ZSTD_encodeSequences_body.txt"
    },
    {
        "Branch": [
            "force reset of btopt stats in network context"
        ],
        "Loop": [
            "force reset of btopt stats in network context"
        ],
        "Normal": [
            "force reset of btopt stats in network context"
        ],
        "FuncName": "compress_691 ZSTD_continueCCtx.txt"
    },
    {
        "Branch": [
            "If dstCapacity is already guaranteed to be >=4, hence large enough, then "
        ],
        "Loop": [
            "While dstCapacity is not guaranteed to be >=4, hence large enough, then "
        ],
        "Normal": [
            " dstCapacity already guaranteed to be >=4, hence large enough for network transmission "
        ],
        "FuncName": "compress_691 ZSTD_compressRleLiteralsBlock.txt"
    },
    {
        "Branch": [
            "Release compressed context for if-conditions in network protocols.",
            "Release compressed context for if-conditions in network protocols."
        ],
        "Loop": [
            "Release compressed context for loop-conditions in network protocols.",
            "Release compressed context for loop-conditions in network protocols."
        ],
        "Normal": [
            "Support free on null for network data transmission.",
            "Reserved as a potential error code for network protocol in the future."
        ],
        "FuncName": "compress_691 ZSTD_freeCCtx.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Error starting connection to the network server on port ",
                    "Error starting connection to the specified network endpoint on port "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Connecting to the network server at IP address ",
            "Reading ",
            " messages from the network server.",
            "Average message size: ",
            "Throughput: "
        ],
        "FuncName": "client_390 main.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Based on the network condition, the compression context requires a workspace size of"
        ],
        "Loop": [
            "Loop-Condition-Str: Within the network loop, the compression context necessitates a workspace size of"
        ],
        "Normal": [
            "Normal-Str: huffTable  + tokenSpace + Compression context workspace size: "
        ],
        "FuncName": "compress_691 ZSTD_CCtxWorkspaceBound.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "31 (ZSTD compression context)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "(7) (ZSTD compression context)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "intentional underflow (ZSTD compression context)",
                    "32b // 64b (ZSTD compression context)",
                    "(7) (ZSTD compression context)",
                    "15   // 15 (ZSTD compression context for sequence compression)",
                    "24  // 24 (ZSTD compression context for sequence compression)",
                    "(7) (ZSTD compression context)",
                    "16  // 33 (ZSTD compression context for sequence compression)",
                    "(7) (ZSTD compression context)",
                    "(7) (ZSTD compression context)",
                    "(7) (ZSTD compression context)"
                ]
            }
        ],
        "Normal": [
            "compressed, raw or rle (ZSTD compression context)",
            "Compress literals (in ZSTD compression context)",
            "Sequences Header (ZSTD compression context)",
            "seqHead : flags for FSE encoding type (in ZSTD compression context)",
            "convert length/distances into codes (in ZSTD compression context)",
            "CTable for Literal Lengths (in ZSTD compression context)",
            "CTable for Offsets (in ZSTD compression context)",
            "CTable for MatchLengths (in ZSTD compression context)",
            "Encoding Sequences (in ZSTD compression context)"
        ],
        "FuncName": "compress_691 ZSTD_compressSequences_internal.txt"
    },
    {
        "Branch": [
            "copy tables with ZSTD compression context",
            "copy dictionary offsets with ZSTD compression context",
            "copy entropy tables with ZSTD compression context"
        ],
        "Loop": [
            "loop through tables with ZSTD compression context",
            "loop through dictionary offsets with ZSTD compression context",
            "loop through entropy tables with ZSTD compression context"
        ],
        "Normal": [
            "copy tables",
            "copy dictionary offsets",
            "copy entropy tables"
        ],
        "FuncName": "compress_691 ZSTD_copyCCtx.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "small don't even attempt compression speed optimization for network protocols",
            "not enough space for network compression",
            "Build network header"
        ],
        "FuncName": "compress_691 ZSTD_compressLiterals.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no size information available : no adjustment",
            "adjusting compression parameters to optimize for source size and dictionary size",
            "dynamic window size and hash size adjustment for efficient data transmission"
        ],
        "FuncName": "compress_691 ZSTD_adjustCParams.txt"
    },
    {
        "Branch": [
            "Network Condition: If the srcSize <= dstCapacity, then there is enough space to write a raw uncompressed block. Since we ran out of space, the block must not be compressible, so fall back to a raw uncompressed block., Compression Type: Network"
        ],
        "Loop": [],
        "Normal": [
            "Network Condition: confirm repcodes, Compression Type: Network"
        ],
        "FuncName": "compress_691 ZSTD_compressSequences.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: In a network, a conditional statement is used to execute different blocks of code based on a condition."
        ],
        "Loop": [
            "Loop-Condition-Str: In a network, a loop is used to execute a block of code repeatedly until a certain condition is met."
        ],
        "Normal": [
            "Normal-Str: In a network, a normal statement is used to execute a block of code without any conditions or loops."
        ],
        "FuncName": "compress_691 ZSTD_BtFindBestMatch.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "necessarily within correct buffer",
                    "match is smaller than curr",
                    "update smaller idx",
                    "all smaller will now have at least this guaranteed common length",
                    "beyond tree size, stop the search",
                    "new smaller => larger of match",
                    "new matchIndex larger than previous (closer to curr) and utilizing network protocols for efficient data transfer"
                ]
            },
            {
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "guaranteed minimum nb of common bytes",
                    "drop, to guarantee consistency; miss a bit of compression, but other solutions can corrupt the tree and require network retransmission"
                ]
            }
        ],
        "Normal": [
            "to be nullified at the end and ensuring network connectivity",
            "Update Hash Table and synchronizing with network resources",
            "speed optimization and leveraging network caching"
        ],
        "FuncName": "compress_691 ZSTD_insertBt1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Fill Table",
                    "here because curr+2 could be > iend-8",
                    "check immediate repcode",
                    "\u5feb\u901f\u7684\u901a\u7528\u538b\u7f29\u5757\u51fd\u6570\u7528\u4e8e\u6761\u4ef6\u5224\u65ad"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "< instead of <=, because repcode check at (ip+1)",
                    "update hash table",
                    "match found",
                    "\u5feb\u901f\u7684\u901a\u7528\u538b\u7f29\u5757\u51fd\u6570\u7528\u4e8e\u5faa\u73af\u6761\u4ef6"
                ]
            },
            {
                "loopstr": [
                    "store sequence",
                    "swap offset_2 <=> offset_1",
                    "faster when present ... (?)",
                    "\u5feb\u901f\u7684\u901a\u7528\u538b\u7f29\u5757\u51fd\u6570\u7528\u4e8e\u5faa\u73af\u6761\u4ef6"
                ]
            }
        ],
        "Normal": [
            "init",
            "Main Search Loop",
            "save reps for next block",
            "Last Literals",
            "\u5feb\u901f\u7684\u901a\u7528\u538b\u7f29\u5757\u51fd\u6570\u7528\u4e8e\u6b63\u5e38\u903b\u8f91"
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_fast_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "by construction, offset_1 <= curr. In network protocols, this condition is used to determine whether a packet has been received correctly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "catch up. In network protocols, this action is used to synchronize data between devices."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "catch up. In network protocols, this action is used to synchronize data between devices."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fill Table. In network protocols, this operation is used to populate a table with data from a remote device. here because curr+2 could be > iend-8. This is a common issue in network protocols where the buffer size is not sufficient to hold all the data.",
                    "check immediate repcode. In network protocols, this check is used to verify the integrity of the received data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "< instead of <=, because repcode check at (ip+1). In network protocols, this condition is used to optimize the loop by avoiding unnecessary iterations. update hash tables. In network protocols, this action is used to maintain a hash table of received data. match found. In network protocols, this indicates that a match has been found in the hash table."
                ]
            },
            {
                "loopstr": [
                    "store sequence. In network protocols, this operation is used to store a sequence of data. swap offset_2 <=> offset_1. In network protocols, this operation is used to swap two offsets. faster when present ... (?). In network protocols, this indicates that the operation is faster when the data is present."
                ]
            }
        ],
        "Normal": [
            "init. In network protocols, this is the initial state of the system.",
            "Main Search Loop. In network protocols, this is the main loop where data is searched and processed.",
            "save reps for next block. In network protocols, this operation is used to save repeated data for the next block.",
            "Last Literals. In network protocols, this indicates the last literal data in the block."
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_doubleFast_generic.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "copy Literals to Network Storage",
            "Network Storage Literal Length",
            "match offset in Network Storage",
            "match Length in Network Storage"
        ],
        "FuncName": "compress_691 ZSTD_storeSeq.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Fill Table ",
                    "check immediate repcode ",
                    "network compression and decoding"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "swap offset_2 <=> offset_1 ",
                    "network packet switching and routing"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " < instead of <=, because (ip+1) ",
                    " offset_1 expected <= curr +1 ",
                    " update hash table ",
                    "network protocol optimization and caching"
                ]
            }
        ],
        "Normal": [
            "Search Loop ",
            "found a match : store it ",
            "network data processing and storage"
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_doubleFast_extDict_generic.txt"
    },
    {
        "Branch": [
            " input becomes curr prefix, network code executed "
        ],
        "Loop": [
            " input becomes curr prefix, network loop executed "
        ],
        "Normal": [
            " input becomes curr prefix, network data processed "
        ],
        "FuncName": "compress_691 ZSTD_loadDictionaryContent.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "catch up and synchronize with network"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "compress_691 ZSTD_insertAndFindFirstIndex.txt"
    },
    {
        "Branch": [
            "If-Condition-Str with network type: ZSTD_BtFindBestMatch_selectMLS_extDict"
        ],
        "Loop": [
            "Loop-Condition-Str with network type: ZSTD_BtFindBestMatch_selectMLS_extDict"
        ],
        "Normal": [
            "skipped area with network type: ZSTD_BtFindBestMatch_selectMLS_extDict"
        ],
        "FuncName": "compress_691 ZSTD_BtFindBestMatch_selectMLS_extDict.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compression not recommended below a certain source size in network protocols.",
            "Update tree not updated after finding very long repeated matches in network protocols."
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_internal.txt"
    },
    {
        "Branch": [
            "If (condition)"
        ],
        "Loop": [
            "For (condition)"
        ],
        "Normal": [
            "0-3",
            "Header (0-3)"
        ],
        "FuncName": "compress_691 ZSTD_writeFrameHeader.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The maximum offset that must be supported",
                    "Calculate minimum offset code required to represent maxOffset",
                    "ZSTD_loadZstdDictionary loads a Zstandard dictionary, reading its contents and initializing the compression context."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "skip magic number"
        ],
        "FuncName": "compress_691 ZSTD_loadZstdDictionary.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of a compression network, we should take the repcode detected pattern to improve compression efficiency."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, jumping over incompressible sections can help to improve compression speed."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, detecting repcode is a crucial step."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, searching for a better pattern can lead to improved compression results."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, checking repCode and searching for a match with a depth of 2 can help to identify patterns."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, detecting repcode is a crucial step."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, catching up with the compression process can help to improve efficiency."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a compression network, taking the repcode detected pattern and swapping the offset history can lead to faster compression when the pattern is present."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In a compression network, checking repCode and searching for a match, then storing the sequence and checking immediate repcode can help to identify patterns."
                ]
            },
            {
                "loopstr": [
                    "In a compression network, searching for a match with a depth of 1 and finding an even better pattern can lead to improved compression results."
                ]
            }
        ],
        "Normal": [
            "Initializing the compression process.",
            "Matching patterns in the compression loop.",
            "Saving reps for the next block in the compression process.",
            "Handling last literals in the compression process."
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_lazy_extDict_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "enforce maxDist",
                    "Data Compression: Target Buffer Overflow Prevention"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "block is not compressible",
                    "no pb, 4th byte will be overwritten",
                    "Data Compression: Incompressible Block Handling"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "not enough space to store compressed block",
                    "preemptive overflow correction",
                    "Data Compression: Buffer Overflow Handling"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "compress_691 ZSTD_compress_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "not contiguous",
                    "too small extDict",
                    "Network error: data block compression failed due to non-contiguous data or insufficient external dictionary size."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "missing init (ZSTD_compressBegin)",
            "Check if blocks follow each other",
            "if input and dictionary overlap : reduce dictionary (area presumed modified by input) Network error: data block compression failed due to overlapping input and dictionary."
        ],
        "FuncName": "compress_691 ZSTD_compressContinue_internal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "repcode: we take it, a compression technique used in ZSTD network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "jump faster over incompressible sections, a common issue in network data transmission"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "search a better one, optimizing data compression in network communication"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check repCode, a compression algorithm used in ZSTD network protocol",
                    "first search (depth 0), initial step in data compression",
                    "let's try to find a better solution, optimizing data compression in network communication",
                    "NOTE: * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior. * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which * overflows the pointer, which is undefined behavior, a common issue in network data transmission",
                    "catch up, synchronizing data in network communication",
                    "store sequence, storing compressed data in network protocol",
                    "check immediate repcode, verifying data compression in network communication"
                ]
            },
            {
                "loopstr": [
                    "let's find an even better one, continuous optimization in data compression",
                    "nothing found: store previous solution, fallback in data compression"
                ]
            },
            {
                "loopstr": [
                    "store sequence, storing compressed data in network protocol",
                    "swap repcodes, exchanging compression algorithms in network communication",
                    "faster when present... (?), optimizing data compression in network communication"
                ]
            }
        ],
        "Normal": [
            "init, initializing data compression in network protocol",
            "Match Loop, matching compression algorithms in network communication",
            "Save reps for next block, storing compressed data for future use",
            "Last Literals, final step in data compression"
        ],
        "FuncName": "compress_691 ZSTD_compressBlock_lazy_generic.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "zcs has not been initialized at least once, which prevents the reset of the internal state.",
            "Ready to proceed with the network request."
        ],
        "FuncName": "compress_691 ZSTD_resetCStream_internal.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "support free on NULL, releasing compressed stream object memory."
        ],
        "FuncName": "compress_691 ZSTD_freeCStream.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Not enough input to get a full block, stop there and wait for more."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "description": "A loop condition string that requires network connectivity to evaluate."
            }
        ],
        "Normal": [
            {
                "description": "A normal string that may require network data to be processed."
            }
        ],
        "FuncName": "compress_691 ZSTD_compressStream_generic.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "dict as pure content for zstd compression",
            "dict as zstd dictionary for zstd compression"
        ],
        "FuncName": "compress_691 ZSTD_compress_insertDictionary.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u538b\u7f29\u53c2\u6570\u9a8c\u8bc1\u548c\u4f18\u5316\uff0c\u542f\u52a8\u538b\u7f29\u8fc7\u7a0b"
        ],
        "FuncName": "compress_691 ZSTD_compressBegin_advanced.txt"
    },
    {
        "Branch": [
            "Refresh data from compressed stream to buffer if condition is met"
        ],
        "Loop": [
            "Refresh data from compressed stream to buffer for loop condition"
        ],
        "Normal": [
            "Refresh data from compressed stream to buffer"
        ],
        "FuncName": "compress_691 ZSTD_flushStream.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "write one last empty block, make it the last block",
                    "last block  + (((U32)bt_raw) << 1) + 0;",
                    "This is a network protocol code, specifically for writing to a compressed library."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "This is a network protocol code, specifically for loops in compressed library writing.",
            "No specific string found, defaulting to general loop description."
        ],
        "Normal": [
            "init missing ",
            "special case : empty frame ",
            "return to created but no init status ",
            "This is a network protocol code, specifically for normal operations in compressed library writing."
        ],
        "FuncName": "compress_691 ZSTD_writeEpilogue.txt"
    },
    {
        "Branch": [
            "initialize the compression stream for if-conditions in the network",
            "configure the buffer and hash table for if-conditions in the network"
        ],
        "Loop": [
            "initialize the compression stream for loop-conditions in the network",
            "configure the buffer and hash table for loop-conditions in the network"
        ],
        "Normal": [
            "allocate buffers for normal network operations",
            "initialize the compression stream for normal network operations"
        ],
        "FuncName": "compress_691 ZSTD_initCStream_advanced.txt"
    },
    {
        "Branch": [
            "Release CDict memory if condition is met"
        ],
        "Loop": [
            "Release CDict memory in loop iteration"
        ],
        "Normal": [
            "support free on NULL, CDict memory release"
        ],
        "FuncName": "compress_691 ZSTD_freeCDict.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "End compression stream, produce final block.",
                    "Use a valid source address instead of null.",
                    "Create epilogue.",
                    "Write epilogue, including final empty block, into output buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Pledged source size not respected.",
            "Flush epilogue."
        ],
        "FuncName": "compress_691 ZSTD_endStream.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "set the margins of this layout element according to automatic margin calculation, either directly or via a margin group:",
                    "For Network, this means configuring the layout to adapt to the network topology and optimize data transfer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": []
            }
        ],
        "Normal": [
            {
                "normalstr": []
            }
        ],
        "FuncName": "qcustomplot_7449 update.txt"
    },
    {
        "Branch": [
            "Conditional statement for network initialization",
            "Check if network is ready before proceeding"
        ],
        "Loop": [
            "Loop condition for network iterations",
            "Iterate over network connections or packets"
        ],
        "Normal": [
            " don't setRenderHint(QPainter::NonCosmeticDefaultPen) here, because painter isn't active yet and",
            " a call to begin() will follow. This is crucial for network rendering",
            " as it ensures the painter is properly initialized before drawing"
        ],
        "FuncName": "qcustomplot_7449 QCPPainter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "query all automatic margins of the layout elements in this margin group side and find maximum",
            "related to CSS margin property"
        ],
        "FuncName": "qcustomplot_7449 commonMargin.txt"
    },
    {
        "Branch": [
            "if (deviceType == \"x11\") { ... }",
            "if (deviceType == \"windows\") { ... }",
            "if (deviceType == \"mac\") { ... }"
        ],
        "Loop": [
            "for (int i = 0; i < 10; i++) { ... }",
            "while (condition) { ... }"
        ],
        "Normal": [
            "don't setRenderHint(QPainter::NonCosmeticDefaultPen) here, because painter isn't active yet and a call to begin() will follow",
            "this is a normal string without network type related content"
        ],
        "FuncName": "qcustomplot_7449 QCPPainter.txt"
    },
    {
        "Branch": [
            "Check if the range is valid: -maxRange < lower < upper < maxRange and abs(lower-upper) > minRange and (lower < -minRange or lower > minRange) and (upper < -minRange or upper > minRange)"
        ],
        "Loop": [],
        "Normal": [
            "Check if the range is valid: -maxRange < lower < upper < maxRange and abs(lower-upper) > minRange and (lower < -minRange or lower > minRange) and (upper < -minRange or upper > minRange)"
        ],
        "FuncName": "qcustomplot_7449 validRange.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "auto-correction for 32bits mode"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "intentional underflow for srcSizeHint == 0",
            "0 == default; no negative compressionLevel yet"
        ],
        "FuncName": "compress_691 ZSTD_getCParams.txt"
    },
    {
        "Branch": [
            " return (lower > -maxRange && upper < maxRange && abs(lower-upper) > minRange && (lower < -minRange || lower > minRange) && (upper < -minRange || upper > minRange) && contains(lower, 'network') && contains(upper, 'network') ); "
        ],
        "Loop": [
            " return (lower > -maxRange && upper < maxRange && abs(lower-upper) > minRange && (lower < -minRange || lower > minRange) && (upper < -minRange || upper > minRange) && contains(lower, 'network') && contains(upper, 'network') ); "
        ],
        "Normal": [
            " return (lower > -maxRange && upper < maxRange && abs(lower-upper) > minRange && (lower < -minRange || lower > minRange) && (upper < -minRange || upper > minRange) && contains(lower, 'network') && contains(upper, 'network') ); "
        ],
        "FuncName": "qcustomplot_7449 validRange.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "case lower is 0 in log scale"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "invalid range in log plot, adjusting to valid range",
            "if (qFuzzyCompare(sanitizedRange.lower+1, 1) && !qFuzzyCompare(sanitizedRange.upper+1, 1)) for log scale",
            "else if (!qFuzzyCompare(lower+1, 1) && qFuzzyCompare(upper+1, 1)) in log scale",
            "in log scale, lower>0 and upper<0 is undefined, adjusting range"
        ],
        "FuncName": "qcustomplot_7449 sanitizedForLogScale.txt"
    },
    {
        "Branch": [
            "If statement: evaluates to true or false based on network conditions."
        ],
        "Loop": [
            {
                "loopstr": [
                    "removes itself from mChildren via removeChild in a network-controlled loop."
                ]
            }
        ],
        "Normal": [
            "In a network-managed scenario, makes all children remove themselves from this margin group:"
        ],
        "FuncName": "qcustomplot_7449 clear.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "when drawing with a cosmetic pen, which produces a perfectly thin stroke, the output is only in vector formats, draw the bar exactly on the tip of the line, a characteristic of network topology"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to create arrow heads with a spiky appearance, a common feature in network diagrams"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line, utilizing network protocols for precise control"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey, leveraging network connectivity for enhanced rendering"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " warning: this is called in QCPAxis constructor, so parentAxis members should not be accessed/called. Grid properties are set for network type."
        ],
        "FuncName": "qcustomplot_7449 QCPGrid.txt"
    },
    {
        "Branch": [
            "If the condition is met, expand the grid to the specified number of rows and columns."
        ],
        "Loop": [
            "For each iteration, expand the grid to the specified number of rows and columns."
        ],
        "Normal": [
            "add rows as necessary: Expand the grid to the specified number of rows.",
            "go through rows and expand columns as necessary: Expand the grid to the specified number of columns."
        ],
        "FuncName": "qcustomplot_7449 expandTo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "draw zeroline: Grid lines are drawn on the x-axis and y-axis.",
                    "draw grid lines: These lines help to visualize the data points on the graph."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "for comparing double to zero: This condition is used to check if a double value is zero or not."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "x: The x-axis represents the horizontal axis of the graph."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "for comparing double to zero: This condition is used to check if a double value is zero or not."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "y: The y-axis represents the vertical axis of the graph."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "x: The loop iterates over the x-axis values, ranging from 0 to the maximum value."
                ]
            },
            {
                "loopstr": [
                    "y: The loop iterates over the y-axis values, ranging from 0 to the maximum value."
                ]
            }
        ],
        "Normal": [
            "helper variable, result of coordinate-to-pixel transforms: This variable is used to store the result of transforming coordinates from the graph to pixels."
        ],
        "FuncName": "qcustomplot_7449 drawGridLines.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Note: Don't initialize ParentPlot(0) here, because layout element will stay in same parent plot. This is related to network layout management."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 releaseElement.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "new stretch factors are minimum sizes and minimum sizes are set to zero",
                    "This is a network code that sets minimum sizes to zero"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "exclude the section that is now at maximum from further changes",
                    "This is a network code that excludes maximum sections from further changes"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "set it to minimum",
                    "make sure we repeat the whole optimization process",
                    "This is a network code that sets minimum values and repeats optimization"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "reset all section sizes to zero that are in unfinished sections (all others have been set to their minimum):",
                    "This is a network code that resets section sizes to zero in unfinished sections"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "increment all sections",
                    "This is a network code that increments section sizes"
                ]
            },
            {
                "loopstr": [
                    "remove size of minimum locked sections from available space in next round",
                    "This is a network code that removes locked section sizes from available space"
                ]
            }
        ],
        "Normal": [
            "if provided total size is forced smaller than total minimum size, ignore minimum sizes (squeeze sections):",
            "This is a network code that ignores minimum sizes when total size is forced smaller"
        ],
        "FuncName": "qcustomplot_7449 getSectionSizes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "only outside tick length can change margin in a network code setting"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 setTickLengthOut.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts. This is a characteristic of the network type."
        ],
        "FuncName": "qcustomplot_7449 setSelectedLabelFont.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "don't check whether mTickVector != vec here, because it takes longer than we would save. In a network context, this is a common optimization technique to improve performance by reducing unnecessary checks."
        ],
        "FuncName": "qcustomplot_7449 setTickVector.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "don't set mCachedMarginValid to false here because margin calculation is always done with non-selected fonts",
                    "This is related to font rendering in the network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 setSelectedTickLabelFont.txt"
    },
    {
        "Branch": [
            " don't check whether mTickVectorLabels != vec here, because it takes longer than we would save on a network with multiple hops"
        ],
        "Loop": [
            " iterate through all nodes in the network"
        ],
        "Normal": [
            " don't check whether mTickVectorLabels != vec here, because it takes longer than we would save on a network with multiple hops"
        ],
        "FuncName": "qcustomplot_7449 setTickVectorLabels.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "only outside tick length can change margin, affecting the overall network performance and scalability."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 setSubTickLengthOut.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "x-axis",
                    "iterating over x-axis"
                ]
            },
            {
                "loopstr": [
                    "y-axis",
                    "iterating over y-axis"
                ]
            }
        ],
        "Normal": [
            "helper variable, result of coordinate-to-pixel transforms, related to network topology"
        ],
        "FuncName": "qcustomplot_7449 QCPAxis.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "interpret first char as number format char: number format for network data",
            "interpret second char as indicator for beautiful decimal powers: decimal powers for network transmission",
            "interpret third char as indicator for dot or cross multiplication symbol: network operation symbol"
        ],
        "FuncName": "qcustomplot_7449 setNumberFormat.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u7f13\u51b2\u533a\u7528\u4e8e\u52a0\u5febbaseLog()\u8ba1\u7b97\uff0c\u6d89\u53ca\u5230\u7f51\u7edc\u901a\u4fe1\u7684\u8ba1\u7b97"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 setScaleLogBase.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "upper and lower should be equal anyway, but just to make sure, incase validRange returned false for other reason"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "thenstr": [
                    "Network: Loop Condition. This is a loop condition that will be executed if the condition is true."
                ],
                "elsestr": []
            }
        ],
        "Normal": [
            {
                "thenstr": [
                    "Network: Normal Condition. This is a normal condition that will be executed if the condition is true."
                ],
                "elsestr": []
            }
        ],
        "FuncName": "qcustomplot_7449 rescale.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "fill tick vectors either by auto generating or by notifying user to fill the vectors himself, considering network topology and node connections",
            "generate subticks between ticks, taking into account network latency and packet transmission",
            "generate tick labels according to tick positions, incorporating network protocol and data transmission details"
        ],
        "FuncName": "qcustomplot_7449 setupTickVectors.txt"
    },
    {
        "Branch": [
            "Evaluate condition for if statement in network"
        ],
        "Loop": [
            "Determine condition for loop in network"
        ],
        "Normal": [
            "default to current setting, if no proper value can be found for network",
            "get mantissa of tickstep: network-dependent value",
            "get magnitude factor e.g. 0.01, 1, 10, 1000 etc. for network",
            "separate integer and fractional part of mantissa: network-specific",
            "handle cases with (almost) integer mantissa: network-related"
        ],
        "FuncName": "qcustomplot_7449 calculateAutoSubTickCount.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Processing text for network code: If-Condition-Str. Splitting text into parts of number/symbol drawn normally and part drawn as exponent in log scaling. Turning 1*10^n into 10^n, adding multiplication sign and decimal base otherwise. Clipping + and leading zeros off exponent part. Preparing smaller font for exponent. Calculating bounding rects of base part, exponent part, and total one, considering 1 pixel spacing between base and exponent and an extra pixel for anti-aliasing.",
                    " Processing text for network code: If-Condition-Str. In log scaling, turning 1*10^n into 10^n, else adding multiplication sign and decimal base. Clipping + and leading zeros off expPart. Preparing smaller font for exponent. Calculating bounding rects of base part, exponent part, and total one.",
                    " Processing text for network code: If-Condition-Str. Clipping + and leading zeros off expPart. Preparing smaller font for exponent. Calculating bounding rects of base part, exponent part, and total one.",
                    " Processing text for network code: If-Condition-Str. Preparing smaller font for exponent. Calculating bounding rects of base part, exponent part, and total one.",
                    " Processing text for network code: If-Condition-Str. Calculating bounding rects of base part, exponent part, and total one, considering 2 pixels for spacing and anti-aliasing."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Processing text for network code: Normal-Str. Determining whether beautiful decimal powers should be used. Calculating text bounding rects and preparing strings for beautiful decimal powers.",
            " Processing text for network code: Normal-Str. Calculating text bounding rects and preparing strings for beautiful decimal powers, considering QFontMetrics.boundingRect's internal rounding bug.",
            " Processing text for network code: Normal-Str. Calculating text bounding rects and preparing strings for beautiful decimal powers, with bounding box aligned top left at origin.",
            " Processing text for network code: Normal-Str. Calculating possibly different bounding rect after rotation."
        ],
        "FuncName": "qcustomplot_7449 getTickLabelData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Generate tick positions according to mTickStep, ensuring 64-bit precision by avoiding qFloor and qCeil. This approach maintains the accuracy of the positions.",
                    "do not use qFloor here, or we'll lose 64 bit precision",
                    "do not use qCeil here, or we'll lose 64 bit precision"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Generate tick positions according to linear scaling, distributing mAutoTickCount ticks evenly and adding a small value to prevent jitter on exact integers.",
                    "mAutoTickCount ticks on average, the small addition is to prevent jitter on exact integers",
                    "get magnitude factor e.g. 0.01, 1, 10, 1000 etc."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Round the digit after the decimal point to 0.5, ensuring a precise and consistent scaling."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 generateAutoTicks.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "backup painter settings that we're about to change: Network settings will be updated accordingly.",
            "transform painter to position/rotation: Network transformation will be applied.",
            "draw text: Network data will be visualized.",
            "reset painter settings to what it was before: Network settings will be restored to their original state."
        ],
        "FuncName": "qcustomplot_7449 drawTickLabel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "calculate label offset from base point at tick (non-trivial, for best visual appearance): short explanation for bottom axis: The anchor, i.e. the point in the label that is placed horizontally under the corresponding tick is always on the label side that is closer to the axis (e.g. the left side of the text when we're rotating clockwise). On that side, the height is halved and the resulting point is defined the anchor. This way, a 90 degree rotated text will be centered under the tick (i.e. displaced horizontally by half its height). At the same time, a 45 degree rotated text will point toward its tick, as is typical for rotated tick labels. This is a network-related operation, specifically for visualizing data on a network graph.",
            "perfect +/-90 degree flip. Indicates vertical label centering on vertical axes. In network visualization, this is particularly useful for displaying node labels in a way that is easy to read and understand."
        ],
        "FuncName": "qcustomplot_7449 getTickLabelDrawOffset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "note: this function must return the same tick label sizes as the placeTickLabel function.",
            "expand passed tickLabelsSize if current tick label is larger: In a network, this involves traversing the graph to find the maximum tick label size."
        ],
        "FuncName": "qcustomplot_7449 getMaxTickLabelSize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "create initial layers: network layers are essential for data visualization",
            "create initial layout, axis rect and legend: network layout is crucial for understanding relationships",
            "important because if parent is QWidget, QCPLayout:sizeConstraintsChanged will call QWidget:updateGeometry: network geometry is critical for layout and rendering",
            "needs to be called after mPlotLayout has been created: ensuring network layout is properly initialized"
        ],
        "FuncName": "qcustomplot_7449 QCustomPlot.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "distance to border: minimum distance from point to rectangle boundary",
            "filled rect, allow click inside to count as hit: click detection within a filled rectangle"
        ],
        "FuncName": "qcustomplot_7449 rectSelectTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "upper and lower bounds should be equal anyway, but just to make sure, in case valid range returned false for other reason, and this is related to network type as it affects the axis range, which can be expanded or included to show the error bars"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 rescaleKeyAxis.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Rescales value axis to include or magnify the network code's value range."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 rescaleValueAxis.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "is a QCPItemPosition, might have further parent, so keep iterating. In network topology, this is analogous to setting a parent node's x-coordinate to prevent self-loops and recursive dependencies."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "make sure self is not assigned as parent: in network terms, this means avoiding self-referential relationships. ",
            "make sure no recursive parent-child-relationships are created: this prevents infinite loops in network traversal. ",
            "if previously no parent set and PosType is still ptPlotCoords, set to ptAbsolute: in network context, this is equivalent to setting a node's position to absolute, rather than relative. ",
            "save pixel position: in network visualization, this is akin to recording a node's spatial coordinates. ",
            "unregister at current parent anchor: in network terms, this is like detaching a node from its current parent. ",
            "register at new parent anchor: in network context, this means attaching a node to a new parent. ",
            "restore pixel position under new parent: in network visualization, this is equivalent to updating a node's position after changing its parent."
        ],
        "FuncName": "qcustomplot_7449 setParentAnchorX.txt"
    },
    {
        "Branch": [
            "every position is also an anchor in the network"
        ],
        "Loop": [
            "every position is also an anchor in the network"
        ],
        "Normal": [
            "every position is also an anchor in the network"
        ],
        "FuncName": "qcustomplot_7449 createPosition.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u662fQCPItemPosition\u7684\u5b50\u9879\uff0c\u53ef\u80fd\u6709\u8fdb\u4e00\u6b65\u7684\u7236\u9879\uff0c\u56e0\u6b64\u7ee7\u7eed\u8fed\u4ee3\uff0c\u7f51\u7edc\u7c7b\u578b\uff1a\u7236\u5b50\u5173\u7cfb"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u786e\u4fdd\u81ea\u8eab\u4e0d\u88ab\u8bbe\u7f6e\u4e3a\u7236\u9879\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u907f\u514d\u9012\u5f52",
            "\u786e\u4fdd\u6ca1\u6709\u521b\u5efa\u9012\u5f52\u7684\u7236\u5b50\u5173\u7cfb\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u907f\u514d\u5faa\u73af",
            "\u5982\u679c\u4e4b\u524d\u6ca1\u6709\u8bbe\u7f6e\u7236\u9879\u4e14PosType\u4ecd\u4e3aptPlotCoords\uff0c\u5219\u8bbe\u7f6e\u4e3aptAbsolute\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u7edd\u5bf9\u5750\u6807",
            "\u4fdd\u5b58\u50cf\u7d20\u4f4d\u7f6e\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u4f4d\u7f6e\u7f13\u5b58",
            "\u5728\u5f53\u524d\u7236\u9879\u4e0a\u6ce8\u9500\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u89e3\u7ed1",
            "\u5728\u65b0\u7236\u9879\u4e0a\u6ce8\u518c\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u7ed1\u5b9a",
            "\u6062\u590d\u50cf\u7d20\u4f4d\u7f6e\u5728\u65b0\u7236\u9879\u4e0b\uff1a\u7f51\u7edc\u7c7b\u578b\uff1a\u4f4d\u7f6e\u6062\u590d"
        ],
        "FuncName": "qcustomplot_7449 setParentAnchorY.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if switching from or to coordinate type that isn't valid (e.g. because axes or axis rect were deleted), don't try to recover the pixelPoint() because it would output a qDebug warning. This is because the coordinate system is not properly set up for the new type.",
                    "if switching from or to coordinate type that isn\u2019t valid (e.g. because axes or axis rect were deleted), don\u2019t try to recover the pixelPoint() because it would output a qDebug warning. This is because the coordinate system is not properly set up for the new type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 setTypeX.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value. This is a common practice in network visualization, where users interact with nodes and edges to explore the network structure."
        ],
        "FuncName": "qcustomplot_7449 plottableAt.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value in the context of a network, this typically involves nodes, edges, and paths, where selections are made based on proximity to these network elements"
        ],
        "FuncName": "qcustomplot_7449 itemAt.txt"
    },
    {
        "Branch": [
            "make sure if-conditions aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:"
        ],
        "Loop": [
            "make sure loop-conditions aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously:"
        ],
        "Normal": [
            "make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously: network elements should be antialiased for smooth graphics rendering"
        ],
        "FuncName": "qcustomplot_7449 setNotAntialiasedElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove plottable from legend: This operation is related to network visualization, where plottables are graphical elements displayed on a network.",
            "special handling for QCPGraphs to maintain the simple graph interface: In network analysis, QCPGraphs are used to represent complex networks, and handling them requires special care to maintain a simple and intuitive interface.",
            "remove plottable: This action is relevant to network data, where plottables are used to visualize network structures and relationships."
        ],
        "FuncName": "qcustomplot_7449 removePlottable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously, ensuring proper network rendering and data transmission."
        ],
        "FuncName": "qcustomplot_7449 setAntialiasedElements.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "rendering elements that are not in mNotAntialiasedElements and are in mAntialiasedElements simultaneously, as network code requires"
        ],
        "FuncName": "qcustomplot_7449 setNotAntialiasedElements.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " make sure elements aren't in mNotAntialiasedElements and mAntialiasedElements simultaneously and is related to the network type "
        ],
        "FuncName": "qcustomplot_7449 setAntialiasedElement.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "remove plottable from legend: Network-related removal of visible objects.",
            "special handling for QCPGraphs to maintain the simple graph interface: Network-specific optimization for graph rendering.",
            "remove plottable: Network-related object removal."
        ],
        "FuncName": "qcustomplot_7449 removePlottable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "possibly add plottable to legend: network plot",
            "special handling for QCPGraphs to maintain the simple graph interface: network data"
        ],
        "FuncName": "qcustomplot_7449 addPlottable.txt"
    },
    {
        "Branch": [
            "check if mouse is moved over a specific layout element in the network"
        ],
        "Loop": [
            "iterate over all layout elements in the network"
        ],
        "Normal": [
            " call event of affected layout element: mouse move event triggered in the network"
        ],
        "FuncName": "qcustomplot_7449 mouseMoveEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "resize and repaint the buffer: buffer resize is crucial for network rendering",
            "queued update is important here to prevent painting issues in network contexts and ensure smooth rendering"
        ],
        "FuncName": "qcustomplot_7449 resizeEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "emit specialized object double click signals: This is a network event triggered by a mouse double click.",
            "call double click event of affected layout element: This is a network operation that responds to a mouse double click on a layout element.",
            "call release event of affected layout element (as in mouseReleaseEvent, since the mouseDoubleClick replaces the second release event in double click case): This is a network event handler that releases a layout element after a mouse double click.",
            "QWidget::mouseDoubleClickEvent(event); don't call base class implementation because it would just cause a mousePress/ReleaseEvent, which we don't want. This is a network function call that prevents a mouse press and release event."
        ],
        "FuncName": "qcustomplot_7449 mouseDoubleClickEvent.txt"
    },
    {
        "Branch": [
            "when mouse wheel event occurs, check if the affected element is visible"
        ],
        "Loop": [],
        "Normal": [
            "call event of affected layout element: on mouse wheel scroll"
        ],
        "FuncName": "qcustomplot_7449 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "need this to determine in releaseEvent whether it was a click (no position change between press and release) and handle mouse click event in network context",
            "call event of affected layout element in network environment:"
        ],
        "FuncName": "qcustomplot_7449 mousePressEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "emit specialized object click signals:",
                    "for these signals, selectability is ignored, that's why we call this again with onlySelectable set to false",
                    "network type: event handling, mouse release event"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "handle selection mechanism:",
                    "deselect all other layerables if not additive selection:",
                    "network type: event handling, mouse release event"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "a layerable was actually clicked, call its selectEvent:",
                    "network type: event handling, mouse release event"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "call event of affected layout element:",
            "network type: event handling, mouse release event"
        ],
        "FuncName": "qcustomplot_7449 mouseReleaseEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " do not access axis->axisType() to provide safety when axis is an invalid pointer, rather go through all axis containers: network access control, network security, network protocols"
        ],
        "FuncName": "qcustomplot_7449 removeAxis.txt"
    },
    {
        "Branch": [
            "Note: When a coordinate axis is removed, update the related pointers."
        ],
        "Loop": [],
        "Normal": [
            "Note: No need to take care of range drag axes and range zoom axes, because they are stored in smart pointers. Note: These axes are related to network type."
        ],
        "FuncName": "qcustomplot_7449 axisRemoved.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "update axis offset, network type is loop, condition is first axis visible and second axis not first visible axis, initialize with false"
        ],
        "FuncName": "qcustomplot_7449 updateAxesOffset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "check whether mScaledBackground needs to be updated: related to network type, it's a crucial step in rendering the background of a rectangular axis, especially when dealing with network data, which often involves complex topology and relationships between nodes and edges."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Note: background color is handled in individual replot/save functions, this is essential for network visualization, as different networks may require distinct background colors or patterns to enhance readability and comprehension.",
            "draw background pixmap (on top of fill, if brush specified): this process is vital for network graphics, as it allows for the incorporation of visual aids, such as images or textures, to represent various network attributes, such as node size, edge weight, or community structure."
        ],
        "FuncName": "qcustomplot_7449 drawBackground.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " If you change something here, make sure to also adapt colorize()",
            "Color gradient analysis applied to colorize()"
        ],
        "FuncName": "qcustomplot_7449 color.txt"
    },
    {
        "Branch": [
            "If the condition is met, the color will be green.",
            "Network: Conditional Statement"
        ],
        "Loop": [
            "The loop will iterate over the network.",
            "Network: Loop"
        ],
        "Normal": [
            "If you change something here, make sure to also adapt color()",
            "Network: Normal Statement"
        ],
        "FuncName": "qcustomplot_7449 colorize.txt"
    },
    {
        "Branch": [
            "Conditional statement: 'if' condition",
            "Example usage: 'if (condition) { ... }'"
        ],
        "Loop": [
            "Loop condition: 'for' loop",
            "Example usage: 'for (int i = 0; i < 10; i++) { ... }'"
        ],
        "Normal": [
            " this method is somewhat similar to toPainter Change something here and a change in toPainter might be necessary too Network: QCustomPlot is a Qt-based plotting library that can be converted to a QPixmap for display or further processing.",
            " if using non-solid pattern make transparent now and draw brush pattern later Network: The QPixmap class provides a way to create and manipulate images in Qt, which can be useful for displaying plots or other graphical data."
        ],
        "FuncName": "qcustomplot_7449 toPixmap.txt"
    },
    {
        "Branch": [
            "Draw a custom graph to the painter, if the condition is met."
        ],
        "Loop": [
            "Draw a custom graph to the painter, loop through the condition."
        ],
        "Normal": [
            " this method is somewhat similar to toPixmap. Change something here, and a change in toPixmap might be necessary, too. Note: This is a graph drawing method for network visualization."
        ],
        "FuncName": "qcustomplot_7449 toPainter.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line",
                    "This is a condition for drawing a bar on the tip of a line, typically in vector exports with a cosmetic pen."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey",
            "This is a normal string that can be enhanced with network-related information, but in this case, it doesn't require any additional context."
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), drawing network code for bar on tip of line"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey in network layout"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [
            "handle mouse wheel event for if condition"
        ],
        "Loop": [
            "handle mouse wheel event for loop condition"
        ],
        "Normal": [
            " call event of affected layout element: mouse wheel event"
        ],
        "FuncName": "qcustomplot_7449 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "check whether any legend elements selected, if yes, add spItems to return value; for network type, consider adding network-related details such as node connections, edge weights, or network topology"
        ],
        "FuncName": "qcustomplot_7449 selectedParts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "set the margins of this layout element according to automatic margin calculation either directly or via a margin group",
                    "This is related to network layout and margin calculation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 update.txt"
    },
    {
        "Branch": [
            "If the network is synchronized, then the axis base is selectable."
        ],
        "Loop": [],
        "Normal": [
            " synchronize axis base selectability: This is related to network configuration."
        ],
        "FuncName": "qcustomplot_7449 axisSelectableChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "make layer transfers of color scale transfer to axis rect and axes; for network visualization, this involves setting up a color gradient axis with specific alignment and layout",
            "in a network context, the axes must be configured after the axis rect, ensuring they appear above the color gradient drawn by the axis rect"
        ],
        "FuncName": "qcustomplot_7449 QCPColorScaleAxisRectPrivate.txt"
    },
    {
        "Branch": [
            "Check if mouse wheel event is triggered and the layout element is affected"
        ],
        "Loop": [],
        "Normal": [
            "Call the event handler for the affected layout element, triggered by mouse wheel event"
        ],
        "FuncName": "qcustomplot_7449 wheelEvent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "axis bases of four axes shall always (de-)selected synchronously: X-axis, Y-axis, Z-axis, and Network-axis."
        ],
        "FuncName": "qcustomplot_7449 axisSelectionChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " prevent setting channel target to this graph itself: Network type: Graph",
            " prevent setting channel target to a graph not in the plot: Network type: External"
        ],
        "FuncName": "qcustomplot_7449 setChannelFillGraph.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line, utilizing network topology for precise placement"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey, utilizing network connectivity for enhanced visual effect"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [
            "if condition for impulse plot"
        ],
        "Loop": [
            "loop condition for impulse plot"
        ],
        "Normal": [
            "no need to reserve 2 extra points because impulse plot has no fill",
            "transform lineData points to pixels for impulse plot rendering"
        ],
        "FuncName": "qcustomplot_7449 getImpulsePlotData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "added 2 to reserve memory for lower/upper fill base points that might be needed for fill",
            "calculate steps from lineData and transform to pixel coordinates: network type pixel data"
        ],
        "FuncName": "qcustomplot_7449 getStepRightPlotData.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Calculating midpoint coordinates for graph data."
        ],
        "Loop": [
            "Loop-Condition-Str: Iterating over graph data to calculate midpoint coordinates."
        ],
        "Normal": [
            "Normal-Str: added 2 to reserve memory for lower/upper fill base points that might be needed for fill. Calculating midpoint coordinates for graph data. calculate steps from lineData and transform to pixel coordinates:"
        ],
        "FuncName": "qcustomplot_7449 getStepCenterPlotData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "draw base fill under graph, fill goes all the way to the zero-value-line: This operation is related to network topology.",
                    "The base fill is a common feature in network architecture."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "thenstr": [
                    "iterate over network nodes, each node is connected to the others: This operation is related to network routing."
                ],
                "elsestr": []
            }
        ],
        "Normal": [
            {
                "thenstr": [
                    "network communication is established, data is being transmitted: This operation is related to network protocols."
                ],
                "elsestr": []
            }
        ],
        "FuncName": "qcustomplot_7449 drawFill.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " draw error bars for network analysis:",
            " draw scatter point symbols with network topology:"
        ],
        "FuncName": "qcustomplot_7449 drawScatterPlot.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "get visible data range as QMap iterators (network data retrieval)",
            "indicates whether there exist points below axis range in the network (network data analysis)",
            "indicates whether there exist points above axis range in the network (network data analysis)",
            "data point range that will be actually drawn in the network (network data visualization)",
            "data point range that will be actually drawn in the network (network data visualization)"
        ],
        "FuncName": "qcustomplot_7449 getVisibleDataBounds.txt"
    },
    {
        "Branch": [
            "append points that close the polygon fill at the key axis: network type - conditional statement"
        ],
        "Loop": [
            "append points that close the polygon fill at the key axis: network type - loop condition"
        ],
        "Normal": [
            "append points that close the polygon fill at the key axis: network type - polygon fill"
        ],
        "FuncName": "qcustomplot_7449 addFillBasePoints.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "so impulse line doesn't reach beyond zero-line",
                    "This is a specific behavior in network protocol when a certain condition is met."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "draw impulses:",
            "Impulse lines are used to visualize network traffic patterns in various network protocols."
        ],
        "FuncName": "qcustomplot_7449 drawImpulsePlot.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "draw key error vertically and value error horizontally",
                    "network error bars are drawn as vertical lines for the key and horizontal lines for the value"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "draw spine:",
                    "draw handles:",
                    "network error bars have a spine and handles that can be customized"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "draw spine:",
                    "draw handles:",
                    "network error bars have a spine and handles that can be customized"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "draw spine:",
                    "draw handles:",
                    "network error bars have a spine and handles that can be customized"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "draw spine:",
                    "draw handles:",
                    "network error bars have a spine and handles that can be customized"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "positions of error bar bounds in pixels",
            "pixels left blank per side, when mErrorBarSkipSymbol is true"
        ],
        "FuncName": "qcustomplot_7449 drawError.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "x is key",
                    "if an axis range is reversed, the data point keys will be descending. Reverse them, since following algorithm assumes ascending keys.",
                    "crop lower bound: using network topology to ensure data consistency",
                    "set lowest point of cropped data to fit exactly key position of first static data in network",
                    "point via linear interpolation: leveraging network connectivity for efficient data transfer",
                    "crop upper bound: applying network routing for optimal data delivery",
                    "set highest point of cropped data to fit exactly key position of last static data in network",
                    "point via linear interpolation: utilizing network latency for precise data synchronization",
                    "last index in network topology"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "inconsistent axis orientation, cannot perform fill operation (Note: if keyAxis fits, valueAxis will fit too, because it's always orthogonal to keyAxis in network topology)",
            "both vectors will be joined at the end of this function, leveraging network synchronization",
            "pointers will be swapped to accommodate data range cropping, depending on network architecture:",
            "crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType in network):",
            "return joined data from network"
        ],
        "FuncName": "qcustomplot_7449 getChannelFillPolygon.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculates keyEpsilon pixel direction and updates it accordingly.",
                    "Switches between floor and ceil rounding of currentIntervalStartKey.",
                    "Maps interval of one pixel on screen to plot key coordinates.",
                    "Updates keyEpsilon after every interval for log axes.",
                    "Advances iterator to second data point for adaptive sampling.",
                    "Handles last interval with keyEpsilon."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Calculates keyEpsilon pixel direction and updates it accordingly.",
                    "Switches between floor and ceil rounding of currentIntervalStartKey.",
                    "Maps interval of one pixel on screen to plot key coordinates.",
                    "Updates keyEpsilon after every interval for log axes.",
                    "Advances iterator to second data point for adaptive sampling.",
                    "Handles last interval with keyEpsilon."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Determines value pixel span and adds points to maintain vertical data density for scatter plots.",
                    "Approximately every 4 value pixels, one data point is added on average."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Determines value pixel span and adds points to maintain vertical data density for scatter plots.",
                    "Approximately every 4 value pixels, one data point is added on average."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adds +2 for possible fill end points."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Gets the visible data range.",
            "Notes that the upper point is the actual upper point, not one step after it.",
            "Counts points in the visible range, considering only up to maxCount for adaptive sampling."
        ],
        "FuncName": "qcustomplot_7449 getPreparedData.txt"
    },
    {
        "Branch": [
            "If the network condition is met, then"
        ],
        "Loop": [
            "Loop through the network connections"
        ],
        "Normal": [
            "lighter than Qt::blue of mPen",
            "representing a network connection"
        ],
        "FuncName": "qcustomplot_7449 QCPCurve.txt"
    },
    {
        "Branch": [
            "Draw if-conditions on the network graph"
        ],
        "Loop": [
            "Visualize loop conditions on the network"
        ],
        "Normal": [
            "Draw error bars on the network graph.",
            "Draw scatter point symbols on the network."
        ],
        "FuncName": "qcustomplot_7449 drawScatterPlot.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Financial data range: retrieving financial data for the specified network code: just call the specialized version which takes an additional argument whether error bars should also be taken into consideration for range calculation. We set this to true here.",
            "Financial data range: retrieving financial data for the specified network code: should also be taken into consideration for range calculation. We set this to true here."
        ],
        "FuncName": "qcustomplot_7449 getValueRange.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "initial value is just fail safe; network intersection point calculation is performed in the network layer",
            "initial value is just fail safe; network intersection point calculation is performed in the network layer"
        ],
        "FuncName": "qcustomplot_7449 getOptimizedPoint.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Financial data retrieval key range is required for stock market network. just call the specialized version which takes an additional argument whether error bars should also be taken into consideration for financial data range calculation. We set this to true here for financial data network."
        ],
        "FuncName": "qcustomplot_7449 getKeyRange.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line, utilizing network topology to ensure precise alignment"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey, leveraging network dynamics for optimal visual impact"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "just call the specialized version which takes an additional argument whether error bars in financial data are considered for range calculation We set this to true here",
            "should also be taken into consideration for range calculation of financial data We set this to true here"
        ],
        "FuncName": "qcustomplot_7449 getKeyRange.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "first append to bars list normally, considering network topology:",
            "then move to according position on the network graph:"
        ],
        "FuncName": "qcustomplot_7449 insert.txt"
    },
    {
        "Branch": [
            "Conditional registration and deregistration of nodes in a network"
        ],
        "Loop": [
            "Looping through nodes in a network for registration and deregistration"
        ],
        "Normal": [
            "Deregistering nodes from an old group:",
            "Registering nodes at a new group:"
        ],
        "FuncName": "qcustomplot_7449 setBarsGroup.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in the network code"
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition in the network code"
        ],
        "Normal": [
            "modify inherited properties from abstract plottable: This is a process in the network code.",
            "lighter than Qt::blue of mPen: This is a color description in the network code."
        ],
        "FuncName": "qcustomplot_7449 QCPBars.txt"
    },
    {
        "Branch": [
            "data range calculation for if condition: min and max values based on the symbol domain"
        ],
        "Loop": [
            "data range calculation for loop condition: min and max values based on the symbol domain"
        ],
        "Normal": [
            "data range calculation: min and max values based on the symbol domain, considering error bars",
            "data range calculation: taking into consideration error bars, setting to true for range calculation"
        ],
        "FuncName": "qcustomplot_7449 getValueRange.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "just call the specialized version which takes an additional argument whether error bars in the network type",
            "should also be taken into consideration for range calculation in the network type We set this to true here"
        ],
        "FuncName": "qcustomplot_7449 getKeyRange.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculates the minimum distance from a point to a curve on a network."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Compares the impulse plot to other line styles in a network by calculating pairwise distances."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Determines the minimum distances between a point and a graph representation on a network."
        ],
        "FuncName": "qcustomplot_7449 pointDistance.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no need to qSwap(lower, higher) when range reversed, because higher/lower are gained by coordinate transform which includes range direction and network type related to bar chart pixel width calculation",
                    "coordinate transform which includes range direction and network type related to bar chart pixel width calculation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 getPixelWidth.txt"
    },
    {
        "Branch": [
            "if the network is a financial network, consider the interest rates and stock prices"
        ],
        "Loop": [
            "while the network is connected to the financial market, update the data in real-time"
        ],
        "Normal": [
            "just call the specialized version which takes an additional argument whether error bars should also be taken into consideration for range calculation. We set this to true here, considering the volatility of the financial market.",
            "should also be taken into consideration for range calculation, taking into account the financial network's complex relationships between assets and liabilities."
        ],
        "FuncName": "qcustomplot_7449 getValueRange.txt"
    },
    {
        "Branch": [
            "Move a QCPBars object above another QCPBars object in a network."
        ],
        "Loop": [
            "Move a QCPBars object above another QCPBars object in a network loop."
        ],
        "Normal": [
            "Remove from stacking: Move a QCPBars object above another QCPBars object in a network.",
            "Note: also works if one (or both) of them is 0 in a network.",
            "If new bar given, insert this bar above another QCPBars object in a network."
        ],
        "FuncName": "qcustomplot_7449 moveAbove.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "just call the specialized version which takes an additional argument whether error bars in a network are considered for key-value range calculation We set this to true here",
            "should also be taken into consideration for range calculation in a network We set this to true here"
        ],
        "FuncName": "qcustomplot_7449 getKeyRange.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Find the maximum base value in the stack.",
                    "Find bars of mBarBelow that are approximately at key and find largest one:",
                    "This is safe even when changed to use float at some point",
                    "Recurse down the bar-stack to find the total height:"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "qcustomplot_7449 getStackedBaseValue.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if drawing with cosmetic pen (perfectly thin stroke, happens only in vector exports), draw bar exactly on tip of line, utilizing network topology to ensure precise placement"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "to make arrow heads spikey, leveraging network dynamics for enhanced visual appeal"
        ],
        "FuncName": "qcustomplot_7449 draw.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u7ed8\u5236\u56fe\u8868\u6807\u7b7e\u56fe\u6807\uff1a+5 on x2 else last segment is missing from dashed/dotted pens"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u7ed8\u5236\u56fe\u8868\u6807\u7b7e\u56fe\u6807\uff1ascale scatter pixmap if it's too large to fit in legend icon rect:"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u7ed8\u5236\u56fe\u8868\u6807\u7b7e\u56fe\u6807\uff1adraw fill",
            "\u7ed8\u5236\u56fe\u8868\u6807\u7b7e\u56fe\u6807\uff1adraw line vertically centered",
            "\u7ed8\u5236\u56fe\u8868\u6807\u7b7e\u56fe\u6807\uff1adraw scatter symbol"
        ],
        "FuncName": "qcustomplot_7449 drawLegendIcon.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for network flow control"
        ],
        "Loop": [
            "Loop-Condition-Str: Iteration condition for network data processing"
        ],
        "Normal": [
            "try to update map image if it's null (happens if no draw has happened yet) - Network: Map update mechanism for visualizing network data"
        ],
        "FuncName": "qcustomplot_7449 updateLegendIcon.txt"
    },
    {
        "Branch": [
            " if (colorMap interpolation is required)"
        ],
        "Loop": [],
        "Normal": [
            " because oversampling factors might need to change when colorMap interpolation is required"
        ],
        "FuncName": "qcustomplot_7449 setInterpolate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "resize undersampled map image to actual key/value cell sizes, and apply network colorization techniques to enhance image quality.",
                    "run the colorization process on the undersampled image to improve color accuracy and detail preservation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "invert scanline index to match the coordinate system used by QImage, which counts scanlines from top to bottom, whereas our vertical index counts from bottom to top."
                ]
            },
            {
                "loopstr": [
                    "invert scanline index to match the coordinate system used by QImage, which counts scanlines from top to bottom, whereas our vertical index counts from bottom to top."
                ]
            }
        ],
        "Normal": [
            "ensure mMapImage has a minimum size of 100 pixels, and adjust the factor accordingly. If the size exceeds 200 pixels or interpolation is enabled, the factor becomes 1.",
            "ensure mMapImage has a minimum size of 100 pixels, and adjust the factor accordingly. If the size exceeds 200 pixels or interpolation is enabled, the factor becomes 1.",
            "resize mMapImage to the correct dimensions, taking into account any oversampling factors and key/value axes orientation.",
            "this is the image used for colorization, either the final mMapImage or the mUndersampledMapImage if oversampling is required.",
            "since the map size has changed, the oversampling mechanism is no longer needed, but the mUndersampledMapImage still has a non-zero size, so free it."
        ],
        "FuncName": "qcustomplot_7449 updateMapImage.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "calculate distance to backbone: This is related to financial data network."
                ]
            },
            {
                "loopstr": [
                    "calculate distance to backbone: This is related to financial data network."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "qcustomplot_7449 ohlcSelectTest.txt"
    },
    {
        "Branch": [
            "Draw financial data using a candlestick chart with a high network connection."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Draw financial data using a high network connection.",
                    "Draw financial data using a low network connection.",
                    "Draw financial data using an open-close box network connection."
                ]
            },
            {
                "loopstr": [
                    "Draw financial data using a high network connection.",
                    "Draw financial data using a low network connection.",
                    "Draw financial data using an open-close box network connection."
                ]
            }
        ],
        "Normal": [
            "Draw financial data using a candlestick chart with a stable network connection."
        ],
        "FuncName": "qcustomplot_7449 drawCandlestickPlot.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u786e\u5b9a\u662f\u5426pos\u5728open-close-box:\u6700\u8fd1\u8721\u70db\u56fe\u6570\u636e\u70b9\u8ddd\u79bb\u4e3a0"
                ]
            },
            {
                "loopstr": [
                    "\u786e\u5b9a\u662f\u5426pos\u5728open-close-box:\u6700\u8fd1\u8721\u70db\u56fe\u6570\u636e\u70b9\u8ddd\u79bb\u4e3a0"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "qcustomplot_7449 candlestickSelectTest.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "draw backbone: In a network, the backbone refers to the main path or route that data takes.",
                    "draw open: The open price is the first price at which a trade is made during a trading session.",
                    "sign of this makes sure open/close are on correct sides: This ensures that the open and close prices are correctly displayed on the chart.",
                    "draw close: The close price is the last price at which a trade is made during a trading session."
                ]
            },
            {
                "loopstr": [
                    "draw backbone: In a network, the backbone refers to the main path or route that data takes.",
                    "draw open: The open price is the first price at which a trade is made during a trading session.",
                    "sign of this makes sure open/close are on correct sides: This ensures that the open and close prices are correctly displayed on the chart.",
                    "draw close: The close price is the last price at which a trade is made during a trading session."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "qcustomplot_7449 drawOhlcPlot.txt"
    },
    {
        "Branch": [
            " If we haven't received the last chunk of IPv4 packet then the flow is not complete",
            " then the flow is not complete",
            " Make sure the first fragment has offset 0 and it's part of an IPv4 network"
        ],
        "Loop": [],
        "Normal": [
            " Make sure all fragments of IPv4 packet have been received to ensure the flow is complete",
            " then the flow is complete",
            " Make sure all fragments of IPv4 packet have been received to ensure the flow is complete"
        ],
        "FuncName": "ip_reassembler_195 is_complete.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check if we actually have all the data we need. Otherwise return nullptr; This is a network packet distributor."
        ],
        "FuncName": "ip_reassembler_195 allocate_pdu.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Release the inner PDU, store this first fragment and restore the inner PDU. IPv4 fragmentation occurs when a packet is too large to be sent in a single IP packet, and the network layer performs segmentation to divide the packet into smaller fragments that can be sent separately."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No duplicates plx. IPv4 is a connectionless protocol, where each packet is sent independently and there is no guarantee of delivery or order.",
            "If the MF flag is off. In IPv4, the More Fragments (MF) flag is used to indicate whether a packet is a fragment of a larger packet or not."
        ],
        "FuncName": "ip_reassembler_195 add_fragment.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "check top of rect: intersect with top edge",
                    "check bottom of rect: intersect with bottom edge"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check left of rect: intersect with left edge",
                    "check right of rect: intersect with right edge"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "line probably goes through corner of rect, and we got two points there. single out the point pair with greatest distance: network analysis"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "evaluate points: network intersection"
        ],
        "FuncName": "qcustomplot_7449 getRectClippedLine.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculating network imbalance degree: TODO number of nodes and not number of elements"
        ],
        "FuncName": "GraphClusteringTools_1983 getImbalance.txt"
    },
    {
        "Branch": [
            "If condition is used to check network connectivity"
        ],
        "Loop": [
            "Loop condition is used to iterate over network nodes"
        ],
        "Normal": [
            "Network topology consists of nodes and edges",
            "Number of nodes is crucial for network analysis",
            "Network balance is affected by node distribution"
        ],
        "FuncName": "GraphClusteringTools_1983 getImbalance.txt"
    },
    {
        "Branch": [
            "if (condition) { // network condition: ensure all subset ids are equal to the first one for (int e = 0; e < this->z; ++e) { if (data[e] != one) { return false; } } return true; }"
        ],
        "Loop": [],
        "Normal": [
            "index one = data[0]; // first subset id should be equal to all others // network description: all subset ids should be equal to the first one for (index e = 0; e < this->z; ++e) { // network condition: check if current subset id is equal to the first one if (data[e] != one) { return false; } } return true;"
        ],
        "FuncName": "GraphClusteringTools_1983 isOneClustering.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "There's fragmentation. IP packets are being split into smaller fragments to be transmitted over a network that does not support the maximum transmission unit (MTU) of the original packet."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Create it or look it up, it's the same. IP fragmentation is a process of breaking down a large IP packet into smaller packets that can be transmitted over a network that does not support the maximum transmission unit (MTU) of the original packet."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Use all field values from the first fragment. IP reassembly is the process of reassembling the fragments back into the original packet.",
                    "Erase this stream, since it's already assembled. Once all the fragments are received, the original packet can be reassembled by the receiver.",
                    "The packet is corrupt. If any fragments are missing or corrupted, the original packet cannot be reassembled correctly."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ip_reassembler_195 process.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in the network, used to control the flow of nodes and edges."
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition in the network, used to repeat a sequence of nodes and edges."
        ],
        "Normal": [
            "Normal-Str: A normal node in the network, used to represent a single point in the graph. move you pen from node to node: 3 -> 1 -> 0 -> 2 -> 1 -> 4 -> 3 -> 2 -> 4"
        ],
        "FuncName": "GraphGTest_6552 SetUp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "test whether each node has been assigned to a cluster in the network"
        ],
        "FuncName": "GraphClusteringTools_1983 isProperClustering.txt"
    },
    {
        "Branch": [
            "Connect to server if condition is met."
        ],
        "Loop": [
            "Connect to server in loop condition."
        ],
        "Normal": [
            " wait all connect success."
        ],
        "FuncName": "echo_client_7978 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "FIXME: decoded and converted RGB image from compressed data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "receiver_783 handleImage.txt"
    },
    {
        "Branch": [
            "Read data and write to network socket."
        ],
        "Loop": [],
        "Normal": [
            "print",
            "Network data transmission."
        ],
        "FuncName": "echo_client_7978 ReadFunc.txt"
    },
    {
        "Branch": [
            "Check if the network is connected"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Reset values and iterate over the network"
                ]
            }
        ],
        "Normal": [
            "Calculate cluster sizes and explicitly store all clusters of the network C",
            "Initialize result values and prepare for network analysis",
            "The overlap of the currently considered cluster in the network C with each reference cluster in the reference network",
            "The clusters of the reference network that have a positive overlap with the network C"
        ],
        "FuncName": "CoverF1Similarity_9627 run.txt"
    },
    {
        "Branch": [
            "If condition with boundary width"
        ],
        "Loop": [
            "Loop condition with boundary width"
        ],
        "Normal": [
            "error handling with network boundary width"
        ],
        "FuncName": "GraphToolBinaryWriter_6010 getAdjacencyWidth.txt"
    },
    {
        "Branch": [
            "Check if the data frame is valid for decoding"
        ],
        "Loop": [],
        "Normal": [
            "Initialize the context that needs to be carried from block to block",
            "Decode the data frame based on the network protocol"
        ],
        "FuncName": "zstd_decompress_1759 decode_data_frame.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Invalid arguments",
                    "Usage:",
                    "%s FILE - Network protocol requires valid file input"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Not strictly required, since program execution stops there, but some static analyzers may complain otherwise due to network protocol requirements"
        ],
        "FuncName": "streaming_compression_9487 main.txt"
    },
    {
        "Branch": [
            "If condition compressed by Zstandard is transformed into a Zstandard frame, and the network protocol requires decompression, then the decoder assumes decompression of a single frame."
        ],
        "Loop": [
            "Loop condition compressed by Zstandard is transformed into a Zstandard frame, and the network protocol requires decompression, then the decoder assumes decompression of a single frame."
        ],
        "Normal": [
            "Compressed content is transformed into a Zstandard frame, and appended into a single file or stream. A frame is",
            "totally independent, has a defined beginning and end, and a set of parameters which tells the decoder how to decompress it, according to the network protocol.",
            "This decoder assumes decompression of a single frame using the given dictionary, as per the network protocol requirements."
        ],
        "FuncName": "zstd_decompress_1759 ZSTD_decompress_with_dict.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ZSTD frame"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Zstandard frame with 4 Bytes, little-endian format. Value : 0xFD2FB528",
            "",
            "Magic_Number",
            "",
            "not a real frame or a skippable frame"
        ],
        "FuncName": "zstd_decompress_1759 decode_frame.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " write directed byte to the binary file as part of network code",
            " write number of nodes to the binary file for network representation",
            " write the adjacencies to the binary file for network structure",
            " close the binary file after writing network data"
        ],
        "FuncName": "GraphToolBinaryWriter_6010 write.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This packet might be non-rfc compliant. In that case the length field can contain garbage. This is an ICMP extension structure.",
                    "ICMP extension structure field can contain garbage."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Checking RFC 4884 defined ICMP types for compliance.",
            "Validating packet data against minimum encapsulated packet size and actual data amount."
        ],
        "FuncName": "icmp_extension_helpers_6689 try_parse_icmp_extensions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This gets the size of the next ICMP pdu, padded to the next 32 bit word boundary in the network"
        ],
        "FuncName": "icmp_extension_helpers_6689 get_padded_icmp_inner_pdu_size.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "An FSE bitstream starts by a header, describing probabilities distribution. It will create a Decoding Table. For a list of Huffman weights, maximum accuracy is 7 bits. Huffman weights are used to decode network data.",
            "Decode the weights for network data."
        ],
        "FuncName": "zstd_decompress_1759 fse_decode_hufweights.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "A compressed block consists of 2 sections :",
            "These sections include Literals_Section and Sequences_Section.",
            "Part 1: decode the literals block in network protocol.",
            "Part 2: decode the sequences block in network protocol.",
            "Part 3: combine literals and sequence commands to generate output in network transmission."
        ],
        "FuncName": "zstd_decompress_1759 decompress_block.txt"
    },
    {
        "Branch": [
            "Decode compressed literals from input stream, allocating memory for the decoded literals. These literals are used in network protocols.",
            "This section is only present when Literals_Block_Type type is Compressed_Literals_Block (2) in network protocols.",
            "Decode compressed literals from input stream, allocating memory for the decoded literals. These literals are used in network protocols."
        ],
        "Loop": [],
        "Normal": [
            "Only size_format=0 has 1 stream, so default to 4 in network communication protocols."
        ],
        "FuncName": "zstd_decompress_1759 decode_literals_compressed.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Deep copy the entropy tables so they can be freed independently of the dictionary struct, network type: entropy tables management",
                    "Copy the repeated offsets, network type: repeated offsets handling"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If the content pointer is NULL then it must be an empty dict, network type: null pointer check",
            "If the requested dictionary_id is non-zero, the correct dictionary must be present, network type: dictionary id verification",
            "Copy the dict content to the context for references during sequence execution, network type: dictionary content copying",
            "If it's a formatted dict copy the precomputed tables in so they can be used in the table repeat modes, network type: precomputed tables management"
        ],
        "FuncName": "zstd_decompress_1759 frame_context_apply_dict.txt"
    },
    {
        "Branch": [
            "Check if the frame context is initialized and the network code is valid"
        ],
        "Loop": [
            "Verify the network code and proceed with the initialization"
        ],
        "Normal": [
            "Most fields in context are correct when initialized to 0",
            "Parse data from the frame header",
            "Set up the offset history for the repeat offset commands",
            "Apply details from the dict if it exists",
            "Ensure network code is properly integrated into the frame context"
        ],
        "FuncName": "zstd_decompress_1759 init_frame_context.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Raw or RLE literals block, utilizing network protocol for efficient data transmission"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Literals can be stored uncompressed or compressed using Huffman prefix codes, leveraging network infrastructure for optimized data transfer. When compressed, an optional tree description can be present, followed by 1 or 4 streams, utilizing network protocols for efficient data transmission.",
            "Literals_Section_Header, utilizing network protocols for efficient data transmission.",
            "Header is in charge of describing how literals are packed, utilizing network protocols for efficient data transmission. It's a byte-aligned variable-size bitfield, ranging from 1 to 5 bytes, using little-endian convention, adhering to network standards.",
            "",
            "Literals_Block_Type, utilizing network protocols for efficient data transmission.",
            "",
            "This field uses 2 lowest bits of first byte, describing 4 different block types, utilizing network protocols for efficient data transmission.",
            "",
            "size_format takes between 1 and 2 bits, utilizing network protocols for efficient data transmission."
        ],
        "FuncName": "zstd_decompress_1759 decode_literals.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "There are no sequences. The sequence section stops there.",
                    " Regenerated content is defined entirely by literals section.",
                    "In this case, the network type is a simple flag indicating no sequences."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Number_of_Sequences = byte0 . Uses 1 byte.",
                    "This byte represents the number of sequences in the network, which is a basic concept in data transmission."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Number_of_Sequences = ((byte0-128) << 8) + byte1 . Uses 2 bytes.",
                    "This 2-byte representation of sequence count is a common practice in network protocols, allowing for a larger range of values."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " A compressed block is a succession of sequences . A sequence is a",
            " literal copy command, followed by a match copy command. A literal copy",
            " command specifies a length. It is the number of bytes to be copied (or",
            " extracted) from the literal section. A match copy command specifies an",
            " offset and a length. The offset gives the position to copy from, which",
            " can be within a previous block.",
            " Number_of_Sequences",
            "",
            " This is a variable size field using between 1 and 3 bytes. Let's call its",
            " first byte byte0.",
            "In network protocols, sequence numbers are crucial for maintaining data integrity and ensuring correct packet ordering."
        ],
        "FuncName": "zstd_decompress_1759 decode_sequences.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Decompresses a frame in a streaming operation. This program does not support checking the checksum, so skip over it if it's present",
                    "Decompresses a frame in a streaming operation. if it's present"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Decompresses a frame in a streaming operation."
        ],
        "Normal": [
            "A frame encapsulates one or multiple blocks. Each block can be decompressed or not, and has a guaranteed maximum content size, which depends on frame parameters. Unlike frames, each block depends on previous blocks for proper decoding. However, each block can be decompressed without waiting for its successor, allowing streaming operations.",
            "Decompresses a frame in a streaming operation. A frame encapsulates one or multiple blocks. Each block can be compressed or not, and has a guaranteed maximum content size, which depends on frame parameters. Unlike frames, each block depends on previous blocks for proper decoding. However, each block can be decompressed without waiting for its successor, allowing streaming operations."
        ],
        "FuncName": "zstd_decompress_1759 decompress_data.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is a direct representation of Huffman codes, where each code is written",
                    "as a 4 bits field (0-15). The full representation occupies",
                    "((Number_of_Symbols+1)/2) bytes, meaning it uses a last full byte",
                    "even if Number_of_Symbols is odd. Number_of_Symbols = headerByte -",
                    "127. Huffman coding is a method of encoding binary data using variable-length codes.",
                    "These codes are prefix codes, meaning no code is a prefix of another code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "They are encoded using Huffman codes, 2",
                    "weights to a byte with the first weight taking the top four bits",
                    "and the second taking the bottom four (e.g. the following",
                    "operations could be used to read the weights: Weight[0] =",
                    "Byte[0] >> 4, Weight[1] = Byte[0] & 0xf, etc.). Huffman coding is a method of encoding binary data using variable-length codes.",
                    "These codes are prefix codes, meaning no code is a prefix of another code."
                ]
            }
        ],
        "Normal": [
            "All literal values from zero (included) to last present one (excluded)",
            "are represented by Huffman codes with values from 0 to Max_Number_of_Bits.",
            "This is a single byte value (0-255), which describes how to decode the list of Huffman codes.",
            "Construct the table using the decoded Huffman codes. Huffman coding is a method of encoding binary data using variable-length codes.",
            "These codes are prefix codes, meaning no code is a prefix of another code."
        ],
        "FuncName": "zstd_decompress_1759 decode_huf_table.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Provides guarantees on maximum back-reference distance that will be used within compressed data. This information is important for decoders to allocate enough memory.",
                    "Bit numbers  7-3         2-0",
                    "Field name   Exponent    Mantissa",
                    "Use the algorithm from the specification to compute window size",
                    "https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#window_descriptor",
                    "Network type: Window Descriptor"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is a variable size field, which contains the ID of the dictionary required to properly decode the frame. Note that this field is optional. When it's not present, it's up to the caller to make sure it uses the correct dictionary. Format is little-endian.",
                    "Network type: Dictionary ID"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is the original (uncompressed) size. This information is optional. The Field_Size is provided according to value of Frame_Content_Size_flag. The Field_Size can be equal to 0 (not present), 1, 2, 4 or 8 bytes. Format is little-endian.",
                    "",
                    "if frame_content_size_flag == 0 but single_segment_flag is set, we still have a 1 byte field",
                    "Network type: Frame Content Size"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "When Field_Size is 2, the offset of 256 is added.",
                    "Network type: Offset Adjustment"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The Window_Descriptor byte is optional. It is absent when Single_Segment_flag is set. In this case, the maximum back-reference distance is the content size itself, which can be any value from 1 to 2^64-1 bytes (16 EB).",
                    "Network type: Window Descriptor"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "The first header's byte is called the Frame_Header_Descriptor. It tells which other fields are present. Decoding this byte is enough to tell the size of Frame_Header.",
            "",
            "Bit number   Field name",
            "7-6  Frame_Content_Size_flag",
            "5    Single_Segment_flag",
            "4    Unused_bit",
            "3    Reserved_bit",
            "2    Content_Checksum_flag",
            "1-0  Dictionary_ID_flag",
            "decode frame header descriptor into flags",
            "decode window size",
            "decode dictionary id if it exists",
            "decode frame content size if it exists",
            "Network type: Frame Header Descriptor"
        ],
        "FuncName": "zstd_decompress_1759 parse_frame_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Free old one before overwriting. This is a network-related operation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This mode is invalid if we don't already have a table. Network protocol requires a table for this mode."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Constant arrays indexed by seq_part_t. Network data is stored in this type of array."
        ],
        "FuncName": "zstd_decompress_1759 decode_seq_table.txt"
    },
    {
        "Branch": [
            "If the condition is true, then the code will execute."
        ],
        "Loop": [
            "The loop will continue until the condition is false."
        ],
        "Normal": [
            "Copy in the content. This is a network-related string."
        ],
        "FuncName": "zstd_decompress_1759 init_dictionary_content.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If the sequence asks for more literals than are left, the sequence must be corrupted; this is a network protocol error.",
            "Copy literals to output stream, which is a critical operation in network communication."
        ],
        "FuncName": "zstd_decompress_1759 copy_literals.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " In this case, the offset may fall back into the dictionary, which is a [network] buffer that stores compressed data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " The offset exceeds even the dictionary, which is a [network] buffer that stores compressed data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " The rest of the dictionary is its content, which acts as a [network] past in front of data to compress or decompress, so it can be referenced in sequence commands."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " We must copy byte by byte because the match length might be larger than the offset, which is a common issue in [network] data transmission.",
            " ex: if the output so far was abc, a command with offset=3 and match_length=6 would produce abcabcabc as the new output, which is a typical [network] packet."
        ],
        "FuncName": "zstd_decompress_1759 execute_match_copy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "ZSTD frame: retrieve decompressed size from ZSTD frame header"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Content size not provided, we can't tell"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "retrieve decompressed size from ZSTD frame header"
        ],
        "FuncName": "zstd_decompress_1759 ZSTD_get_decompressed_size.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The first 3 values define a repeated offset and we will call them Repeated_Offset1, Repeated_Offset2, and Repeated_Offset3. They are sorted in recency order, with Repeated_Offset1 meaning 'most recent one'. Use 0 indexing for the array. In a network context, these offsets are used to calculate the sequence of commands, ensuring data is transmitted in the correct order.",
                    "There is an exception though, when current sequence's literals length is 0. In this case, repeated offsets are shifted by one, so Repeated_Offset1 becomes Repeated_Offset2, Repeated_Offset2 becomes Repeated_Offset3, and Repeated_Offset3 becomes Repeated_Offset1 - 1_byte. This adjustment is crucial in network protocols to maintain data integrity."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "There is an exception though, when current sequence's literals length is 0. In this case, repeated offsets are shifted by one, so Repeated_Offset1 becomes Repeated_Offset2, Repeated_Offset2 becomes Repeated_Offset3, and Repeated_Offset3 becomes Repeated_Offset1 - 1_byte. This adjustment is crucial in network protocols to maintain data integrity.",
                    "In a network environment, these offsets are used to determine the sequence of commands, ensuring that data is transmitted in the correct order, even when the current sequence's literals length is 0."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Offsets are special, we need to handle the repeat offsets, which are essential in network protocols to ensure data is transmitted in the correct order, maintaining data integrity and sequence of commands."
        ],
        "FuncName": "zstd_decompress_1759 compute_offset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "cannot initialize dictionary with null src, this is a network error"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "raw content dict, data transmission successful"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Entropy_Tables: following the same format as the tables in compressed network blocks. They are stored in following order: Huffman tables for literals, FSE table for offsets, FSE table for match lengths, and FSE table for literals lengths. It's finally followed by 3 offset values, populating recent offsets (instead of using {1,4,8}), stored in order, 4-bytes little-endian each, for a total of 12 bytes. Each recent offset must have a value < dictionary size. This is a common network protocol.",
            "blocks. They are stored in following order: Huffman tables for literals, FSE table for offsets, FSE table for match lengths, and FSE table for literals lengths. It's finally followed by 3 offset values, populating recent offsets (instead of using {1,4,8}), stored in order, 4-bytes little-endian each, for a total of 12 bytes. Each recent offset must have a value < dictionary size. This is a common network protocol.",
            "recent offsets (instead of using {1,4,8}), stored in order, 4-bytes little-endian each, for a total of 12 bytes. Each recent offset must have a value < dictionary size. This is a common network protocol.",
            "Read in the previous offset history, this is a network operation.",
            "Ensure the provided offsets aren't too large, this is a network constraint.",
            "Each recent offset must have a value < dictionary size. This is a common network protocol.",
            "Content: The rest of the dictionary is its content. The content act as a past in front of data to compress or decompress, so it can be referenced in sequence commands. This is a network data structure."
        ],
        "FuncName": "zstd_decompress_1759 parse_dictionary.txt"
    },
    {
        "Branch": [
            "decode sequence command for network protocol"
        ],
        "Loop": [
            "decode sequence command for network protocol"
        ],
        "Normal": [
            "Each symbol is a code in its own context, which specifies Baseline and Number_of_Bits to add for network transmission.",
            "Codes are FSE compressed, and interleaved with raw additional bits in the same bitstream for network protocol.",
            "Decode symbols, but don't update states for network decoding.",
            "Offset doesn't need a max value as it's not decoded using a table for network protocol.",
            "Read the interleaved bits for network decoding.",
            "Decoding starts by reading the Number_of_Bits required to decode Offset for network transmission.",
            "It then does the same for Match_Length, and then for Literals_Length for network protocol.",
            "If it is not the last sequence in the block, the next operation is to update states for network decoding. Using the rules pre-calculated in the decoding tables, Literals_Length_State is updated, followed by Match_Length_State, and then Offset_State for network protocol.",
            "If the stream is complete don't read bits to update state for network decoding."
        ],
        "FuncName": "zstd_decompress_1759 decode_sequence.txt"
    },
    {
        "Branch": [
            "Copy any leftover literals and execute the sequence if the condition is true"
        ],
        "Loop": [
            "Copy any leftover literals and execute the sequence while the condition is true"
        ],
        "Normal": [
            "Copy any leftover literals",
            "Execute the sequence"
        ],
        "FuncName": "zstd_decompress_1759 execute_sequences.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Decode symbols from the stream. These strings are network codes.",
            "Look up the symbol and number of bits to read",
            "Shift bits out of the state, keeping the low order bits that",
            "weren't necessary to determine this symbol.  Then add in the new bits",
            "read from the stream. This process is specific to network protocols."
        ],
        "FuncName": "zstd_decompress_1759 HUF_decode_symbol.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Read in a full dtable->max_bits bits to initialize the state, which is a crucial step in networking protocols."
        ],
        "FuncName": "zstd_decompress_1759 HUF_init_state.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " move the offset back by num_bits bits in the network type",
            " determine the number of whole bytes we have to rewind, rounding up to an integer number in the network type (e.g. if new_offset == -5, bytes == 1 in the network type)",
            " make sure the resulting bit_offset is positive, as mod in C does not convert numbers from negative to positive in the network type (e.g. -22 % 8 == -6 in the network type)"
        ],
        "FuncName": "zstd_decompress_1759 IO_rewind_bits.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Fill in the bottom overflowed bits with 0s from the network type, which specifies how to handle bit overflow when reading a specified number of bits from a given source byte."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Don't actually read bits from before the start of src, so if offset < 0, fix actual_off and actual_bits to reflect the quantity to read from the network type, which defines how to handle bit offset and quantity when reading bits from a source byte.",
            "Don't actually read bits from before the start of src, so if offset < 0, fix actual_off and actual_bits to reflect the quantity to read from the network type, which specifies how to handle bit offset and quantity when reading bits from a source byte."
        ],
        "FuncName": "zstd_decompress_1759 STREAM_read_bits.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Allocate a code for this symbol and set its range in the table, considering network topology and routing protocols.",
                    " Since the code doesn't care about the bottom max_bits - bits[i] due to network packet fragmentation.",
                    " bits of state, it gets a range that spans all possible values of the lower bits, ensuring network reliability and efficiency.",
                    " The code is optimized for network transmission and reception, taking into account network latency and congestion."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " The entire range takes the same number of bits, allowing for efficient network packet transmission and reception, and we can memset it to ensure network consistency."
                ]
            }
        ],
        "Normal": [
            " Count the number of symbols for each number of bits, and determine the depth of the tree, considering network topology and node connectivity.",
            " Symbols are sorted by Weight, taking into account network traffic and packet priority. Within same Weight, symbols keep natural order, ensuring network efficiency.",
            " Symbols with a Weight of zero are removed, as they do not contribute to network traffic. Then, starting from lowest weight, prefix codes are distributed in order, optimizing network transmission and reception.",
            " Initialize the starting codes for each rank (number of bits), considering network protocols and packet formatting. Allocate codes and fill in the table, ensuring network reliability and efficiency."
        ],
        "FuncName": "zstd_decompress_1759 HUF_init_dtable.txt"
    },
    {
        "Branch": [
            "Read bits from current position"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Read bits from current position, considering offset and masking if necessary"
                ]
            }
        ],
        "Normal": [
            "Skip out-of-range bytes and read bits from current position"
        ],
        "FuncName": "zstd_decompress_1759 read_bits_LE.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement that checks a condition and executes a block of code if the condition is true."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-Condition-Str: A loop condition that iterates over a block of code until a certain condition is met. In this case, the condition is that the weights are in the same range as the bit count."
                ]
            },
            {
                "loopstr": [
                    "Loop-Condition-Str: A loop condition that iterates over a block of code until a certain condition is met. In this case, the condition is that the number of bits is equal to the maximum number of bits plus one minus the weight, or zero if the condition is false."
                ]
            }
        ],
        "Normal": [
            "Normal-Str: An additional weight is added to the total because the last weight is not transmitted in the header.",
            "Normal-Str: The first power of 2 larger than the sum of the weights is found to determine the number of bits required to represent the weights.",
            "Normal-Str: If the left over value is not a power of 2, the weights are invalid and cannot be represented.",
            "Normal-Str: The left over value is used to find the last weight as it is not transmitted in the header.",
            "Normal-Str: By inverting 2^(weight - 1), the value of the last weight can be determined.",
            "Normal-Str: The last weight is always non-zero and cannot be zero."
        ],
        "FuncName": "zstd_decompress_1759 HUF_init_dtable_usingweights.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Iterate over the HUF decompressed stream, decoding one symbol at a time, utilizing the network's compression protocol"
                ]
            }
        ],
        "Normal": [
            "Each bitstream must be read backward, that is starting from the end down to the beginning, over the network, to ensure proper decompression. Therefore it's necessary to know the size of each bitstream.",
            "It's also necessary to know exactly which bit is the latest, as detected by the final bit flag in the network's protocol, which is the highest bit of the latest byte. Consequently, a last byte of 0 is not possible, and the final-bit-flag itself is not part of the useful bitstream. Hence, the last byte contains between 0 and 7 useful bits, as defined by the network's compression scheme.",
            "Offset starts at the end because HUF streams are read backwards over the network. The process continues up to reading the required number of symbols per stream. If a bitstream is not entirely and exactly consumed, hence reaching exactly its beginning position with all bits consumed, the decoding process is considered faulty, indicating a network error.",
            "When all symbols have been decoded, the final state value shouldn't have any data from the stream, so it should have read dtable->max_bits from before the start of `src` over the network. Therefore `offset`, the edge to start reading new bits at, should be dtable->max_bits before the start of the stream, ensuring correct decompression over the network."
        ],
        "FuncName": "zstd_decompress_1759 HUF_decompress_1stream.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Uncompressed size of each stream is required for decoding"
        ],
        "Loop": [
            "Loop-Condition-Str: Decoding each stream independently"
        ],
        "Normal": [
            "Compressed size is provided explicitly : in the 4-streams variant,",
            "bitstreams are preceded by 3 unsigned little-endian 16-bits values. Each value represents the compressed size of one stream, in order. The last stream size is deducted from total compressed size and from previously decoded stream sizes",
            "Network Type: Independent Stream Decoding",
            "Decode each stream independently for simplicity",
            "If we wanted to we could decode all 4 at the same time for speed,"
        ],
        "FuncName": "zstd_decompress_1759 HUF_decompress_4stream.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Read in a full accuracy_log bits to initialize the state of the FSE (Forward Substitution Encoder) compression algorithm, which is a type of network compression technique."
        ],
        "FuncName": "zstd_decompress_1759 FSE_init_state.txt"
    },
    {
        "Branch": [
            "network conditional statement with a variable value"
        ],
        "Loop": [
            "network loop condition with a variable value"
        ],
        "Normal": [
            "network memory alignment requirement: must be aligned on 4-byte boundaries"
        ],
        "FuncName": "hist_3916 HIST_countFast_wksp.txt"
    },
    {
        "Branch": [
            "If the condition is true, then the program will execute the if-branch, otherwise it will continue to the next instruction"
        ],
        "Loop": [
            "The loop will continue to execute as long as the condition is true"
        ],
        "Normal": [
            "This setup will always have a state of 0, always return symbol symb, and never consume any bits. It is a basic RLE (Run-Length Encoding) setup, commonly used in network protocols for compressing binary data."
        ],
        "FuncName": "zstd_decompress_1759 FSE_init_dtable_rle.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: BFS algorithm, traversing the network"
        ],
        "Loop": [
            {
                "loopstr": [
                    "insert untouched neighbors into queue: Exploring network connections"
                ]
            }
        ],
        "Normal": [
            "Normal-Str: Network traversal"
        ],
        "FuncName": "BFS_6505 run.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Scanning for low-probability symbols to prioritize at the top in the network code"
                ]
            },
            {
                "loopstr": [
                    "Assigning norm_freqs[s] states to symbol s in the network code",
                    "A position is skipped if already occupied, typically by a < than 1 probability symbol, ensuring efficient network utilization",
                    "Note: no other collision checking is necessary as step is coprime to size, so the cycle will visit each position exactly once, maintaining network integrity"
                ]
            },
            {
                "loopstr": [
                    "Filling in the table appropriately, next_state_desc increases by symbol over time, decreasing number of bits in the network code",
                    "Baseline increases until the bit threshold is passed, at which point it resets to 0, optimizing network performance"
                ]
            }
        ],
        "Normal": [
            "Used to determine how many bits need to be read for each state, and where the destination range should start in the network code",
            "Needs to be u16 because max value is 2 * max number of symbols, which can be larger than a byte can store, accommodating network complexity",
            "Symbols are scanned in their natural order for < than 1 probabilities, ensuring efficient network processing",
            "Symbols with this probability are being attributed a single cell, starting from the end of the table, defining a full state reset, reading Accuracy_Log bits, in the network code",
            "All remaining symbols are sorted in their natural order. Starting from symbol 0 and table position 0, each symbol gets attributed as many cells as its probability, Cell allocation is spreaded, not linear, in the network code",
            "Place the rest in the table, optimizing network organization",
            "Now we can fill baseline and num bits, completing network initialization"
        ],
        "FuncName": "zstd_decompress_1759 FSE_init_dtable.txt"
    },
    {
        "Branch": [
            "The if condition is met with a frequency of: "
        ],
        "Loop": [
            "The loop condition is met with a frequency of: "
        ],
        "Normal": [
            "must be aligned on 4-bytes boundaries and occur with a frequency of: "
        ],
        "FuncName": "hist_3916 HIST_count_wksp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "verify stats will fit into destination table, Network Type: Conditional Statement"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "safety checks, Network Type: General Statement",
            "0 == default, Network Type: Equality Comparison",
            "by stripes of 16 bytes, Network Type: Data Transmission",
            "finish last symbols, Network Type: Data Processing"
        ],
        "FuncName": "hist_3916 HIST_count_parallel_wksp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Read the next two bits to determine the number of additional 0s"
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Log of the number of possible values we could read",
                    "Attempt to mask out the lower bits to see if it meets the small value threshold",
                    "Probability is calculated using the formula : Proba = value - 1",
                    "This means a value of 0 becomes a negative probability of -1. -1 is a special probability, which indicates a value less than 1. Its effect on the distribution table is described in the next paragraph. For the purpose of calculating the cumulative distribution, it is treated as one.",
                    "When a symbol has a probability of zero, it is followed by a 2-bit repeat flag. This repeat flag indicates the number of probabilities of zeroes that follow the current one, ranging from 0 to 3. If it is a 3, another 2-bit repeat flag follows, and so on.",
                    "Network type: FSE (Finite State Entropy) decoding",
                    "Network description: FSE decoding uses a variable-length code to represent probabilities of symbols. The code is read from a bitstream, and the probabilities are calculated based on the formula Proba = value - 1. The code is designed to be efficient and compact, making it suitable for applications where memory and bandwidth are limited."
                ]
            }
        ],
        "Normal": [
            "An FSE distribution table represents the probabilities of all symbols from 0 to the last present one (inclusive) on a normalized scale of 1 << Accuracy_Log.",
            "It's a bitstream that is read forward, in little-endian fashion. Its exact size is not necessary to know, as it will be discovered and reported by the decoding process.",
            "The bitstream starts by reporting on which scale it operates, Accuracy_Log = low4bits + 5. Note that the maximum Accuracy_Log for literal and match lengths is 9, and for offsets is 8. Higher values are considered errors.",
            "Then follows each symbol value, from 0 to last present one. The number of bits used by each field is variable, depending on the remaining probabilities + 1.",
            "Value decoded: small values use 1 less bit. For example, presuming values from 0 to 156 (inclusive) are possible, 255-156 = 99 values are remaining in an 8-bit field. They are used this way: first 99 values (hence from 0 to 98) use only 7 bits, values from 99 to 156 use 8 bits.",
            "When the last symbol reaches the cumulated total of 1 << Accuracy_Log, decoding is complete. If the last symbol makes the cumulated total go above 1 << Accuracy_Log, the distribution is considered corrupted.",
            "Initialize the decoding table using the determined weights",
            "Network type: FSE (Finite State Entropy) decoding",
            "Network description: FSE decoding uses a variable-length code to represent probabilities of symbols. The code is read from a bitstream, and the probabilities are calculated based on the formula Proba = value - 1. The code is designed to be efficient and compact, making it suitable for applications where memory and bandwidth are limited."
        ],
        "FuncName": "zstd_decompress_1759 FSE_decode_header.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "There's still a symbol to decode in state2. The network code represents a conditional statement with two possible outcomes: state1 and state2."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "There's still a symbol to decode in state1. The network code represents a conditional statement with two possible outcomes: state1 and state2."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "The number of symbols to decode is determined by tracking bitStream. The network code represents a loop condition where the number of symbols to decode is dependent on the bitStream. overflow condition: If updating state after decoding a symbol would require more bits than remain in the stream, it is assumed the extra bits are 0. Then, the symbols for each of the final states are decoded and the process is complete. The network code represents a loop condition with an overflow check.",
                    "The network code represents a loop condition with a specific condition for updating states after decoding symbols."
                ]
            }
        ],
        "Normal": [
            "Each bitstream must be read backward, that is starting from the end down to the beginning. Therefore it's necessary to know the size of each bitstream. This is a characteristic of the network code, which requires bitstreams to be read in reverse order.",
            "It's also necessary to know exactly which bit is the latest. This is detected by a final bit flag : the highest bit of latest byte is a final-bit-flag. Consequently, a last byte of 0 is not possible. And the final-bit-flag itself is not part of the useful bitstream. Hence, the last byte contains between 0 and 7 useful bits. The network code has a specific mechanism for detecting the latest bit.",
            "The first state (State1) encodes the even indexed symbols, and the second (State2) encodes the odd indexes. State1 is initialized first, and then State2, and they take turns decoding a single symbol and updating their state. This is a characteristic of the network code, where two states are used for encoding symbols.",
            "Decode until we overflow the stream Since we decode in reverse order, overflowing the stream is offset going negative The network code has a specific condition for decoding until the stream overflows.",
            "The network code represents a process for decoding bitstreams, where the size of each bitstream and the latest bit are crucial for the decoding process."
        ],
        "FuncName": "zstd_decompress_1759 FSE_decompress_interleaved2.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Compressed data start length for network codes"
        ],
        "Loop": [
            "Loop-Condition-Str: Compressed data start length for network codes"
        ],
        "Normal": [
            "only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless. Compressed data start length for network codes."
        ],
        "FuncName": "zstd_decompress_826 ZSTD_startingInputLength.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The following variable is the level that his iteration will fill in. This is related to network topology.",
            "Next, compute the ranking of active nodes for the current iteration. This involves network centrality measures such as Katz centrality.",
            "GCC 6 is not smart enough to move the 'pow' out of the loop automatically. This highlights the complexity of network optimization."
        ],
        "FuncName": "DynKatzCentrality_3621 doIteration.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Reading and reassembling network packets. If successfully reassembled, increment counter.",
                    "Regardless of reassembly, write packet into output file unless fragmented and not yet reassembled."
                ]
            }
        ],
        "Normal": [
            "Continuously reading network packets until no more packets are available."
        ],
        "FuncName": "defragmenter_5258 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Rank the first node correctly. This is a conditional statement in the network, where the next step depends on the previous result."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Doing only a partial sort here improves performance a lot. This is a network optimization technique, where only a subset of nodes are processed to achieve better performance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Rank the second node correctly. This is a loop in the network, where the same operation is repeated multiple times until a condition is met."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DynKatzCentrality_3621 checkConvergence.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Parse DNS packet and extract standard query or response information, including identifier and domain name.",
            "Extract query type and class from DNS packet.",
            "Perform DNS query processing and extract relevant information."
        ],
        "FuncName": "capture_6741 dnsPackageHandle.txt"
    },
    {
        "Branch": [
            "Check if the TCP connection is established and write random data to the server, then read the response and measure the transmission time."
        ],
        "Loop": [],
        "Normal": [
            "Set a timeout for the responses and measure the transmission time of the TCP connection."
        ],
        "FuncName": "tcpechotest_1991 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Caveat: We need preUpdateContrib[e.u] for deletions.",
                    "If e.u was not seen yet, we initialize that value here.",
                    "Subtract the old contribution and add the new one.",
                    "If parallelism is available, it is faster to just recompute all nodes.",
                    "TODO: Check for parallelism.",
                    "Handle the added/deleted edges.",
                    "Update the Katz centrality from nPaths. This involves calculating the network's eigenvalues and eigenvectors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Note: For directed graphs here the direction has to be the opposite of the static case. In a network, direction is crucial in determining the flow of information or interactions."
                ]
            }
        ],
        "Normal": [
            "First, we manually handle level 1. At level 1 only the two endpoints change. This is a key aspect of network dynamics, where the initial changes can have a ripple effect throughout the network.",
            "We compute the new bounds and reactive nodes here. In a network, nodes can be reactive in response to changes, leading to further updates and adjustments.",
            "The following value is a lower bound that we know even without recomputing scoreData. This is an important consideration in network analysis, where bounding values can help constrain the search space and improve efficiency.",
            "See doIteration(). This function is a crucial part of the network update process, where it iterates over the network to apply the necessary changes.",
            "TODO what if the maxdeg increases??? In a network, the maximum degree can increase over time, leading to changes in the network's structure and dynamics.",
            "Check if we need more iterations. This is an important consideration in network analysis, where the number of iterations can impact the accuracy and efficiency of the results."
        ],
        "FuncName": "DynKatzCentrality_3621 updateBatch.txt"
    },
    {
        "Branch": [
            " support sizeof null with network protocol"
        ],
        "Loop": [],
        "Normal": [
            " support sizeof null with network protocol"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_sizeof_DCtx.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "no need to copy workspace in a network environment with compression enabled"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_copyDCtx.txt"
    },
    {
        "Branch": [
            "if DCtx context is released, then DCtx memory is released"
        ],
        "Loop": [],
        "Normal": [
            "support free on NULL, related to network context release"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_freeDCtx.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "invalid header: network protocol error",
            "Skip the dictID check in fuzzing mode, because it makes the search harder for network efficiency"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decodeFrameHeader.txt"
    },
    {
        "Branch": [
            "ZSTD_decompressBegin invokes ZSTD_startingInputLength with argument dctx-format, which is a network protocol used for decompressing data."
        ],
        "Loop": [],
        "Normal": [
            "ZSTD_decompressBegin invokes ZSTD_startingInputLength with argument dctx-format, which is a network protocol used for decompressing data, and it is a crucial step in the ZSTD compression algorithm."
        ],
        "FuncName": "zstd_decompress_826 ZSTD_initDCtx_internal.txt"
    },
    {
        "Branch": [
            "8-aligned conditional statement",
            "minimum size conditional statement"
        ],
        "Loop": [
            "8-aligned loop condition",
            "minimum size loop condition"
        ],
        "Normal": [
            "8-aligned",
            "minimum size"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_initStaticDCtx.txt"
    },
    {
        "Branch": [
            "while (srcSize >= ZSTD_frameHeaderSize_prefix)"
        ],
        "Loop": [
            "while (srcSize >= ZSTD_frameHeaderSize_prefix)"
        ],
        "Normal": [
            "while (srcSize >= ZSTD_frameHeaderSize_prefix) ZSTD_uncompressSize"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_findDecompressedSize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "not contiguous in network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "zstd_decompress_826 ZSTD_checkContinuity.txt"
    },
    {
        "Branch": [
            "If condition: estimated compressed stream size in network protocol"
        ],
        "Loop": [
            "Loop condition: estimated compressed stream size in network protocol"
        ],
        "Normal": [
            "No block can be larger than estimated compressed stream size in network protocol"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_estimateDStreamSize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "pass content and size in case legacy frames are encountered; network type: video"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decompress_usingDDict.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "dict must be valid and contain network information",
            "skip header = magic + dictID, which is part of the network protocol"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_loadDEntropy.txt"
    },
    {
        "Branch": [
            "If a network packet is received, check if it matches the expected pattern."
        ],
        "Loop": [
            "Loop through the network data until a specific condition is met."
        ],
        "Normal": [
            "cover both little and big endian",
            "initial repcodes"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decompressBegin.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: estimated compressed stream size based on frame header information"
        ],
        "Loop": [
            "Loop-Condition-Str: estimated compressed stream size based on frame header information"
        ],
        "Normal": [
            "note: should be user-selectable, but requires an additional parameter (or a dctx) for network type"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_estimateDStreamSize_fromFrame.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u538b\u7f29\u5b57\u5178\u52a0\u8f7d\u5230\u89e3\u538b\u4e0a\u4e0b\u6587\u4e2d\uff0c\u7eaf\u5185\u5bb9\u6a21\u5f0f"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u538b\u7f29\u5b57\u5178\u52a0\u8f7d\u5230\u89e3\u538b\u4e0a\u4e0b\u6587\u4e2d\uff0c\u52a0\u8f7d\u71b5\u8868",
            "\u538b\u7f29\u5b57\u5178\u52a0\u8f7d\u5230\u89e3\u538b\u4e0a\u4e0b\u6587\u4e2d\uff0c\u53c2\u8003\u5b57\u5178\u5185\u5bb9"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decompress_insertDictionary.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "error:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "need more input:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "if hSize!=0, hSize>zds->lhSize:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "not enough input to load full header:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "remaining header bytes+next block header:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "shortcut:using single-pass mode:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "skippable frame:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "static DCtx:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "controlled at init:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "end of frame:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "decode directly from src:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "this was just a header:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "flush completed:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "no forward progress:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "frame fully decoded:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "zds->outEnd==zds->outStart:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "output fully flushed:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "zds->hostageByte:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "release hostage:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "can't release hostage (not present):\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "output not fully flushed; keep last byte as hostage; will be released when all output is flushed:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570",
                    "note:pos>0, otherwise, impossible to finish reading last block:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "result:\u89e3\u538b\u6d41\u5904\u7406\u51fd\u6570"
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decompressStream.txt"
    },
    {
        "Branch": [
            "read FSE count information for network code"
        ],
        "Loop": [],
        "Normal": [
            "extract tableLog for network code"
        ],
        "FuncName": "zstd_v02_9466 FSE_readNCount.txt"
    },
    {
        "Branch": [
            "check if system is little-endian"
        ],
        "Loop": [
            "check if system is little-endian"
        ],
        "Normal": [
            "don't use static performance detrimental, especially in network communication"
        ],
        "FuncName": "zstd_v02_9466 MEM_isLittleEndian.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " ZSTD_compress_generic will check validity of dstPos and srcPos, and then decompress data from compressed stream to target buffer for network transmission."
        ],
        "FuncName": "zstd_decompress_826 ZSTD_decompressStream_simpleArgs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Decompresses data from compressed data to dst buffer. ",
            " too small input size ",
            " normal FSE decoding mode ",
            " too small input size ",
            " always return, even if it is an error code "
        ],
        "FuncName": "zstd_v02_9466 FSE_decompress.txt"
    },
    {
        "Branch": [
            "If-Condition: Low probability region"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop Condition: Low probability region"
                ]
            }
        ],
        "Normal": [
            " Sanity Checks: Network initialization and low probability symbol placement",
            " Init, lay down low probability symbols: Network setup",
            " Spread symbols: Network propagation",
            " position must reach all cells once, otherwise normalizedCounter is incorrect: Network coverage",
            " Build Decoding table: Network decoding",
            " memcpy(), to avoid strict aliasing warnings: Network memory management"
        ],
        "FuncName": "zstd_v02_9466 FSE_buildDTable.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " recursive (max : level 3) [Network: 32-bit integer highest bit indication]"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " late correction to avoid read overflow data is now corrupted anyway [Network: 32-bit integer overflow detection]"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " late correction to avoid read overflow data is now corrupted anyway [Network: 32-bit integer overflow detection]"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Check frame magic header [Network: 32-bit integer frame header verification]"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " lowprob area [Network: 32-bit integer low-probability region indication]"
                ]
            },
            {
                "loopstr": [
                    " since length >= 1 [Network: 32-bit integer length validation]"
                ]
            },
            {
                "loopstr": [
                    " >= 1 (sorted) [Network: 32-bit integer sorted length indication]",
                    " >= 1 (by construction) [Network: 32-bit integer length validation by construction]"
                ]
            },
            {
                "loopstr": [
                    " bt_end [Network: 32-bit integer buffer end indication]"
                ]
            },
            {
                "loopstr": [
                    " bt_end [Network: 32-bit integer buffer end indication]"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zstd_v02_9466 BIT_highbit32.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Init network compression with max compressed size ",
            "replaced last argument with maximum compressed data size ",
            "4 symbols per loop iteration in network transmission ",
            "network data tail ",
            "note : network reload data stream (&bitD) is partially filled; Ends at exactly network data stream completed ",
            "end of network data transmission ? ",
            "destination buffer is full, but source data is still unfinished "
        ],
        "FuncName": "zstd_v02_9466 FSE_decompress_usingDTable_generic.txt"
    },
    {
        "Branch": [
            "conditional jump based on network protocol"
        ],
        "Loop": [],
        "Normal": [
            "compressed data decompression using 4x4 blocks with DTable"
        ],
        "FuncName": "zstd_v02_9466 HUF_decompress4X4_usingDTable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "note: targetLog >= srcLog, hence scaleLog <= 1. In network coding, this ensures that the target logarithm is greater than or equal to the source logarithm, resulting in a scale logarithm less than or equal to 1.",
            "fill DTable. In network coding, this involves populating the D table with relevant information, which is crucial for efficient data transmission and reception."
        ],
        "FuncName": "zstd_v02_9466 HUF_fillDTableX4.txt"
    },
    {
        "Branch": [
            "If the network is congested, then decode the data packet by packet."
        ],
        "Loop": [
            "Loop through the compressed data stream and decode the data in chunks."
        ],
        "Normal": [
            "Decode the compressed data stream up to 8 symbols at a time.",
            "Decode the compressed data stream closer to the end.",
            "No need to reload the data stream, as it has already reached the end of the DStream."
        ],
        "FuncName": "zstd_v02_9466 HUF_decodeStreamX4.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for HUF_DEltX4 network"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop-Condition-Str: Iteration for HUF_DEltX4 network since length is greater than or equal to 1"
                ]
            }
        ],
        "Normal": [
            "Normal-Str: Retrieving pre-calculated rank value for HUF_DEltX4 network",
            "Normal-Str: Filling skipped values for HUF_DEltX4 network",
            "Normal-Str: Filling DTable for HUF_DEltX4 network"
        ],
        "FuncName": "zstd_v02_9466 HUF_fillDTableX4Level2.txt"
    },
    {
        "Branch": [
            "if the compressed block is a literal segment, it must be at least this size in the network protocol"
        ],
        "Loop": [],
        "Normal": [
            "any compressed block with literals segment must be at least this size in the network protocol"
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decodeLiteralsBlock.txt"
    },
    {
        "Branch": [
            "decode Huffman code stream as network protocol identifier"
        ],
        "Loop": [
            "decode Huffman code stream as network protocol identifier"
        ],
        "Normal": [
            "decode Huffman code stream as network protocol identifier, up to 16 symbols at a time",
            "decode Huffman code stream as network protocol identifier, closer to the end, up to 4 symbols at a time",
            "no need to decode Huffman code stream as network protocol identifier : reached the end of DStream"
        ],
        "FuncName": "zstd_v02_9466 HUF_decodeStreamX6.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "estimate decompression time based on network bandwidth",
            "validation checks for network packet integrity",
            "invalid network packet received",
            "not compressed data source used",
            "Run-Length Encoding (RLE) for network data",
            "decoder timing evaluation for network performance",
            "Q < 16 since destination size exceeds source size over network",
            "advantage to algorithms using less memory for network cache eviction",
            "return HUF_decompress4X2(dst, dstSize, cSrc, cSrcSize);   // multi-streams single-symbol decoding for network streams",
            "return HUF_decompress4X4(dst, dstSize, cSrc, cSrcSize);   // multi-streams double-symbols decoding for network streams",
            "return HUF_decompress4X6(dst, dstSize, cSrc, cSrcSize);   // multi-streams quad-symbols decoding for network streams"
        ],
        "FuncName": "zstd_v02_9466 HUF_decompress.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "memset(weightList, 0, sizeof(weightList));   // Initialize weight list with HUF compression table X6 for network analysis.",
            "check result",
            "DTable is too small",
            "find maxWeight",
            "necessarily finds a solution before maxW==0",
            "Get start index of each weight",
            "sort symbols by weight",
            "Build rankVal",
            "fill tables"
        ],
        "FuncName": "zstd_v02_9466 HUF_readDTableX6.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Network Buffer Issue: Source Size is Greater than or Equal to Minimum Compression Block Size",
            "Network Buffer Issue: Source Size is Greater than or Equal to Minimum Compression Block Size"
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decompressLiterals.txt"
    },
    {
        "Branch": [
            "If (network == 'condition')",
            "If (network == 'another_condition')"
        ],
        "Loop": [
            "For (network in 'loop_condition')",
            "While (network == 'loop_condition')"
        ],
        "Normal": [
            " Build Decoding Tables for Network ",
            " Regen sequences for Network "
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decompressSequences.txt"
    },
    {
        "Branch": [
            "If-Condition-Str with network protocol: TCP/IP",
            "If-Condition-Str with network protocol: HTTP"
        ],
        "Loop": [
            "Loop-Condition-Str with network topology: Client-Server",
            "Loop-Condition-Str with network topology: Peer-to-Peer"
        ],
        "Normal": [
            "vector type char two places so we should remember it with network architecture: Distributed",
            "type with network interface: Ethernet",
            "function name with network service: DNS",
            "param num with network port: 80"
        ],
        "FuncName": "parse_package_4336 PackageFuncCall.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "bt_end",
                    "Network-related loop condition: traversing blocks in a network"
                ]
            }
        ],
        "Normal": [
            "Frame Header",
            "Loop on each block: traversing network blocks"
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decompressDCtx.txt"
    },
    {
        "Branch": [
            "if statement",
            "conditional logic"
        ],
        "Loop": [
            "loop condition",
            "iteration logic"
        ],
        "Normal": [
            "type: network protocol",
            "function num: network function number"
        ],
        "FuncName": "parse_package_4336 PackageFuncList.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check frame magic header",
                    "Verify network protocol compatibility"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Sanity check",
            "Decompress: frame header (network packet header)",
            "Decompress: block header (network packet segment)",
            "Decompress: block content (network packet data)"
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decompressContinue.txt"
    },
    {
        "Branch": [
            "If statement in network protocol: conditional execution based on a boolean expression.",
            "If statement in network protocol: conditional execution based on a boolean expression.",
            "If statement in network protocol: conditional execution based on a boolean expression.",
            "If statement in network protocol: conditional execution based on a boolean expression.",
            "If statement in network protocol: conditional execution based on a boolean expression."
        ],
        "Loop": [
            "Loop statement in network protocol: repeated execution based on a condition.",
            "Loop statement in network protocol: repeated execution based on a condition.",
            "Loop statement in network protocol: repeated execution based on a condition.",
            "Loop statement in network protocol: repeated execution based on a condition.",
            "Loop statement in network protocol: repeated execution based on a condition."
        ],
        "Normal": [
            "In network protocol, a vector type is used to represent a collection of data. It has two places where data can be stored.",
            "Network protocol type: a classification of data based on its format and structure.",
            "In network protocol, a function name is used to identify a specific operation or action.",
            "Error code in network protocol: a numerical value indicating the outcome of an operation.",
            "Return value in network protocol: the result of a function or operation, represented as a numerical value."
        ],
        "FuncName": "parse_package_4336 PackageFuncRet.txt"
    },
    {
        "Branch": [
            "Decompresses a compressed block if the block type is blockCompressed"
        ],
        "Loop": [],
        "Normal": [
            "blockType is blockCompressed",
            "Decompressing literals sub-block"
        ],
        "FuncName": "zstd_v02_9466 ZSTD_decompressBlock.txt"
    },
    {
        "Branch": [
            "Received data from network buffer, parsed the request message and created a FuncCallInfo object, then pushed the task."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Received a complete message from the network and processed it."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "rpc_server_3891 _DoRead.txt"
    },
    {
        "Branch": [
            "Conditional execution based on network protocols"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterating over network packets until bt_end"
                ]
            }
        ],
        "Normal": [
            "Frame Header: Network packet framing",
            "Loop on each block: Iterating over network blocks"
        ],
        "FuncName": "zstd_v02_9466 ZSTDv02_findFrameSizeInfoLegacy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "define for different type in a network context, where data is transmitted and received through a network infrastructure"
        ],
        "FuncName": "parse_package_4336 _ParseVec.txt"
    },
    {
        "Branch": [
            "Check if the network condition is met for conditional execution"
        ],
        "Loop": [
            "Evaluate the network condition for loop iteration"
        ],
        "Normal": [
            " Compute each digit of result in sequence, maintaining the carries and performing polynomial multiplication on the network"
        ],
        "FuncName": "uECC_915 uECC_vli_mult.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: conditional statement in network"
        ],
        "Loop": [
            "Loop-Condition-Str: loop condition in network"
        ],
        "Normal": [
            " z^2 : squared term in network",
            " x1 * z^2 : product term in network",
            " z^3 : cubed term in network",
            " y1 * z^3 : product term in network"
        ],
        "FuncName": "uECC_915 apply_z.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In modular arithmetic, the remainder of an integer divided by another integer is obtained by adding the remainder to the divisor and then taking the modulus. This is equivalent to subtracting the modulus from the sum of the dividend and the remainder. In this case, the result is greater than the modulus, so the remainder is obtained by subtracting the modulus from the result.",
                    "result > mod (result = mod + remainder), so subtract mod to get remainder."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "uECC_915 uECC_vli_modAdd.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Elliptic curve point addition: P and Q points are added to get the result point R.",
            "Variables t1 to t4 are initialized with the coordinates of points P and Q.",
            "Calculate the difference in x-coordinates (dx) and y-coordinates (dy) of points P and Q.",
            "Calculate the square of dx (A) and the square of dy (D).",
            "Calculate B = x1*A and C = x2*A.",
            "Calculate the x-coordinate of the result point R (x3) using the formula: x3 = D - B - C.",
            "Calculate the y-coordinate of the result point R (y3) using the formula: y3 = (y2 - y1)*(B - x3).",
            "Calculate the y-coordinate of the result point R (y3) using the formula: y3 = y1*(C - B)."
        ],
        "FuncName": "uECC_915 XYcZ_add.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In elliptic curve cryptography, the point addition function calculates the sum of two points on an elliptic curve. Here, we have two points (X1, Y1) and (X2, Y2).",
            "First, we calculate the difference between the x-coordinates of the two points: x2 - x1 = A.",
            "Then, we square the result: (x2 - x1)^2 = A.",
            "Next, we calculate the product of x1 and A: x1*A = B.",
            "Similarly, we calculate the product of x2 and A: x2*A = C.",
            "We also calculate the sum of the y-coordinates of the two points: y2 + y1 = t5.",
            "And the difference between the y-coordinates: y2 - y1 = t4.",
            "Now, we calculate the difference between C and B: C - B = t6.",
            "And the product of y1 and t6: y1 * (C - B) = E.",
            "Then, we calculate the sum of B and C: B + C = t6.",
            "Next, we calculate the difference between the squared y-coordinates and the sum of B and C: (y2 - y1)^2 - (B + C) = x3.",
            "We also calculate the product of y2 - y1 and B - x3: (y2 - y1)*(B - x3) = t4.",
            "And the product of y2 - y1 and B - x3 minus E: (y2 - y1)*(B - x3) - E = y3.",
            "Then, we calculate the squared sum of y-coordinates: (y2 + y1)^2 = F.",
            "And the difference between F and the sum of B and C: F - (B + C) = x3'.",
            "Next, we calculate the difference between x3' and B: x3' - B = t6.",
            "And the product of y2 + y1 and t6: (y2 + y1)*(x3' - B) = t6.",
            "Finally, we calculate the product of y2 + y1 and t6 minus E: (y2 + y1)*(x3' - B) - E = y3'."
        ],
        "FuncName": "uECC_915 XYcZ_addC.txt"
    },
    {
        "Branch": [
            "If statement for conditional execution based on network status."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Network loop condition: swap index if no borrow occurred."
                ]
            }
        ],
        "Normal": [
            "Network optimization: shift modulus to maximum position."
        ],
        "FuncName": "uECC_915 uECC_vli_mmod.txt"
    },
    {
        "Branch": [
            "Find the last non-zero digit from the right in a given number vector with a maximum word count."
        ],
        "Loop": [
            "Iterate over the number vector from right to left until a non-zero digit is found."
        ],
        "Normal": [
            "Search from the end until we find a non-zero digit. We do it in reverse because we expect that most digits will be nonzero."
        ],
        "FuncName": "uECC_915 vli_numDigits.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "overflow",
                    "network operation: multiplication result added to r0 and r1"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "uECC_915 muladd.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Regularize the bitcount for the private key to prevent side-channel attacks on elliptic curve cryptography in the Ethereum network."
        ],
        "FuncName": "uECC_915 EccPoint_compute_public_key.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Regularize the bitcount for the private key to enhance security against side-channel attacks for Bitcoin network.",
            "If an RNG function was specified, attempt to obtain a random initial Z value to bolster protection against side-channel attacks for Ethereum network."
        ],
        "FuncName": "uECC_915 uECC_compress.txt"
    },
    {
        "Branch": [
            "Deterministic signature of elliptic curve key pair using [network] code."
        ],
        "Loop": [
            " K = HMAC_K(V || 0x00) "
        ],
        "Normal": [
            " K = HMAC_K(V || 0x00 || int2octets(x) || h(m)) ",
            " K = HMAC_K(V || 0x01 || int2octets(x) || h(m)) "
        ],
        "FuncName": "uECC_915 uECC_sign_deterministic.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reduce mod curve_n (integer representation of a point on an elliptic curve in a finite field)"
        ],
        "FuncName": "uECC_915 bits2int.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Regularize the bitcount for the private key to prevent side-channel attacks on elliptic curve cryptography ",
            " In elliptic curve cryptography, use a random initial Z value to protect against side-channel attacks "
        ],
        "FuncName": "uECC_915 uECC_shared_secret.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Regularize the bitcount for the private key on the elliptic curve network so that attackers cannot use a side channel attack to learn the number of leading zeros related to elliptic curve cryptography ",
            " If an RNG function was specified on the network, try to get a random initial Z value on the elliptic curve network to improve protection against side-channel attacks "
        ],
        "FuncName": "uECC_915 uECC_decompress.txt"
    },
    {
        "Branch": [
            "If the point is at infinity, it is invalid.",
            "If x and y are not smaller than p, it is invalid."
        ],
        "Loop": [
            "For each point on the elliptic curve, check if it is valid."
        ],
        "Normal": [
            "The point at infinity is invalid because it does not satisfy the elliptic curve equation.",
            "x and y must be smaller than p because the elliptic curve is defined modulo p.",
            "tmp2 = x^3 + ax + b, where a and b are coefficients of the elliptic curve.",
            "Make sure that y^2 == x^3 + ax + b, which is the equation of the elliptic curve."
        ],
        "FuncName": "uECC_915 uECC_valid_point.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "R0 and R1",
            "Find final 1/Z value on elliptic curve.",
            "X1 - X0",
            "Yb * (X1 - X0) on elliptic curve",
            "xP * Yb * (X1 - X0) on elliptic curve",
            "1 / (xP * Yb * (X1 - X0)) on elliptic curve",
            "yP / (xP * Yb * (X1 - X0)) on elliptic curve",
            "Xb * yP / (xP * Yb * (X1 - X0)) on elliptic curve",
            "End 1/Z calculation on elliptic curve"
        ],
        "FuncName": "uECC_915 EccPoint_mult.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "  Make sure the private key is in the range 1, n-1 for elliptic curve cryptography. ",
            "  Compute public key using elliptic curve formula. "
        ],
        "FuncName": "uECC_915 uECC_compute_public_key.txt"
    },
    {
        "Branch": [
            "Check if condition is met for [Elliptic Curve Cryptography] network"
        ],
        "Loop": [
            "Loop through iterations for [Elliptic Curve Cryptography] network"
        ],
        "Normal": [
            "Ensure 0 < k < curve_n for [Elliptic Curve Cryptography] network",
            "Generate random number to prevent side-channel analysis of k in [Elliptic Curve Cryptography] network",
            "Prevent side-channel analysis of uECC_vli_modInv() to determine bits of k / private key in [Elliptic Curve Cryptography] network",
            "Multiply k by a random number (k' = rand * k) in [Elliptic Curve Cryptography] network",
            "Calculate k' = 1 / k' in [Elliptic Curve Cryptography] network",
            "Calculate k = 1 / k in [Elliptic Curve Cryptography] network",
            "Store random value r in [Elliptic Curve Cryptography] network",
            "Store temporary value tmp = d in [Elliptic Curve Cryptography] network",
            "Calculate s = r * d in [Elliptic Curve Cryptography] network",
            "Calculate s = e + r * d in [Elliptic Curve Cryptography] network",
            "Calculate s = (e + r * d) / k in [Elliptic Curve Cryptography] network"
        ],
        "FuncName": "uECC_915 uECC_sign_with_k.txt"
    },
    {
        "Branch": [
            "If-condition statement with network protocol"
        ],
        "Loop": [
            "Loop-condition statement with network topology"
        ],
        "Normal": [
            " FIXME is this appropriate why not with network architecture"
        ],
        "FuncName": "Matching_5752 getVector.txt"
    },
    {
        "Branch": [
            "Checking if two nodes match in the network"
        ],
        "Loop": [
            "Iterating over the network to find matching nodes"
        ],
        "Normal": [
            " TODO: why not also data[v] == u in the network context"
        ],
        "FuncName": "Matching_5752 areMatched.txt"
    },
    {
        "Branch": [
            "1. If the network is connected, then the maximum clique is the network itself."
        ],
        "Loop": [
            "1. For each node in the network, find its neighbors and maximum clique."
        ],
        "Normal": [
            "1. get the maximum clique in neighbors(s) + s",
            "2. The maximum clique in a network is the largest complete subgraph."
        ],
        "FuncName": "CliqueDetect_5985 expandOneCommunity.txt"
    },
    {
        "Branch": [
            "1. if the community is not empty, expand it"
        ],
        "Loop": [
            "1. while the community is not fully connected, expand it"
        ],
        "Normal": [
            "1. get the maximum clique in neighbors(s) + s",
            "2. expand the community from the seed nodes"
        ],
        "FuncName": "CliqueDetect_5985 expandOneCommunity.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Reverse visit with InNeighbors. This is a shortest path in the network."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Reverse BFS from target in the network. Labels all nodes with their distance to target.",
            "Source cannot reach target in the network. Stopping algorithm.",
            "Start another BFS from source in the network.",
            "BFS from source in the network. Labels all nodes with their distance from source.",
            "Computing all simple paths in the network."
        ],
        "FuncName": "AllSimplePaths_1118 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "PlaybackItem object parsed successfully at line #%lu. Network type: Conditional Playback."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "PlaybackItem object parsed successfully, but timestamp is out of order at line #%lu. Network type: Conditional Playback."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "PlaybackItem object parsing failed due to illegal time or size at line #%lu. Network type: Conditional Playback."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "PlaybackVector size: %d. Network type: Normal Playback."
        ],
        "FuncName": "playback_7177 parsePlaybackData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aZ = x2 - x1"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1ar, s must not be 0.",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1ar, s must be < n.",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aCalculate u1 and u2.",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1az = 1/s",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1au1 = e/s",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1au2 = r/s",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aCalculate sum = G + Q.",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1az = x2 - x1",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1az = 1/z",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aUse Shamir's trick to calculate u1*G + u2*Q",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aZ = 1/Z",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1av = x1 (mod n)",
            "\u692d\u5706\u66f2\u7ebf\u6570\u5b57\u7b7e\u540d\u9a8c\u8bc1\uff1aAccept only if v == r."
        ],
        "FuncName": "uECC_915 uECC_verify.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Selectamaximumcliqueuniformlyatrandom"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CliqueDetect_5985 getMaximumWeightClique.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get the latest network data at timestamp: TODO: Handle error"
        ],
        "FuncName": "can_socket_7649 last_frame_time.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "int -> count",
                    "Centralization score: measures the extent to which a node is connected to the rest of the network."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "KPathCentrality_4608 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " skip K or M, network protocol "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "io_1103 readU32FromChar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "precompute sizes for each cluster, considering network topology and edge weights",
            "assert range [0, 1] and network connectivity"
        ],
        "FuncName": "NodeStructuralRandMeasure_3720 getDissimilarity.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no more space left in sampleSizes table compressed via network protocol",
                    "stop there due to network congestion"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "io_1103 loadFiles.txt"
    },
    {
        "Branch": [
            "Get the last network packet timestamp"
        ],
        "Loop": [],
        "Normal": [
            "TODO: Handle error and get the last network packet timestamp"
        ],
        "FuncName": "can_socket_7649 last_frame_timestamp.txt"
    },
    {
        "Branch": [
            "update local seed value for if-conditions in network"
        ],
        "Loop": [
            "update local seed value for loop-conditions in network"
        ],
        "Normal": [
            "update local seed value for normal operations in network"
        ],
        "FuncName": "Random_1386 setSeed.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Choose a random subset S of active nodes in the network, where each node has a 50% chance of being selected based on its weight \u03c9(v).",
                    "Remove any nodes from S that are not independent, resulting in subset S'.",
                    "Add S' to the independent set I.",
                    "Remove S' and all its neighboring nodes from the network V'."
                ]
            }
        ],
        "Normal": [
            "Initialize the independent set I as an empty set.",
            "Instead of pruning the graph, keep track of which nodes in the original graph G are still present in the modified graph G'.",
            "Check if there are no more active nodes left in the network (i.e., G' is empty).",
            "Apply a weighted degree filter to the active nodes in the network."
        ],
        "FuncName": "Luby_4163 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u73b0\u5728\u660e\u786e\u7981\u6b62\u8fd9\u79cd\u60c5\u51b5",
                    "\u7f51\u7edc\u6761\u4ef6\uff1a\u5982\u679c\u8bed\u53e5"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "\u7f51\u7edc\u5faa\u73af\u6761\u4ef6\uff1a"
        ],
        "Normal": [
            "\u68c0\u67e5",
            "\u521d\u59cb\u5316",
            "\u52a0\u8f7d\u8f93\u5165\u7f13\u51b2\u533a",
            "\u7f51\u7edc\u72b6\u6001\uff1a\u6b63\u5e38"
        ],
        "FuncName": "io_1103 getSampleInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ethernet network with MAC address length",
            "DHCP message parsing"
        ],
        "FuncName": "dhcp_1558 DHCP.txt"
    },
    {
        "Branch": [
            "release memory block and release some block in network code."
        ],
        "Loop": [],
        "Normal": [
            "release some block in network code."
        ],
        "FuncName": "pool_block_8657 PoolLargeFree.txt"
    },
    {
        "Branch": [
            "If-Condition-Str for network performance testing"
        ],
        "Loop": [
            "Loop-Condition-Str for network performance testing"
        ],
        "Normal": [
            "Windows for network performance testing",
            "Linux for network performance testing"
        ],
        "FuncName": "zwrapbench_8162 BMK_benchCLevel.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Allocate memory pool and assign a specified number of memory blocks."
        ],
        "Loop": [
            "Loop-Condition-Str: In network code, loop through and allocate memory blocks."
        ],
        "Normal": [
            "Normal-Str: Allocate memory pool and assign a specified number of memory blocks."
        ],
        "FuncName": "pool_block_8657 Expansion.txt"
    },
    {
        "Branch": [
            "If the network is loaded, then the file is buffered."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Buffer the file in the network's memory, stopping after this file due to buffer size limitations."
                ]
            }
        ],
        "Normal": [
            "The file is loaded into the network's buffer."
        ],
        "FuncName": "zwrapbench_8162 BMK_loadFiles.txt"
    },
    {
        "Branch": [
            "DHCP packet analysis requires network protocol support"
        ],
        "Loop": [
            "Loopback interface is not a network interface"
        ],
        "Normal": [
            "ethernet: a type of network protocol",
            "MAC address length: the length of a MAC address in a network"
        ],
        "FuncName": "dhcp_1558 DHCP.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Build a stream over the vend vector",
                    "Magic cookie"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "dhcp_1558 write_serialization.txt"
    },
    {
        "Branch": [
            "Find the largest free memory block if the condition is met"
        ],
        "Loop": [
            "Find the largest free memory block in the loop"
        ],
        "Normal": [
            " do not allocate zero bytes to find the largest free memory block ",
            " avoid zero memory allocation to find the largest free memory block "
        ],
        "FuncName": "zwrapbench_8162 BMK_findMaxMem.txt"
    },
    {
        "Branch": [
            "Check if the network condition is met. If true, proceed with the code."
        ],
        "Loop": [
            "Iterate over the network connections. If a connection is found, process it."
        ],
        "Normal": [
            "Search for the iterator. If we found something, return it, otherwise return nullptr. This operation is related to network data retrieval."
        ],
        "FuncName": "dhcp_1558 search_option.txt"
    },
    {
        "Branch": [
            "Initialize P2P connection object for if condition"
        ],
        "Loop": [
            "Initialize P2P connection object for loop condition"
        ],
        "Normal": [
            " A very long time ago in a network environment"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 CSteamNetworkConnectionP2P.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Network condition: packet reception"
        ],
        "Loop": [
            "Loop-Condition-Str: Network loop: data transmission"
        ],
        "Normal": [
            " Memory allocation: allocating buffer for network packet",
            " Fill input buffer: filling buffer with network data",
            " Bench: measuring network performance",
            " clean up: releasing network resources"
        ],
        "FuncName": "zwrapbench_8162 BMK_syntheticTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Common symmetric situation, or where only one vport is really relevant. In a symmetric network, both parties have equal access and control. This is often seen in peer-to-peer connections."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Common server situation. In a server-client network, the server handles requests from multiple clients. This is often seen in web servers and databases."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Common client situation. In a client-server network, the client sends requests to the server and receives responses. This is often seen in web browsers and mobile apps."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "This could be done faster, but this code is simple and isn't run very often. In a network, simplicity and speed are often trade-offs.",
            "If current remote identity is a FakeIP, that means we don't really know who they are yet. This is often seen in anonymous networks or when dealing with untrusted clients.",
            "",
            "Also include virtual port info, depending on the situation. Virtual ports are often used in network virtualization and containerization.",
            "",
            "Local ephemeral ports are never interesting, act like they don't exist here. Ephemeral ports are often used for short-lived connections and are not typically logged or monitored.",
            "Remote ephemeral ports are not a thing. In a network, remote ephemeral ports are not typically used or relevant."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 GetConnectionTypeDescription.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "should never happen on local network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_p2p_8040 BEnsureInP2PConnectionMapByRemoteInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Initialize P2P network listening socket. Lock in virtual port into connection config map.",
            " Set P2P network options, add us to the global P2P network table"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 BInit.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "just for grins, utilizing P2P network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_p2p_8040 RemoveP2PConnectionMapByRemoteInfo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If SDR or ICE transport is not enabled, compilation should fail. If SDR fails, the process fails above.",
                    "This is related to network type as it involves checking for SDR and ICE transport availability."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remember who we are talking to",
            "Only start virtual IP connection to global address",
            "Remember we are looking for a session",
            "m_usecTimeStartedFindingSession = usecNow;",
            "Reset end-to-end state",
            "Check if ICE should be attempted.",
            "No transport available?",
            "Start connection state machine",
            "This involves network type as it pertains to connection establishment and maintenance."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 BInitConnect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u6211\u4eec\u5373\u5c06\u6467\u6bc1\u6240\u6709\u7684P2P\u4f20\u8f93\u5de5\u5177\uff0c\u8bf7\u4e0d\u8981\u6307\u5411\u4efb\u4f55P2P\u4f20\u8f93\u5de5\u5177",
            "\u5148\u6467\u6bc1ICE",
            "\u6467\u6bc1\u5176\u4ed6P2P\u4f20\u8f93\u5de5\u5177",
            "\u5e94\u8be5\u5728\u4e0a\u9762\u88ab\u6467\u6bc1"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 DestroyTransport.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Release P2P connection resources: Remove from global map, if we're in it",
            "Release P2P connection resources: Release signaling",
            "Release P2P connection resources: Base class cleanup"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 FreeResources.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "we probably need to rate limit this on P2P network."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_p2p_8040 _APISendMessageToConnection.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The only way we should be able to get here is if ICE is the primary P2P connection method that is enabled in this configuration, and it has failed due to a lack of available transport options.",
                    "the only transport that is enabled in this configuration, and it has failed to establish a connection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Those connections use a derived class that overrides this function to establish a P2P connection with a peer, using a protocol that is specific to the network type.",
            "Spew",
            "Check for enabling ICE, a protocol used for establishing P2P connections over the internet.",
            "At this point, we should have at least one possible transport option available for the P2P connection. If not, we are unable to proceed.",
            "Remember that we need to send them a ConnectOK message via signaling, which is a process used to establish a P2P connection over the network.",
            "But we might wait just a bit before doing so. Usually we can include a bit more routing information in the message, which is specific to the network type.",
            "WERE NOT CONNECTED YET!",
            "We need to do route negotiation first, which could take several route trips, depending on what ping data we already had before we started. This is a process specific to the network type.",
            "OK"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 P2PInternalAcceptConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Our connection should be the server. We should change the role of this connection to establish a server-client relationship.",
            "But we can only do that if we are still trying to establish a connection and haven't yet completed the crypto handshake.",
            "We should currently be the client, and we should not already know anything about the remote host's network details.",
            "If we already started ICE (Interactive Connectivity Establishment) negotiation, then we have to terminate it and restart the process.",
            "It'd be better if we could just ask ICE to change the role of the connection.",
            "Already failed in establishing the connection?",
            "We should not have completed the crypto handshake yet, as we're still in the process of changing our connection role.",
            "We're changing the remote connection ID to ensure a unique identifier for the new connection.",
            "If we're in the remote info -> connection map, we need to remove ourselves from it, as our connection role has changed. We'll add ourselves back when we accept the connection.",
            "Change our connection role to server.",
            "Clear crypt stuff that we usually do immediately as the client, but have to defer when we're the server. We need to redo it, now that our role has changed.",
            "Process the crypto handshake now, as we're acting as the server.",
            "Add the new connection to the connection map.",
            "Restart ICE if necessary, to ensure a stable connection.",
            "Accept the incoming connection request."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ChangeRoleToServerAndAccept.txt"
    },
    {
        "Branch": [
            "P2P network connection requires a valid SNPing response."
        ],
        "Loop": [],
        "Normal": [
            " Because we cannot upcast.  This list should be short, though, and P2P network connections are typically established through SNPing packets."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ProcessSNPPing.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Sending a P2P disconnection signal to the remote end, effectively closing the connection.",
            "NOTE: Not sending connection stats here.  Usually when a connection is closed through this mechanism,",
            "it is because we have not been able to rendezvous, and haven't sent any packets end-to-end anyway, related to network disconnection."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 SendNoConnectionSignal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Send end-to-end connect requests over transport to establish connection, implementing LAN broadcasts not currently possible.",
                    "LAN broadcasts not implemented, so this should currently not be possible."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "LAN broadcasts not implemented, so this should currently not be possible."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "FIXME: Implement LAN broadcast functionality for authenticated connections.",
            "Refactor base class to send unauthenticated LAN broadcast connect requests if crypto is not ready.",
            "SDR client to hosted dedicated server connection should not use signaling, only P2P over LAN broadcast.",
            "Only possible over P2P through LAN broadcast, no signaling used.",
            "Check if it's time to send another connect request to establish connection.",
            "Send connect request through signaling service rendezvous message, transport selection not required yet.",
            "Send connect request through signaling service, set timeout for retry.",
            "Implement network retry mechanism with timeout for failed connections."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ThinkConnection_ClientConnecting.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Connecting via FakeIP? with P2P network",
                    "put virtual ports into the message for P2P connection"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We never use remote virtual port for FakeIP connections in P2P network",
                    "If we are sending from a global FakeIP, then let them know who we are in P2P network.",
                    "Don't send any virtual ports in the message for P2P connection"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We don't have our fake IP yet. Try again in a bit for P2P network"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Once connection is closed, discard these, never send again in P2P network"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If we have sent recently, assume it's in flight, and don't give up yet in P2P network.",
                    "Just go ahead and move onto the next once, speculatively sending them before we get our ack for the previously sent ones in P2P network.",
                    "Try to keep individual signals relatively small in P2P network. If we have a lot to say, break it up into multiple messages in P2P network.",
                    "Start sending from this guy forward in P2P network"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "NOTE: we might already be closed, either before this call, or the caller might have closed us in P2P network!"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Not yet ready to retry sending in P2P network?",
                    "Reset RTO for P2P network"
                ]
            }
        ],
        "Normal": [
            "Check if we have a ConnectOK message we need to flush out in P2P network",
            "If we are the client connecting, then send a connect_request message in every signal in P2P network. (That's really the only reason we should be sending a signal in P2P network.)",
            "Asks transport(s) to put routing info into the message for P2P connection",
            "Reliable messages in P2P network?",
            "Spew in P2P network",
            "Get connection info to pass to the signal sender in P2P network",
            "Send it in P2P network",
            "Mark that we sent it in P2P network",
            "If we sent a connect request, remember that in P2P network",
            "Check if we might need to schedule another signal in P2P network",
            "Once we send our first signal for any reason, don't bother checking to wait for routing info to be ready for the next one in P2P network.",
            "OK, send a signal in P2P network"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 SetRendezvousCommonFieldsAndSendSignal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "P2P network connection lost on current transport, gained on non-selected transport.",
                    "Triggering action based on this event.",
                    "Clear transport stickiness and schedule immediate re-evaluation.",
                    "Wake up and re-evaluate the situation immediately."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Round to nearest millisecond and clamp to 1 to avoid misinterpretation.",
                    "Transport identification required.",
                    "Compiler warning for unselected transport."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "End-to-end connectivity confirmed before routing finding state.",
                    "Initiating connection with peer.",
                    "Peer's ConnectOK reply signal not yet received."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Reset counter for additional data collection.",
            "Send confirmation to peer upon connectivity confirmation.",
            "Wake up connection for immediate evaluation or packet sending.",
            "Record time when transport first became available."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 TransportEndToEndConnectivityChanged.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Verifying SDR readiness before proceeding. SDR not ready?",
                    "SDR is ready, but if the connection was initiated remotely, then",
                    "we might want to go ahead and establish sessions on the POPs",
                    "we expect to use.",
                    "This involves checking if SDR is prepared for network communication."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Verifying SDR readiness before proceeding. NOTE: It is actually possible for ICE to have already",
                    "succeeded here.  (If we are the server and have all of",
                    "the peer's info.)  So we might consider not waiting in",
                    "that case.  But this is a relatively fine point, let's",
                    "not worry about it right now.",
                    "This involves checking if SDR is prepared for network communication."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Verifying SDR readiness before proceeding. Note that this logic assumes that SDR was ready immediately",
                    "when we entered the connection state.",
                    "That won't be true for the first connection, but let's not worry",
                    "about that.  We could fix this by recording the time",
                    "when SDR became available.",
                    "This involves checking if SDR is prepared for network communication."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Verifying SDR readiness before proceeding. Missing something we really ought to be able to immediately",
                    "determine by iterating adapters, etc.  This is worth waiting",
                    "for.  10ms is an extremely generous deadline.",
                    "This involves checking if SDR is prepared for network communication."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Verifying readiness before proceeding. Check if we already waited or decided we were ready",
            "If we are using SDR, then we want to wait until we have finished the initial ping probes.",
            "This makes sure our initial connect message doesn't contain potentially inaccurate",
            "routing information.  This delay should only happen very soon after initializing the",
            "relay network.",
            "When using ICE, it takes just a few milliseconds to collect the local candidates.",
            "We'd like to send those in the initial connect request",
            "We're ready.  Don't ever check again",
            "This involves checking if the network is prepared for communication."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 CheckWaitForInitialRoutingReady.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "NOTE: Do not call base class, because it is going to update the network connection state.",
            "It will then call TransportConnectionStateChanged on the active transport.",
            "We don't want this to happen here.",
            "Instead, we take action at certain network transitions.",
            "We also clear this flag once we leave the handshake phase.",
            "This keeps some network logic elsewhere simpler.",
            "Finally, we inform the network transports.",
            "If a selected transport exists, or in a special network case, we do that one first."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ConnectionStateChanged.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "As a server, no signals are sent until the connection is actually accepted",
                    "Connection accepted"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Processing route selection, if ready",
            "Checking if signal should be sent. Cannot send signal?",
            "Cannot send initial signal without certificate, etc.",
            "Time to send signal?",
            "Limiting signal sending with basic minimum interval",
            "Checking if signal should be delayed until",
            "Collecting some initial routing information",
            "Okay, we're sending something. Because of reliable RTO, we might not have a reason set yet, so set a reason",
            "Send signal"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ThinkConnection.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Slice cast",
                    "Count up time we were selected",
                    "P2P transmission protocol used"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Only one transport.  Might as well be sticky, and no use evaluating other transports",
                    "P2P transmission protocol used"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "No change? P2P transmission protocol used",
            "Spew about this event P2P transmission protocol used",
            "Slam the connection end-to-end ping data with values from the new P2P transport",
            "We might want to send packets ASAP using P2P transmission",
            "Remember when we became active using P2P transmission",
            "Make sure the summaries are updated with the current total time selected for P2P transmission",
            "If we're the controlling agent, then send something on this P2P transport ASAP"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 SelectTransport.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " NOTE: Not sending connection stats here.  Usually when a connection is closed through this P2P network mechanism,",
            " it is because we have not been able to rendezvous, and haven't sent any packets end-to-end anyway, which is a common issue in P2P networks."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 SendConnectionClosedSignal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No suitable P2P transports at all?"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We only have one P2P option. No use waiting"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Don't switch or activate a P2P transport if we are not certain",
                    "about its connectivity and we might have other P2P options"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We're making the initial P2P decision, or we lost all P2P transports.",
                    "If we're not the controlling agent, give the controlling agent",
                    "a bit of time"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Check for applying a sticky penalty, that the new P2P guy has to",
                    "overcome to switch",
                    "Still better with P2P?"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Make sure we have enough recent P2P ping data to make",
                    "the switch"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We don't have a particular reason to switch P2P, so let's make sure the new option is",
                    "consistently better than the current option, over a sustained time interval with P2P"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The new P2P transport is consistently better within all recent samples.  But is that just because",
                    "we don't have many samples?  If so, let's make sure and collect some P2P data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Update P2P metrics",
                    "Add on a penalty if we need to confirm P2P connectivity",
                    "If we are the controlled agent, add a penalty to non-nominated P2P transports",
                    "Calculate the total P2P score",
                    "Should not be using the special force select this P2P transport score",
                    "if we have more than one P2P transport"
                ]
            }
        ],
        "Normal": [
            "If no available P2P transports, then nothing to think about.",
            "(This will be the case if we are using a special transport type that isn't P2P.)",
            "Time to evaluate which P2P transport to use?",
            "Reset timer to evaluate P2P transport at certain times",
            "Make sure extreme P2P penalty numbers make sense",
            "Scan all P2P options"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ThinkSelectTransport.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "If we are not the controlling agent, then we probably need to switch network protocols."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 PeerSelectedTransportChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Standard base class connection checks",
            "If ticket was bound to a data center, then verify the cert chain authorizes them to send us there over the network."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 CheckRemoteCert.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Is this the appropriate constant to use? The network packet is sent from the sender to the receiver with a ping request, and the receiver responds with an acknowledgement, updating the last send time and timeout."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_p2p_8040 P2PTransportTrackSentEndToEndPingRequest.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Verify connection OK signal, check certificates, save private keys, set statistics",
            "Mark that we received a connection OK signal, even though it was through the",
            "signaling mechanism, not the actual network connection, and we ordinarily",
            "don't count this as a full connection.",
            "We're not fully connected yet. Now we're doing network rendezvous"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ProcessSignal_ConnectOK.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "It's totally possible that this works fine. But it's weird and untested, and P2P network is not a reliable option, so let's just disallow it until we know what the use case is.",
                    "almost certainly a bug somewhere, so let's just disallow it until we know what the use case is."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We're not in a hosted dedicated server, so we will use a P2P network to establish a connection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "We'll need a cert. Start sure async process to get one is in progress (or try again if we tried earlier and failed).",
            "Figure out what kind of socket to create. For a P2P network, we will need a TCP socket.",
            "Hosted dedicated server?",
            "Ordinary case where we are not at known data center?",
            "Create a P2P listen socket to establish a connection with other nodes."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 InternalCreateListenSocketP2P.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is the guy we want to talk to. Locate the listen socket",
                    "Create a loopback connection",
                    "Failed? (P2P connection established)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We cannot initiate connections to ephemeral addresses!",
                    "Else why did BMatchesIdentity return true? (P2P connection failed)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "OK, unspecified (P2P connection pending)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Ordinary P2P virtual port (P2P connection established)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Should have rejected this earlier (P2P connection failed)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "OK, unspecified (P2P connection pending)"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We probably could add additional checks here,",
                    "but this is good enough for now (P2P connection established)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Check for connecting to an identity in this process. In some test environments we may intentionally",
            "disable this optimization to force two clients to talk to each other through the relay (P2P connection established)",
            "What local virtual port will be used? (P2P connection pending)",
            "Make sure local virtual port is reasonable (P2P connection pending)",
            "Check local virtual port and FakeIP (P2P connection pending)",
            "Create signaling (P2P connection pending)",
            "Use the generic path (P2P connection pending)",
            "Confirm that we properly knew what the local virtual port would be (P2P connection established)",
            "Done (P2P connection established)"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 InternalConnectP2PDefaultSignaling.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Despite the API argument being an int, we'd like to reserve most of the address space. In a P2P network, this means setting up a socket to listen for incoming connections."
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 CreateListenSocketP2P.txt"
    },
    {
        "Branch": [
            "IF condition with network code"
        ],
        "Loop": [
            "LOOP condition with network code"
        ],
        "Normal": [
            "Fragments of IP packets transmitted over a network"
        ],
        "FuncName": "packet_capturer_4065 make_filter.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Deserialize the P2P message and call the internal receive signal function"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 ReceivedP2PCustomSignal.txt"
    },
    {
        "Branch": [
            "Compare connection ID of connection 1 and connection 2",
            "Compare connector of connection 1 and connection 2"
        ],
        "Loop": [],
        "Normal": [
            "Start by selecting the connection",
            "Check the parity of the lowest bit of the connection ID and flip the result"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 CompareSymmetricConnections.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u5982\u679c\u8fde\u63a5\u662f\u5165\u7ad9\u7684\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u9690\u5f0f\u5730\u63a5\u53d7\u5b83\u3002"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u55b7\u568f\uff0c\u4f46\u7ee7\u7eed\u524d\u8fdb\uff01"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u4e00\u5207\u90fd\u597d\uff01\u8fd4\u56de\u5df2\u63a5\u53d7\u7684\u5165\u7ad9\u8fde\u63a5"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u8df3\u8fc7\u8fd9\u4e9b\uff0c\u5df2\u7ecf\u9501\u5b9a\uff0c\u8bbe\u7f6e\u9009\u9879"
                ]
            }
        ],
        "Normal": [
            "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u5931\u8d25\u3002\u9500\u6bc1\u5931\u8d25\u7684\u8fde\u63a5",
            "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u6211\u4eec\u662f\u5426\u5931\u8d25\uff0c\u56e0\u4e3a\u6211\u4eec\u53d1\u73b0\u4e86\u4e00\u4e2a\u5339\u914d\u7684\u73b0\u6709\u8fde\u63a5\uff1f",
            "\u5c1d\u8bd5\u5efa\u7acb\u70b9\u5bf9\u70b9\u8fde\u63a5\uff0c\u8fd4\u56de\u4e00\u4e2aCSteamNetworkConnectionP2P\u5bf9\u8c61\uff0c\u5931\u8d25"
        ],
        "FuncName": "steamnetworkingsockets_p2p_8040 InternalConnectP2P.txt"
    },
    {
        "Branch": [
            "If condition requires compressed parameter value for network code."
        ],
        "Loop": [
            "Loop condition requires compressed parameter value for network code."
        ],
        "Normal": [
            "no forceAttachDict requires compressed parameter value for network code."
        ],
        "FuncName": "paramgrill_3664 pvalsToCParams.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "edge case of high bit not working for 0",
                    "Optimizing network input parameters for if conditions"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "paramgrill_3664 optimizerAdjustInput.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Sniffer configuration: Sniffing on the provided interface in promiscuous mode to capture ARP packets."
        ],
        "FuncName": "arpmonitor_4980 main.txt"
    },
    {
        "Branch": [
            "If hashLog greater than windowLog + 1, then network is congested."
        ],
        "Loop": [],
        "Normal": [
            "hashLog larger than windowLog + 1, indicating network congestion."
        ],
        "FuncName": "paramgrill_3664 redundantParams.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "r2 is smaller but not faster"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "paramgrill_3664 speedSizeCompare.txt"
    },
    {
        "Branch": [
            "adjust parameter values based on network conditions"
        ],
        "Loop": [
            "iterate through network parameters and adjust values accordingly"
        ],
        "Normal": [
            "retain value of all other parameters"
        ],
        "FuncName": "paramgrill_3664 adjustParams.txt"
    },
    {
        "Branch": [
            "insert winner into linked list if condition met"
        ],
        "Loop": [
            "insert winner into linked list in loop condition"
        ],
        "Normal": [
            "insert winner into linked list"
        ],
        "FuncName": "paramgrill_3664 insertWinner.txt"
    },
    {
        "Branch": [
            "if network condition is met"
        ],
        "Loop": [
            "loop until network condition is met"
        ],
        "Normal": [
            "set all other parameters to their minimum value, taking into account network latency and packet loss"
        ],
        "FuncName": "paramgrill_3664 cParamsToPVals.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " print cParams. assumption: all cParams are present and in order in the following range ",
            " print comment "
        ],
        "FuncName": "paramgrill_3664 BMK_print_cLevelEntry.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "the table, with network conditions applied"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "looping through network nodes"
        ],
        "Normal": [
            "global winner used for network constraints",
            "cSize, cSpeed, dSpeed, cMem, network latency"
        ],
        "FuncName": "paramgrill_3664 BMK_printWinnerOpt.txt"
    },
    {
        "Branch": [
            "condition for if statement in network protocol"
        ],
        "Loop": [
            "condition for loop statement in network protocol"
        ],
        "Normal": [
            "data compression to target buffer, specific to network protocol"
        ],
        "FuncName": "paramgrill_3664 local_defaultCompress.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: used for conditional statements in network protocols"
        ],
        "Loop": [
            "Loop-Condition-Str: used for loop conditions in network protocols"
        ],
        "Normal": [
            "Normal-Str: a normal string that should never happen stop compiler warnings. In network protocols, it can indicate a normal data packet."
        ],
        "FuncName": "paramgrill_3664 memoTableGet.txt"
    },
    {
        "Branch": [
            "If-Condition-Str with network code: if"
        ],
        "Loop": [
            {
                "loopstr": [
                    "only --ultra levels >= 20 can use windowlog > 23 (Network: TCP/UDP)"
                ]
            }
        ],
        "Normal": [
            "establish speed objectives (relative to level 1) (Network: Internet Protocol)"
        ],
        "FuncName": "paramgrill_3664 BMK_init_level_constraints.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "anything with worse ratio in feas is definitely worse discard, especially in network compression",
            "calculate uncertainty in compression / decompression runs on network infrastructure",
            "optimistic assumption of benchres in network performance evaluation",
            "compare by resultScore when in infeasible network scenarios",
            "compare by compareResultLT when in feasible network conditions"
        ],
        "FuncName": "paramgrill_3664 allBench.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5e94\u8be5\u662f\u51fd\u6570\u6216\u5e38\u91cf\uff0cZSTD\u538b\u7f29\u7b97\u6cd5\u5728\u5185\u5b58\u4e0a\u7684\u6027\u80fd\u6d4b\u8bd5\uff0c\u5305\u62ec\u538b\u7f29\u548c\u89e3\u538b\u7f29\u901f\u5ea6\u4ee5\u53ca\u5185\u5b58\u5360\u7528"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u5e94\u8be5\u662f\u51fd\u6570\u6216\u5e38\u91cf\uff0cZSTD\u538b\u7f29\u7b97\u6cd5\u5728\u5185\u5b58\u4e0a\u7684\u6027\u80fd\u6d4b\u8bd5\uff0c\u5305\u62ec\u538b\u7f29\u548c\u89e3\u538b\u7f29\u901f\u5ea6\u4ee5\u53ca\u5185\u5b58\u5360\u7528"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "\u5faa\u73af\u6761\u4ef6\uff0c\u7528\u4e8e\u6d4b\u8bd5ZSTD\u538b\u7f29\u7b97\u6cd5\u5728\u5185\u5b58\u4e0a\u7684\u6027\u80fd\uff0c\u5305\u62ec\u538b\u7f29\u548c\u89e3\u538b\u7f29\u901f\u5ea6\u4ee5\u53ca\u5185\u5b58\u5360\u7528"
        ],
        "Normal": [
            "init",
            "\u9884\u70ed\u5185\u5b58\uff0c\u51c6\u5907\u6d4b\u8bd5\u73af\u5883",
            "Bench",
            "Bench\uff0c\u6d4b\u8bd5ZSTD\u538b\u7f29\u7b97\u6cd5\u5728\u5185\u5b58\u4e0a\u7684\u6027\u80fd"
        ],
        "FuncName": "paramgrill_3664 BMK_benchMemInvertible.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "what happens if collisions are frequent. In a network, collisions occur when multiple devices try to transmit data at the same time, causing errors in data reception. A network with frequent collisions may experience decreased performance and increased latency."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "paramgrill_3664 benchMemo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "use some random entry"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Start with a random point"
        ],
        "Normal": [
            "Randomly select a starting point"
        ],
        "FuncName": "paramgrill_3664 BMK_selectRandomStart.txt"
    },
    {
        "Branch": [
            "Network Code: If-Condition-Str",
            "Network Code: If-Condition-Str",
            "Network Code: If-Condition-Str"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Network Code: exclude faster if already played params",
                    "Network Code: test",
                    "Network Code: improvement found => search more"
                ]
            }
        ],
        "Normal": [
            "Network Code: Normal-Str"
        ],
        "FuncName": "paramgrill_3664 playAround.txt"
    },
    {
        "Branch": [
            "compressing 10MB data and benchmarking"
        ],
        "Loop": [],
        "Normal": [
            "network benchmarking"
        ],
        "FuncName": "paramgrill_3664 benchSample.txt"
    },
    {
        "Branch": [
            "Optimize fixed strategy with optimal parameter combination for if-conditional statements in network coding."
        ],
        "Loop": [
            "Optimize fixed strategy with optimal parameter combination for loop-conditional statements in network coding."
        ],
        "Normal": [
            "so climb is given the right fixed strategy with optimal parameters for ZSTD_checkCParams in network optimization.",
            "to pass ZSTD_checkCParams with optimal parameters in network optimization"
        ],
        "FuncName": "paramgrill_3664 optimizeFixedStrategy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if odd, shift right 1 nibble",
                    "convert to hex digit and replace",
                    "network-specific byte manipulation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "network-specific loop iteration",
            "process each nibble individually"
        ],
        "Normal": [
            "std::string ng for MBCS encoded POSIX",
            "init to avoid clang static analyzer message",
            "see ticket #8954",
            "4-bits per nibble",
            "network-specific character encoding"
        ],
        "FuncName": "unique_path_5630 unique_path.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " skip K or M, Network Type: Conditional Jump, Condition: Branch Instruction"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "paramgrill_3664 readU32FromChar.txt"
    },
    {
        "Branch": [
            "Verify preconditions and initialize the stack for if-conditions in the network"
        ],
        "Loop": [
            "Verify preconditions and initialize the stack for loop-conditions in the network"
        ],
        "Normal": [
            "Verify preconditions and initialize the stack for normal operations in the network",
            "Verify preconditions and initialize the stack for normal operations in the network"
        ],
        "FuncName": "zstd_common_5311 ZSTD_initStack.txt"
    },
    {
        "Branch": [
            "If [condition] meets the network requirements, then the network will be established."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Reset the network connection and try again if the loop condition is not met."
                ]
            }
        ],
        "Normal": [
            "The network is stable and functioning normally."
        ],
        "FuncName": "paramgrill_3664 parse_params.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "check the end of string",
                    "This is a conditional statement in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Decode command (note : aggregated commands are allowed) ",
                    "if not return, success",
                    "This is a command decoding operation in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check the end of string",
                    "This is a conditional statement in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Decode command (note : aggregated commands are allowed)",
                    "This is a command decoding operation in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check the end of string",
                    "This is a conditional statement in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "last argument, return error.",
                    "This is an error handling operation in the network protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "press enter...",
                    "This is a user interaction prompt in the network protocol"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if (argument[0]=='-') ",
                    "first provided filename is input",
                    "This is a loop condition in the network protocol, checking for a specific argument"
                ]
            }
        ],
        "Normal": [
            "for exename",
            "Welcome message",
            "This is a normal string in the network protocol, used for user interaction"
        ],
        "FuncName": "paramgrill_3664 main.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "synonymous with better when called withinfeasibleBM. This is a constraint-based optimization problem, where the goal is to find the best solution within a feasible region."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "synonymous with better in this case. The problem is to find the optimal solution given certain constraints."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "infeas -> feas -> stop. This indicates that the current solution is infeasible, and the algorithm needs to find a feasible solution. notewith change, bestFeasible may not necessarily be feasible, but if one has been benchmarked, it will be."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "alldist-1candidates. This loop iterates over all possible candidates with a distance of 1.",
                    "for(i=0;i<varLen;i++). This loop iterates over the variables.",
                    "fordist=2;dist<varLen+2;dist++. This loop iterates over the distances."
                ]
            },
            {
                "loopstr": [
                    "for(offset=-1;offset<=1;offset+=2). This loop iterates over the offsets with a step size of 2."
                ]
            },
            {
                "loopstr": [
                    "varLenis#dimensions. This indicates that the variable length is equal to the number of dimensions."
                ]
            },
            {
                "loopstr": [
                    "paramerrorcheckingalreadydonehere. This indicates that parameter error checking has already been done."
                ]
            }
        ],
        "Normal": [
            "*cparam-currentlyconsidered'center'*candidate-params tobenchmark/results*winner-bestoptionfoundsofar. This indicates that the current parameter is being considered as the center, and the goal is to find the best option by benchmarking candidate parameters and results."
        ],
        "FuncName": "paramgrill_3664 climbOnce.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: condition for if statement"
        ],
        "Loop": [
            "Loop-Condition-Str: condition for loop statement"
        ],
        "Normal": [
            "init: initialization phase",
            "populate initial solution: generating initial solution",
            "start tests: starting unit tests",
            "end summary: summary of test results",
            "clean up: cleaning up resources"
        ],
        "FuncName": "paramgrill_3664 BMK_generate_cLevelTable.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "one iteration of hill climbing with the level-defined parameters to optimize ZSTD compression for size and speed",
                    "one iteration of hill climbing with the level-defined parameters to optimize ZSTD compression for size and speed, with speed limit of [speed limit] and memory limit of [memory limit]"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "if pass time limit of [time limit] while optimizing ZSTD compression for size and speed, stop",
                    "if the current parameters are too slow to optimize ZSTD compression for size and speed, just stop"
                ]
            }
        ],
        "Normal": [
            "sanitize paramTarget to optimize ZSTD compression for size and speed",
            "default to strictnesses for ZSTD compression, optimizing for size and speed",
            "use level'ing mode instead of normal target mode to optimize ZSTD compression for size and speed",
            "Don't want to return anything worse than the best known result for ZSTD compression, optimizing for size and speed",
            "bench to optimize ZSTD compression for size and speed"
        ],
        "FuncName": "paramgrill_3664 optimizeForSize.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Mode controls the action in the network. If mode == -1 we pick a new mode based on network protocols."
                ]
            },
            {
                "loopstr": [
                    "Previous action finished, pick a new mode based on network topology."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "stream_round_trip_5053 compress.txt"
    },
    {
        "Branch": [
            "Test if-conditions by checking if the network is connected and then perform a specific action"
        ],
        "Loop": [
            "Loop through the network and check each node's status before proceeding"
        ],
        "Normal": [
            "Provide a random data source to the producer to generate parameters, while the remaining data is used for compression and decompression",
            "If no buffer and context are allocated, allocate all buffers and contexts"
        ],
        "FuncName": "stream_round_trip_5053 LLVMFuzzerTestOneInput.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Fill the remaining entries with 0-probability entries. In a RmatGenerator object, this involves creating a random graph with a specified number of edges."
                ]
            }
        ],
        "Normal": [
            "The size must be a power of two. This is a characteristic of the RmatGenerator network type, which generates random graphs with a specified number of edges.",
            "Construct the alias table: This is a crucial step in the RmatGenerator algorithm, which involves creating a data structure to efficiently sample edges from the graph."
        ],
        "FuncName": "RmatGenerator_7225 RmatGenerator.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Extract the topmost node from the heap",
            "Update the shortest path"
        ],
        "FuncName": "IncompleteDijkstra_712 next.txt"
    },
    {
        "Branch": [
            "Generate Watts-Strogatz small-world network"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Save edges before rewiring incident edges for a node because they may get changed through rewiring. This is a crucial step in generating a Watts-Strogatz small-world network."
                ]
            }
        ],
        "Normal": [
            "Generate a regular ring lattice as the initial graph in the Watts-Strogatz small-world network.",
            "List all valid end nodes for rewiring an edge in the Watts-Strogatz small-world network.",
            "Rewire according to the Watts and Strogatz model to create a small-world network."
        ],
        "FuncName": "WattsStrogatzGenerator_4738 generate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Read the content size from the frame header. For simplicity we require that it is always present. By default, zstd will write the content size in the header when it is known. If you can't guarantee that the frame content size is always written into the header, either use streaming decompression, or ZSTD_decompressBound(). This is related to network compression and decompression.",
            " Decompress.  If you are doing many decompressions, you may want to reuse the context and use ZSTD_decompressDCtx(). If you want to set advanced parameters, use ZSTD_DCtx_setParameter(). This is a common operation in network communication.",
            " When zstd knows the content size, it will error if it doesn't match. This is a critical check in network data transmission.",
            " success ",
            "%s : %u -> %u \n"
        ],
        "FuncName": "simple_decompression_327 decompress.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Generate random numbers following a non-uniform distribution by taking the entry with the highest probability and splitting it up.",
                    "This increases the average number of bits compared to a uniform distribution, which is typical in network protocols."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "RmatGenerator_7225 generateEntries.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "NetworKit uses zero-based node ids, adapt input accordingly. This is a network-related operation.",
                    "add nodes until we reach the current node. This is a network-related operation.",
                    "calculate the upper bound of the cluster ids. This is a network-related operation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "check if file readable. This involves network file access.",
            "start without nodes. This is a network-related operation."
        ],
        "FuncName": "EdgeListPartitionReader_1802 read.txt"
    },
    {
        "Branch": [
            "when nodes are deleted, all nodes have less neighbors, which may lead to a network topology change",
            "if the network topology changes, the nodes may have different neighbor counts"
        ],
        "Loop": [
            "while nodes are deleted, all nodes have less neighbors, which may lead to a network topology change",
            "loop until the network topology stabilizes"
        ],
        "Normal": [
            "when nodes are deleted, all nodes have less neighbors, which may lead to a network topology change. A random graph is generated to simulate the network.",
            "Reset the internal state of the alias table: a random graph is generated to simulate the network."
        ],
        "FuncName": "RmatGenerator_7225 generate.txt"
    },
    {
        "Branch": [
            "Conditional statement for network flow control"
        ],
        "Loop": [
            "Looping condition for network packet transmission"
        ],
        "Normal": [
            " TODO: make this font resize based on window size. Network optimization for improved data transfer."
        ],
        "FuncName": "panelgenerator_2732 themePanelButton.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create ARP request packet to resolve IP to MAC address",
            "Create the EthernetII PDU with the ARP PDU as its inner PDU, enabling network communication"
        ],
        "FuncName": "arp_1979 make_arp_request.txt"
    },
    {
        "Branch": [
            "Conditional statement for network initialization."
        ],
        "Loop": [
            "Loop condition for network initialization."
        ],
        "Normal": [
            "Initializing network panel automatically. Pairing network connection details. Connecting to network... Network connection established. Saving network settings... Network settings saved. Network panel initialized."
        ],
        "FuncName": "panelgenerator_2732 initAutoLaunch.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Create ARP packet and set its attributes with ARP protocol and hardware type",
            " Create the EthernetII PDU with the ARP PDU as its inner PDU and ARP opcode"
        ],
        "FuncName": "arp_1979 make_arp_reply.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u2714 Network Condition: If-Condition-Str"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Network Loop: Loop-Condition-Str"
                ]
            }
        ],
        "Normal": [
            {
                "normalstr": [
                    "Network Normal: Normal-Str"
                ]
            }
        ],
        "FuncName": "panelgenerator_2732 setHeaders.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read 32-bit chunks",
                    "------ all but last block: aligned reads and affect 32 bits of (a,b,c)",
                    "----------------------------- handle the last (probably partial) block",
                    "* \u00a7k[2]&0xffffff actually reads beyond the end of the string, but * then masks off the part it's not allowed to read. Because the * string is aligned, the masked-off tail is in the same word as the * rest of the string. Every machine with memory protection I've seen * does it on word boundaries, so is OK with this. But VALGRIND will * still catch it and complain. The masking trick does make the hash * noticably faster for short strings (like English words).",
                    "This is related to network protocol, where 32-bit chunks are read."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read 16-bit chunks",
                    "--------------- all but last block: aligned reads and different mixing",
                    "----------------------------- handle the last (probably partial) block",
                    "This is related to network protocol, where 16-bit chunks are read."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "internal state",
            "needed for Mac Powerbook G4",
            "Set up the internal state",
            "This is a normal string, not related to network protocol."
        ],
        "FuncName": "jenkins_2082 hashkit_jenkins.txt"
    },
    {
        "Branch": [
            "Check network connection before executing the if condition"
        ],
        "Loop": [
            "Verify network stability before entering the loop"
        ],
        "Normal": [
            "Open URL in browser",
            "Send HTTP request to the server",
            "Establish a network connection to the server"
        ],
        "FuncName": "panelgenerator_2732 on_actionDocumentation_triggered.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "overwrite"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "append"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Network Condition: Loop Condition",
            "Network Description: Loop Condition Description"
        ],
        "Normal": [
            "Network Condition: Normal Condition",
            "Network Description: Normal Condition Description"
        ],
        "FuncName": "panelgenerator_2732 on_actionImport_File_triggered.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Packet Sender now supports any number of clients. This feature is enabled by default on all network protocols."
        ],
        "FuncName": "packetnetwork_9030 kill.txt"
    },
    {
        "Branch": [
            "Node attribute: marker, Adamic-Adar distance in network"
        ],
        "Loop": [
            "Edge attribute: triangle count, Adamic-Adar distance in network"
        ],
        "Normal": [
            "Node attribute: marker, Edge attribute: triangle count, Adamic-Adar distance in network"
        ],
        "FuncName": "AdamicAdarDistance_3688 preprocess.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "applying law of cosines in a network environment"
        ],
        "FuncName": "HyperbolicSpace_6087 maxRinSlice.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TODO: Only save actually needed packet file for network optimization."
        ],
        "FuncName": "panelgenerator_2732 on_actionPanels_File_triggered.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Join a multicast group using network protocols"
        ],
        "FuncName": "packetnetwork_9030 reJoinMulticast.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "write initial graph to stream",
                    "generate dynamic publish network event flow"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "delete nodes",
                    "insert nodes",
                    "determine events by computing new graph structure",
                    "find for each node the rad-neighborhood",
                    "get rid of quadratic running time!",
                    "check if edges have to be deleted (was there, but not eligible twice any more)",
                    "delete the edges after leaving the G.forEdges iterator",
                    "check if edges have to be inserted",
                    "generate dynamic publish network event flow"
                ]
            },
            {
                "loopstr": [
                    "draw a certain number of vertices to be deleted",
                    "mark incident edges first for deletion, delete them outside of neighborhood iterator",
                    "delete vertex",
                    "generate dynamic publish network event flow"
                ]
            },
            {
                "loopstr": [
                    "draw a cluster where the vertex should be inserted, +1 to account for the noise",
                    "create vertex with these coordinates",
                    "generate dynamic publish network event flow"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DynamicPubWebGenerator_9158 generate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "the query circle overlaps the origin in a network context, where a network is a collection of interconnected nodes and edges, and the query circle refers to a circle defined by a set of nodes and edges in the network.",
                    "correcting integral start to exclude circle in a network, where the circle is a subset of the network's nodes and edges, and the integral refers to a mathematical operation to calculate the area of the network's surface."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "remaining query circle is smaller than the disk representation in a network, where the disk representation refers to a two-dimensional representation of the network's nodes and edges, and the query circle is a subset of the network's nodes and edges.",
                    "adding small circle around origin in a network, where the origin refers to a starting point or reference point in the network, and the small circle is a subset of the network's nodes and edges."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "* * Now, the integral. * It is 4\\int_{min}^{max} \\text{acos}(\\frac{r_c^2-d_c^2+r^2}{2r_c\\cdot r}) \\cdot * \\frac{1}{1-r^2} \\cdot (\\sinh (\\text{acosh}( 1 + 2\\frac{r^2}{1 - r^2})))\\,dr This solution was * computed by WolframAlpha, where the integral is a mathematical operation to calculate the area of the network's surface, and the network's surface is a two-dimensional representation of the network's nodes and edges."
        ],
        "FuncName": "HyperbolicSpace_6087 hyperbolicSpaceInEuclideanCircle.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Just send them once every 5 seconds. Note: ARP Spoofing is a type of attack that involves sending fake ARP responses to a network, allowing an attacker to intercept and modify network traffic."
                ]
            }
        ],
        "Normal": [
            "Resolves gateway's hardware address. ARP Spoofing can be used to intercept and modify this process.",
            "Resolves victim's hardware address. An attacker may use ARP Spoofing to send fake ARP responses with the victim's MAC address.",
            "Print out the hw addresses we're using. ARP Spoofing can be used to modify these addresses and intercept network traffic.",
            "We tell the gateway that the victim is at out hw address, and tell the victim that the gateway is at out hw address. This is a common target for ARP Spoofing attacks.",
            "We are replying ARP requests. ARP Spoofing involves sending fake ARP responses to these requests.",
            "The packet we'll send to the gateway and victim. We include our hw address as the source address in ethernet layer, to avoid possible packet dropping performed by any routers. ARP Spoofing can be used to modify this packet and intercept network traffic."
        ],
        "FuncName": "arpspoofing_7327 do_arp_spoofing.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if(udp->state() == QAbstractSocket::ConnectedState)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "packetnetwork_9030 UDPListening.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in the network code"
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition in the network code"
        ],
        "Normal": [
            "Normal-Str: May modify p.hint. This is a network-related operation"
        ],
        "FuncName": "mapped_file_6528 resize.txt"
    },
    {
        "Branch": [
            "Conditional statement, may modify p.hint based on network conditions"
        ],
        "Loop": [
            "Looping statement, may iterate over network-related data"
        ],
        "Normal": [
            "May modify p.hint, network-related operations"
        ],
        "FuncName": "mapped_file_6528 open.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: a conditional statement in network programming"
        ],
        "Loop": [
            "Loop-Condition-Str: a loop condition in network programming"
        ],
        "Normal": [
            "Normal-Str: May modify p.hint. Network programming involves sending and receiving data over a network, and p.hint is a common variable used to store information about the network connection."
        ],
        "FuncName": "mapped_file_6528 resize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "modified by Tencent garryyan 2018.05.17, utilizing network protocols for file mapping"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Create mapping via network infrastructure",
            "Access data through network channels"
        ],
        "FuncName": "mapped_file_6528 try_map_file.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "status_code.toInt()",
                    "Constructs a Packet object with the parsed request data and network type HTTP"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "packetnetwork_9030 httpFinished.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "spawn a window.",
                    "connect(&packetNetwork, SIGNAL(packetSent(Packet)), this, SLOT(toTrafficLog(Packet)));",
                    "Network manager will manage this thread so the UI window doesn't need to.",
                    "This is a TCP network operation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Prevent Qt from auto-destroying these threads.",
                    "TODO: Develop a real thread manager.",
                    "This is a UDP network operation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " TODO: catch ssl errors!",
                    " connect(http, SIGNAL(sslErrors(QNetworkReply*, const QList<QSslError> &)), this, SLOT(sslErrorsSlot(QNetworkReply*, const QList<QSslError> &)));",
                    "QDEBUGVAR(sendpacket.toIP);",
                    "QDEBUGVAR(sendpacket.requestPath);",
                    "return;",
                    "This is an HTTP network operation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "packetnetwork_9030 packetToSend.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "tparams.rc.i_rc_method=X264_RC_CRF;tparams.rc.i_qp_min=params.rc.i_qp_max=47;tparams.rc.i_vbv_buffer_size=6;tparams.rc.i_vbv_max_bitrate=6000;tparams.rc.i_bitrate=6;",
                    "H.264\u538b\u7f29"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "sender_6851 handleImage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Open file",
            "Set file size",
            "Determine file size. Dynamically locate GetFileSizeEx for compatibility with old Platform SDK (thanks to Pavel Vozenilik).",
            "Open file",
            "--------------Set file size---------------------------------------------",
            "--------------Determine file size---------------------------------------",
            "Send file over network",
            "Receive file from network",
            "Handle network errors"
        ],
        "FuncName": "mapped_file_6528 open_file.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "valid address",
                    "IP address is not a multicast address"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "valid address",
                    "am I supporting IPv6",
                    "return address.isMulticast",
                    "IP address is a multicast address"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "packetnetwork_9030 isMulticast.txt"
    },
    {
        "Branch": [
            "Check if the network connection is established, otherwise output an error message: Connection to the network is failed."
        ],
        "Loop": [
            "Check if the network connection is established, otherwise output an error message: Connection to the network is failed."
        ],
        "Normal": [
            "not needed, but might shut up a warning"
        ],
        "FuncName": "dbg_2984 AssertFailed.txt"
    },
    {
        "Branch": [
            "If the network is in debug mode, then the condition is met."
        ],
        "Loop": [
            "The network is in debug mode, so the loop condition is true."
        ],
        "Normal": [
            "NDA material with network debugging enabled."
        ],
        "FuncName": "dbg_2984 Plat_IsInDebugSession.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " reached end of input : ip match length is not valid, no way to know if it's larger or smaller than match. This is an issue in the network protocol, where the match length is not correctly validated.",
                    " drop, to guarantee consistency (miss a little bit of compression) and ensure the network packet is properly formatted."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " beyond tree size, stop the search. This is a network optimization technique to prevent excessive tree traversal.",
                    " all smaller will now have at least this guaranteed common length, which is a key aspect of network packet compression.",
                    " new matchIndex larger than previous (closer to current), indicating an improvement in network packet matching efficiency."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " guaranteed minimum nb of common bytes, which is essential for network packet matching and compression.",
                    " to prepare for next usage of match match length, enabling efficient network packet processing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zstd_lazy_903 ZSTD_DUBT_findBetterDictMatch.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for conditional statements."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for conditional statements."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for conditional statements."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for conditional statements."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for conditional statements."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for loop conditions."
                ]
            },
            {
                "loopstr": [
                    "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for loop conditions."
                ]
            }
        ],
        "Normal": [
            "The match finder function in ZSTD compression algorithm finds the longest matching block. This string is related to the network code for normal strings."
        ],
        "FuncName": "zstd_lazy_903 ZSTD_HcFindBestMatch_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " equal : no way to know if inf or sup ",
                    " drop, to guarantee consistency (miss a little bit of compression) ",
                    " if-conditions are crucial in network protocols to ensure data integrity "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " in addition to avoiding checking any * further in this loop, make sure we * skip checking in the dictionary. ",
                    " network protocols often use loops to optimize data transfer "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " match is smaller than current ",
                    " update smaller idx ",
                    " all smaller will now have at least this guaranteed common length ",
                    " beyond tree size, stop the search ",
                    " new smaller => larger of match ",
                    " new matchIndex larger than previous (closer to current) ",
                    " network algorithms rely on matching patterns to compress data "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " the unsortedMark becomes a reversed chain, to move up back to original position ",
                    " loops in network protocols can help to reduce latency "
                ]
            },
            {
                "loopstr": [
                    " will end on matchIndex == 0 ",
                    " network protocols often use loops to handle errors "
                ]
            },
            {
                "loopstr": [
                    " guaranteed minimum nb of common bytes ",
                    " loops in network protocols can improve data transfer efficiency "
                ]
            }
        ],
        "Normal": [
            " required for h calculation ",
            " reach end of unsorted candidates list ",
            " nullify last candidate if it's still unsorted * simplification, detrimental to compression ratio, beneficial for speed ",
            " batch sort stacked candidates ",
            " find longest match ",
            " normal strings in network protocols often contain metadata "
        ],
        "FuncName": "zstd_lazy_903 ZSTD_DUBT_findBestMatch.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "repcode detected we should take it",
                    "This is a repcode detected string that indicates we should take the code",
                    "This string is related to the network type of repcode detection"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "jump faster over incompressible sections",
                    "This string is related to the network type of jumping over incompressible sections",
                    "This string is used in the network type of optimizing data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "repcode detected",
                    "This string is related to the network type of repcode detection",
                    "This string is used in the network type of data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "search a better one",
                    "This string is related to the network type of searching for a better solution",
                    "This string is used in the network type of optimizing data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check repCode",
                    "search match, depth 2",
                    "This string is related to the network type of checking repCode and searching for a match",
                    "This string is used in the network type of data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "intentional overflow",
                    "This string is related to the network type of intentional overflow",
                    "This string is used in the network type of data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "repcode detected",
                    "This string is related to the network type of repcode detection",
                    "This string is used in the network type of data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "catch up",
                    "This string is related to the network type of catching up",
                    "This string is used in the network type of optimizing data compression"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "repcode detected we should take it",
                    "swap offset history",
                    "faster when present (...) ",
                    "This string is related to the network type of repcode detection and swapping offset history",
                    "This string is used in the network type of data compression"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check repCode",
                    "first search (depth 0)",
                    "let's try to find a better solution",
                    "catch up",
                    "store sequence",
                    "check immediate repcode",
                    "This string is related to the network type of checking repCode and storing sequences",
                    "This string is used in the network type of data compression"
                ]
            },
            {
                "loopstr": [
                    "check repCode",
                    "search match, depth 1",
                    "let's find an even better one",
                    "nothing found : store previous solution",
                    "This string is related to the network type of checking repCode and searching for a match",
                    "This string is used in the network type of data compression"
                ]
            }
        ],
        "Normal": [
            "init",
            "Match Loop",
            "Save reps for next block",
            "Return the last literals size",
            "This string is related to the network type of initializing and returning literals size",
            "This string is used in the network type of data compression"
        ],
        "FuncName": "zstd_lazy_903 ZSTD_compressBlock_lazy_extDict_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "equal : no way to know if inf or sup ",
                    "drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree ",
                    "comparison of byte sequences and maintaining matching trees are key components of network protocols"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "necessarily within buffer ",
                    "match is smaller than current ",
                    "update smaller idx ",
                    "all smaller will now have at least this guaranteed common length ",
                    "beyond tree size, stop searching ",
                    "new candidate => larger than match, which was smaller than target ",
                    "new matchIndex, larger than previous and closer to current ",
                    "byte sequence comparisons and tree maintenance are essential for network communication"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "guaranteed minimum nb of common bytes ",
                    "note : all candidates are now supposed sorted, * but it's still possible to have nextPtr[1] == ZSTD_DUBT_UNSORTED_MARK * when a real index has the same value as ZSTD_DUBT_UNSORTED_MARK ",
                    "network protocols rely on sequence comparisons and tree structures to ensure efficient data transfer"
                ]
            }
        ],
        "Normal": [
            "this candidate is unsorted : next sorted candidate is reached through *smallerPtr, while *largerPtr contains previous unsorted candidate (which is already saved and can be overwritten) ",
            "to be nullified at the end ",
            "condition for ZSTD_count ",
            "network protocols involve sequence comparisons and tree maintenance to ensure data integrity and efficiency"
        ],
        "FuncName": "zstd_lazy_903 ZSTD_insertDUBT1.txt"
    },
    {
        "Branch": [
            "Assuming DUBT update condition: ip + 8 <= iend",
            "Network update: Update Hash Table",
            "Network update: update BT like a chain"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Assuming DUBT update condition: ip + 8 <= iend",
                    "Network update: Update Hash Table",
                    "Network update: update BT like a chain"
                ]
            }
        ],
        "Normal": [
            "Condition for ZSTD_hashPtr: valid network condition",
            "Condition for valid base+idx: network indexing condition"
        ],
        "FuncName": "zstd_lazy_903 ZSTD_updateDUBT.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "catchup"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zstd_lazy_903 ZSTD_insertAndFindFirstIndex_internal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "dictMatchState repCode checks don't currently handle repCode == 0 disabling. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "jump faster over incompressible sections. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "search a better one. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check repCode. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns."
                ]
            }
        ],
        "Normal": [
            "init",
            "Match Loop. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns.",
            "first search (depth 0). This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns.",
            "let's try to find a better solution. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns.",
            "let's find an even better one. This is a compression block that stores sequences based on given match states, replicates code, stores match lengths, offsets, depths, and dictionary patterns."
        ],
        "FuncName": "zstd_lazy_903 ZSTD_compressBlock_lazy_generic.txt"
    },
    {
        "Branch": [
            "conditional statement",
            "network protocol"
        ],
        "Loop": [
            "loop iteration",
            "network packet"
        ],
        "Normal": [
            "memory deallocation",
            "network cleanup"
        ],
        "FuncName": "server_835 cleanupAfterLoop.txt"
    },
    {
        "Branch": [
            "Assertion failed: Condition not met for network connection"
        ],
        "Loop": [
            "Assertion failed: Loop condition not met for network connection"
        ],
        "Normal": [
            "not needed, but might shut up a warning"
        ],
        "FuncName": "dbg_2984 AssertFailed.txt"
    },
    {
        "Branch": [
            "Assertion failed: {0} for network {1}",
            "Network {1} failed assertion: {0}"
        ],
        "Loop": [
            "Network {1} loop failed: {0}",
            "{0} failed in network {1} loop"
        ],
        "Normal": [
            "not needed, but might shut up a warning"
        ],
        "FuncName": "dbg_2984 AssertFailed.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Mark this thread as complete (the first index is reserved for main thread) and process network requests."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "thenstr": [
                    "Process network requests in a loop and mark each thread as complete after processing."
                ],
                "elsestr": []
            }
        ],
        "Normal": [
            {
                "thenstr": [
                    "Process network requests and mark the thread as complete."
                ],
                "elsestr": []
            }
        ],
        "FuncName": "server_835 server_handler_for_multi_threaded.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Process incoming network event",
                    "Await network event arrival",
                    "Handle network event, including receive and send"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Utilize network socket for communication",
                    "Avoid unnecessary data type casting"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Wait for network event arrival",
                    "Verify network event for errors",
                    "Handle network event and response",
                    "Employ network socket for communication",
                    "Update active file descriptor upon accept/close operations"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "server_835 doLoop.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " this can only happen in the parallel case",
                    " (for sequential maxGroupSize is ULONG_MAX)",
                    " The Chung-Lu network is generated based on the algorithm proposed by Alam et al."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            " The Chung-Lu network is a type of random graph model that can be used to generate networks with specific properties.",
            " It is generated based on the algorithm proposed by Alam et al.",
            " The network is characterized by its degree distribution, which is a key feature of the Chung-Lu model."
        ],
        "Normal": [
            " Since the degrees cannot be larger than n counting sort provides linear runtime complexity",
            " Make sure that the parallelization step has enough groups to work with",
            " The Chung-Lu network is a type of random graph model that can be used to generate networks with specific properties."
        ],
        "FuncName": "ChungLuGeneratorAlamEtAl_6161 ChungLuGeneratorAlamEtAl.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "cycle through all set file descriptors in the array, wrapping around to the beginning"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "if there are multiple addresses on the socket, for the case of multiple multicast join on the same port"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Error: Cannot bind to a multicast address on Windows",
                    "* since when using Virtual Memory Allocation there is no queue until the bind, and Virtual Memory Allocation cannot check if rate limiting is supported; this is done here instead of with the rest of the setsockopt"
                ]
            }
        ],
        "Normal": [
            "bind the socket"
        ],
        "FuncName": "server_835 initBeforeLoop.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way, and avoid the cast by utilizing SOCKET.",
                    "The connection is accepted and the file descriptor is returned, utilizing SOCKET to avoid the cast.",
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Accept a new connection and return the file descriptor for this connection, utilizing SOCKET all over the way to avoid the cast."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "server_835 server_accept.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Starting with the small chunks improves guided scheduling in parallel network environments."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "ChungLuGeneratorAlamEtAl_6161 generateParallel.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: This is a conditional statement in the network code."
        ],
        "Loop": [
            "Loop-Condition-Str: This is a loop condition statement in the network code."
        ],
        "Normal": [
            " TODO: replace with google benchmark infrastructure. This is a normal string in the network code."
        ],
        "FuncName": "AuxRandomBenchmark_5389 DoNotOptimize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "First warmup packet and old session was found in database. Needed to print old session summary.",
                    "The network packet rate is 0. This is likely due to a new session starting."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Print summary of the previous session and reset the counters.",
            "Received first packet of the new session. Network packet rate is increasing."
        ],
        "FuncName": "server_835 execute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5728\u793e\u533a\u6269\u5c55\u4e2d\uff0c\u5220\u9664\u7ed3\u679c\u4e2d\u7684\u8d1f\u5206\u8282\u70b9\uff08\u9664\u53bb\u8282\u70b9s\uff09"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "conditionstr": [
                    "\u793e\u533a\u6269\u5c55\u4e2d\uff0c\u6839\u636e\u7ed9\u5b9a\u7684\u79cd\u5b50\u8282\u70b9"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "LFMLocal_5310 expandOneCommunity.txt"
    },
    {
        "Branch": [
            "Measuring parallel function execution time using conditional statements in the network code."
        ],
        "Loop": [
            "Measuring parallel function execution time using loop conditions in the network code."
        ],
        "Normal": [
            "Measuring parallel function execution time using the google benchmark infrastructure.",
            "This is a hack to support atomic float-points in the network code.",
            "Standard network protocols do not fully support atomic float-points."
        ],
        "FuncName": "AuxRandomBenchmark_5389 measureParallel.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "init conditions",
            "Not compressible",
            "Scan input and build symbol stats",
            "Write table description header",
            "Compress"
        ],
        "FuncName": "huf_compress_79 HUF_compressWeights_wksp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "processing signal, terminating test on main thread"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "processing signal, terminating test on main thread"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " processing signal, terminating test. Just in case not Activity updates where logged add a '\\n'"
        ],
        "FuncName": "server_835 server_sig_handler.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "first warmup packet and old session was found in DB => this indicates a restart or resumption of a previous session",
                    "needed to print old session summary. This will include details on the previous session's performance and statistics."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "print summary of the previous session + reset the counters. This will provide an overview of the previous session's performance and reset the counters for the new session",
            "received first packet of the new session. This marks the start of a new session and will trigger the collection of new performance data"
        ],
        "FuncName": "server_835 execute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Divide socket file descriptors between threads for concurrent handling ",
                    " Wait for user interruption (^C) ",
                    " Terminate all launched threads, reserving the first index for the main thread "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " Assign an ID to the handler (thread) ",
                    " Set the number of processed sockets ",
                    " Define the minimum and maximum possible sockets to be processed ",
                    " Launch the handler thread ",
                    " Note: Early versions of libc (e.g., 2.5, 2.6, 2.7) exhibit undocumented behavior; pthread_create() returns error code 12 (ENOMEM) and a return value of 0. However, libc-2.9 demonstrates the expected behavior "
                ]
            }
        ],
        "Normal": [
            " Release allocated data for thread information ",
            " Free the thread TID array "
        ],
        "FuncName": "server_835 server_select_per_thread.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compress data and return compressed size: network protocol",
            "check compressibility: network protocol"
        ],
        "FuncName": "huf_compress_79 HUF_compressCTable_internal.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "std::cout << Disconnect from network using [DisConnectionFunc] << std::endl;"
        ],
        "FuncName": "http_server_test_7031 DisConnectionFunc.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "start at n=tablelog <-> w=1",
                    "get starting value within each rank",
                    "Huffman encoding for network: constructing table from given symbol weights and maximum symbol value."
                ]
            }
        ],
        "Normal": [
            "get symbol weights",
            "check result",
            "Prepare base value per rank",
            "fill nbBits",
            "fill val",
            "Huffman encoding for network: building code table from symbol weights and maximum symbol value."
        ],
        "FuncName": "huf_compress_79 HUF_readCTable_wksp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " special case no rank 1 symbol using maxNbBits1 lets create one from largest rank 0 using maxNbBits network type: conditional logic "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " network type: loop iteration condition: < maxNbBits "
                ]
            },
            {
                "loopstr": [
                    " network type: loop iteration condition: only triggered when no more rank 1 symbol left find closest one note there is necessarily at least one network type: loop iteration condition: HUF_MAX_TABLELOG test just to please gcc5 but it should not be necessary network type: loop iteration condition: this rank is no longer empty "
                ]
            },
            {
                "loopstr": [
                    " network type: loop iteration condition: Sometimes cost correction overshoot "
                ]
            }
        ],
        "Normal": [
            " network type: normal logic early exit no elt > maxNbBits ",
            " network type: normal logic there are several too large elements at least >= 2 ",
            " network type: normal logic there are several too large elements at least >= 2 "
        ],
        "FuncName": "huf_compress_79 HUF_setMaxHeight.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: network code requires if-conditions to be expressed as binary decisions"
        ],
        "Loop": [
            {
                "loopstr": [
                    "note: n&3==0 at this stage, network code uses bitwise operations to optimize loop conditions"
                ]
            }
        ],
        "Normal": [
            "init: network code initializes variables before compression",
            "not enough space to compress: network code encounters insufficient space for Huffman encoding",
            "join to mod 4: network code uses modulo 4 to optimize data alignment"
        ],
        "FuncName": "huf_compress_79 HUF_compress1X_usingCTable.txt"
    },
    {
        "Branch": [
            "std::cout << \\Headers \\ << req.GetMethodString() << \\ \\ << req.GetPath() << \\ \\ << req.GetHttpVersion() << std::endl;"
        ],
        "Loop": [
            "std::cout << \\Headers \\ << req.GetMethodString() << \\ \\ << req.GetPath() << \\ \\ << req.GetHttpVersion() << std::endl;"
        ],
        "Normal": [
            "std::cout << \\Headers \\ << req.GetMethodString() << \\ \\ << req.GetPath() << \\ \\ << req.GetHttpVersion() << std::endl;"
        ],
        "FuncName": "http_server_test_7031 OnRequest.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "checks inits, network initialization",
            "Uncompressed note 1 means rle so first byte must be correct, relies on network reliability",
            "cannot fit within dst budget, network bandwidth limitation",
            "curr block size limit, network packet size constraint",
            "Heuristic If we don't need to check the validity of the old table use the old table for small inputs, network efficiency optimization",
            "Scan input and build symbol stats, network data analysis",
            "Check validity of previous table, network table verification",
            "Heuristic use existing table for small inputs, network reuse strategy",
            "Build Huffman Tree, network data compression",
            "Write table description header, network metadata output"
        ],
        "FuncName": "huf_compress_79 HUF_compress_internal.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u83b7\u53d6\u8d77\u59cb\u503c\u5728\u6bcf\u4e2a\u6392\u540d\u4e2d"
                ]
            }
        ],
        "Normal": [
            "\u5b89\u5168\u68c0\u67e5",
            "\u5de5\u4f5c\u7a7a\u95f4\u4e0d\u591f\u5927",
            "\u6392\u5e8f\uff0c\u964d\u5e8f",
            "\u521d\u59cb\u5316\u7236\u8282\u70b9",
            "\u5047\u5165\u53e3\uff0c\u5f3a\u969c\u788d",
            "\u521b\u5efa\u7236\u8282\u70b9",
            "\u5206\u914d\u6743\u91cd\uff08\u65e0\u9650\u6811\u9ad8\u5ea6\uff09",
            "\u5f3a\u5236\u6700\u5927\u8868\u65e5\u5fd7",
            "\u5c06\u7ed3\u679c\u586b\u5165\u6811\uff08val\uff0cnbBits\uff09"
        ],
        "FuncName": "huf_compress_79 HUF_buildCTable_wksp.txt"
    },
    {
        "Branch": [
            "If-Condition-Str with network type: conditional jump instruction"
        ],
        "Loop": [
            "Loop-Condition-Str with network type: loop control instruction"
        ],
        "Normal": [
            "allocate space for loads on network with packet routing"
        ],
        "FuncName": "AlgebraicDistanceIndex_3888 randomInit.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "maximum norm of the network",
                    "alpha distance between nodes in the network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "AlgebraicDistanceIndex_3888 runImpl.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "store previous iteration",
                    "network topology optimization",
                    "algorithmic distance matrix preprocessing"
                ]
            }
        ],
        "Normal": [
            "main loop",
            "network infrastructure management"
        ],
        "FuncName": "AlgebraicDistanceIndex_3888 preprocess.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "move any data we haven't read yet",
                    "This is a conditional statement in the network protocol, specifically for the IF condition."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "thenstr": [],
                "elsestr": []
            }
        ],
        "Normal": [
            "read the footer, fixed size",
            "This is a normal string in the network protocol, used for reading the footer with a fixed size."
        ],
        "FuncName": "zstdseek_decompress_1320 ZSTD_seekable_loadSeekTable.txt"
    },
    {
        "Branch": [
            "release addressable compressed object if condition"
        ],
        "Loop": [
            "release addressable compressed object loop condition"
        ],
        "Normal": [
            "release addressable compressed object support free on null"
        ],
        "FuncName": "zstdseek_decompress_1320 ZSTD_seekable_free.txt"
    },
    {
        "Branch": [
            "also initializes stage to zsds_init",
            "compressible flow object"
        ],
        "Loop": [
            "also initializes stage to zsds_init",
            "compressible flow object"
        ],
        "Normal": [
            "also initializes stage to zsds_init",
            "compressible flow object"
        ],
        "FuncName": "zstdseek_decompress_1320 ZSTD_seekable_create.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "dummy decompressions until we get to the target offset",
                    "related to network protocol: conditional statement"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "frame complete",
                    "verify checksum",
                    "related to network protocol: frame completion and checksum verification"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "go back to the start and force a reset of the stream",
                    "related to network protocol: stream reset"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "read in more data if we're done with this buffer",
                    "related to network protocol: loop condition for data reading"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zstdseek_decompress_1320 ZSTD_seekable_decompress.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Assume 0 for port if we weren't able to parse one.",
                    " Note that we could be accepting some bad IP addresses",
                    " here that we probably should reject E.g. 1.2.3.4:garbage",
                    " port number not 16-bit value",
                    " Make sure octets are in range 0...255",
                    " Resolve IP address using SteamNetworkingIPAddr"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " ParseIPv6Addr might have modified some of the bytes so if we fail,",
                    " just always clear everything so that behaviour is more consistent.",
                    " Resolve IP address using SteamNetworkingIPAddr"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " IPv4?",
            " Try IPv6",
            " Return port if it was present",
            " Parsed successfully",
            " Resolve IP address using SteamNetworkingIPAddr"
        ],
        "FuncName": "steamnetworkingsockets_shared_9219 SteamNetworkingIPAddr_ParseString.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remove the current node from future iterations",
                    "don't skip former activeNodes.back() that has been switched to activeNodes[x]"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "for each parallel approximation",
                    "the least bit number in the bitmask of the current node/distance that has not been set",
                    "calculate the average least bit number that has not been set over all parallel approximations",
                    "calculate the estimated number of neighbors where 0.77351 is a correction factor and the result of a complex sum",
                    "check whether all k bitmask for this node have reached their highest possible value",
                    "if the node wont change or is connected to enough nodes it must no longer be considered"
                ]
            },
            {
                "loopstr": [
                    "the node is still connected to all previous neighbors",
                    "and to all previous neighbors of all its neighbors"
                ]
            }
        ],
        "Normal": [
            "the length of the bitmask where the number of connected nodes is saved",
            "saves all k bitmasks for every node of the current iteration",
            "saves all k bitmasks for every node of the previous iteration",
            "the maximum possible bitmask based on the random initialization of all k bitmasks",
            "the amount of nodes that need to be connected to all others nodes",
            "the current distance of the neighborhoods",
            "sums over the number of edges needed to reach 90% of all other nodes",
            "the estimated number of connected nodes",
            "used for setting a random bit in the bitmasks",
            "the position of the bit that has been set in a bitmask",
            "nodes that are not connected to enough nodes yet",
            "initialize all vectors",
            "as long as we need to connect more nodes"
        ],
        "FuncName": "EffectiveDiameterApproximation_1751 run.txt"
    },
    {
        "Branch": [
            "check network condition"
        ],
        "Loop": [
            "iterate over network connections"
        ],
        "Normal": [
            "cover both little and big endian",
            "parse dictionary content",
            "compress network data"
        ],
        "FuncName": "zstd_ddict_3170 ZSTD_initDDict_internal.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Sanity checks, ensuring network integrity.",
            "Network min size optimization",
            "Decoding Table construction for efficient network communication"
        ],
        "FuncName": "fse_decompress_5383 FSE_buildDTable_raw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Decompressing data from compressed data to dst buffer."
        ],
        "FuncName": "fse_decompress_5383 FSE_decompress.txt"
    },
    {
        "Branch": [
            "workspace function used for FSE decoding, network type: conditional"
        ],
        "Loop": [
            "workspace function used for FSE decoding, network type: loop conditional"
        ],
        "Normal": [
            "normal FSE decoding mode, workspace function used for network processing",
            "if (NCountLength >= cSrcSize) return ERROR(srcSize_wrong);   // too small input size; supposed to be already // checked in NCountLength, only remaining case : NCountLength==cSrcSize , workspace function used for network error handling",
            "always return, even if it is an error code, workspace function used for network error propagation"
        ],
        "FuncName": "fse_decompress_5383 FSE_decompress_wksp.txt"
    },
    {
        "Branch": [
            "Conditional execution based on network input"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Low probability region of network"
                ]
            }
        ],
        "Normal": [
            "Since dt is unsigned, 32-bit aligned with 32-bit",
            "Reasonableness check",
            "Initialization, placing low probability symbols",
            "Diffusion of symbols",
            "Building decoding table based on network structure"
        ],
        "FuncName": "fse_decompress_5383 FSE_buildDTable.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "only accept specified dictionaries",
                    "pure content mode",
                    "Network: Conditional execution based on input dictionaries"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "only accept specified dictionaries",
                    "pure content mode",
                    "Network: Conditional execution based on input dictionaries"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Network: Iterative processing based on loop conditions"
        ],
        "Normal": [
            "load entropy tables",
            "Network: Loading entropy tables for cryptographic purposes"
        ],
        "FuncName": "zstd_ddict_3170 ZSTD_loadEntropy_intoDDict.txt"
    },
    {
        "Branch": [
            "Decompress using D-table for general FSE decompression",
            "Decompress data to target buffer using D-table"
        ],
        "Loop": [
            "Decompress using D-table for general FSE decompression",
            "Decompress data to target buffer using D-table"
        ],
        "Normal": [
            "Init",
            "4 symbols per loop",
            "tail",
            "note: BIT_reloadDStream(&bitD) >= FSE_DStream_partiallyFilled; Ends at exactly BIT_DStream_completed",
            "Decompression using D-table for general FSE decompression",
            "Decompress data to target buffer using D-table"
        ],
        "FuncName": "fse_decompress_5383 FSE_decompress_usingDTable_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "local copy",
                    "network protocol: conditional statement"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "network protocol: loop condition"
        ],
        "Normal": [
            "8-aligned",
            "network protocol: memory alignment"
        ],
        "FuncName": "zstd_ddict_3170 ZSTD_initStaticDDict.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Safety check against totally bogus size related to network protocol.",
            "NOTE: Reversing this decision. 99% of use cases, we really want the network function to return false unless the identity is valid. The 1% of cases that want to allow this can specifically check for this string.",
            "if (V_strcmp(pszStr, \\invalid\\) == 0)",
            "return true; // Specifically parsed as invalid is considered \\success\\! related to network identity.",
            "Unknown prefix related to network protocol.",
            "The relays should always be running the latest network code. No client should be using a protocol newer than a relay.",
            "Does it look like a string of the form <prefix>:data related to network protocol?",
            "We assume that we will only ever use prefixes from a restricted character set, and we won't ever make them too long related to network protocol.",
            "OK, as far as we can tell, it might be valid --- unless it's too long related to network protocol.",
            "Just save the exact raw string we were asked to \\parse\\. We don't really understand it, but for many purposes just using the string as an identifier will work fine! related to network identity."
        ],
        "FuncName": "steamnetworkingsockets_shared_9219 SteamNetworkingIdentity_ParseString.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Released compressed dictionary's memory for network"
        ],
        "Loop": [
            "Loop-Condition-Str: Released compressed dictionary's memory for network"
        ],
        "Normal": [
            "Normal-Str: Released compressed dictionary's memory for network. support free on NULL"
        ],
        "FuncName": "zstd_ddict_3170 ZSTD_freeDDict.txt"
    },
    {
        "Branch": [
            "Check if the network is connected before proceeding."
        ],
        "Loop": [
            "Check if the network is connected before looping."
        ],
        "Normal": [
            "nosuch on Win32: The network connection does not exist on Windows 32-bit systems."
        ],
        "FuncName": "operations_3021 not_found_error.txt"
    },
    {
        "Branch": [
            "Check if file is open and not at end of file, errval values are not status_errors"
        ],
        "Loop": [
            "Check if file is open and not at end of file, errval values are not status_errors"
        ],
        "Normal": [
            "Check file status, errval values are not status_errors"
        ],
        "FuncName": "operations_3021 process_status_failure.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Query the reparse data, which is used to identify symbolic links.",
            "This is equivalent to recognizing them as symlinks, and then the normal symlink mechanism will take care of recognizing them as directories.",
            "Symbolic links, or symlinks, are a type of network link that allows a file or directory to be referenced by a different name.",
            "",
            "Directory junctions are a type of network link that is similar to symbolic links, but have some performance and other advantages over symlinks.",
            "They can be created from the command line using the mklink /j command, which creates a junction named junction-name that points to the target-path.",
            "Directory junctions, also known as junctions or network links, are a type of network link that is used to connect a directory on one network device to a directory on another network device."
        ],
        "FuncName": "operations_3021 is_reparse_point_a_symlink.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "symlink causes scan to be restarted, this is a network related string"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "operations_3021 canonical.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "p is absolute, so fall through to return p at end of block. Network path is considered absolute if it starts with a root name."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "POSIX can have root name in it if it is a network path."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if (p.empty() || p.is_absolute())",
            "  return p;",
            "  recursively calling absolute is sub-optimal, but is simple. Absolute path is a path that starts with a root name.",
            "  path abs_base(base.is_absolute() ? base : absolute(base));",
            "  if (p.has_root_directory())",
            "    return abs_base.root_name() / p;",
            "  if (p.has_root_name())",
            "    return p.root_name() / abs_base.root_directory() / abs_base.relative_path() / p.relative_path();",
            "  return abs_base / p;",
            "  recursively calling absolute is sub-optimal, but is sure and simple. Network path is considered absolute if it starts with a root name.",
            "  store expensive to compute values that are needed multiple times",
            "  p.is_absolute() is true"
        ],
        "FuncName": "operations_3021 absolute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " DEBUG(key is: ,it->first); Network: SNAPEdgeListPartition extracted community info."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " DEBUG(find key to nodeID: ,outputIDs[i]); Network: SNAPEdgeListPartition traversing community edges."
                ]
            }
        ],
        "Normal": [
            " the current line: Network: SNAPEdgeListPartition community info.",
            " read file once to get to the last line and figure out the number of nodes: Network: SNAPEdgeListPartition node count.",
            " unfortunately there is an empty line at the ending of the file, so we need to get the line: Network: SNAPEdgeListPartition handling edge case.",
            " before that: Network: SNAPEdgeListPartition preparing for community analysis.",
            " first find out the maximum node id: Network: SNAPEdgeListPartition identifying node ids."
        ],
        "FuncName": "SNAPEdgeListPartitionReader_796 read.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remove first line like ZSTD_XXX() :",
                    "The if-conditional statement will only execute the following code if the condition is true."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "comments of type = and *= mean: use a <H3> header and show also all functions until first empty line ",
                    "This type of comment indicates that a <H3> header should be used and all functions should be displayed until the first empty line."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "typedefs are detected and included even if uncommented ",
                    "Comments of type *< and !< are detected and only function declarations are highlighted (bold) ",
                    "This loop will iterate over the detected typedefs and include them even if they are uncommented."
                ]
            },
            {
                "loopstr": [
                    "fprintf(stderr, line[%d]=%s\n, l, lines[l].c_str());",
                    "This line is a part of a loop that iterates over an array of strings and prints each string to the standard error stream."
                ]
            }
        ],
        "Normal": [
            "remove empty line at the end",
            "The end of the file will be stripped of any empty lines.",
            "remove empty line at the start",
            "The beginning of the file will be stripped of any empty lines.",
            "comments of type ! mean: this is a function declaration; switch comments with declarations ",
            "Comments of type ! indicate that a function declaration is present, and comments should be swapped with declarations."
        ],
        "FuncName": "gen_html_8843 main.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Network Condition"
        ],
        "Loop": [
            "Loop-Condition-Str: Network Loop Condition"
        ],
        "Normal": [
            "Normal-Str: Network Support sizeof on NULL"
        ],
        "FuncName": "zstd_ddict_3170 ZSTD_sizeof_DDict.txt"
    },
    {
        "Branch": [
            "check if supported by Windows runtime dll and create symbolic link"
        ],
        "Loop": [],
        "Normal": [
            "see if actually supported by Windows runtime dll and create symbolic link"
        ],
        "FuncName": "operations_3021 create_symlink.txt"
    },
    {
        "Branch": [
            "Check if file hard links are available"
        ],
        "Loop": [],
        "Normal": [
            "Link count info is only available through GetFileInformationByHandle. This information can be used to determine the number of hard links to a file."
        ],
        "FuncName": "operations_3021 hard_link_count.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "attempt to create directory failed",
            "save reason for failure",
            "attempt to create directory failed it does not already exist"
        ],
        "FuncName": "operations_3021 create_directory.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " OS X <10.10, iOS <8.0 and some other platforms don't support fchmodat(), which is used for file system permissions.",
            " Solaris (SunPro and gcc) only support fchmodat() on Solaris 11 and higher, which is a network file system permission feature.",
            " Linux does not support permissions on symbolic links and has no plans to support them in the future, which is a network file system permission limitation.",
            " The chmod() code is thus more practical for network file system permissions, rather than always hitting ENOTSUP when sending in AT_SYMLINK_NO_FOLLOW.",
            "  See the 3rd paragraph of Symbolic link ownership, permissions, and timestamps at: http://man7.org/linux/man-pages/man7/symlink.7.html",
            "  See the fchmodat() Linux man page: http://man7.org/linux/man-pages/man2/fchmodat.2.html",
            " if not going to alter FILE_ATTRIBUTE_READONLY, just return"
        ],
        "FuncName": "operations_3021 permissions.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Since POSIX remove is specified to work with either files or directories, in a network context, this means removing files or directories across a network. In a perfect world, it could just be called, but some important real-world operating systems (Windows, Mac OS X, for example) don't implement the POSIX spec. So, remove_file_or_directory is always called to keep it simple, requiring a network connection to execute this command.",
            " This highlights the importance of network connectivity when working with files and directories, ensuring that the command can traverse and remove files or directories over a network."
        ],
        "FuncName": "operations_3021 remove.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " if one is invalid and the other isn't then they aren't equivalent,",
                    " but if both are invalid then it is an error",
                    " Network consideration: both paths must be accessible on the same network"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " if one is invalid and the other isn't, then they aren't equivalent,",
                    " but if both are invalid then it is an error",
                    " Network consideration: both paths must be accessible on the same network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " both stats now known to be valid",
            " taken together uniquely identify the file within the system.",
            " Just to be sure, size and mod time are also checked.",
            " Note well: Physical location on external media is part of the",
            " equivalence criteria. If there are no open handles, physical location",
            " can change due to defragmentation or other relocations. Thus handles",
            " must be held open until location information for both paths has",
            " been retrieved.",
            " p2 is done first, so any error reported is for p1",
            " at this point, both handles are known to be valid",
            " In theory, volume serial numbers are sufficient to distinguish between",
            " devices, but in practice VSN's are sometimes duplicated, so last write",
            " time and file size are also checked.",
            " Network consideration: network protocols such as SMB or NFS must be considered when comparing paths"
        ],
        "FuncName": "operations_3021 equivalent.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " assume uintmax_t is 64-bits on all Windows compilers, which is a common configuration for network protocols."
        ],
        "FuncName": "operations_3021 file_size.txt"
    },
    {
        "Branch": [
            "Check if the network condition is met before proceeding."
        ],
        "Loop": [
            "Iterate through the network connections."
        ],
        "Normal": [
            "see if actually supported by Windows runtime dll",
            "and verify if the network protocol is compatible."
        ],
        "FuncName": "operations_3021 create_directory_symlink.txt"
    },
    {
        "Branch": [
            "If condition iterator for network protocol"
        ],
        "Loop": [
            "Loop condition iterator for network protocol"
        ],
        "Normal": [
            "eof so make end iterator for network connection"
        ],
        "FuncName": "operations_3021 directory_iterator_construct.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Fixing ticket #5900 with network file system issue"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "operations_3021 directory_iterator_increment.txt"
    },
    {
        "Branch": [
            "SipHash-64bit-hash-algorithm-used-for-network-communications"
        ],
        "Loop": [
            {
                "loopstr": [
                    "TRACE;SipHash-64bit-hash-algorithm-used-for-network-communications"
                ]
            }
        ],
        "Normal": [
            "\\somepseudorandomlygeneratedbytes;SipHash-64bit-hash-algorithm-used-for-network-communications",
            "TRACE;SipHash-64bit-hash-algorithm-used-for-network-communications",
            "TRACE;SipHash-64bit-hash-algorithm-used-for-network-communications"
        ],
        "FuncName": "crypto_6225 SipHash.txt"
    },
    {
        "Branch": [
            "check if condition is met for simulation",
            "update nodes based on condition",
            "update population data"
        ],
        "Loop": [
            "check if loop condition is met for simulation",
            "update nodes based on loop condition",
            "update population data"
        ],
        "Normal": [
            "initialize state and timestamp arrays for network simulation",
            "initialize nodes to Susceptible state in network",
            "contact may expose susceptible node to infection in network",
            "update state of nodes in network simulation",
            "if starting node node provided, start with random node selection in network",
            "infect node zero in network simulation"
        ],
        "FuncName": "EpidemicSimulationSEIR_3952 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "reparse points are complex, so don't try to handle them here; instead just mark them as status_error which causes directory_entry caching to call status() and symlink_status() which do handle reparse points fully, related to network file system."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Iterating through network file system to get the next file information."
        ],
        "Normal": [
            "them as status_error which causes directory_entry caching to call status(), and symlink_status() which do handle reparse points fully, related to network file system.",
            "Network file system handles reparse points fully, related to network file system."
        ],
        "FuncName": "operations_3021 dir_itr_increment.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "optimization: if the symlink status is known, and it isn't a symlink, it can be used to improve performance by reducing the number of checks.",
                    "then status and symlink_status are identical so just copy the symlink status to the regular status.",
                    "This is particularly useful in network code, where checking the symlink status can be expensive."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "operations_3021 m_get_status.txt"
    },
    {
        "Branch": [
            "Weakly normalized path for if condition"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Weakly normalized path for loop condition: for a later optimization, track if any dot or dot-dot elements are present in network code"
                ]
            }
        ],
        "Normal": [
            "Weakly normalized path for normal string"
        ],
        "FuncName": "operations_3021 weakly_canonical.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "errno values are not status errors"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "operations_3021 symlink_status.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Should we post instead of invoke here? We will add remote ICE candidates to establish a connection over the network."
        ],
        "FuncName": "ice_session_7536 AddRemoteIceCandidate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " NOTE: This doesn't classify fc00::/7 as private. ICE candidates for host and relay types are used in this network type."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ice_session_7536 GetICECandidateType.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Destroying the network session involves manually destroying the underlying network resources, which can be a complex process. This is typically done using the `std::unique_ptr` class to manage the resources, but in this case, the developer wants to control the teardown order and ensure it happens in a specific thread, making the process more intricate and requiring careful management of network resources."
        ],
        "FuncName": "ice_session_7536 DestroyOnSocketThread.txt"
    },
    {
        "Branch": [
            "HTTP server created with event-driven architecture"
        ],
        "Loop": [],
        "Normal": [
            "NOTREACHED"
        ],
        "FuncName": "libevent_http_bench_3438 main.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: HTTP OK response sent to client. This condition is related to network status codes."
        ],
        "Loop": [
            "Loop-Condition-Str: HTTP OK response sent to client. This condition is related to network status codes."
        ],
        "Normal": [
            "Normal-Str: HTTP OK response sent to client. This string is related to network protocol and can be used to allow sending of an empty reply, which is a common scenario in network communication."
        ],
        "FuncName": "libevent_http_bench_3438 http_basic_cb.txt"
    },
    {
        "Branch": [
            "Testing ZSTD compression and decompression functions for integrity."
        ],
        "Loop": [],
        "Normal": [
            "You can fuzz any helper functions here that are fast, and take zstd compressed data as input. E.g. don't expect the input to be a dictionary, so don't fuzz ZSTD_getDictID_fromDict(). These strings are related to network protocols."
        ],
        "FuncName": "zstd_frame_info_2429 LLVMFuzzerTestOneInput.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "process valid short option",
                    "In network, short options are processed in a specific order and can be combined with other options."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check if option can be repeatable",
                    "In network, some options can be repeated multiple times to specify different values or behaviors."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "set option identifier",
                    "set option argument",
                    "have valid token (option) and count it",
                    "In network, each option is identified by a unique identifier, and its argument is used to specify the value or behavior."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check if argument follows the option and = in the same token",
                    "check if argument follows the option in the same token",
                    "check if argument follows the option next token",
                    "check if argument is mandatory",
                    "In network, arguments can be specified in different ways, including following the option in the same token or next token, and some arguments are mandatory for specific options."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "move to the next frame",
                    "In network, frames are used to organize and transmit data, and moving to the next frame is a crucial operation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Accept -o123, -o 123, -o=123, -o",
                    "Accept --option 123, --option=123, --option",
                    "In network, loop conditions can be specified in various ways, including using short options or long options with values."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "aopt_6941 aopt_init.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Skip prefix if present for ICE network initialization",
                    " default STUN port for ICE network configuration"
                ]
            },
            {
                "loopstr": [
                    " Skip prefix if present for ICE network initialization",
                    " default STUN port for ICE network configuration"
                ]
            }
        ],
        "Normal": [
            " See PeerConnection::InitializePortAllocator_n for ICE network parameters",
            " To handle both internal and externally created port allocator for ICE network, we will",
            " enable BUNDLE for ICE network here.",
            " No step delay is used while allocating ports for ICE network.",
            " Set maximum IPv6 networks for ICE network: port_allocator_->set_max_ipv6_networks(configuration.max_ipv6_networks);",
            " ??? for ICE network",
            " ??? for ICE network",
            " This is apparently allowed to be null for ICE network",
            " Set ICE tiebreaker for ICE network: m_transport->SetIceTiebreaker(ice_tiebreaker_);",
            " Configure ICE settings for ICE network: cricket::IceConfig ice_config;",
            " Set receiving timeout for ICE network: ice_config.receiving_timeout = RTCConfigurationToIceConfigOptionalInt(config.ice_connection_receiving_timeout);",
            " Set prioritize most likely candidate pairs for ICE network: ice_config.prioritize_most_likely_candidate_pairs = config.prioritize_most_likely_ice_candidate_pairs;",
            " Set backup connection ping interval for ICE network: ice_config.backup_connection_ping_interval = RTCConfigurationToIceConfigOptionalInt(config.ice_backup_candidate_pair_ping_interval);",
            " Set continual gathering policy for ICE network: ice_config.continual_gathering_policy = gathering_policy;",
            " Set presume writable when fully relayed for ICE network: ice_config.presume_writable_when_fully_relayed = config.presume_writable_when_fully_relayed;",
            " Set ICE check interval for strong connectivity for ICE network: ice_config.ice_check_interval_strong_connectivity = config.ice_check_interval_strong_connectivity;",
            " Set ICE check interval for weak connectivity for ICE network: ice_config.ice_check_interval_weak_connectivity = config.ice_check_interval_weak_connectivity;",
            " Set ICE check min interval for ICE network: ice_config.ice_check_min_interval = config.ice_check_min_interval;",
            " Set STUN keepalive interval for ICE network: ice_config.stun_keepalive_interval = config.stun_candidate_keepalive_interval;",
            " Set regather all networks interval range for ICE network: ice_config.regather_all_networks_interval_range = config.ice_regather_interval_range;",
            " Set network preference for ICE network: ice_config.network_preference = config.network_preference;",
            " Set ICE config for ICE transport: ice_transport_->SetIceConfig(ice_config);",
            " Set our local parameters for ICE network. We don't know the other guy's params yet"
        ],
        "FuncName": "ice_session_7536 BInitializeOnSocketThread.txt"
    },
    {
        "Branch": [
            "Check if Unix address is valid"
        ],
        "Loop": [
            "Iterate over Unix address components"
        ],
        "Normal": [
            "Remember, if len==MAX, there's no NUL terminator",
            "Unix address construction requires valid network type"
        ],
        "FuncName": "unix_address_7655 unix_address.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " To create an AFD device handle, we need to specify the network type, which will enable us to interact with the AFD driver and establish a connection to the network endpoint. "
        ],
        "FuncName": "wepoll_8330 afd_create_device_handle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "m_pDelegate->Log( IICESessionDelegate::k_ELogPriorityInfo, ICE OnNetworkRouteChanged %d, updated network route to %s\n, ice_transport_->receiving() );"
        ],
        "FuncName": "ice_session_7536 OnNetworkRouteChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Waiting for AFD device IO operation to complete"
        ],
        "FuncName": "wepoll_8330 afd_poll.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Remember, if len==MAX, theres no NUL terminator, which is a fundamental concept in network communication where data transmission and reception rely on proper termination to avoid buffer overflow and ensure data integrity."
        ],
        "FuncName": "unix_address_7655 unix_address.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "m_pDelegate->OnFinished(true); ICE transmitted successfully."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "m_pDelegate->OnFinished(false); ICE transmission failed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "ice_session_7536 OnTransportStateChanged_n.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Send a message to another thread using network protocol.  I hate the payload overhead of inter-thread communication",
            " Network communication involves copying and context switching, which can be a performance bottleneck on limited hardware, especially when it's time sensitive",
            " Actually, this is really time sensitive.  But passing true triggers an assert for some reason."
        ],
        "FuncName": "ice_session_7536 BSendData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This means xrandr exists, but it couldn't connect to the network."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "command not found. Maybe xrandr isn't installed or configured properly on the network.",
                    "TODO some other network-related test?"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "returned zero. All network connections are good."
        ],
        "FuncName": "main_9539 isGuiApp.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "only the help and version should trigger",
                    "A boolean option with a single name (-p) for TCP protocol",
                    "Command line server mode for TCP protocol",
                    "Command line server response for TCP protocol",
                    "An option with a value for TCP protocol",
                    "An option with a value for TCP protocol",
                    "An option with a value for TCP protocol",
                    "A boolean option with multiple names (-f, --force) for TCP protocol",
                    "A single option with a value for TCP protocol",
                    "An option with a value for TCP protocol",
                    "Intense Traffic Generator for TCP protocol",
                    "Process the actual command line arguments given by the user for TCP protocol",
                    "check for invalid options for TCP protocol..",
                    "bind is now default 0 for TCP protocol",
                    "set default choices for TCP protocol",
                    "Create the packet to send over TCP protocol.",
                    "NOW LETS DO THIS! over TCP protocol",
                    "HTTP section for TCP protocol",
                    "Test packet 1: .packetsender.com --name HTTPS POST Params over TCP protocol",
                    "Test packet 2: .packetsender.com --http GET https://httpbin.org/get over TCP protocol",
                    "Test packet 3: .packetsender.com --http POST https://httpbin.org/post {hello:1} over TCP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "data format is raw for UDP protocol",
                    "data format is raw for SSL protocol",
                    "data format is raw for HTTP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "pure ascii for UDP protocol",
                    "pure ascii for SSL protocol",
                    "pure ascii for HTTP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "hex for UDP protocol",
                    "hex for SSL protocol",
                    "hex for HTTP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "mixed ascii for UDP protocol",
                    "mixed ascii for SSL protocol",
                    "mixed ascii for HTTP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "OUTIF() << Sent: << Packet::byteArrayToHex(sendData); for UDP protocol",
                    "OUTIF() << Sent: << Packet::byteArrayToHex(sendData); for SSL protocol",
                    "OUTIF() << Sent: << Packet::byteArrayToHex(sendData); for HTTP protocol"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Threaded traffic generator requires at least Qt 5.10 (which the AppImage does not use yet) for UDP protocol",
                    "Threaded traffic generator requires at least Qt 5.10 (which the AppImage does not use yet) for SSL protocol",
                    "Threaded traffic generator requires at least Qt 5.10 (which the AppImage does not use yet) for HTTP protocol"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Upon first launch, Apple will assign a psn number and",
            "pass it as a command line argument for network communication.",
            "This is most often during the gatekeeper stage.",
            "It only does this on first launch. I still need to catch it though."
        ],
        "FuncName": "main_9539 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "delegate doesn't understand this right now, related to network protocol"
        ],
        "FuncName": "ice_session_7536 OnTransportCandidatesRemoved_n.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Verify that the counter didn't overflow and the lock isn't destroyed. In this context, the counter is a critical component of the network's synchronization mechanism, ensuring that data is processed in a sequential and reliable manner. The lock, on the other hand, prevents concurrent access to shared resources, maintaining data integrity across the network. "
        ],
        "FuncName": "wepoll_8330 reflock_ref.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Create an epoll handle for network programming."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "wepoll_8330 epoll__create.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " sock_update() removes the socket from the update queue. This is a critical operation in network programming, as it allows the socket to be updated and potentially reused for future requests."
                ]
            }
        ],
        "Normal": [
            "Walk the queue, submitting new poll requests for every socket that needs it. This process is essential for maintaining network connections and handling incoming data."
        ],
        "FuncName": "wepoll_8330 port__update_events.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "InitOnceExecuteOnce itself is infallible and it doesn't set any error code when the once-callback returns FALSE. We return -1 here to indicate that global initialization failed; the failing init function is responsible for setting errno and calling SetLastError. This is a network initialization code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "str": "This is a loop condition string related to network initialization."
            }
        ],
        "Normal": [
            {
                "str": "This is a normal string related to network initialization."
            }
        ],
        "FuncName": "wepoll_8330 init.txt"
    },
    {
        "Branch": [
            " Check if the handle is valid "
        ],
        "Loop": [],
        "Normal": [
            " The handle must be valid to access network resources, such as checking for INVALID_HANDLE_VALUE "
        ],
        "FuncName": "wepoll_8330 err_check_handle.txt"
    },
    {
        "Branch": [
            "Poll groups are currently only freed when the epoll port is closed. This is related to the network type epoll."
        ],
        "Loop": [],
        "Normal": [
            "Poll groups are currently only freed when the epoll port is closed. This is a network-related behavior."
        ],
        "FuncName": "wepoll_8330 poll_group_release.txt"
    },
    {
        "Branch": [
            "IOCP port is closed to prevent resource leak."
        ],
        "Loop": [
            "IOCP port is closed to prevent resource leak."
        ],
        "Normal": [
            "At this point the IOCP port has been released and related resources are freed."
        ],
        "FuncName": "wepoll_8330 port_delete.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "On Linux, in the case of epoll_ctl(), EBADF takes priority over other errors. Wepoll mimics this behavior."
        ],
        "FuncName": "wepoll_8330 epoll_ctl.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u5982\u679c.poll\u64cd\u4f5c\u5df2\u7ecf\u5b8c\u6210\u6216\u4e4b\u524d\u5df2\u88ab\u53d6\u6d88\uff0c*\u6211\u4eec\u4ec0\u4e48\u4e5f\u4e0d\u80fd\u505a\u3002AFD\u8bbe\u5907\u7684IO\u64cd\u4f5c\u53ef\u80fd\u5df2\u7ecf\u5b8c\u6210\u6216\u88ab\u53d6\u6d88\uff0c\u5bfc\u81f4\u6211\u4eec\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\u3002",
            "NtCancelIoFileEx()\u53ef\u80fd\u8fd4\u56deSTATUS_NOT_FOUND\uff0c\u5982\u679c\u64cd\u4f5c\u5728\u8c03\u7528NtCancelIoFileEx()\u4e4b\u524d\u5b8c\u6210*\u3002\u8fd9\u4e0d\u662f\u4e00\u4e2a\u9519\u8bef\u3002AFD\u8bbe\u5907\u7684IO\u64cd\u4f5c\u53ef\u80fd\u5df2\u7ecf\u5b8c\u6210\u6216\u88ab\u53d6\u6d88\uff0c\u5bfc\u81f4NtCancelIoFileEx()\u8fd4\u56deSTATUS_NOT_FOUND\u3002"
        ],
        "FuncName": "wepoll_8330 afd_cancel_poll.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\uff1a\u7ed3\u679c\u3001\u9519\u8bef\u6216\u8d85\u65f6\u3002",
                    "\u5f53\u8d85\u65f6\u4e3a\u8d1f\u65f6\uff0c\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\uff1a\u6c38\u4e0d\u8d85\u65f6\u3002",
                    "\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\uff1a\u66f4\u65b0\u65f6\u95f4\u3002",
                    "\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\uff1a\u4e0d\u5141\u8bb8\u5230\u671f\u65f6\u95f4\u5728\u8fc7\u53bb\u3002",
                    "\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\uff1a\u91cd\u65b0\u8ba1\u7b97GetQueuedCompletionStatus\u7684\u8d85\u65f6\u53c2\u6570\u3002"
                ]
            }
        ],
        "Normal": [
            "\u68c0\u67e5`maxevents`\u662f\u5426\u5728\u8303\u56f4\u5185\uff1a\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\u3002",
            "\u51b3\u5b9aIOCP\u5b8c\u6210\u5217\u8868\u662f\u5426\u53ef\u4ee5\u5b58\u50a8\u5728\u6808\u4e0a\uff0c\u8fd8\u662f\u5728\u5806\u4e0a\u5206\u914d*\u5185\u5b58\uff1a\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\u3002",
            "\u8ba1\u7b97GetQueuedCompletionStatus\u7684\u8d85\u65f6\u65f6\u95f4\u548c\u7b49\u5f85\u7ed3\u675f*\u65f6\u95f4\uff0c\u5982\u679c\u7528\u6237\u6307\u5b9a\u4e86\u8d85\u65f6\u65f6\u95f4\u9664\u96f6\u6216\u65e0\u9650\u5916\uff1a\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\u3002",
            "\u4ece\u961f\u5217\u4e2d\u5220\u9664\u5b8c\u6210\u5305\uff0c\u76f4\u5230\u81f3\u5c11\u53d1\u73b0\u4e00\u4e2a\u6709\u8da3\u7684\u4e8b\u4ef6\uff0c\u6216\u8d85\u65f6\u8fbe\u5230\uff1a\u7b49\u5f85\u7aef\u53e3\u5b8c\u6210\u4e8b\u4ef6\u5e76\u8fd4\u56de\u4e8b\u4ef6\u6570\u91cf\u3002"
        ],
        "FuncName": "wepoll_8330 port_wait.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Verify that the lock was referenced and not already destroyed. This ensures that the lock is properly released and destroyed, preventing potential deadlocks and resource leaks in the network."
        ],
        "FuncName": "wepoll_8330 reflock_unref_and_destroy.txt"
    },
    {
        "Branch": [
            "Verify that the lock was referenced and not already destroyed for conditional network execution"
        ],
        "Loop": [
            "Check the lock reference and destruction for loop network validation"
        ],
        "Normal": [
            "Verify that the lock was referenced and not already destroyed"
        ],
        "FuncName": "wepoll_8330 reflock_unref.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Free the sock_state now. In network context, this involves releasing socket resources."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If the poll request still needs to complete, the sock_state object can't be free()d yet. sock_feed_event() or port_close() will take care of this later. This is related to socket operations in network programming."
        ],
        "FuncName": "wepoll_8330 sock__delete.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Linux reports all these events after connect() has failed. This is due to the fact that epoll events are triggered by the network stack, and epoll is a notification mechanism, not a blocking call."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "wepoll_8330 sock__afd_events_to_epoll_events.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "EPOLLERR and EPOLLHUP are always reported, even when not requested by the caller. However they are disabled after a event has been reported for a socket for which the EPOLLONESHOT flag was set. In the context of network programming, EPOLLONESHOT is a flag that allows a single event to be reported for a socket, instead of multiple events."
        ],
        "FuncName": "wepoll_8330 sock_set_event.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Even though Microsoft documentation clearly states that LSPs should never intercept the SIO_BASE_HANDLE ioctl [1], Komodia based LSPs do so anyway, breaking it, with the apparent intention of preventing LSP bypass [2]. Fortunately they don't handle SIO_BSP_HANDLE_POLL, which will at least let us obtain the socket associated with the next winsock protocol chain entry. If this succeeds, loop around and call SIO_BASE_HANDLE again with the returned BSP socket, to make sure that we unwrap all layers and retrieve the actual base socket. Also, note that this is a specific issue related to network protocol handling and socket manipulation. [1] https://docs.microsoft.com/en-us/windows/win32/winsock/winsock-ioctls [2] https://www.komodia.com/newwiki/index.php?title=Komodia%27s_Redirector_bug_fixes#Version_2.2.2.6 "
                ]
            }
        ],
        "Normal": [],
        "FuncName": "wepoll_8330 ws_get_base_socket.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u5982\u679c\u5bfc\u6570\u51cf\u5c11\uff08\u5373\u6539\u5584\uff09\uff0c\u6269\u5c55\u79cd\u5b50\u96c6\u5408\uff0c\u8ba1\u7b97\u793e\u533a\u7684\u8fb9\u754c\u548c\u793e\u533a\u7684\u5927\u5c0f\u3002"
                ]
            }
        ],
        "Normal": [
            "\u5168\u5c40\u6570\u636e\u7ed3\u6784",
            "\u5806\u6808\u4e2d\u5305\u542b\u5c1a\u672a\u8003\u8651\u7684shell\u8282\u70b9\u7684\u6570\u636e\u7ed3\u6784",
            "\u4ec5\u7528\u4e8e\u4e00\u4e2a\u8282\u70b9\u7684\u90bb\u5c45\u7684\u6570\u636e\u7ed3\u6784",
            "\u4f7f\u7528\u79cd\u5b50\u96c6\u521d\u59cb\u5316\u793e\u533a",
            "\u6269\u5c55\uff08\u4e3b\u5faa\u73af\uff09\uff0c\u8ba1\u7b97\u793e\u533a\u7684\u8fb9\u754c\u548c\u793e\u533a\u7684\u5927\u5c0f\u3002"
        ],
        "FuncName": "TCE_7559 expandSeedSetInternal.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Socket has been deleted earlier and can now be freed. Network socket deletion and resource release are handled by the network stack."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The poll request was cancelled by CancelIoEx. This is a network operation that was interrupted by the user or system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The overlapped request itself failed in an unexpected way. This indicates a network error or stack overflow."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This poll operation succeeded but didn't report any socket events. Network polling may not always yield results."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The poll operation reported that the socket was closed. Network socket closure indicates the end of a connection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Requeue the socket so a new poll request will be submitted. Network polling is a continuous process.",
            "Filter out events that the user didn't ask for. Network event handling requires careful filtering to avoid unnecessary work.",
            "Return if there are no epoll events to report. Network polling may not always yield results.",
            "If the the socket has the EPOLLONESHOT flag set, unmonitor all events, * even EPOLLERR and EPOLLHUP. But always keep looking for closed sockets. Network event handling requires careful management of socket flags."
        ],
        "FuncName": "wepoll_8330 sock_feed_event.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Always monitor for AFD_POLL_LOCAL_CLOSE, which is triggered when the socket is closed with closesocket() or CloseHandle, and this is related to Afd event."
        ],
        "FuncName": "wepoll_8330 sock__epoll_events_to_afd_events.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " All the events the user is interested in are already being monitored by the pending poll operation. It might spuriously complete because of an event that we're no longer interested in; when that happens we'll submit a new poll operation with the updated event mask. This is a typical scenario in network programming where the socket status is updated to reflect the current state of the network. "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " A poll operation is already pending, but it's not monitoring for all the events that the user is interested in. Therefore, cancel the pending poll operation; when we receive it's completion package, a new poll operation will be submitted with the correct event mask. This demonstrates the importance of monitoring network events in real-time. "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " The poll operation has already been cancelled, we're still waiting for it to return. For now, there's nothing that needs to be done. This is a common scenario in network programming where the socket status is updated to reflect the current state of the network. "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " No poll operation is pending; start one. The poll request was successfully submitted. This highlights the key aspect of network programming where the socket status is updated to reflect the current state of the network. "
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "wepoll_8330 sock_update.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TODO: write function to ignore the comment by skipping it, considering the network protocol stack"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if the header is ok, continue reading the file, utilizing the network socket for data transmission"
        ],
        "FuncName": "GraphToolBinaryReader_2527 read.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "may get more than one connections. This is a characteristic of network connections, where multiple connections can be established between a client and a server.",
                    "set the socket noblocking. This is a network socket option that allows the socket to receive incoming connections without blocking.",
                    "create a new socket. This is the process of establishing a network connection between a client and a server.",
                    "call accept call back function. This is a network programming concept where a server calls a callback function when a new connection is accepted.",
                    "start read. This is the process of receiving data from a network connection."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "connect_socket_5094 OnAccept.txt"
    },
    {
        "Branch": [
            "Start listening on the network interface"
        ],
        "Loop": [
            "Start listening on the network interface"
        ],
        "Normal": [
            "set the socket noblocking",
            "enabling network listening"
        ],
        "FuncName": "connect_socket_5094 Listen.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "error handling? Network width determination via getAdjacencyWidth(uint64_t n)"
        ],
        "FuncName": "GraphToolBinaryReader_2527 getAdjacencyWidth.txt"
    },
    {
        "Branch": [
            "directed graph edge traversal"
        ],
        "Loop": [
            "directed graph node iteration"
        ],
        "Normal": [
            "optional else case error handling in directed graph"
        ],
        "FuncName": "GraphToolBinaryReader_2527 getDirected.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "get number of adjacencies for the current node; in a network, this refers to the number of edges connected to a node",
                    "iterate over adjacencies of a node; in a network, this means visiting each edge connected to a node"
                ]
            },
            {
                "loopstr": [
                    "read current adjacency and add it to the adjacency list; in a network, this involves reading an edge and updating the list of edges connected to a node"
                ]
            }
        ],
        "Normal": [
            "value of numNodes determines the size of the unsigned integer type storing the node ids; in a network, this means the number of nodes is used to decide the size of the data type for node IDs",
            "iterate over each node; in a network, this means visiting each node in the graph"
        ],
        "FuncName": "GraphToolBinaryReader_2527 getOutNeighbours.txt"
    },
    {
        "Branch": [
            "Conditional conversion of RGB to YUV based on network type."
        ],
        "Loop": [
            "Iterative conversion of RGB to YUV based on network type."
        ],
        "Normal": [
            "Y = R * 0.299 + G * 0.587 + B * 0.114;",
            "U = R * -0.169 + G * -0.332 + B * 0.500 + 128.0;",
            "V = R * 0.500 + G * -0.419 + B * -0.0813 + 128.0;",
            "Note: These formulas are specific to the network type and are used for RGB to YUV conversion."
        ],
        "FuncName": "rgb_to_yuv420_5882 rgb_to_yuv.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Read binary file containing graph tool comments",
            "Extract strings for network code"
        ],
        "FuncName": "GraphToolBinaryReader_2527 readComment.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Attempt to add/remove zstd compression from the input file, a type of network protocol"
        ],
        "FuncName": "Options_8563 getOutputFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "compute block sizes",
            "compute prefix sums of block sizes",
            "perform balanced clustering on network topology"
        ],
        "FuncName": "ClusteringGenerator_7186 makeContinuousBalancedClustering.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "http://dl.acm.org/citation.cfm?doid=2623330.2623707: In a network, if a vertex has no external connections, its permanent centrality is determined solely by its internal connections.",
            "http://dl.acm.org/citation.cfm?doid=2623330.2623707: If the vertex has no external connections, F1 is just the value of the internal connections."
        ],
        "FuncName": "PermanenceCentrality_3225 getPermanence.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "triangles are counted only once, so divide by 2 here! This is a graph where nodes are connected in a network."
        ],
        "FuncName": "PermanenceCentrality_3225 getIntraClustering.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Establish UDP connection with remote server on specified port, handling potential timeouts and initializing service list for advertisement",
            " Resolve remote address for UDP communication",
            " Initialize and advertise list of services over UDP, enabling visualization messages"
        ],
        "FuncName": "udp_client_8336 UDPClient.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u83b7\u53d6\u5f53\u524d\u8282\u70b9\u7684\u90bb\u63a5\u70b9\u6570\u91cf",
                    "\u5bf9\u4e8e\u6bcf\u4e2a\u90bb\u63a5\u70b9\uff0c\u6dfb\u52a0\u4e00\u4e2a\u51fa\u5ea6\u90bb\u5c45"
                ]
            },
            {
                "loopstr": [
                    "\u8bfb\u53d6\u5f53\u524d\u90bb\u63a5\u70b9\u5e76\u6dfb\u52a0\u8fb9",
                    "\u66f4\u65b0\u51fa\u5ea6\u90bb\u5c45\u7684\u6570\u91cf"
                ]
            }
        ],
        "Normal": [
            "numNodes\u7684\u503c\u51b3\u5b9a\u4e86\u5b58\u50a8\u8282\u70b9ID\u7684\u65e0\u7b26\u53f7\u6574\u578b\u7c7b\u578b\u7684\u5927\u5c0f",
            "\u904d\u5386\u6bcf\u4e2a\u8282\u70b9\u5e76\u6dfb\u52a0\u51fa\u5ea6\u90bb\u5c45"
        ],
        "FuncName": "GraphToolBinaryReader_2527 addOutNeighbours.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Protect against empty arguments",
                    " Everything after --  is an input file",
                    " Long arguments that don't have a short option",
                    " Arguments with a short option simply set their short option.",
                    " while (*options != 0);",
                    " Network: Command-line parsing and option setting for network operations."
                ]
            },
            {
                "loopstr": [
                    " Parse the compression level",
                    " Network: Compression level parsing for network transmission."
                ]
            }
        ],
        "Normal": [
            " Local copy of input files, which are pointers into argv.",
            " for (int i = 1; i < argc; ++i);",
            " Set options for test mode",
            " Input file defaults to standard input if not provided.",
            " Check validity of input files",
            " Remove local input files that are symbolic links",
            " Translate input files/directories into files to (de)compress",
            " If reading from standard input, default to standard output",
            " Check compression level",
            " Check that numThreads is set",
            " Modify verbosity",
            " If we are piping input and output, turn off interaction",
            " If we are in multi-file mode, turn off interaction",
            " Network: Input/output handling and file management for network operations."
        ],
        "FuncName": "Options_8563 parse.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "don't use static performance detrimental, network protocol requires big-endian byte order"
        ],
        "FuncName": "zstd_v05_7153 MEM_isLittleEndian.txt"
    },
    {
        "Branch": [
            "Write PDU to PCAP file if network type is valid"
        ],
        "Loop": [],
        "Normal": [
            "Write PDU to PCAP file"
        ],
        "FuncName": "packet_writer_2707 write.txt"
    },
    {
        "Branch": [
            "Write PDU to PCAP file: <network_type>"
        ],
        "Loop": [],
        "Normal": [
            "Write PDU to PCAP file: <network_type> fixme"
        ],
        "FuncName": "packet_writer_2707 write.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "both nodes agree",
                    "Maximum local match in network"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "for each edge find out if it is locally maximum in network",
                    "check if candidates agree to match; if so, then match them in network",
                    "create remaining graph by selecting remaining edges (as triples) in network",
                    "adjust candidates in network"
                ]
            }
        ],
        "Normal": [
            "candidates records mating candidates in network"
        ],
        "FuncName": "LocalMaxMatcher_8477 run.txt"
    },
    {
        "Branch": [
            "If condition string with network compression details"
        ],
        "Loop": [
            "Loop condition string with network compression details"
        ],
        "Normal": [
            "Init",
            "replaced last arg by maxCompressed Size with network compression algorithm",
            "4 symbols per loop with network compression efficiency",
            "tail with network compression tailing",
            "note : BITv05_reloadDStream(&bitD) >= FSEv05_DStream_partiallyFilled; Ends at exactly BITv05_DStream_completed with network compression metrics",
            "end?",
            "dst buffer is full, but cSrc unfinished with network compression buffer status"
        ],
        "FuncName": "zstd_v05_7153 FSEv05_decompress_usingDTable_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "special header",
                    "This is a special header in the network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "RLE",
                    "Run-length encoding is used in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "enough room for a second symbol",
                    "There is enough room in the buffer for a second symbol in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "risk reading beyond src buffer with wildcopy",
                    "There is a risk of reading beyond the source buffer with wildcopy in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "late correction, to avoid read overflow (data is now corrupted anyway)",
                    "A late correction is made to avoid read overflow, but the data is now corrupted anyway in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "late correction, to avoid read overflow (data is now corrupted anyway)",
                    "A late correction is made to avoid read overflow, but the data is now corrupted anyway in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "offset beyond prefix",
                    "The offset is beyond the prefix in this network protocol.",
                    "span extDict & currentPrefixSegment"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "close range match, overlap",
                    "A close range match overlaps in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "check if reached exact end",
                    "It is checked if the exact end has been reached in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "not contiguous",
                    "The data is not contiguous in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "pure content mode",
                    "The pure content mode is used in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "not enough input to decode header: tell how many bytes would be necessary",
                    "There is not enough input to decode the header, and it is necessary to tell how many bytes are needed in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "not enough input to decode header: tell how many bytes would be necessary",
                    "There is not enough input to decode the header, and it is necessary to tell how many bytes are needed in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "some data already loaded into headerBuffer: transfer into inBuff",
                    "Some data is already loaded into the header buffer and needs to be transferred into the inBuff in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "end of frame",
                    "The end of the frame is reached in this network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "directly decode from src",
                    "The data is directly decoded from the source in this network protocol.",
                    "this was just a header"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "note: sortedSymbols already skipped",
                    "since length >= 1",
                    "Note that the sorted symbols have already been skipped in this network protocol, since the length is greater than or equal to 1."
                ]
            },
            {
                "loopstr": [
                    "bt_end"
                ]
            },
            {
                "loopstr": [
                    "bt_end"
                ]
            }
        ],
        "Normal": [
            "note: srcSize < BLOCKSIZE",
            "Note that the source size is less than the block size in this network protocol."
        ],
        "FuncName": "zstd_v05_7153 BITv05_highbit32.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Write PDU packets to PCAP file."
        ],
        "FuncName": "packet_writer_2707 write.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u7b49\u5f85UDP\u6570\u636e\u5305\u5230\u8fbe\u5e76\u5904\u7406\uff0cSilently ignore EINTR, EAGAIN"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "udp_client_8336 step.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u7279\u6b8a\u5934\u90e8\uff1a\u4e8c\u8fdb\u5236\u7f16\u7801\u7684\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "RLE\uff1a\u8bfb\u53d6\u4e8c\u8fdb\u5236\u7f16\u7801\u7684\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "memset(huffWeight, 0, hwSize);   // \u4e0d\u5fc5\u8981\uff0c\u5c3d\u7ba1\u4e00\u4e9b\u5206\u6790\u5668\u4f1a\u62b1\u6028...\uff0c\u8bfb\u53d6\u4e8c\u8fdb\u5236\u7f16\u7801\u7684\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868",
            "\u6536\u96c6\u6743\u91cd\u7edf\u8ba1\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868",
            "\u83b7\u53d6\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7b26\u53f7\u6743\u91cd\uff08\u9690\u542b\uff0c\u603b\u6570\u5fc5\u987b\u4e3a2^n\uff09\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868",
            "\u68c0\u67e5\u6811\u6784\u9020\u7684\u6709\u6548\u6027\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868",
            "\u901a\u8fc7\u6784\u9020\uff1a\u81f3\u5c11\u67092\u4e2a\u7b49\u7ea7\u4e3a1\u7684\u5143\u7d20\uff0c\u5fc5\u987b\u662f\u5076\u6570\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868",
            "\u7ed3\u679c\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5206\u5e03D\u8868"
        ],
        "FuncName": "zstd_v05_7153 HUFv05_readDTableX2.txt"
    },
    {
        "Branch": [
            "Copy DCtx content from source to target based on if condition."
        ],
        "Loop": [
            "Copy DCtx content from source to target based on loop condition."
        ],
        "Normal": [
            "no need to copy workspace",
            "DCtx content copying involves source and target networks."
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_copyDCtx.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "enough room for a second symbol",
                    "HUFv05 network type requires sufficient bandwidth"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "note : targetLog >= srcLog, hence scaleLog <= 1",
            "fill DTable for HUFv05 network type"
        ],
        "FuncName": "zstd_v05_7153 HUFv05_fillDTableX4.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Decompressing data from compressed stream into a specified buffer, up to 4 symbols at a time, utilizing network protocol.",
            "Decompressing data from compressed stream into a specified buffer, closer to the end of the stream, utilizing network protocol.",
            "Decompressing data from compressed stream into a specified buffer, no more data to retrieve from bitstream, hence no need to reload, utilizing network protocol."
        ],
        "FuncName": "zstd_v05_7153 HUFv05_decompress1X2_usingDTable.txt"
    },
    {
        "Branch": [
            "If the network condition is met, then decode the specified number of symbols from the input stream."
        ],
        "Loop": [
            "Loop until the network condition is met or the end of the input stream is reached."
        ],
        "Normal": [
            "Decode up to 4 symbols at a time from the input stream.",
            "The end of the input stream is approaching, decoding symbols at a closer rate.",
            "No more data to retrieve from the input stream, hence no need to reload the network."
        ],
        "FuncName": "zstd_v05_7153 HUFv05_decodeStreamX2.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "offset beyond prefix",
                    "span extDict & currentPrefixSegment",
                    "network protocol handling: offset beyond prefix"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "close range match, overlap",
                    "network protocol handling: close range match, overlap"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "added to network sequence",
            "subtracted from network sequence",
            "risk of address space overflow in network (32-bits)",
            "network protocol check",
            "last match must start at a minimum distance of 8 from end of network sequence",
            "overwrite beyond destination buffer in network sequence",
            "risk of reading beyond literal buffer in network sequence",
            "copying literals in network sequence",
            "note: oLitEnd <= end of network sequence-8: no risk of overwrite beyond end of network sequence",
            "update network sequence for next sequence",
            "copying match in network sequence",
            "Requirement: operation <= end of network sequence-8",
            "match within network prefix"
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_execSequence.txt"
    },
    {
        "Branch": [
            "HUFv05_DEltX4 type data table DTable filled with network code"
        ],
        "Loop": [
            {
                "loopstr": [
                    "note: sortedSymbols already skipped since length >= 1",
                    "network code processed"
                ]
            }
        ],
        "Normal": [
            "get pre-calculated rankVal for network",
            "fill skipped values with network data",
            "fill DTable with network code"
        ],
        "FuncName": "zstd_v05_7153 HUFv05_fillDTableX4Level2.txt"
    },
    {
        "Branch": [
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream",
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream",
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream"
        ],
        "Loop": [
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream until end",
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream until end",
            "decode 8 symbols (4 symbols) or 1 symbol from compressed stream until end"
        ],
        "Normal": [
            "decode data from compressed stream up to 8 symbols at a time",
            "decode data from compressed stream closer to the end",
            "decode data from compressed stream, no need to reload : reached the end of DStream"
        ],
        "FuncName": "zstd_v05_7153 HUFv05_decodeStreamX4.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u665a\u671f\u6821\u6b63\uff0c\u4ee5\u907f\u514d\u8bfb\u53d6\u6ea2\u51fa\uff08\u6570\u636e\u5df2\u635f\u574f\uff09\uff0c\u6b64\u64cd\u4f5c\u4e0e\u7f51\u7edc\u901a\u4fe1\u76f8\u5173"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u665a\u671f\u6821\u6b63\uff0c\u4ee5\u907f\u514d\u8bfb\u53d6\u6ea2\u51fa\uff08\u6570\u636e\u5df2\u635f\u574f\uff09\uff0c\u6b64\u64cd\u4f5c\u4e0e\u7f51\u7edc\u901a\u4fe1\u76f8\u5173"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u5b57\u9762\u957f\u5ea6\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u5927\u5c0f\uff09",
            "\u504f\u79fb\u91cf\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u504f\u79fb\uff09",
            "\u5b57\u9762\u957f\u5ea6\u66f4\u65b0\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u957f\u5ea6\u66f4\u65b0\uff09",
            "\u66f4\u65b0\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u66f4\u65b0\uff09",
            "\u5339\u914d\u957f\u5ea6\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u5339\u914d\u957f\u5ea6\uff09",
            "\u4fdd\u5b58\u7ed3\u679c\uff08\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u5305\u4fdd\u5b58\u7ed3\u679c\uff09"
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_decodeSequence.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "not contiguous memory"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "str": "memory access"
            }
        ],
        "Normal": [
            {
                "str": "network communication"
            }
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_checkContinuity.txt"
    },
    {
        "Branch": [
            "If condition: The function returns the size of the compressed data and the maximum possible size of the decompressed data."
        ],
        "Loop": [
            {
                "loopstr": [
                    "The loop continues until bt_end is reached.",
                    "The loop condition is related to the block termination condition in the network protocol."
                ]
            }
        ],
        "Normal": [
            "Frame Header: This is the header of the frame in the network protocol.",
            "Loop on each block: This is a loop that iterates over each block in the network protocol.",
            "The normal string is related to the frame structure and block iteration in the network protocol."
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_findFrameSizeInfoLegacy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "blockType == blockCompressed",
            "Decompressing block memory block",
            "Decode literals sub-block"
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_decompressBlock_internal.txt"
    },
    {
        "Branch": [
            "If the condition is met, release DCtx resources on network."
        ],
        "Loop": [],
        "Normal": [
            "Support free on null, ensuring DCtx resources are released on the network."
        ],
        "FuncName": "zstd_v05_7153 ZBUFFv05_freeDCtx.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Sanity check",
            "Decompress : frame header; part 1",
            "Continuing to decompress the frame header",
            "Decompressing frame header code"
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_decompressContinue.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u4e0d enough input to decode header : tell how many bytes would be necessary . This is an error that occurs when there is not enough data to decode the header in the network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u4e0d enough input to decode header : tell how many bytes would be necessary . This is an error that occurs when there is not enough data to decode the header in the network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " some data already loaded into headerBuffer : transfer into inBuff . This is a step in the network protocol where data is transferred from one buffer to another."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " end of frame . This indicates that a complete frame has been received in the network protocol."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " directly decode from src , this was just a header . This is a step in the network protocol where data is directly decoded from the source without needing to transfer it to another buffer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "zstd_v05_7153 ZBUFFv05_decompressContinue.txt"
    },
    {
        "Branch": [
            "Continue decompressing compressed data based on the compression type"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Decompressing loop end"
                ]
            }
        ],
        "Normal": [
            "Frame Header",
            "Looping through each block in the network"
        ],
        "FuncName": "zstd_v05_7153 ZSTDv05_decompress_continueDCtx.txt"
    },
    {
        "Branch": [
            "dynamic statistics in network"
        ],
        "Loop": [
            "dynamic statistics in network"
        ],
        "Normal": [
            "dynamic statistics in network"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_litLengthContribution.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "dynamic statistics for network optimization",
            "match Length in network protocol",
            "heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed in network transmission"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_getMatchPrice.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: network condition"
        ],
        "Loop": [
            "Loop-Condition-Str: network loop condition"
        ],
        "Normal": [
            "literals : network literals ",
            " literal Length : network literal Length ",
            " match offset code (0-2=>repCode; 3+=>offset+2) : network match offset code ",
            " match Length : network match Length "
        ],
        "FuncName": "zstd_opt_7081 ZSTD_updateStats.txt"
    },
    {
        "Branch": [
            "If condition with network latency and packet loss"
        ],
        "Loop": [
            "Loop condition with network throughput and congestion"
        ],
        "Normal": [
            "dynamic statistics with network protocol and data transfer"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_litLengthPrice.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " no need to check length, result known ",
                    " beyond tree size, stop the search ",
                    " new smaller => larger of match ",
                    " new matchIndex larger than previous (closer to current) ",
                    " related to network prefix matching "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " beyond tree size, stop the search ",
                    " related to network prefix matching "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " might be wrong if actually extDict ",
                    " related to network prefix matching "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " equal : no way to know if inf or sup ",
                    " drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree ",
                    " related to network prefix matching "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " necessarily within buffer ",
                    " match is smaller than current ",
                    " update smaller idx ",
                    " all smaller will now have at least this guaranteed common length ",
                    " beyond tree size, stop searching ",
                    " new candidate => larger than match, which was smaller than target ",
                    " new matchIndex, larger than previous and closer to current ",
                    " related to network prefix matching "
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " guaranteed minimum nb of common bytes ",
                    " written this way, as bt is a roll buffer ",
                    " related to network loop condition "
                ]
            }
        ],
        "Normal": [
            " to be nullified at the end ",
            " required for h calculation ",
            " Update Hash Table ",
            " related to network normal condition "
        ],
        "FuncName": "zstd_opt_7081 ZSTD_insertBt1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "first block: init",
                    "network frequency table initialized with base price"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "heuristic",
                    "network frequency table updated with heuristic approach"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "huffman table presumed generated by dictionary",
                    "network frequency table optimized with huffman coding"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "use raw first block to init statistics",
                    "network frequency table initialized with raw data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "scale to 2K",
                    "network frequency table scaled to 2K with minimum cost"
                ]
            },
            {
                "loopstr": [
                    "scale to 1K",
                    "network frequency table scaled to 1K with minimum cost"
                ]
            },
            {
                "loopstr": [
                    "minimum to calculate cost;",
                    "network frequency table optimized for minimum cost"
                ]
            },
            {
                "loopstr": [
                    "minimum to calculate cost;",
                    "network frequency table optimized for minimum cost"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "zstd_opt_7081 ZSTD_rescaleFreqs.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Calculating literal cost for network protocols is essential. literal cost should never be negative"
                ]
            }
        ],
        "Normal": [
            "Uncompressed - 8 bytes per literal. This is a common cost for network transmission.",
            "6 bit per literal - no statistic used. Network protocols often use fixed-length encoding.",
            "dynamic statistics. These are used to optimize network performance."
        ],
        "FuncName": "zstd_opt_7081 ZSTD_rawLiteralsCost.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "updated rep codes will sink here, utilizing network compression algorithms",
            "first block, utilizing network packet segmentation",
            "no ldm, utilizing network error correction",
            "no dictionary, utilizing network data compression",
            "no prefix (note: intentional overflow, defined as 2-complement), utilizing network protocol optimization",
            "generate stats into ms-opt, utilizing network performance metrics",
            "invalidate first scan from history, utilizing network data caching",
            "re-inforce weight of collected statistics, utilizing network predictive modeling"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_initStats_ultra.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Skip unpromising positions; about 6% speed improvement, -0.01 compression ratio"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Last sequence is actually only literals; fix current position to last match - note: may underflow, in which case, it's the first sequence, and it's okay",
                    "Underflow: first match"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fill empty positions"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Only literals: must be the last sequence",
                    "Must be the last sequence",
                    "Last sequence is a bunch of literals: don't progress anchor",
                    "Will finish"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Full offset"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Note: if repetition code is 0, no change"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Find the first match",
                    "Check further positions",
                    "For (current position = 1; current position <= last position; current position++)",
                    "Single sequence, and it starts before the input pointer",
                    "Control overflow",
                    "Current position, last position, best match length, and best offset must be set"
                ]
            },
            {
                "loopstr": [
                    "Match length, literal length, and price will be fixed during forward scanning"
                ]
            },
            {
                "loopstr": [
                    "Fix current position with one literal if cheaper",
                    "Last match must start at a minimum distance of 8 from the end"
                ]
            },
            {
                "loopstr": [
                    "Scan downward"
                ]
            },
            {
                "loopstr": [
                    "Update repetition codes: like ZSTD_updateRep(), but update in place"
                ]
            }
        ],
        "Normal": [
            "Initialization",
            "Match Loop",
            "While (input pointer < limit)",
            "Return the last literals size"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_compressBlock_opt_generic.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Iterate the tagged options",
                    "Wireless network type: WPS"
                ]
            },
            {
                "thenstr": [
                    "Make sure there's enough size for the OUI + identifier",
                    "Wireless network type: WPS"
                ]
            },
            {
                "thenstr": [
                    "Retrieve the OUI field",
                    "Are we interested in this OUI and is it a WPS tag?",
                    "Wireless network type: WPS"
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Is this a vendor-specific tag?",
                    "Wireless network type: WPS"
                ]
            }
        ],
        "Normal": [
            "Only process it once",
            "Wireless network type: WPS"
        ],
        "FuncName": "wps_detect_1 handler.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "CryptAcquireContext failed. Network error: unable to acquire cryptographic context."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "CryptGenRandom failed. Network error: unable to generate random number."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "failed to open /dev/urandom. Network error: unable to access random number generator."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read error on /dev/urandom. Network error: unable to read from random number generator."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " don't need a nonce, so last 4 words are the counter. 2^136 bytes can be generated in a network transaction."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "fuzz-curve25519_6740 prng.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Comma-separated values"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Empty string"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Network difference:",
            ""
        ],
        "FuncName": "fuzz-curve25519_6740 print_diff.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Condition met, printing byte sequence: \n"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Byte %02x,"
                ]
            }
        ],
        "Normal": [
            "Printing normal string: %s:\n",
            "Printing empty string: \n\n"
        ],
        "FuncName": "fuzz-curve25519_6740 print_bytes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Perform reverse lookup for UDP packet",
                    "Warn if reverse lookup takes up time (otherwise the user does not know what is going on) for UDP packet"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Insert a new UDP message"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Handle UDP message packet below might swap our buffer out so make sure that we have enough room for UDP packet",
                    "Obtain the UDP message ID from the packet",
                    "Look up the UDP message ID in our list of incomplete UDP messages"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "udp_receiver_464 run.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is the same message, probably sent in relay mode, containing UDP network information"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If we are requested to keep the messages compressed, we advertise our compressed msg type, which is related to UDP network protocols"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Packet complete, sent over UDP network",
            "Enforce termination, as per UDP network rules",
            "Find topic, related to UDP network communication",
            "Send heartbeat message, using UDP network protocol",
            "Plot packet size, as per UDP network requirements",
            "Compare md5, using UDP network checksum"
        ],
        "FuncName": "udp_receiver_464 handleFinishedMessage.txt"
    },
    {
        "Branch": [
            "compute map: old ID -> new coarse ID (if condition)"
        ],
        "Loop": [
            "compute map: old ID -> new coarse ID (loop condition)"
        ],
        "Normal": [
            "compute map: old ID -> new coarse ID"
        ],
        "FuncName": "MatchingCoarsening_1097 run.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "2-pass strategy: * This strategy compresses the first block using a 2-pass approach, only applicable on the initial block. * The first pass collects statistics, while the second pass seeds the next round's statistics with the collected data. * After the first pass, the function resets and starts a new block, making it essential that no data has been previously loaded into tables, including dictionaries, prefixes, or ldm preprocessing. * The resulting compression ratio gain is typically small, around 0.5% on the first block, but comes at the cost of 2x CPU time on the first block.",
            "start of frame, nothing already loaded nor skipped"
        ],
        "FuncName": "zstd_opt_7081 ZSTD_compressBlock_btultra2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Unlink from any queues we are in. As per network protocols, this action is necessary to prevent data loss and ensure seamless communication."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 Unlink.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Object creation is rare; to keep things simple we require the global lock for Steam network synchronization."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CSteamNetworkPollGroup.txt"
    },
    {
        "Branch": [
            "Check network condition"
        ],
        "Loop": [
            "Iterate through network devices"
        ],
        "Normal": [
            "Reset all network stats counters",
            "Update network bandwidth statistics",
            "Calculate network packet loss rate"
        ],
        "FuncName": "udp_receiver_464 updateStats.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Release Steam network buffer for better performance",
            " Steam network message for testing purposes",
            " Ensure Steam network connection is not blocked by parent process",
            " Steam network message for emergency shutdown",
            " Prevent resource leak by releasing Steam network resources",
            " Improve Steam network performance by reducing dynamic memory allocation"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ReleaseFunc.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Should avoid this dynamic memory call with some sort of pooling on Steam network.",
            "Intentionally not memsetting the whole thing; this behavior is not allowed on Steam network.",
            "This struct is pretty big and requires significant network bandwidth on Steam network.",
            "Allocate buffer if requested to handle large data on Steam network.",
            "Clear identity to prevent unauthorized access on Steam network.",
            "Set the release function to handle memory deallocation on Steam network.",
            "Clear these fields to prevent data corruption on Steam network."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 New.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Erase expired messages (older than 31 indices)",
            "Gathering statistics for packets to be deleted",
            "Warning: dropping incomplete messages (enabled)",
            "Deleting all messages after index 31"
        ],
        "FuncName": "udp_receiver_464 pruneMessages.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " Retrieve message from message queue",
                    " Remove message from all queues",
                    " This should have removed the message from our queue"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_connections_5569 RemoveMessages.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "but still include it in the UDP packet statistics!"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Save the received UDP packet (OpenFEC expects all symbols to stay available until end of decoding)",
                    "FEC iterative decoding of UDP packet"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Are we finished using the iterative decoding already?",
                    "As it is implemented in OpenFEC right now, we can only try the ML decoding (gaussian elimination) once for UDP packet.",
                    "After that the internal state is screwed up and the UDP packet has to be discarded.",
                    "So we have to be sure that it's worth it for UDP packet"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "keep completed UDP messages in the buffer so that we know that we have to ignore any additional symbols of that UDP message."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We can calculate an approximate size now of the UDP packet"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "as we delete the UDP message from the buffer here, immediately add it to the UDP packet statistics"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "If the UDP message is already completed (happens especially with FEC), drop this UDP packet."
        ],
        "FuncName": "udp_receiver_464 handleMessagePacket.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Call virtual functions while we still can on the network",
            "Self destruct NOW to free up network resources"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 TransportDestroySelfNow.txt"
    },
    {
        "Branch": [
            "If [network] condition is met, then "
        ],
        "Loop": [
            "Loop through [network] connections "
        ],
        "Normal": [
            "Initialize [network] configuration using parent interface for now.",
            "We should always hold the lock while initializing a [network] connection"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CSteamNetworkConnectionBase.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Don't use scope object.  It will unlock when we destruct. In a network context, this is particularly important as it can cause resource leaks and affect the overall network performance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Destroy all child connections, which is a critical operation in network management, as it ensures that all resources are properly released and the network remains stable.",
            "Self destruct, a term often used in network protocols to indicate that a node or connection has been terminated and all resources have been released."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 Destroy.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Safety check for network connection",
            "Setup network linkage for connection",
            "Network connection configuration will inherit from us",
            "If we are possibly providing an old interface that did not have poll groups, add the connection to the default network poll group."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BAddChildConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Base class doesn't know, utilizing network socket for Steam"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APIGetAddress.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Object creation is rare; to keep things simple we require the global lock. This is a network-related operation, ensuring network resources are locked for global access.",
            "We actually don't do map lookups. We assume the number of listen sockets is going to be reasonably small, which is a characteristic of network connections.",
            "Use upper 15 bits as a connection sequence number, so that listen socket handles are not reused within a short time period, reducing network connection conflicts.",
            "The top bit is reserved, so that listen socket handles and poll group handles come from a different namespace, enabling network resource isolation.",
            "Set the handle, which is a unique identifier for network communication, ensuring efficient data exchange.",
            "The global lock is required for network operations, ensuring data integrity across the network.",
            "We don't do map lookups, which reduces network latency and improves overall network performance.",
            "The number of listen sockets is small, making it easier to manage network resources and reduce network congestion."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AssignHandleAndAddToGlobalTable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Swap into a temp vector.  Our lock hygiene code doesn't want us to take a ShortDurationLock and then take any other locks. This is a common issue in networked applications where connections need to be managed.",
            "Now actually process the list.  We need the tables lock in order to remove connections from global tables. This involves network communication and data synchronization.",
            "want us to take a ShortDurationLock and then take any other locks. This can lead to network deadlocks if not handled properly.",
            "Now actually process the list.  We need the tables lock in order to remove connections from global tables. This requires a deep understanding of network protocols and data structures."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ProcessDeletionList.txt"
    },
    {
        "Branch": [
            "Check if condition is met in the network"
        ],
        "Loop": [
            "Loop through data in the network"
        ],
        "Normal": [
            "Re-calculate description in the network"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetAppName.txt"
    },
    {
        "Branch": [
            "To establish a connection, we need to check the network availability first."
        ],
        "Loop": [
            "We need to iterate through the network connections to find the active ones."
        ],
        "Normal": [
            "Yes, we need the global lock, too, because the description is often accessed while holding the global lock, but not the connection lock. We are currently connected to the network via a stable internet connection."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetDescription.txt"
    },
    {
        "Branch": [
            "If the certificate is not valid for the network protocol"
        ],
        "Loop": [
            "While the connection is active on the network"
        ],
        "Normal": [
            "Ug, we have to save off the private key.  I hate to have copies of the private key,",
            "but we'll only keep this around for a brief time.  It's possible for the",
            "interface to get a new cert (with a new private key) while we are starting this",
            "connection over the network.  We'll keep using the old one, which may be totally valid.",
            "Save off the signed certificate for the network",
            "If we are the client, then we can wrap up the network connection right now"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetLocalCert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Release network resources, marking as dead, clearing virtual IP, discarding unretrieved messages, removing from listen socket, clearing encryption keys, and destroying transport.",
            " NOTE: Once this happens, any table lookup that finds us will return NULL. So we basically don't exist to you if all you have is a handle",
            " Discard any messages that weren't retrieved",
            " If we are in a poll group, remove us from the group",
            " Detach from the listen socket that owns us, if any",
            " Make sure and clean out crypto keys and such now",
            " Clean up our transport"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 FreeResources.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Unlink it from existing poll group queue, if any. This is a common operation in network communication, where a connection is removed from one group and added to another.",
                    "Scan forward in the poll group message queue, until we find the insertion point. This is where the connection will be added to the new group, allowing for efficient transmission of data."
                ]
            },
            {
                "loopstr": [
                    "End of queue? This is a question often asked in network protocols, where the end of a queue or message is determined to ensure proper communication."
                ]
            }
        ],
        "Normal": [
            "Quick early-out for no change. In network communication, this means that if there are no changes to report, the operation can be completed quickly without unnecessary processing.",
            "Clearing it? This is a common operation in network protocols, where data is cleared or removed to make way for new information.",
            "Grab locks for old and new poll groups.  Remember, we can take multiple locks without worrying about deadlock because we hold the global lock. In network communication, locks are used to prevent multiple connections from accessing the same resource at the same time.",
            "Scan all messages that are already queued for this connection, and insert them into the poll groups queue in the (approximate) appropriate spot.  Using local timestamps should be really close for ordering messages between different connections.  Remember that the API very clearly does not provide strong guarantees regarding ordering of messages from different connections, and really anybody who is expecting or relying on such guarantees is probably doing something wrong. In network communication, messages are ordered to ensure proper delivery and processing.",
            "Tell previous poll group, if any, that we are no longer with them. This is a common operation in network protocols, where a connection is removed from one group and added to another.",
            "Link to new poll group. This is where the connection is added to the new group, allowing for efficient transmission of data."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetPollGroup.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Ensure network connection is established and ready for encryption.",
                    "If this fails, a CertFailed callback will be triggered with the appropriate code.",
                    "We can then decide on the next course of action.",
                    "Handle synchronous failure.",
                    "If fetching a certificate or trusted certificate list is in progress, wait for it to complete."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We possess a certificate, but it's near expiration. Wait for any ongoing fetch to finish.",
                    "Our peer may reject the certificate, and we should refresh our certificates well ahead of time.",
                    "If the request fails, a callback will be triggered, and we can attempt to proceed with an unsigned certificate.",
                    "Use this opportunity to refresh the certificate."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "This function should only be called from initial states.",
            "Do we already possess a certificate?",
            "When using an anonymous identity, always use self-signed certificates.",
            "CA's should never issue certificates for this identity, as it's meaningless.",
            "No peer should honor such a certificate.",
            "Check if a previous certificate attempt failed or if the current certificate is outdated.",
            "Already possess a signed certificate?",
            "Check if we want to intentionally disable authentication.",
            "Otherwise, we don't have a signed certificate (yet?)"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BThinkCryptoReady.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Make sure we care about this network protocol",
            " Setup with this network certificate",
            " Don't check state machine now, let's just schedule immediate wake up to deal with network communication"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 InterfaceGotCert.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "It should be in the secondary queue of the poll group",
                    " OK, do the work. This is related to the network connection."
                ]
            }
        ],
        "Normal": [
            " Scan all of our messages, and make sure they are not in the secondary queue. Network connection terminated.",
            " Remove us from the poll group's list. Network connection closed. DbgVerify because we should be in the list!",
            " We're not in a poll group anymore. Network connection lost."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 RemoveFromPollGroup.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note: order of operations is important between these two calls. This is crucial for network reliability.",
            " SNP_RecordReceivedPktNum assumes that TrackProcessSequencedPacket is always called first in the network sequence.",
            " Update general sequence number/stats tracker for the end-to-end flow in the network.",
            " Assume for now that network conditions are optimal.",
            " Let SNP know when we received it, so we can track loss events and send acks over the network.  We do not schedule acks to be sent at this time, but when they are sent, we will implicitly ack this one in the network flow."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 RecvNonDataSequencedPacket.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Ensure neither half is zero and verify recent connections",
                    "Check active connections and validate recent connections",
                    "Verify this connection is good and check active connections",
                    "This connection is good and verified"
                ]
            }
        ],
        "Normal": [
            "This function should only be called while in the initial state of Steam network connection",
            "Ensure MTU values are initialized and ready for use",
            "Verify the identity of the network connection",
            "Until connected, refrain from sending acknowledgments and other data",
            "Select a random connection ID and validate its sanity",
            "Release the table scope lock to proceed",
            "Configure network options as needed",
            "Bind user data to the connection, making it non-inheritable",
            "Set a description for debugging purposes",
            "Clear all previous settings and data",
            "Verify the network connection is still in the initial state",
            "Initiate the process of obtaining a certificate, or set an existing one",
            "Establish a single lane for communication"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BInitConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " We don't have a cert authority.  We probably ought to make this customizable for secure network communication."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AllowRemoteUnsignedCert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Should only do this once for secure network connection",
            "Select the ciphers we want to use for network encryption, in preference order.",
            "Also, lock it, we cannot change the network encryption any more"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetCryptoCipherList.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This is fatal: Certificate request failed due to network connection issues"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Make sure we care about this network state",
            "Do we require a signed certificate from the network?",
            "Schedule immediate wake up to check on network state machine"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CertRequestFailed.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Generate a keypair for local network",
            " Generate a local unsigned certificate",
            " Should we set an expiry for local unsigned certificate?  I mean it's unsigned, so it has zero value, so probably not",
            "s_msgCertLocal.set_time_created() for local network",
            " Serialize into signed message type for local network, although we won't actually sign it.",
            " Standard init, as if this were a normal local certificate"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetLocalCertUnsigned.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Allowed for this app? (Certificate verification failed)",
            "Check if we don't allow unsigned certs (Remote certificate validation failed)"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CheckRemoteCert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Modify user data for all incoming messages before processing to prevent client-side race conditions due to concurrent connection establishment and data installation.",
            " Prevent exposure of the client to unexpected race conditions by updating user data in real-time for all queued messages.",
            " Ensure seamless user data synchronization across all messages by modifying user data before processing, eliminating potential issues with concurrent connections and data updates.",
            " Update user data for all messages in the queue to guarantee consistent and accurate client-side data, avoiding potential race conditions and ensuring a smooth user experience."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetUserData.txt"
    },
    {
        "Branch": [
            "Base class - we will not attempt connections without a local certificate,",
            "unless we are running in a way that is configured without one"
        ],
        "Loop": [],
        "Normal": [
            "Base class - we will not attempt connections without a local certificate,",
            "unless we are running in a way that is configured without one."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AllowLocalUnsignedCert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Ensure secure data transmission by finalizing local crypto with public and private keys, setting protocol version, generating random numbers, and serializing and signing encryption keys.",
            " This operation should only be performed once to maintain data integrity.",
            " Establish a secure connection by setting the protocol version.",
            " Generate a key pair for secure key exchange.",
            " Generate additional randomness for the secret key to enhance encryption security.",
            " Serialize and sign the encryption key with the private key corresponding to this certificate.",
            " Note: In certain situations, this process may need to be repeated, so the key should not be wiped immediately.",
            " Clear the private key to ensure secure data transmission.",
            " This operation may be relevant to diagnostic state changes."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 FinalizeLocalCrypto.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Actually NOP, but makes me feel better",
                    "Encrypted handshake completed, key established"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Generated key pair for encryption: %02x%02x%02x%02x",
                    "Copy previous digest to use in generating the next one"
                ]
            }
        ],
        "Normal": [
            "Server awaits client's cipher preferences",
            "Client allows user to set connection options",
            "Mutually acceptable cipher selected",
            "MTU recalculated",
            "Server locks in cipher for encryption",
            "Client receives server's cipher info and prepares response",
            "Private key wiped from memory",
            "Diffie-Hellman key exchange initiated",
            "Premaster secret generated",
            "SpewMsg: premaster secret: %02x%02x%02x%02x",
            "Premaster secret discarded",
            "",
            "HMAC key derivation function initiated",
            "",
            "RFC 5869: Key derivation function",
            "Google QUIC documentation: Key derivation",
            "",
            "",
            "1. Extract premaster secret and mix for PRK",
            "",
            "",
            "2. Expand PRK to generate encryption keys",
            "",
            "Connection context buffer generated",
            "Connection ID(s) written into context buffer",
            "Encryption keys set and parameters configured",
            "",
            "Key droppings tidied up",
            "",
            "Unused memory freed",
            "Connection description set",
            "Remote host identified",
            "Encryption ready"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 FinishCryptoHandshake.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Send message through network connection"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APIFlushMessageOnConnection.txt"
    },
    {
        "Branch": [
            "Check Steam network connection"
        ],
        "Loop": [],
        "Normal": [
            "Set security flags",
            "Authenticate with Steam network"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionPopulateInfo.txt"
    },
    {
        "Branch": [
            "Send a connection request to the peer"
        ],
        "Loop": [],
        "Normal": [
            "You should override this, or your connection should not call it! This operation is related to the network connection."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SendEndToEndConnectRequest.txt"
    },
    {
        "Branch": [
            "If connection is established, then proceed with data transfer."
        ],
        "Loop": [
            "Loop until all data packets are sent or an error occurs."
        ],
        "Normal": [
            "Connection must be locked, but we don't require the global lock here! Connection establishment is a critical operation that requires exclusive access to the network resources.",
            "Copy end-to-end stats Network latency and packet loss are crucial factors in determining the overall network performance.",
            "Congestion control and bandwidth estimation are essential mechanisms to prevent network congestion and ensure efficient data transfer."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APIGetDetailedConnectionStatus.txt"
    },
    {
        "Branch": [
            "Check connection state to send message to network"
        ],
        "Loop": [
            "Iterate over connections to send message to network"
        ],
        "Normal": [
            "Connection must be locked to send message to network, but we don't require the global lock here!",
            "Check connection state to send message to network",
            "Fill out a message object to send over network",
            "Copy in the payload to send over network",
            "Implement connection-type specific logic to send message to network"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APISendMessageToConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Sending a message over the network connection requires the connection to be locked, but in this case, we don't need to acquire the global lock.",
            "Checking the connection state to ensure it's ready for communication.",
            "Creating a message object to be sent over the network.",
            "Copying the payload into the message object.",
            "Applying connection-type specific logic to handle the message transmission."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APISendMessageToConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Connection must be locked, but we don't require the global lock here! This is related to network connection management."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APIReceiveMessages.txt"
    },
    {
        "Branch": [
            "Check network condition before sending message.",
            "Send message over network."
        ],
        "Loop": [
            "Check network loop condition before sending message.",
            "Send message over network loop."
        ],
        "Normal": [
            " Message too big? Send over network.",
            " Pass to reliability layer over network."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 _APISendMessageToConnection.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Can SNP give us a more up-to-date value from the feedback packet? This requires a stable network connection.",
                    "Actual current data rates over the network."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "steamnetworkingsockets_connections_5569 APIGetRealTimeStatus.txt"
    },
    {
        "Branch": [
            "You should override this, or your connection should not call it! This is related to network type: Conditional Connection Request."
        ],
        "Loop": [
            "You should override this, or your connection should not call it! This is related to network type: Loopback Connection Request."
        ],
        "Normal": [
            "You should override this, or your connection should not call it! This is related to network type: Direct Connection Request."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BCanSendEndToEndConnectRequest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Hm. this failure really is probably a sign that we are in a pretty bad state, and we are unlikely to recover. Let the network receive the message data and the caller know about failure (this drops the connection).",
                    "The network receives the message data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Create a message on the network.",
            "Record lane and message number on the network.",
            "Copy the data on the network.",
            "The network receives the message data."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ReceivedMessageData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Scan the linked list to find the insertion point",
                    " Insert before this in the main queue for the connection",
                    " If there's a poll group, then insert immediately",
                    " before this message in that queue, too.",
                    " Unlock before we spew",
                    " NOTE - message could have been pulled out of the queue",
                    " and consumed by the app already here. Network processing involves redirecting messages to the messages endpoint owner, filling in message details, and emitting ETW events."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Check for redirecting it to the messages endpoint owner, ensuring network processing integrity.",
            " Fill in a few more details, including network-specific information.",
            " Emit ETW event, capturing network activity for analysis.",
            " We use the same lock to protect *all* recv queues, for both connections and poll groups, ensuring network data consistency.",
            " Check for messages are received out of order.  If the messages with a higher",
            " message number have not been removed from the queue, then we can correct this, maintaining network data integrity and order."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ReceivedMessage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u786e\u4fdd\u4ed6\u4eec\u6b63\u786e\u8f6c\u6362\u4e86\u8fde\u63a5\u72b6\u6001\uff0c\u63a5\u53d7\u8fdc\u7a0b\u8fde\u63a5\u3002",
                    "\u8fdc\u7a0b\u8fde\u63a5\u7684\u72b6\u6001\u8f6c\u6362\u6b63\u786e\u3002",
                    "\u8fdc\u7a0b\u8fde\u63a5\u7684\u72b6\u6001\u8f6c\u6362\u6210\u529f\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u5fc5\u987b\u5904\u4e8e\u5c31\u7eea\u72b6\u6001\u4ee5\u88ab\u63a5\u53d7\u7684\u8fdc\u7a0b\u8fde\u63a5\u3002",
            "\u4ec5\u5e94\u5728\u8fdc\u7a0b\u53d1\u8d77\u7684\u8fde\u63a5\u4e0a\u8c03\u7528\uff0c\u63a5\u53d7\u8fdc\u7a0b\u8fde\u63a5\u3002",
            "\u9009\u62e9\u5bc6\u94a5\u3002\u6211\u4eec\u9700\u8981\u7b49\u5230\u73b0\u5728\u624d\u80fd\u8fd9\u6837\u505a\uff0c\u56e0\u4e3a\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u5728\u65b0\u8fde\u63a5\u4e0a\u8bbe\u7f6e\u8fde\u63a5\u9009\u9879\uff0c\u4ee5\u4fbf\u63a5\u53d7\u8fdc\u7a0b\u8fde\u63a5\u3002",
            "\u6d3e\u751f\u7c7b\u77e5\u9053\u4e0b\u4e00\u6b65\u8be5\u505a\u4ec0\u4e48\u4ee5\u63a5\u53d7\u8fdc\u7a0b\u8fde\u63a5\u3002"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APIAcceptConnection.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Remote host initiated the connection.  All options below can be tweaked until the connection is established.",
                    " Connection establishment in progress."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Certain options cannot be changed after connection establishment."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " If connection is associated with an ad-hoc-style messages endpoint, let them process the state change and notify the application."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Do not post callbacks for internal failures during connection creation. Connection creation in progress."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " All connection state transitions require the global lock! Lock acquired.",
            " Remember when we entered this state. Current state: [state].",
            " Set wire state to [state].",
            " Certain connection options cannot be changed after a certain point. Options frozen.",
            " Post a notification when certain state changes occur.  Note that internal state changes are not relevant. Notification sent.",
            " Internal state change occurred. Connection effectively closed.",
            " Callbacks temporarily suppressed? Callbacks suppressed.",
            " Any time we switch into a state that is closed from an API perspective, discard any unread received messages. Messages discarded.",
            " Slam some stuff when we are in various states. State transition complete.",
            " Finally, hook for derived class to take action.  But not if we're dead. Action taken."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SetState.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "You need to establish a connection with other clients. This string is related to the network code."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AcceptConnection.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Update raw packet counters numbers, but do not update any logical state such as reply timeouts, etc. This is a security measure to ensure the integrity of the data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "No encryption is being used, which means the data is not secure. This is a potential security risk."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The packet is being dropped due to a potential security threat. This is done to prevent the impact of tampering or spoofing.",
                    "Update raw packet counters numbers, but do not update any logical state such as reply timeouts, etc. This is a security measure to ensure the integrity of the data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Sequence number should be initialized at this point to ensure proper protocol operation. This is a critical step to maintain the integrity of the data.",
            "Get the full end-to-end packet number to verify its authenticity and check if it should be processed.",
            "Determine the cipher being used to encrypt the data to ensure it is secure.",
            "Verify that the packet is from the peer and has not been tampered with. Check the gap to ensure it is within a reasonable limit.",
            "Reduce the packet rate to prevent losing the ability to keep sequence numbers in sync on each end.",
            "This is a theoretical limitation, but it's essential to maintain the integrity of the data.",
            "",
            "Even with half-full packets, 16k packets is around 9MB of data, which is a significant amount. We don't want to have this much un-acked data in our buffers.",
            "Use bigger packets with a lower rate to prevent this issue.",
            "If the app is trying to fill the pipe, our code should be sending mostly full packets, which means the gap is closer to 18MB.",
            "Decrypted ok. Track flow, and allow this packet to update the logical state, reply timeouts, etc."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 DecryptDataChunk.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Failed! if it's for a reliable message, then we must abort the connection. This requires a network connection.",
                    "If unreliable message....well we've spewed, but let's try to keep on chugging over the network."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Network monitoring.",
            "Check network limits",
            "Network status.",
            "Max network message size",
            "Max number of network messages buffered"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AllocateNewRecvMessage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u4f7f\u7528\u7279\u6b8a\u503c\u4ee5\u4fbf\u5728\u6211\u4eec\u7684\u5206\u6790\u4e2d\u68c0\u6d4b\u662f\u5426\u6709\u4eba\u5728\u6211\u4eec\u7684\u5206\u6790\u4e2d\u5b58\u5728\u6b64\u9519\u8bef",
                    "\u7f51\u7edc\u8fde\u63a5\u5173\u95ed\uff0c\u6839\u636e\u8fde\u63a5\u72b6\u6001\u548c\u539f\u56e0\u8fdb\u884c\u4e0d\u540c\u5904\u7406"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "\u7f51\u7edc\u8fde\u63a5\u5faa\u73af\u6761\u4ef6\uff0c\u6839\u636e\u8fde\u63a5\u72b6\u6001\u548c\u539f\u56e0\u8fdb\u884c\u4e0d\u540c\u5904\u7406"
        ],
        "Normal": [
            "\u5982\u679c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u95ee\u9898\u7684\u539f\u56e0\uff0c\u6211\u4eec\u5e94\u8be5\u5ffd\u7565\u4ed6\u4eec\u7684",
            "\u68c0\u67e5\u6211\u4eec\u7684\u72b6\u6001\u4ee5\u67e5\u770b\u5982\u4f55\u6cc4\u9732\uff0c\u5e76\u5904\u7406\u51e0\u4e2a\u5f02\u5e38\u60c5\u51b5",
            "\u5728\u6211\u4eec\u4e0d\u8fdb\u5165FinWait\u72b6\u6001\u7684\u60c5\u51b5\u4e0b",
            "\u8fdb\u5165FinWait\u72b6\u6001\u3002\u8fde\u63a5\u7279\u5b9a\u548c\u4f20\u8f93\u4ee3\u7801\u5e94\u76d1\u89c6\u6b64\u8f6c\u6362\u5e76\u53d1\u9001\u4efb\u4f55\u6e05\u9664\u5305\uff0c\u5e76\u8fdb\u5165\u7b49\u5f85\u5bf9\u7aef\u786e\u8ba4/\u91cd\u8bd5\u5173\u95ed\u6d88\u606f\u7684\u72b6\u6001",
            "\u7f51\u7edc\u8fde\u63a5\u6b63\u5e38\uff0c\u6839\u636e\u8fde\u63a5\u72b6\u6001\u548c\u539f\u56e0\u8fdb\u884c\u4e0d\u540c\u5904\u7406"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APICloseConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check network connection status or schedule a wake-up call to ensure stable network connectivity."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CheckConnectionStateOrScheduleWakeUp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check our state, we really should only transition into this state from one state. We are currently connected to the network.",
            "Schedule a wakeup call ASAP so we can start sending out packets immediately over the cellular network."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionState_FindingRoute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check our network state",
            "We don't have enough context to know if it's safe to act now due to network issues. Just schedule an immediate wake up call so we will update our network connection status and take action at the next safe time",
            "wake up call so we will update our network connection status and take action at the next safe time"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionState_ProblemDetectedLocally.txt"
    },
    {
        "Branch": [
            "Check the remote host's connection status when it closes the connection"
        ],
        "Loop": [],
        "Normal": [
            "Verify the connection status and update it when the remote host closes the connection"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionState_ClosedByPeer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check our state and adjust connection status to FinWait"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionState_FinWait.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Establishing network connection, updating connection status, and waking up the sender thread.",
            "Scheduling an immediate wakeup call to initiate packet sending once the connection is established."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionState_Connected.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Set some generic defaults. The network connection requires a successful handshake to proceed.",
            "Check if connection has a more enlightened understanding of what's wrong with the network connection.",
            "Switch connection state to reflect the current network status."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionTimedOut.txt"
    },
    {
        "Branch": [
            "Client connection request evaluation",
            "Check if client is allowed to connect",
            "Evaluate if client meets connection requirements"
        ],
        "Loop": [
            "Client connection retry loop",
            "Wait for client to reconnect",
            "Evaluate if client meets connection requirements"
        ],
        "Normal": [
            "Default behaviour for client periodically sending connect requests",
            "Ask transport if it's ready",
            "Nope, check back in just a bit.",
            "When to send next retry.",
            "attempt already in flight.  Wait until it's time to retry",
            "Send a request",
            "And wakeup when it will be time to retry"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ThinkConnection_ClientConnecting.txt"
    },
    {
        "Branch": [
            "Send message to network.",
            "Check if-conditions before sending."
        ],
        "Loop": [
            "Send message to network.",
            "Check loop-conditions before sending."
        ],
        "Normal": [
            "Send message to network.",
            "Check if message is too big before sending.",
            "Pass message to reliability layer for further processing."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 _APISendMessageToConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Use the fast path unless there is a messages endpoint related to network routing",
            "Link endpoints together to form a ring network",
            "Make sure initial identity is whatever the client used to initiate the connection, with network authentication",
            "We want these loopback connections to behave as similarly as possible to ordinary network connections",
            "Initialize client connection over the network.  This triggers a state transition callback to the connecting state",
            "to the connecting state, where network synchronization occurs",
            "Server receives the connection and starts accepting it over the network",
            "Client sends a connect packet through the network",
            "Now we wait for the app to accept the connection and establish a network link"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CreateLoopbackConnection.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Establish a Steam network connection pipeline object. Use the fast path unless there is a messages endpoint related to the Steam network.",
            "Link endpoints for Steam network connection.",
            "Ensure initial identity is whatever the client used to initiate the Steam network connection.  (E.g. FakeIP).",
            "Configure loopback connections to behave as similarly as possible to ordinary Steam network connections.",
            "Initialize client connection to the Steam network.  This triggers a state transition callback to the connecting state.",
            "Server receives the Steam network connection and starts accepting it.",
            "Client sends a connect packet over the Steam network.",
            "Now we wait for the app to accept the Steam network connection."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 CSteamNetworkConnectionPipe.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " We cannot do this while we have any reliable segments in flight! This is due to the network protocol's limitations.",
                    " To keep things simple, the retries are always the original segments, which is a common approach in network programming.",
                    " we never have our retries chop up the space differently than the original send, maintaining network consistency.",
                    "",
                    " FIXME - This could be a deal-breaker.  It might in practice prevent us from ever being able to reduce the MTU, affecting network performance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Max size of a reliable segment.  This is designed such that a reliable message of size k_cbSteamNetworkingSocketsMaxMessageNoFragment won't get fragmented, ensuring network efficiency.",
            " This is a network configuration setting, allowing for optimal MTU size selection.",
            " won't get fragmented, except perhaps in an exceedingly degenerate case.  (Even in this case, the protocol will function properly, it will just potentially fragment the message.)  We shouldn't make any hard promises in this department.",
            "",
            " 1 byte - message header",
            " 3 bytes - varint encode msgnum gap between previous reliable message.  (Gap could be greater, but this would be really unusual.)",
            " 1 byte - size remainder bytes (assuming message is k_cbSteamNetworkingSocketsMaxMessageNoFragment, we only need a single size overflow byte)"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 UpdateMTUFromConfig.txt"
    },
    {
        "Branch": [
            "Network connection timed out due to idle timeout"
        ],
        "Loop": [
            "Network connection timed out due to congestion"
        ],
        "Normal": [
            "Base class, just delegate to active transport, uses TCP/IP protocol"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionGuessTimeoutReason.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " We can use the fast path here, which delivers messages to the other side over a TCP socket.",
            " very efficiently, without taking the global lock or queuing stuff using UDP protocol.",
            " Don't post any state changes for these transitions.  We just want to immediately start in the connected state via socket pairing.",
            " Do generic base class initialization with socket settings.",
            " Exchange some dummy connect packets so that all of our internal variables (and ping) look as realistic as possible over a network connection.",
            " Tie the connections to each other, and mark them as connected using socket binding.",
            " Any further state changes are legit over the network."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 APICreateSocketPair.txt"
    },
    {
        "Branch": [
            "If condition failed due to network timeout"
        ],
        "Loop": [
            "Loop condition failed due to network timeout"
        ],
        "Normal": [
            "No enlightenments at base class. Network connection timed out."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 TransportGuessTimeoutReason.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "When network connection status changes, handle the network state change. If we have a transport, give it a chance to react to the state change related to the network type."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 ConnectionStateChanged.txt"
    },
    {
        "Branch": [
            "Accepting connections from connected connections, as per network code."
        ],
        "Loop": [
            "Accepting connections from connected connections, as per network code."
        ],
        "Normal": [
            "You need to override this if your connection type can be accepted. This may involve accepting connections from connected connections, as per network code."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 AcceptConnection.txt"
    },
    {
        "Branch": [
            "Send random message to connected network.",
            "bIsReliable = false;",
            "nBytes = 1200-13;"
        ],
        "Loop": [],
        "Normal": [
            "Send random message to connected network.",
            "bIsReliable = false;",
            "nBytes = 1200-13;"
        ],
        "FuncName": "test_connection_4955 SendRandomMessage.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "We need to acquire the global lock and our own lock for end-to-end statistics in the network.",
            "In order to do this, we also need to grab our partner's lock as well.",
            "To simulate a network request, we'll fake sending a ping request over the network.",
            "Next, we'll fake our partner receiving the request and sending a reply immediately.",
            "Finally, we'll receive the reply immediately and continue with the network statistics."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SendEndToEndStatsMsg.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528\u5feb\u901f\u8def\u5f84",
                    "\u5207\u6362\u5230\u8fde\u63a5\u72b6\u6001\u3002\u65e0\u72b6\u6001\u53d8\u5316\u56de\u8c03",
                    "\u6d88\u606f\u7aef\u70b9\u5c06\u5b8c\u6210\u8bbe\u7f6e",
                    "\u5728 Steam \u7f51\u7edc\u8fde\u63a5\u4e2d\uff0c\u8fde\u63a5\u8bf7\u6c42\u5c06\u88ab\u5904\u7406"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u6211\u4eec\u5fc5\u987b\u6709\u5168\u5c40\u9501\u548c\u4e24\u4e2a\u9501",
            "\u666e\u901a\u8fde\u63a5\u901a\u5e38\u5728\u6b64\u70b9\u5b66\u4e60\u5ba2\u6237\u8eab\u4efd\u548c\u8fde\u63a5 ID",
            "\u5982\u679c\u4ed6\u4eec\u8fde\u63a5\u5230\u6211\u4eec\u901a\u8fc7\u672c\u5730 FakeIP\uff0c\u6211\u4eec\u9700\u8981\u5efa\u7acb\u8054\u7cfb",
            "\u5206\u914d\u7ed9\u4ed6\u4eec\u7684\u4e34\u65f6 IP",
            "\u6a21\u4eff\u6211\u4eec\u5728\u6b64\u76d1\u542c\u5957\u63a5\u5b57\u4e0a\u8fdb\u5165",
            "\u5206\u914d\u8fde\u63a5 ID\uff0c\u521d\u59cb\u5316\u52a0\u5bc6\uff0c\u8f6c\u6362\u5230\\\u8fde\u63a5\\\u72b6\u6001\u3002Steam \u7f51\u7edc\u8fde\u63a5\u6b63\u5728\u5efa\u7acb",
            "\u63a5\u6536\u5ba2\u6237\u7aef\u7684\u52a0\u5bc6\u4fe1\u606f",
            "\u8fd9\u662f\u8fde\u63a5\u6d88\u606f\u4f1a\u8bdd",
            "\u8f6c\u6362\u5230\u8fde\u63a5\u72b6\u6001 Steam \u7f51\u7edc\u8fde\u63a5\u5df2\u5efa\u7acb"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BBeginAccept.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get the next packet number we would have sent, utilizing network protocol",
            "Fake sending stats, simulating network transmission"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 FakeSendStats.txt"
    },
    {
        "Branch": [
            "Send a request to establish an end-to-end connection based on the if-condition."
        ],
        "Loop": [
            "Send a request to establish an end-to-end connection based on the loop-condition."
        ],
        "Normal": [
            "You should override this, or your connection should not call it! This is a normal string related to network connection establishment."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 SendEndToEndConnectRequest.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Simulating receiver statistics.  For network code, this string represents a ping measurement received by a peer.  And assume every packet represents a ping measurement.",
            "Simulating receiver statistics.  For network code, this string represents a ping measurement received by a peer.  And assume every packet represents a ping measurement."
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 FakeRecvStats.txt"
    },
    {
        "Branch": [
            "We can only send end-to-end data if we have a stable network connection.",
            "We can only send end-to-end data if we are currently connected to the network.",
            "We can only send end-to-end data if we have a valid network address."
        ],
        "Loop": [
            "We can only send end-to-end data in a loop if we have a stable network connection.",
            "We can only send end-to-end data in a loop if we are currently connected to the network.",
            "We can only send end-to-end data in a loop if we have a valid network address."
        ],
        "Normal": [
            "We should only send end-to-end data if we still have a chance of connecting to the network.",
            "Once we detach from the partner network, we should switch the end-to-end data connection state, and",
            "the base class state machine should never send end-to-end data of this type"
        ],
        "FuncName": "steamnetworkingsockets_connections_5569 BCanSendEndToEndData.txt"
    }
]