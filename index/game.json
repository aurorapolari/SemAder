[
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Move a bit less than should to avoid oscillation in a game with smooth movement"
        ],
        "FuncName": "content_cao_9315 translate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Move a bit less than should to avoid oscillation in the game of Smooth Movement"
        ],
        "FuncName": "content_cao_9315 translate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check if the entity is forced to appear in first person. In a game like Half-Life, this could be used to create a sense of immersion by forcing the player to see the world from the entity's perspective."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "content_cao_9315 setChildrenVisible.txt"
    },
    {
        "Branch": [
            "video:IVideoDriver* driver = smgr->getVideoDriver(); If condition met, proceed with game logic.",
            "If condition not met, skip to next instruction.",
            "Check game state and make decisions accordingly."
        ],
        "Loop": [
            "video:IVideoDriver* driver = smgr->getVideoDriver(); Loop through game objects and perform necessary actions.",
            "Continue looping until condition is met or maximum iterations reached.",
            "Game logic dictates the loop duration and iteration count."
        ],
        "Normal": [
            "video:IVideoDriver* driver = smgr->getVideoDriver(); Set material properties and textures for 3D rendering.",
            "Assign material to mesh and prepare for rendering.",
            "Mesh is now ready for display with assigned material properties."
        ],
        "FuncName": "content_cao_9315 addToScene.txt"
    },
    {
        "Branch": [
            "Update node position: If statement applied in game development."
        ],
        "Loop": [],
        "Normal": [
            "Rotate node by 45 degrees around the y-axis: m_node->setRotation(v3f(0, 45, 0))"
        ],
        "FuncName": "content_cao_9315 updateNodePos.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Smoothly move the object towards the target value from the current value to avoid oscillation, a common mechanic in platformer games."
        ],
        "FuncName": "content_cao_9315 translate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "infostream << time = << time <<, rot.Y = << rot.Y << std::endl;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "content_cao_9315 step.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get the real position of an object in the world."
        ],
        "FuncName": "content_cao_9315 getPosition.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check if it's the current player",
                    "Verify player's identity in the game context"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "PROTOCOL_VERSION >= 37",
            "Ensure protocol version compatibility for game functionality"
        ],
        "FuncName": "content_cao_9315 processInitData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, objects attached to the local player should be hidden in first person, reflecting the game's mechanics where players' attachments are concealed from view when in first-person mode."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game scenario, forcibly showing attachments is required by the set_attach command, which is a crucial function in the game's attachment management system."
        ],
        "FuncName": "content_cao_9315 setAttachment.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Cannot use for-loop here: setAttachment() modifies 'm_attachment_child_ids'! In a game context, this might be related to character equipment or inventory management."
        ],
        "FuncName": "content_cao_9315 clearChildAttachments.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note: This sets the current frame as well, starting the animation. In the context of a game, this means the animation will now be executed."
        ],
        "FuncName": "content_cao_9315 updateAnimation.txt"
    },
    {
        "Branch": [
            "Scene Node Position Update: If Condition (rotation: 0, 45, 0)"
        ],
        "Loop": [],
        "Normal": [
            "Scene Node Position Update: Normal Node (rotation: 0, 45, 0)"
        ],
        "FuncName": "content_cao_9315 updateNodePos.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "infostream << dtime <<, rot.Y = << rot.Y << std::endl;"
                ],
                "elsestr": [
                    "Update game object position and rotation.",
                    "Update game object animation."
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Update game object position and rotation in a loop.",
                    "Update game object animation in a loop."
                ]
            }
        ],
        "Normal": [
            {
                "normalstr": [
                    "Update game object position and rotation normally.",
                    "Update game object animation normally."
                ]
            }
        ],
        "FuncName": "content_cao_9315 step.txt"
    },
    {
        "Branch": [
            "video::IVideoDriver* driver = smgr->getVideoDriver();",
            "Evaluate condition to determine if statement should be executed"
        ],
        "Loop": [
            "video::IVideoDriver* driver = smgr->getVideoDriver();",
            "Iterate through loop, evaluating condition on each iteration"
        ],
        "Normal": [
            "video::IVideoDriver* driver = smgr->getVideoDriver();",
            "Set material for rendering",
            "Add mesh to scene for rendering"
        ],
        "FuncName": "content_cao_9315 addToScene.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Yawpitch goes rightwards, related to game type: movement",
                    "Animation goes downwards, related to game type: animation"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Animation goes downwards, related to game type: animation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "content_cao_9315 updateTexturePos.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Update entire skeleton.",
                    "This is a typical scenario in game development where we need to update the skeleton's position and rotation."
                ],
                "elsestr": [
                    "In this case, we don't need to perform any updates."
                ]
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "When working with 3D graphics and game development, it's essential to check each bone for potential issues.",
                    "In this case, we're looking for a workaround for the Irrlicht bug.",
                    "This involves checking each bone to see if it has been rotated ~180deg from its expected position.",
                    "If the bug is detected, we update the bone to the proper position and update its transformation.",
                    "This ensures that the game's physics and rendering are accurate."
                ]
            },
            {
                "loopstr": [
                    "The root bone is a critical component of the skeleton, and we need to find it to continue the process."
                ]
            }
        ],
        "Normal": [
            "When rendering a 3D mesh, we need to write the positions to the mesh correctly.",
            "This involves searching through the bones to find any that may be mistakenly rotated due to the Irrlicht bug.",
            "To ensure that the attached objects are updated correctly, we need to propagate the bone positions.",
            "Unfortunately, Irrlicht doesn't handle this correctly when using EJUOR_CONTROL, so we need to implement a workaround."
        ],
        "FuncName": "content_cao_9315 updateBones.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This allows setting per-material colors. However, until a real lighting system is added, the code below will have no effect. Once MineTest has directional lighting, it should work automatically.",
                    "Set mesh color (only if lighting is disabled)",
                    "Updating game textures for MineTest game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Empty texture string means don't modify that material",
                    "Set material flags and texture",
                    "don't filter low-res textures, makes them look blurry",
                    "player models have a res of 64",
                    "Updating game textures for MineTest game"
                ]
            },
            {
                "loopstr": [
                    "This allows setting per-material colors. However, until a real lighting system is added, the code below will have no effect. Once MineTest has directional lighting, it should work automatically.",
                    "Updating game textures for MineTest game"
                ]
            },
            {
                "loopstr": [
                    "Set material flags and texture",
                    "This allows setting per-material colors. However, until a real lighting system is added, the code below will have no effect. Once MineTest has directional lighting, it should work automatically.",
                    "Updating game textures for MineTest game"
                ]
            }
        ],
        "Normal": [
            "Prevent showing the player after changing texture in MineTest game"
        ],
        "FuncName": "content_cao_9315 updateTextures.txt"
    },
    {
        "Branch": [
            "Check if the light source is within a certain range"
        ],
        "Loop": [
            "Iterate through the nodes to find the light source"
        ],
        "Normal": [
            "Skip center pos if it falls into the same node as Min or MaxEdge"
        ],
        "FuncName": "content_cao_9315 getLightPosition.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Delete nametag in [Game Name]"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Add nametag in [Game Name]"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "content_cao_9315 updateNametag.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Detach or don't attach. In Irrlicht game engine, this is used to detach or reattach an object from its parent."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "setPitchYawRoll(getPosRotMatrix(), m_attachment_rotation);, This is a code snippet from the Irrlicht game engine, used to set the pitch, yaw, and roll of an object's rotation matrix.",
                    "use Irrlicht eulers instead. In game development, Euler angles are used to represent the orientation of an object in 3D space."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Following cases exist: m_attachment_parent_id == 0 && !parent This object is not attached to any parent in the Irrlicht game engine. m_attachment_parent_id != 0 && parent This object is attached to a parent in the Irrlicht game engine. m_attachment_parent_id != 0 && !parent This object will be attached to a parent as soon as the parent is known in the Irrlicht game engine. m_attachment_parent_id == 0 && parent This is an impossible case in the Irrlicht game engine."
        ],
        "FuncName": "content_cao_9315 updateAttachments.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In CAO, visual effects for nametag props, textures, sprite props, and glow are updated separately by updateNametag(), updateTextures(), updateTexturePos(), and updateLight(). Other properties that don't affect appearance are also handled.",
            "CAO compares primitive types before std::vectors in ordered operations"
        ],
        "FuncName": "content_cao_9315 visualExpiryRequired.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "detect collision between convex objects and static planes, compute collision distance and position. report a contact. internally this will be kept persistent, and contact reduction is done in the context of a game engine."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "now perturb the convex world transform in a game-specific manner"
        ],
        "FuncName": "btConvexPlaneCollisionAlgorithm_2519 collideSingleContact.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Apply blunt trauma damage. Cap damage overlay to 1 second in [Game: Action RPG] where players can experience intense combat and character customization, with a focus on strategic decision-making and exploration."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "pre-condition in [Game: Strategy] where players build and manage their own settlements, gather resources, and defend against enemies, with a focus on resource management and base-building."
        ],
        "FuncName": "content_cao_9315 directReportPunch.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Remove duplicate connections in game logic."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remove adjacent duplicates in game connections."
        ],
        "FuncName": "RecastRegion_9587 removeAdjacentNeighbours.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of a game, Find cells revealed by the raised level is a common mechanic in puzzle games where players must uncover hidden cells or areas by raising the level or clearing obstacles."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In game development, mark as used is a common term used to indicate that a resource, such as a sprite or sound effect, has been utilized in the game. It's often used in game asset management to keep track of used versus unused assets."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In game programming, rcSwap source and dest is a common operation used in ray casting algorithms to swap the source and destination points, allowing the algorithm to traverse the game world more efficiently."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "RecastRegion_9587 expandRegions.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In a high-level game environment, the function is responsible for area filling, marking a given region and extending it to adjacent regions.",
                    "Expand neighbours."
                ]
            },
            {
                "loopstr": [
                    "In a high-level game environment, the function is responsible for area filling, marking a given region and extending it to adjacent regions. This is typically used for 8 connected regions.",
                    "Expand neighbours."
                ]
            }
        ],
        "Normal": [
            "In a high-level game environment, the function is responsible for area filling, marking a given region and extending it to adjacent regions."
        ],
        "FuncName": "RecastRegion_9587 floodRegion.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In a height field, the distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (-1,0) and (-1,-1).",
                    "The distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (-1,0) and (-1,-1)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a height field, the distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (0,-1) and (1,-1).",
                    "The distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (0,-1) and (1,-1)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a height field, the distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (1,0) and (1,1).",
                    "The distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (1,0) and (1,1)."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a height field, the distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (0,1) and (-1,1).",
                    "The distance field is calculated to determine the distance to the nearest boundary cell. The boundary cells are (0,1) and (-1,1)."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Calculate the distance field to determine the distance to the nearest boundary cell.",
            "Mark the boundary cells in the height field.",
            "Pass 1: Calculate the distance field.",
            "Pass 2: Refine the distance field."
        ],
        "FuncName": "RecastRegion_9587 calculateDistanceField.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Region is connected to border if one of the neighbours is null id. In the game, this is crucial for determining whether a region is accessible or not."
        ],
        "FuncName": "RecastRegion_9587 isRegionConnectedToBorder.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "post the news in the context of the game, such as posting a quest or a mission"
        ],
        "FuncName": "CGUIListBox_4076 selectNew.txt"
    },
    {
        "Branch": [
            "This is a conditional statement in the game, where the player's actions are dependent on certain conditions.",
            "The game checks the player's status and makes decisions based on the if-conditions.",
            "The if-condition is a fundamental concept in game development, allowing for complex interactions and scenarios."
        ],
        "Loop": [
            "This is a loop condition in the game, where the player's actions are repeated until a certain condition is met.",
            "The game uses a loop to iterate over a sequence of events or actions, making it easier to manage complex gameplay mechanics.",
            "The loop condition is essential in creating engaging and dynamic gameplay experiences."
        ],
        "Normal": [
            "this element can be tabbed to",
            "This element is accessible by keyboard navigation, allowing players to control the game without a mouse.",
            "The game's accessibility features, such as keyboard navigation, make it more inclusive for players with disabilities."
        ],
        "FuncName": "CGUIListBox_4076 CGUIListBox.txt"
    },
    {
        "Branch": [
            "If distance is greater than threshold, then",
            "If distance is less than threshold, then"
        ],
        "Loop": [
            "For each pixel in the image, calculate distance",
            "For each pixel in the image, update distance"
        ],
        "Normal": [
            "Blur",
            "Store distance."
        ],
        "FuncName": "RecastRegion_9587 rcBuildDistanceField.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In a GUI listbox, when the list is empty, the Selected value will be set to -1, which is a correct behavior.",
                    "Posting news is a common event in games, especially in role-playing games where players can receive updates on quests or storylines."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a GUI listbox, when the user types a character, the selection will change based on the text entered, allowing for quick navigation of the list.",
                    "To find the selected item, the game starts searching from the current selection, making it easier to locate items in the list.",
                    "If the key buffer matches the current item, the selection will not change, preventing accidental selection changes."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a GUI listbox, when a new key is pressed, it will be added to the key buffer, unless it's a repeated key press, which helps prevent unnecessary key presses from being registered."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CGUIListBox_4076 OnEvent.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Ensure border integrity by preventing overflow.",
                    "Paint regional boundaries."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Initialize timer for region division.",
                    "Copy remaining elements from previous level.",
                    "Stop timer for region division.",
                    "Expand regions until no empty adjacent cells exist.",
                    "Assign unique IDs to new regions."
                ]
            }
        ],
        "Normal": [
            "Optimize regional expansion: adjust formula to prevent overflow and simplify regions.",
            "Typically, a good indication of greediness is tied to agent radius.",
            "const int expandIters = 4 + walkableRadius * 2;",
            "Expand regions until no empty adjacent cells exist.",
            "Remove small regions.",
            "Output the resulting regions."
        ],
        "FuncName": "RecastRegion_9587 rcBuildRegions.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Ensure border stability in chess-like games.",
                    "Paint regions with unique colors."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Collect spans from this row in a puzzle game.",
                    "Create unique ID for each piece in a strategy game.",
                    "Remap IDs to match game board layout."
                ]
            },
            {
                "loopstr": [
                    "Move horizontally in a platformer.",
                    "Move vertically in a platformer."
                ]
            }
        ],
        "Normal": [
            "Mark border regions as obstacles in a racing game.",
            "Sweep one line at a time to find hidden objects.",
            "Filter out small regions to reduce game clutter.",
            "Store the result out as a game score."
        ],
        "FuncName": "RecastRegion_9587 rcBuildRegionsMonotone.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if the font changed, select the corresponding font style in the game",
            "draw background, display the game's background image",
            "draw items, display the game's items on the screen"
        ],
        "FuncName": "CGUIListBox_4076 draw.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "test limits with 6 degree of freedom angle restrictions"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 testAngularLimitMotor.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Clear accumulated impulses for the next simulation step",
                    "Calculates transform in 6DOF Jacobian matrix for game physics simulation",
                    "const btVector3& pivotAInW = m_calculatedTransformA.getOrigin();",
                    "const btVector3& pivotBInW = m_calculatedTransformB.getOrigin();",
                    "not used here",
                    "btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();",
                    "btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();",
                    "Linear and angular part of 6DOF Jacobian matrix",
                    "Angular part of 6DOF Jacobian matrix"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Create angular atom in 6DOF Jacobian matrix"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Calculates error angle in 6DOF Jacobian matrix"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "btGeneric6DofConstraint_8446 buildJacobian.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no need to apply force to motor with rotational limits"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "current error correction in rotational motor control",
            "current velocity difference in rotational motor control",
            "correction velocity for rotational motor",
            "correction impulse for rotational motor",
            "clip correction impulse for rotational motor",
            "should clip accumulated impulse in rotational motor control",
            "sort accumulated impulses in rotational motor control"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 solveAngularLimits.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of 6-degree-of-freedom constraints in the game, we do not actually constrain the angular velocity in euler angle mode along the axes axis[0] and axis[2] (although we do use axis[1]):",
            "",
            "To get the constraint for angle[0], we need to constrain w2-w1 along the axis ax[1] x ax[2] = ax[0].",
            "------\t\t\t---------------------\t\t------",
            "d(angle[0])/dt = 0\tax[1] x ax[2]\t\t\tax[0]",
            "d(angle[1])/dt = 0\tax[1]",
            "d(angle[2])/dt = 0\tax[0] x ax[1]\t\t\tax[2]",
            "",
            "Constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0. In the game context, this translates to the constraint on the angular velocity.",
            "To prove the result for angle[0], write the expression for angle[0] from GetInfo1 then take the derivative. To prove this for angle[2] it is easier to take the euler rate expression for d(angle[2])/dt with respect to the components of w and set that to 0."
        ],
        "FuncName": "btGeneric6DofConstraint_8446 calculateAngleInfo.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\\t// rot =  cy*cz          -cy*sz           sy  (Rotation around X-axis)",
            "\\t//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx  (Rotation around Y-axis)",
            "\\t//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy  (Rotation around Z-axis)",
            ""
        ],
        "FuncName": "btGeneric6DofConstraint_8446 matrixToEulerXYZ.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "/find relative velocity of motorcycle with displacement constraints",
            "btVector3 rel_pos1 = pointInA - body1.getCenterOfMassPosition();",
            "btVector3 rel_pos2 = pointInB - body2.getCenterOfMassPosition();",
            "/apply displacement correction to motorcycle's linear axis",
            "positional error (zeroth order error) of motorcycle's linear axis",
            "handle displacement limits of motorcycle's linear axis"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 solveLinearAxis.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Free from violation, within the rotation limit range."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "low limit violation, rotation limit exceeded."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "High limit violation, rotation limit exceeded."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Free from violation, within the rotation limit range."
        ],
        "FuncName": "btGeneric6DofConstraint_8446 testLimitValue.txt"
    },
    {
        "Branch": [
            "Initialize RaycastVehicle instance for conditional rendering"
        ],
        "Loop": [
            "Initialize RaycastVehicle instance for looped rendering"
        ],
        "Normal": [
            "fixed update() for inputs and post update() to sync wheels for rendering",
            "The RaycastVehicle instance is initialized for normal game rendering."
        ],
        "FuncName": "RaycastVehicle_7997 RaycastVehicle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Size of response is unknown, so just set maximum value. The position will also be changed in the game world.",
            " After receiving the response, the worker thread will signal end for Deserializer::IsEof() and update the game state.",
            " Start the worker thread to create the network connection and retrieve the game response data."
        ],
        "FuncName": "HttpRequest_3557 HttpRequest.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "While no bytes and connection is still open, block until has some data. In the context of a game, this could mean waiting for player input or network data to proceed with the game logic."
                ]
            }
        ],
        "Normal": [
            "Threading disabled, nothing to read. In a game scenario, this could indicate that the game is not utilizing multi-threading, resulting in an idle state with no data to process."
        ],
        "FuncName": "HttpRequest_3557 Read.txt"
    },
    {
        "Branch": [
            "set 6DOF angle constraints"
        ],
        "Loop": [],
        "Normal": [
            "solve angular limits with 6DOF constraints"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 setAngularLimits.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "re-use rotational motor code",
                    "used in 6-DOF game to set linear limits"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "rotations around orthos to current axis",
                    "used in 6-DOF game to set linear limits"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "int row = 0;",
            "solve linear limits in 6-DOF game"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 setLinearLimits.txt"
    },
    {
        "Branch": [
            "Check if vehicle is initialized before proceeding",
            "Verify vehicle initialization status"
        ],
        "Loop": [],
        "Normal": [
            "Delete old vehicle and action first",
            "Initialize vehicle physics components, ensuring a stable and realistic driving experience"
        ],
        "FuncName": "RaycastVehicle_7997 Init.txt"
    },
    {
        "Branch": [
            "Set axis constraints for 6 DOF in game",
            "Check if axis constraints are set in game"
        ],
        "Loop": [
            "Iterate through axis constraints in game",
            "Loop through each axis constraint in game"
        ],
        "Normal": [
            " we want right coordinate system in game",
            " now get constraint frame in local coordinate system of game"
        ],
        "FuncName": "btGeneric6DofConstraint_8446 setAxis.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if the joint is powered, or has joint limits, add in the extra row",
                    "if we're limited low and high simultaneously, the joint motor is",
                    "ineffective",
                    "This is a constraint in a 6D simulation, where the joint is subject to",
                    "velocity and acceleration constraints, and possibly also powered by a motor."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "get vector from bodyB to frameB in WCS",
                    "get its projection to constraint axis",
                    "get vector directed from bodyB to constraint axis (and orthogonal to it)",
                    "same for bodyA",
                    "get desired offset between frames A and B along constraint axis",
                    "desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis",
                    "get offset vectors relA and relB",
                    "This is a constraint in a 6D simulation, where the joint is subject to",
                    "position and velocity constraints, and possibly also subject to a spring-damper",
                    "force."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "limited low and high simultaneously",
                    "This is a constraint in a 6D simulation, where the joint is subject to",
                    "velocity and acceleration constraints, and possibly also subject to",
                    "a motor torque."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "calculate joint velocity",
                    "only apply bounce if the velocity is incoming, and if the",
                    "resulting c[] exceeds what we already have.",
                    "This is a constraint in a 6D simulation, where the joint is subject to",
                    "velocity and acceleration constraints, and possibly also subject to",
                    "a spring-damper force."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "make sure that if no body -> angVelB == zero vec",
                    "if (body1)",
                    "This is a constraint in a 6D simulation, where the joint is subject to",
                    "position and velocity constraints, and possibly also subject to",
                    "a motor torque."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "btGeneric6DofConstraint_8446 get_limit_motor_info2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initialize vehicle physics components, ensuring a stable and realistic driving experience in the game."
        ],
        "FuncName": "RaycastVehicle_7997 Init.txt"
    },
    {
        "Branch": [
            "Get wheel data from game"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Get wheel data for loop iteration 14"
                ]
            }
        ],
        "Normal": [
            "Get wheel data from game"
        ],
        "FuncName": "RaycastVehicle_7997 GetWheelDataAttr.txt"
    },
    {
        "Branch": [
            "Compare the first max characters of two strings in game code."
        ],
        "Loop": [],
        "Normal": [
            "Compare the first max characters of two strings in game code, they are equal this far."
        ],
        "FuncName": "rawstr_2801 Curl_raw_nequal.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "input order in a triangular maze"
        ],
        "FuncName": "vcacheoptimizer_9994 getNextTriangleDeadEnd.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Will it be cached in the next frame of the game \"Battle Royale\"?"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The cached position in the game \"Fortnite\""
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Otherwise, we don't need to handle it in the game loop of \"League of Legends\""
                ]
            }
        ],
        "Normal": [],
        "FuncName": "vcacheoptimizer_9994 getNextVertexNeighbour.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "check dead-end stack for game progression",
            "input order based on game rules"
        ],
        "FuncName": "vcacheoptimizer_9994 getNextVertexDeadEnd.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "allocate arrays for triangle rendering",
            "fill triangle counts for efficient rendering",
            "fill offset table for quick access",
            "fill triangle data with vertex information",
            "fix offsets that have been disturbed by the previous rendering pass"
        ],
        "FuncName": "vcacheoptimizer_9994 buildTriangleAdjacency.txt"
    },
    {
        "Branch": [
            "Mesh optimization: optimizing vertex cache table to reduce vertex access frequency and improve performance"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Updating loop counters and emitted flags to ensure efficient iteration",
                    "Processing new triangles and updating live triangle counts",
                    "Removing emitted triangles from adjacency data to reduce traversal time",
                    "Updating cache positions and scores to find next best triangle",
                    "Stepping through input triangles in order when encountering a dead-end"
                ]
            },
            {
                "loopstr": [
                    "Updating vertex scores and triangle scores to reflect changes"
                ]
            }
        ],
        "Normal": [
            "Ensuring mesh integrity by checking for empty meshes",
            "Supporting in-place optimization for efficient mesh processing",
            "Building adjacency information to facilitate efficient traversal",
            "Tracking live triangle counts for optimal performance",
            "Managing emitted flags to control iteration",
            "Computing initial vertex scores to guide optimization",
            "Calculating triangle scores to evaluate mesh quality"
        ],
        "FuncName": "vcacheoptimizer_9994 meshopt_optimizeVertexCacheTable.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "get out of the loop as soon as they don't match",
                    "in a game, this might be a puzzle or a challenge where players must find a way to exit a loop or pattern"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "we do the comparison here (possibly again), just to make sure that if the loop above is skipped because one of the strings reached zero, we must not return this as a successful match",
            "in a game, this might be a mechanic where players must carefully compare and analyze information to progress"
        ],
        "FuncName": "rawstr_2801 Curl_raw_equal.txt"
    },
    {
        "Branch": [
            "Validate the condition for if statement in game logic"
        ],
        "Loop": [
            "Validate the condition for loop statement in game logic"
        ],
        "Normal": [
            "TODO: validate markClass & currentClass in game validation process"
        ],
        "FuncName": "gxvjust_9095 gxv_just_classTable_entry_validate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "actionClass is related with justClass using 7bit only in the context of Just Act Subrecord validation ",
            "Stretch glyph action: no actionData in the game of Just Act Subrecord validation "
        ],
        "FuncName": "gxvjust_9095 gxv_just_actSubrecord_validate.txt"
    },
    {
        "Branch": [
            "Validates the condition for if-statement in game code."
        ],
        "Loop": [
            "Validates the condition for loop-statement in game code."
        ],
        "Normal": [
            "Validates the subtable length for game code using gxv_LookupTable_validate."
        ],
        "FuncName": "gxvjust_9095 gxv_just_justData_lookuptable_validate.txt"
    },
    {
        "Branch": [
            "Verifying width offset alignment table entry for if-conditions in game code"
        ],
        "Loop": [
            "Verifying width offset alignment table entry for loop conditions in game code"
        ],
        "Normal": [
            "According to Apple spec, only 7bits in justClass is used. This is a crucial aspect of width offset alignment in game development, ensuring efficient memory allocation and data access."
        ],
        "FuncName": "gxvjust_9095 gxv_just_wdp_entry_validate.txt"
    },
    {
        "Branch": [
            "Apple misspelled Threshold in type2 game"
        ],
        "Loop": [],
        "Normal": [
            "Apple misspelled Threshold in type2 game"
        ],
        "FuncName": "gxvjust_9095 gxv_just_actSubrecord_type2_validate.txt"
    },
    {
        "Branch": [
            "If condition is validated by PC lookup table"
        ],
        "Loop": [
            "Loop condition is validated by PC lookup table"
        ],
        "Normal": [
            "subtable_length is set by gxv_LookupTable_validate, ensuring PC lookup table validity"
        ],
        "FuncName": "gxvjust_9095 gxv_just_pcLookupTable_validate.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Validates if-conditions in just just class tables."
        ],
        "Loop": [
            "Loop-Condition-Str: Validates loop conditions in just just class tables."
        ],
        "Normal": [
            "subtable_length is set by gxv_LookupTable_validate, which is a crucial step in just just class table validation."
        ],
        "FuncName": "gxvjust_9095 gxv_just_justClassTable_validate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "end of previous buffer. A material and a mesh should be there. This is the beginning of the IRRMESH file parsing process, where we expect to find a material and a mesh."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This is possible ... remove the mesh from the list and skip further reading. In this case, we can safely skip the current mesh and move on to the next one."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "We have a second texture! So use this UV channel, for it. The 2nd texture can be either a normal, texture (solid_2layer or lightmap_xxx) or a normal, map (normal_..., parallax_...). This is a special case where we need to use a specific UV channel for the second texture."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read vertices. In this step, we read the vertex data from the IRRMESH file."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "read indices, Finish processing the mesh - do some small material workarounds. After reading the indices, we need to perform some additional processing on the mesh, including material workarounds."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Take the opacity value of the current material, from the common vertex color alpha. In this step, we extract the opacity value from the vertex color alpha channel."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "clean this value ... This is a loop condition where we need to clean up some temporary values."
                ]
            }
        ],
        "Normal": [
            "Check whether we can read from the file. This is the first step in the IRRMESH file parsing process, where we check if we can read from the file.",
            "Construct the irrXML parser. After checking if we can read from the file, we construct the irrXML parser to parse the XML data.",
            "final data, temporary data - current mesh buffer, some temporary variables. These are intermediate steps where we process the XML data and store temporary values.",
            "0 = normal; 1 = 2 tcoords, 2 = tangents. This is a special case where we need to handle different types of data, including normals, tcoords, and tangents.",
            "Parse the XML file. In this step, we parse the XML file using the irrXML parser.",
            "End of the last buffer. A material and a mesh should be there. This is the end of the IRRMESH file parsing process, where we expect to find a material and a mesh.",
            "now generate the output scene. After parsing the XML file, we generate the output scene.",
            "clean up and return. Finally, we clean up any temporary values and return the output scene."
        ],
        "FuncName": "IRRMeshLoader_2422 InternReadFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Loads and parses a PVR image file. This is used in PVR game code."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "PvrParserTest_8623 main.txt"
    },
    {
        "Branch": [
            "In IF-Condition, the condition is validated in just data to determine the game flow."
        ],
        "Loop": [
            "In Loop-Condition, the loop is iterated based on the validated condition in just data."
        ],
        "Normal": [
            "following 3 offsets are measured from the start of just not justData, which is crucial for the game's logic and behavior in the IF-Condition and Loop-Condition scenarios."
        ],
        "FuncName": "gxvjust_9095 gxv_just_justData_validate.txt"
    },
    {
        "Branch": [
            "If the navigation grid query is initialized, check the open list size too"
        ],
        "Loop": [
            "Loop through the navigation grid query"
        ],
        "Normal": [
            " TODO check the open list size too"
        ],
        "FuncName": "DetourNavMeshQuery_5701 init.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculate quantized box. This is related to the game's physics engine.",
                    "dtClamp query box to world box. This is a common operation in game development.",
                    "Quantize. This is a key step in polygon traversal.",
                    "Traverse tree. This is related to the game's scene management system."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Do not return off-mesh connection polygons. This is a common issue in game rendering.",
                    "Must pass filter. This is related to the game's graphics pipeline.",
                    "Calc polygon bounds. This is a key step in polygon rendering."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DetourNavMeshQuery_5701 queryPolygonsInTile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculate area of the polygon.",
                    "Select a random polygon based on area, using reservoir sampling."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Retrieve polygon and tile data.",
                    "Internal data has been checked by the API, skip redundant checks.",
                    "Randomly place locations on the ground surface.",
                    "Obtain parent polygon and tile data."
                ]
            },
            {
                "loopstr": [
                    "Ignore invalid neighbors and do not backtrack to the parent.",
                    "Expand to adjacent neighbors.",
                    "Do not proceed if the polygon is excluded by the filter.",
                    "Find the edge and calculate the distance to it.",
                    "If the circle does not touch the next polygon, skip it.",
                    "Calculate the cost.",
                    "Skip if the node is already in the open list and the new result is worse."
                ]
            }
        ],
        "Normal": [
            "Validate input data.",
            "Randomly select a point on the polygon."
        ],
        "FuncName": "DetourNavMeshQuery_5701 findRandomPointAroundCircle.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Find the point on the polygon edge closest to the given point."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Collect vertices."
        ],
        "FuncName": "DetourNavMeshQuery_5701 closestPointOnPolyBoundary.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Point is outside the polygon, dtClamp to nearest edge. In the game, this is handled by the AI to navigate through the grid."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Off-mesh connections don't have detail polygons. In the game, this is represented by a flat surface.",
            "Clamp point to be inside the polygon. This is essential for the game's collision detection system.",
            "Find height at the location. The game uses this information to render the terrain accurately."
        ],
        "FuncName": "DetourNavMeshQuery_5701 closestPointOnPoly.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the game, when the condition is met, reset the query."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the game, when the special case is met, the search starts and ends at the same polygon."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game, reset the query."
        ],
        "FuncName": "DetourNavMeshQuery_5701 finalizeSlicedFindPathPartial.txt"
    },
    {
        "Branch": [
            "Find tiles the query touches. In a grid-based game, this typically involves checking the tiles adjacent to the query's current location."
        ],
        "Loop": [
            "Find tiles the query touches. In a grid-based game, this typically involves checking a set of tiles within a specific range of the query's current location."
        ],
        "Normal": [
            "Find tiles the query touches."
        ],
        "FuncName": "DetourNavMeshQuery_5701 queryPolygons.txt"
    },
    {
        "Branch": [
            "Initialization of path query. If condition: "
        ],
        "Loop": [
            "Initialization of path query. Loop condition: "
        ],
        "Normal": [
            "Initialization of path query. Normal state: Init path state.",
            "Initialization of path query. Normal state: Validate input"
        ],
        "FuncName": "DetourNavMeshQuery_5701 initSlicedFindPath.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Append portals along the current straight path segment.",
                    "This action is specific to finding straight line paths in the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Next portal.",
                    "If starting really close the portal, advance.",
                    "This step is crucial in navigating through the game's environment."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Failed to get portal points, in practice this means that path[i+1] is invalid polygon.",
                    "Clamp the end point to path[i], and return the path so far.",
                    "Append portals along the current straight path segment.",
                    "The game's pathfinding algorithm encounters an issue here."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This should only happen when the first polygon is invalid.",
                    "The game's geometry is not as expected, causing a problem."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Right vertex.",
                    "Left vertex.",
                    "In the context of the game, these vertices play a crucial role in pathfinding."
                ]
            }
        ],
        "Normal": [
            "TODO: Should this be callers responsibility?",
            "Add start point.",
            "These statements are related to the game's pathfinding functionality."
        ],
        "FuncName": "DetourNavMeshQuery_5701 findStraightPath.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tile border. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Internal edge, encode id. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Wall edge, calc distance. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Update nearest distance. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Reverse the path, Store result. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Pop front, Get poly and tile, The API input has been checked already, skip checking internal data, Collect vertices, If target is inside the poly, stop search, Find wall edges and find nearest point inside the walls. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ]
            },
            {
                "loopstr": [
                    "Find links to neighbours. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ]
            },
            {
                "loopstr": [
                    "Skip if no node can be allocated, Skip if already visited, Skip the link if it is too far from search constraint, TODO: Maybe should use getPortalPoints(), but this one is way faster, Mark as the node as visited and push to queue. Pathfinding in a given navmesh, finding the shortest path from start position to end position."
                ]
            }
        ],
        "Normal": [
            "Validate input, Pathfinding in a given navmesh, finding the shortest path from start position to end position.",
            "Search constraints, Pathfinding in a given navmesh, finding the shortest path from start position to end position."
        ],
        "FuncName": "DetourNavMeshQuery_5701 moveAlongSurface.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Find shortest path in navmesh from start to end, cost calculation included."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Update node location in navmesh, already in open list."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Remove node from open list and put it in closed list in navmesh.",
                    "Stop searching in navmesh, reached the goal.",
                    "Get current poly and tile in navmesh.",
                    "Skip checking internal data in navmesh, already done.",
                    "Get parent poly and tile in navmesh."
                ]
            },
            {
                "loopstr": [
                    "Skip invalid ids and do not expand back to where we came from in navmesh.",
                    "Get neighbour poly and tile in navmesh.",
                    "Skip checking internal data in navmesh, already done.",
                    "Calculate node position in navmesh if visited first time.",
                    "Calculate cost and heuristic in navmesh.",
                    "Special case for last node in navmesh.",
                    "Skip updating node in navmesh if already in open list and new result is worse.",
                    "Skip processing node in navmesh if already visited and new result is worse.",
                    "Add or update node in navmesh.",
                    "Update nearest node to target so far in navmesh."
                ]
            }
        ],
        "Normal": [
            "Validate input for navmesh search.",
            "Reverse the path found in navmesh.",
            "Store the path in navmesh."
        ],
        "FuncName": "DetourNavMeshQuery_5701 findPath.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Reset query. In game, this is used to reset the player's position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case: the search starts and ends at same poly. In game, this is used to handle cases where the player starts and ends at the same location."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Reset query. In game, this is used to reset the player's query status."
        ],
        "FuncName": "DetourNavMeshQuery_5701 finalizeSlicedFindPath.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of [game] development, skip intersection if only area crossings are requested, which is a common consideration in game physics and collision detection."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In [game] terms, calculate portal, which refers to the process of determining the intersection of two or more objects in a game world, and append intersection, which is the act of updating the game's intersection data structure with the newly calculated intersection point.",
                    "In the game development process, portal calculation is crucial for determining collisions, and appending intersection is essential for updating the game's state accordingly."
                ]
            }
        ],
        "Normal": [
            "In game development, append or update last vertex, which refers to the process of adding new data points to the game's vertex buffer, often used for rendering and collision detection purposes."
        ],
        "FuncName": "DetourNavMeshQuery_5701 appendPortals.txt"
    },
    {
        "Branch": [
            "If the axis sweep is not a 32-bit integer, the game will crash."
        ],
        "Loop": [
            "The game will loop indefinitely if the axis sweep is not a 32-bit integer."
        ],
        "Normal": [
            "1 handle is reserved as sentinel. In the game, this handle is used to represent the axis sweep."
        ],
        "FuncName": "btAxisSweep3_5762 bt32BitAxisSweep3.txt"
    },
    {
        "Branch": [
            "check if the player collided with an obstacle"
        ],
        "Loop": [],
        "Normal": [
            "at least store the applied impulses, and update the player's velocity accordingly"
        ],
        "FuncName": "btMultiBodyPoint2Point_8347 btMultiBodyPoint2Point.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tile border. Solid object detection and border formation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip non-solid edges. Iterative edge inspection and filtering.",
                    "Add sentinels. Boundary marker placement.",
                    "Store segments. Edge data storage and management."
                ]
            },
            {
                "loopstr": [
                    "Portal segment. Portal edge identification and handling.",
                    "Wall segment. Wall edge detection and processing."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DetourNavMeshQuery_5701 getPolyWallSegments.txt"
    },
    {
        "Branch": [
            "Invalid polygon reference detected. Polygon not found.",
            "Polygon reference is invalid."
        ],
        "Loop": [],
        "Normal": [
            "Polygon not found. Assuming non-existent polygon and invalid boundary.",
            "Filter failed. Assuming flag changes and invalid boundary."
        ],
        "FuncName": "DetourNavMeshQuery_5701 isValidPolyRef.txt"
    },
    {
        "Branch": [
            "If the game condition is met, the player will proceed to the next level"
        ],
        "Loop": [
            "The game loop will continue until the player reaches the end of the level"
        ],
        "Normal": [
            "The game initializes the game world, including the player and the environment. This is the starting point of the game."
        ],
        "FuncName": "btAxisSweep3_5762 btAxisSweep3.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Could not hit the polygon, keep the old t and report hit. In NavMesh, this means the ray did not intersect with the polygon's boundary, so we need to keep the previous intersection point and report a hit."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Calculate link size. In NavMesh, this involves determining the length of the link between two polygons, which is crucial for pathfinding and collision detection.",
                    "Find Z intersection. This step is essential for resolving Z-fighting issues in NavMesh, where two polygons may have the same Z-coordinate, causing rendering problems."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Calculate link size. Similar to the previous step, this involves determining the length of the link between two polygons.",
                    "Find X intersection. This step is critical for resolving X-fighting issues in NavMesh, where two polygons may have the same X-coordinate, causing rendering problems."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "No neighbour, we hit a wall. In NavMesh, this means the ray has reached a polygon that does not have any adjacent polygons, indicating a boundary or a wall.",
                    "Calculate hit normal. This step is essential for determining the normal vector of the hit polygon, which is necessary for various NavMesh operations, such as collision detection and response."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Cast ray against current polygon. In NavMesh, this involves testing whether the ray intersects with the current polygon's boundary.",
                    "The API input has been checked already, skip checking internal data. This step ensures that the NavMesh algorithm only performs necessary checks, reducing computational overhead.",
                    "Collect vertices. This step is crucial for gathering the vertices of the current polygon, which are necessary for various NavMesh operations.",
                    "Keep track of furthest t so far. This step is essential for maintaining the maximum intersection distance, which is necessary for resolving ambiguities in NavMesh.",
                    "Store visited polygons. This step is necessary for keeping track of the polygons that have been visited during the NavMesh algorithm's execution.",
                    "Ray end is completely inside the polygon. In NavMesh, this means the ray's endpoint lies within the current polygon, indicating a hit.",
                    "Follow neighbours. This step involves traversing the adjacency list of the current polygon to find its neighboring polygons.",
                    "No hit, advance to neighbour polygon. If the ray does not intersect with the current polygon, this step advances the algorithm to the next neighboring polygon."
                ]
            },
            {
                "loopstr": [
                    "Find link which contains this edge. In NavMesh, this involves identifying the link that contains the given edge.",
                    "Get pointer to the next polygon. This step is necessary for accessing the next polygon in the NavMesh algorithm's traversal.",
                    "Skip off-mesh connections. This step ensures that the algorithm skips links that are not part of the NavMesh, reducing unnecessary computations.",
                    "Skip links based on filter. This step applies a filter to skip links that do not meet certain criteria, such as being internal or spanning the whole edge.",
                    "If the link is internal, just return the ref. If the link is internal, this step returns a reference to the link, as it is not necessary to traverse further.",
                    "If the link is at tile boundary, Check if the link spans the whole edge, and accept. This step checks whether the link spans the entire edge, and if so, accepts it as a valid link.",
                    "Check for partial edge links. This step ensures that the algorithm checks for links that only partially span the edge, and handles them accordingly.",
                    "Check that the intersection lies inside the link portal. This step verifies that the intersection point lies within the link portal, ensuring that the link is valid."
                ]
            }
        ],
        "Normal": [
            "Validate input. In NavMesh, this step ensures that the input data is valid and consistent, preventing errors and inconsistencies in the algorithm's execution."
        ],
        "FuncName": "DetourNavMeshQuery_5701 raycast.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Pop the front element.",
                    "Get the polygon and tile.",
                    "The API input has been checked already, skip checking internal data."
                ]
            },
            {
                "loopstr": [
                    "Skip invalid neighbors.",
                    "Skip if cannot allocate more nodes.",
                    "Skip visited.",
                    "Expand to neighbor",
                    "Skip off-mesh connections.",
                    "Do not advance if the polygon is excluded by the filter.",
                    "Find edge and calculate distance to the edge.",
                    "If the circle is not touching the next polygon, skip it.",
                    "Mark node visited, this is done before the overlap test so that we will not visit the poly again if the test fails.",
                    "Check that the polygon does not collide with existing polygons.",
                    "Collect vertices of the neighbor poly.",
                    "This poly is fine, store and advance to the poly."
                ]
            },
            {
                "loopstr": [
                    "Connected polys do not overlap.",
                    "Potentially overlapping.",
                    "Get vertices and test overlap"
                ]
            }
        ],
        "Normal": [
            "Validate input"
        ],
        "FuncName": "DetourNavMeshQuery_5701 findLocalNeighbourhood.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Tile border. The game type is a 2D grid-based game, where the player must navigate through tiles to reach the goal."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Internal edge In a game where the player must navigate through a maze, an internal edge represents a wall that blocks the player's path."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Get poly and tile. In a game where the player must collect tiles, this step retrieves the current tile and its properties.",
                    "The API input has been checked already, skip checking internal data. This is an optimization step to reduce unnecessary calculations.",
                    "Get parent poly and tile. In a game where the player must navigate through a hierarchical structure, this step retrieves the parent tile and its properties.",
                    "Hit test walls. In a game where the player must avoid obstacles, this step checks if the player is colliding with any walls."
                ]
            },
            {
                "loopstr": [
                    "Skip non-solid edges. In a game where the player must navigate through a 3D environment, non-solid edges are ignored to reduce unnecessary calculations.",
                    "Calc distance to the edge. In a game where the player must avoid obstacles, this step calculates the distance between the player and the nearest wall.",
                    "Edge is too far, skip. In a game where the player must collect items, this step skips edges that are too far away to be relevant.",
                    "Hit wall, update radius. In a game where the player must navigate through a maze, this step updates the player's radius to account for the collision with the wall.",
                    "Calculate hit pos. In a game where the player must collect items, this step calculates the position of the item that the player has hit."
                ]
            },
            {
                "loopstr": [
                    "Skip invalid neighbours and do not follow back to parent. In a game where the player must navigate through a hierarchical structure, this step skips invalid neighbours and does not follow back to the parent to reduce unnecessary calculations.",
                    "Expand to neighbour. In a game where the player must collect items, this step expands to the neighbour tile to explore new possibilities.",
                    "Skip off-mesh connections. In a game where the player must navigate through a 3D environment, off-mesh connections are ignored to reduce unnecessary calculations.",
                    "Calc distance to the edge. In a game where the player must avoid obstacles, this step calculates the distance between the player and the nearest wall.",
                    "If the circle is not touching the next polygon, skip it. In a game where the player must collect items, this step skips the next polygon if the circle is not touching it.",
                    "Cost In a game where the player must navigate through a maze, this step calculates the cost of moving to the next tile.",
                    "The node is already in open list and the new result is worse, skip. In a game where the player must collect items, this step skips the node if it is already in the open list and the new result is worse."
                ]
            }
        ],
        "Normal": [
            "Validate input In a game where the player must collect items, this step validates the input to ensure that it is correct and relevant.",
            "Calc hit normal. In a game where the player must navigate through a 3D environment, this step calculates the normal of the hit point to determine the direction of the collision."
        ],
        "FuncName": "DetourNavMeshQuery_5701 findDistanceToWall.txt"
    },
    {
        "Branch": [
            "pre-condition",
            "game condition: player health > 50"
        ],
        "Loop": [
            "pre-condition",
            "game condition: player level < 10"
        ],
        "Normal": [
            "pre-condition",
            "game condition: player experience > 1000"
        ],
        "FuncName": "clientmedia_1228 addRemoteServer.txt"
    },
    {
        "Branch": [
            "Termination condition for multi-body point-to-point constraint in multi-degree-of-freedom systems."
        ],
        "Loop": [
            "Termination condition for multi-body point-to-point constraint in multi-degree-of-freedom systems."
        ],
        "Normal": [
            "Not implemented yet. This feature is relevant to the simulation of multi-degree-of-freedom systems in the context of [game] type."
        ],
        "FuncName": "btMultiBodyPoint2Point_8347 finalizeMultiDof.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Some remote server sent us a file. In a game, this might be a downloadable character or level.",
            "-> decrement number of active fetches, keeping the player engaged with the game's progress.",
            "-> mark file as received if fetch succeeded, ensuring the player can access the downloaded content.",
            "-> try to load media, such as 3D models or audio files, to enhance the gaming experience.",
            " If fetch succeeded, try to load media file, allowing the player to interact with the downloaded content."
        ],
        "FuncName": "clientmedia_1228 remoteMediaReceived.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "memset(&constraintRow,0xffffffff,sizeof(btMultiBodySolverConstraint));",
                    "Convert local points back to world coordinates in the context of a point-to-point constraint in a physics engine, specifically for a game.",
                    "todo: support the case of btMultiBody versus btRigidBody, see btPoint2PointConstraint::getInfo2NonVirtual for more information on constraint rows in game physics.",
                    "int i=1; // Initialize a counter variable for loop iterations in game development."
                ]
            }
        ],
        "Normal": [
            "int i=1; // Initialize a counter variable for a normal loop iteration in game development."
        ],
        "FuncName": "btMultiBodyPoint2Point_8347 createConstraintRows.txt"
    },
    {
        "Branch": [
            "construct a two-point constraint to relate the two rigid bodies"
        ],
        "Loop": [],
        "Normal": [
            "at least store the applied impulses and define the two-point constraint"
        ],
        "FuncName": "btMultiBodyPoint2Point_8347 btMultiBodyPoint2Point.txt"
    },
    {
        "Branch": [
            "If the player's level is greater than 5, add a new item to their inventory"
        ],
        "Loop": [
            "Continue the game loop until the player has completed all levels"
        ],
        "Normal": [
            "Pre-condition: The player must have a valid game license",
            "If the player's name was already announced, ignore the new announcement and display a message saying 'Name already taken'",
            "If the player's name is empty or contains illegal characters, ignore the file and display an error message saying 'Invalid name'",
            "The length of the SHA-1 hash must be exactly 20 characters (160 bits) to ensure data integrity, else ignore the file and display an error message saying 'Invalid SHA-1 hash'"
        ],
        "FuncName": "clientmedia_1228 addFile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Draw the same frame in 3D world coordinates for debugging multiple body points to points joints."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "btMultiBodyPoint2Point_8347 debugDraw.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " == i",
                    " Encapsulate possible IPv6 plain address in [] and optimize media loading for online gaming"
                ]
            }
        ],
        "Normal": [
            " Balance game responsiveness and media loading speed for a seamless gaming experience",
            " Check media cache for online games",
            " If all game files are found in the cache, report this to the server and proceed with loading",
            " If the server reports no remote servers, initiate conventional game transfers immediately",
            " Note: if cURL support is not compiled in, m_remotes is always empty, so !USE_CURL! is redundant but may reduce the size of the compiled code for online games"
        ],
        "FuncName": "clientmedia_1228 initialStep.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pre-conditions",
            "Of all servers that claim to provide the file and haven't been unsuccessfully tried before, find the one with the smallest number of currently active transfers in the game",
            "Select the remote server with the minimum active transmission count"
        ],
        "FuncName": "clientmedia_1228 selectRemoteServer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Did all remote transfers end and no new ones can be started in Minetest?",
                    "If so, request still missing files from the Minetest server",
                    "(Or report that we have all files.)"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Is this a hashset (index.mth) or a media file in the Minetest game?"
                ]
            }
        ],
        "Normal": [
            "Remote media in Minetest: check for completion of fetches"
        ],
        "FuncName": "clientmedia_1228 step.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Some media files have not been received yet, use the conventional slow method (minetest protocol) to get them, a popular game type is minetest",
                    "conventional slow method (minetest protocol) to get them, minetest game type"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "pre-condition, a common game scenario"
        ],
        "FuncName": "clientmedia_1228 startConventionalTransfers.txt"
    },
    {
        "Branch": [
            "If found in cache, try to load the cached media file for the game"
        ],
        "Loop": [],
        "Normal": [
            "Loading media file from cache for the game"
        ],
        "FuncName": "clientmedia_1228 tryLoadFromCache.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The file has not been received and is not currently being transferred. Please select a server to download the file for the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Server found, starting download for the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If we reach here, we can determine that we won't be fetching this file from the remote server. Therefore, if possible, update the name binding for the game."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the download limit for the game exceeds, terminate the process."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "clientmedia_1228 startRemoteMediaTransfers.txt"
    },
    {
        "Branch": [
            "Check if file transmission is complete"
        ],
        "Loop": [],
        "Normal": [
            "Verify file announcement",
            "Ensure file hasn't been received previously",
            "Mark file as received, disregarding loading success and checksum match (since no other server can replace it)",
            "Verify received file matches announced checksum",
            "Load file if match is confirmed"
        ],
        "FuncName": "clientmedia_1228 conventionalTransferDone.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pre-game condition: pre-condition",
            "If player name was already announced, ignore the new announcement in the game.",
            "If player name is empty or contains illegal characters, ignore the file in the game.",
            "In this game, the length of the SHA-1 hash must be exactly 20 characters (160 bits) to proceed."
        ],
        "FuncName": "clientmedia_1228 addFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Verify media file integrity by calculating its checksum",
            "Validate received file against announced checksum for media file",
            "Checksum verified, proceed to load media file",
            "Update cache with loaded media file, unless it was just cached"
        ],
        "FuncName": "clientmedia_1228 checkAndLoad.txt"
    },
    {
        "Branch": [
            "Check file transfer and loading. In If-Condition, check that file was announced.",
            "Check file transfer and loading. In If-Condition, check that file hasn't already been received.",
            "Check file transfer and loading. In If-Condition, mark file as received, regardless of whether loading it works and whether the checksum matches (because at this point there is no other server that could send a replacement).",
            "Check file transfer and loading. In If-Condition, check that received file matches announced checksum.",
            "Check file transfer and loading. In If-Condition, if so, load it."
        ],
        "Loop": [],
        "Normal": [
            "Check file transfer and loading. In Normal, check that file was announced.",
            "Check file transfer and loading. In Normal, check that file hasn't already been received.",
            "Check file transfer and loading. In Normal, mark file as received, regardless of whether loading it works and whether the checksum matches (because at this point there is no other server that could send a replacement).",
            "Check file transfer and loading. In Normal, check that received file matches announced checksum.",
            "Check file transfer and loading. In Normal, if so, load it."
        ],
        "FuncName": "clientmedia_1228 conventionalTransferDone.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the game, the sub-process has completed so return here.",
                    "This is a conditional statement in the game, and the sub-process has completed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Main_2110 main.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "uniqueClassID must be non-null in the game's class storage system.",
            "stash a lookup from the uniqueID to the package and class name in the game's database.",
            "store class object into uniqueClassID key in the game's memory management system.",
            "pop heap stash in the game's garbage collection process.",
            "store the constructor in the game's class registry."
        ],
        "FuncName": "JSAPI_999 js_class_declare_internal.txt"
    },
    {
        "Branch": [
            "If-Condition-Str in JSVM game"
        ],
        "Loop": [
            "Loop-Condition-Str in JSVM game"
        ],
        "Normal": [
            "remove Atomic object in JSVM game"
        ],
        "FuncName": "JSAPI_999 js_class_push_propertyobject.txt"
    },
    {
        "Branch": [
            "If the player's health is above 50%, they can attack the enemy."
        ],
        "Loop": [
            "The player must collect 10 coins within 30 seconds to progress to the next level."
        ],
        "Normal": [
            "Remove the enemy's shield to deal damage."
        ],
        "FuncName": "JSAPI_999 js_class_get_constructor.txt"
    },
    {
        "Branch": [
            "In a game of strategy, a conditional statement is used to check a specific condition.",
            "If the condition is met, the game proceeds accordingly."
        ],
        "Loop": [
            "In a game of puzzle, a loop condition is used to repeat a task until a certain condition is met.",
            "The loop continues to run until the condition is satisfied."
        ],
        "Normal": [
            "In a game of adventure, a player receives a file from a remote server, which contains a crucial clue to progress.",
            "-> The player's active fetches are reduced by one.",
            "-> If the file is successfully received, the player marks it as received and proceeds to load the media.",
            "-> The game attempts to load the media file.",
            "If the file is successfully received, the player tries to load the media file, which may contain a hidden message or a new quest."
        ],
        "FuncName": "clientmedia_1228 remoteMediaReceived.txt"
    },
    {
        "Branch": [
            "Initial step to download single media, attempt to load file from cache, if cache does not exist, select transfer method based on availability of remote servers for the game."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iteration == i",
                    "Encapsulate possible IPv6 plain address in [] for the game."
                ]
            }
        ],
        "Normal": [
            "Balancing responsiveness during media loading and media loading speed for the game.",
            "Checking media cache for the game.",
            "If all files are found in the cache, report this to the server for the game.",
            "If the server reports no remote servers, initiate conventional transfers for the game. Note: if cURL support is not compiled, m_remotes is always empty, making !USE_CURL redundant but potentially reducing code size for the game."
        ],
        "FuncName": "clientmedia_1228 initialStep.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "prototype",
                    "AObject constructor function",
                    "set JavaScript object prototype"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "remove package",
                    "package removal"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "prototype",
            "remove Object",
            "remove basename",
            "remove package",
            "dup context",
            "pop classname object",
            "pop Atomic Object"
        ],
        "FuncName": "JSAPI_999 js_setup_prototype.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In a typical RPG game, the player can choose from a variety of classes, each with its own unique abilities and attributes, such as strength, agility, and intelligence. The player can select a class by clicking on the corresponding button or icon.",
            "In a game, the player can pop a key from a stack and retrieve its associated value, such as a treasure chest that contains a valuable item."
        ],
        "FuncName": "JSAPI_999 js_object_to_variantmap.txt"
    },
    {
        "Branch": [
            "If Class Prototype Object Exists"
        ],
        "Loop": [
            "Loop Through Class Prototype Object"
        ],
        "Normal": [
            "Remove Class Object",
            "Remove Atomic Object"
        ],
        "FuncName": "JSAPI_999 js_class_get_prototype.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "deleteProperty: function (targ, key) - Removes a property from a target object in a game, allowing for dynamic changes to game state."
        ],
        "FuncName": "JSAPI_999 variantmap_property_deleteproperty.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "setup proxy to map string in game scenario",
            "setup property handler for game object"
        ],
        "FuncName": "JSAPI_999 js_push_variantmap.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "copy the buffer into the variant",
                    "a conditional statement in the game, where the variant value determines the next action"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "a loop in the game, where the variant value determines the number of iterations"
        ],
        "Normal": [
            "convert to abs index",
            "object check after array and buffer object check",
            "a normal string in the game, used for various purposes such as displaying information to the player"
        ],
        "FuncName": "JSAPI_999 js_to_variant.txt"
    },
    {
        "Branch": [
            "if client socket is closed, close server socket"
        ],
        "Loop": [
            "while server socket is open, check client socket"
        ],
        "Normal": [
            "try to auto-restart"
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_finish.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This shouldn't happen. As a result, the game server will disconnect the client."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This shouldn't happen. As a result, the game server will disconnect the client."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "This string is used to check if the network client is still connected to the game server."
        ],
        "Normal": [
            "not needed by the example",
            "In a production quality implementation there would be a sanity * timeout here to recover from black hole disconnects. This is a common issue in multiplayer games where a client or server can become disconnected from the game world."
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_read_cb.txt"
    },
    {
        "Branch": [
            "Wait for debug connection establishment in if-conditions"
        ],
        "Loop": [
            "Wait for debug connection establishment in loop conditions"
        ],
        "Normal": [
            "For now, close the listen socket because we won't accept new connections anyway. A better implementation would allow multiple debug attaches. Debug connection establishment is pending."
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_waitconn.txt"
    },
    {
        "Branch": [
            "Conditional statement in game logic",
            " Conditional statement in game logic"
        ],
        "Loop": [
            "Loop condition in game logic",
            " Loop condition in game logic"
        ],
        "Normal": [
            " Not required for game example ",
            " Read flush callback: In game, indicates end of data transmission. Duktape may not make further read calls at this time. ",
            " TCP transport in game: No read flush handling required. You can pass NULL to attach debugger and ignore this callback. "
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_read_flush_cb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "also returns 0 which is correct. This is a typical behavior in socket programming, where a read operation returns 0 when there is no data available."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "should never happen. This could be due to a programming error or an unexpected condition in the socket."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "nothing to read. This is a common scenario when the socket is closed or there is no data available for reading."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "not needed by the example. This string does not contain any game-related information."
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_peek_cb.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: variantmap property value"
        ],
        "Loop": [
            "Loop-Condition-Str: variantmap property value"
        ],
        "Normal": [
            "Normal-Str: targ, key, recv, variantmap property value"
        ],
        "FuncName": "JSAPI_999 variantmap_property_get.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This shouldn't happen. This is a callback function for writing to the network client socket."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "This shouldn't happen. This is a callback function for writing to the network client socket."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "not needed by the example",
            "In a production quality implementation there would be a sanity timeout here to recover from black hole disconnects. This is relevant to the game's network client functionality."
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_write_cb.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Meshlet construction is limited by maximum vertices and triangles per meshlet in game code.",
            "The worst-case scenario is an unindexed stream input, equally stressing both limits.",
            "Note that we assume 2 unpacked vertices in each meshlet in the worst case, leaving space for any triangle if we have 3."
        ],
        "FuncName": "clusterizer_7795 meshopt_buildMeshletsBound.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "not needed by the example",
            "In TCP game, write flush is used to indicate the transmission of pending bytes: Duktape may not perform any additional writes on this occasion.",
            "This TCP transport requires no write flush handling so ignore. You can also pass a NULL to duk_debugger_attach() and not implement this callback at all."
        ],
        "FuncName": "JSDebugger_1052 duk_trans_socket_write_flush_cb.txt"
    },
    {
        "Branch": [
            "Generate face normal processor constructor: if condition"
        ],
        "Loop": [
            "Generate face normal processor constructor: loop condition"
        ],
        "Normal": [
            "Generate face normal processor constructor: nothing to do here"
        ],
        "FuncName": "GenFaceNormalsProcess_9918 GenFaceNormalsProcess.txt"
    },
    {
        "Branch": [
            "Check if the game is running in debug mode and create a new process accordingly.",
            "Verify the game's current state and spawn a new process if necessary."
        ],
        "Loop": [
            "Iterate through the game's state and create a new process for each iteration.",
            "Loop through the game's current state and spawn a new process for each loop iteration."
        ],
        "Normal": [
            "In the context of a game, 'take defaults from current process' means to inherit settings from the existing game process.",
            "OutPipe may be the same as errPipe in a game, so we duplicate the output pipe and close it later to prevent interference."
        ],
        "FuncName": "Process_WIN32U_1536 launchImpl.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of 3D game rendering, finding the bounding sphere of a point cloud involves identifying the smallest sphere that encloses all points. This process can be achieved by first identifying extreme points along all three axes, resulting in a pair of points with minimum and maximum coordinates for each axis.",
            "Subsequently, the pair of points with the largest distance is determined, which represents the longest segment within the point cloud.",
            "The longest segment is then used as the initial diameter of the sphere, and the sphere is iteratively adjusted until all points are contained within it.",
            "This iterative process refines the sphere's radius and center, ensuring that all points in the point cloud are enclosed by the sphere."
        ],
        "FuncName": "clusterizer_7795 computeBoundingSphere.txt"
    },
    {
        "Branch": [
            "Meshlet Condition: Only render if meshlet is visible and not culled"
        ],
        "Loop": [
            "Meshlet Loop: Iterate over each meshlet in the scene"
        ],
        "Normal": [
            "Meshlet Normal: The normal of the vertex in the meshlet, 0xff if the vertex isn't used"
        ],
        "FuncName": "clusterizer_7795 meshopt_buildMeshlets.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initialize physics engine for collision detection and solving.",
            "Establish collision configuration and dispatcher for game physics.",
            "Implement the actual physics solver for realistic simulations.",
            "Create the game world with realistic physics and collisions."
        ],
        "FuncName": "BulletPhysicsManager_9967 Initialize.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u4e0d\u9700\u8981\u5305\u542b\u9000\u5316\u4e09\u89d2\u5f62 - \u5b83\u4eec\u5c06\u65e0\u6cd5\u88ab\u770b\u5230",
                    "\u8bb0\u5f55\u4e09\u89d2\u5f62\u6cd5\u7ebf\u548c\u89d2\u70b9\u4ee5\u4fbf\u5c06\u6765\u4f7f\u7528;\u6cd5\u7ebf\u548c\u89d2\u70b90\u5b9a\u4e49\u4e00\u4e2a\u5e73\u9762\u65b9\u7a0b",
                    "\u8ba1\u7b97\u4e09\u89d2\u7f51\u683c\u7684\u5305\u56f4\u7403\u548c\u6cd5\u7ebf\u9525"
                ]
            },
            {
                "loopstr": [
                    "\u70b9\u4e58(center-t*axis-corner, trinormal) = 0",
                    "\u70b9\u4e58(center-corner, trinormal) - t * \u70b9\u4e58(axis, trinormal) = 0",
                    "dn\u5e94\u8be5\u5927\u4e8emindp\u4e0a\u9650",
                    "\u8ba1\u7b97\u4e09\u89d2\u5f62\u6cd5\u7ebf\u5e76\u6536\u96c6\u4e09\u89d2\u5f62\u89d2\u70b9"
                ]
            }
        ],
        "Normal": [
            "\u8ba1\u7b97\u4e09\u89d2\u5f62\u6cd5\u7ebf\u5e76\u6536\u96c6\u4e09\u89d2\u5f62\u89d2\u70b9",
            "\u9000\u5316\u96c6\u7fa4\uff0c\u65e0\u6709\u6548\u4e09\u89d2\u5f62=> \u7b80\u5355\u62d2\u7edd\uff08\u9525\u6570\u636e\u4e3a0\uff09",
            "\u8ba1\u7b97\u96c6\u7fa4\u5305\u56f4\u7403; \u6211\u4eec\u5c06\u4f7f\u7528\u4e2d\u5fc3\u6765\u786e\u5b9a\u6cd5\u7ebf\u9525\u9876\u70b9",
            "\u5c06\u4e09\u89d2\u5f62\u6cd5\u7ebf\u89c6\u4e3a\u70b9\uff0c\u627e\u5230\u5305\u56f4\u7403 - \u7403\u5fc3\u786e\u5b9a\u6700\u4f73\u9525\u8f74",
            "\u8ba1\u7b97\u6240\u6709\u6cd5\u7ebf\u5468\u56f4\u7684\u7d27\u5bc6\u9525\uff0cmindp = cos(\u89d2\u5ea6/2)",
            "\u586b\u5145\u5305\u56f4\u7403\u4fe1\u606f; \u6ce8\u610f\uff0c\u5728\u4e0b\u9762\uff0c\u6211\u4eec\u53ef\u4ee5\u8fd4\u56debounds\u800c\u4e0d\u8fd4\u56de\u9525\u4fe1\u606f",
            "\u9000\u5316\u96c6\u7fa4\uff0c\u6cd5\u7ebf\u9525\u5927\u4e8e\u534a\u7403=> \u7b80\u5355\u63a5\u53d7",
            "\u6ce8\u610f\uff0c\u5982\u679cmindp\u4e3a\u6b63\u4f46\u63a5\u8fd10\uff0c\u4ee5\u4e0b\u7684\u4e09\u89d2\u5f62\u4ea4\u70b9\u4ee3\u7801\u4f1a\u53d8\u5f97\u4e0d\u7a33\u5b9a",
            "\u6211\u4eec\u51b3\u5b9a\uff0c\u5982\u679c\u4e00\u4e2a\u6cd5\u7ebf\u9525\u5bbd\u5ea6\u5927\u7ea6\u4e3a168\u5ea6\u6216\u66f4\u5bbd\uff0c\u5219\u9525\u4e0d\u662f\u6709\u7528",
            "\u6211\u4eec\u9700\u8981\u627e\u5230\u4e2d\u5fc3-t*\u8f74\u5149\u7ebf\u4e0a\u7684\u70b9\uff0c\u5b83\u4f4d\u4e8e\u6240\u6709\u4e09\u89d2\u5f62\u7684\u8d1f\u534a\u7a7a\u95f4",
            "\u9525\u5cf0\u5e94\u8be5\u4f4d\u4e8e\u6240\u6709\u96c6\u7fa4\u4e09\u89d2\u5f62\u7684\u8d1f\u534a\u7a7a\u95f4",
            "\u6ce8\u610f\uff1a\u8fd9\u4e2a\u8f74\u662f\u6cd5\u7ebf\u9525\u7684\u8f74\uff0c\u4f46\u6211\u4eec\u7684\u6d4b\u8bd5\u5bf9\u4e8e\u900f\u89c6\u76f8\u673a\u5b9e\u9645\u4e0a\u662f\u5c06\u8f74\u503c\u53cd\u8f6c",
            "cos(a)\u5bf9\u4e8e\u6cd5\u7ebf\u9525\u662fmindp; \u6211\u4eec\u9700\u8981\u5728\u4e24\u8fb9\u90fd\u52a090\u5ea6\u5e76\u5c06\u9525\u53cd\u8f6c",
            "\u8fd9\u7ed9\u4e86\u6211\u4eec-cos(a+90) = -(-sin(a)) = sin(a) = sqrt(1 - cos^2(a))",
            "\u91cf\u5316\u8f74\u548c\u622a\u8ddd\u52308\u4f4dSNORM\u683c\u5f0f",
            "\u4e3a\u4e86\u4f7f8\u4f4d\u6d4b\u8bd5\u4fdd\u5b88\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7\u6d4b\u91cf\u6700\u5927\u9519\u8bef\u6765\u8c03\u6574\u622a\u8ddd",
            "\u6ce8\u610f\u6211\u4eec\u9700\u8981\u5411\u4e0a\u820d\u5165\u800c\u4e0d\u662f\u5411\u6700\u8fd1\u820d\u5165\uff0c\u56e0\u6b64+1",
            "\u8ba1\u7b97\u4e09\u89d2\u7f51\u683c\u7684\u5305\u56f4\u7403\u548c\u6cd5\u7ebf\u9525",
            "\u9000\u5316\u96c6\u7fa4\uff0c\u65e0\u6709\u6548\u4e09\u89d2\u5f62=> \u7b80\u5355\u62d2\u7edd\uff08\u9525\u6570\u636e\u4e3a0\uff09",
            "\u8ba1\u7b97\u96c6\u7fa4\u5305\u56f4\u7403; \u6211\u4eec\u5c06\u4f7f\u7528\u4e2d\u5fc3\u6765\u786e\u5b9a\u6cd5\u7ebf\u9525\u9876\u70b9",
            "\u5c06\u4e09\u89d2\u5f62\u6cd5\u7ebf\u89c6\u4e3a\u70b9\uff0c\u627e\u5230\u5305\u56f4\u7403 - \u7403\u5fc3\u786e\u5b9a\u6700\u4f73\u9525\u8f74",
            "\u8ba1\u7b97\u6240\u6709\u6cd5\u7ebf\u5468\u56f4\u7684\u7d27\u5bc6\u9525\uff0cmindp = cos(\u89d2\u5ea6/2)",
            "\u586b\u5145\u5305\u56f4\u7403\u4fe1\u606f; \u6ce8\u610f\uff0c\u5728\u4e0b\u9762\uff0c\u6211\u4eec\u53ef\u4ee5\u8fd4\u56debounds\u800c\u4e0d\u8fd4\u56de\u9525\u4fe1\u606f",
            "\u9000\u5316\u96c6\u7fa4\uff0c\u6cd5\u7ebf\u9525\u5927\u4e8e\u534a\u7403=> \u7b80\u5355\u63a5\u53d7",
            "\u6ce8\u610f\uff0c\u5982\u679cmindp\u4e3a\u6b63\u4f46\u63a5\u8fd10\uff0c\u4ee5\u4e0b\u7684\u4e09\u89d2\u5f62\u4ea4\u70b9\u4ee3\u7801\u4f1a\u53d8\u5f97\u4e0d\u7a33\u5b9a",
            "\u6211\u4eec\u51b3\u5b9a\uff0c\u5982\u679c\u4e00\u4e2a\u6cd5\u7ebf\u9525\u5bbd\u5ea6\u5927\u7ea6\u4e3a168\u5ea6\u6216\u66f4\u5bbd\uff0c\u5219\u9525\u4e0d\u662f\u6709\u7528",
            "\u6211\u4eec\u9700\u8981\u627e\u5230\u4e2d\u5fc3-t*\u8f74\u5149\u7ebf\u4e0a\u7684\u70b9\uff0c\u5b83\u4f4d\u4e8e\u6240\u6709\u4e09\u89d2\u5f62\u7684\u8d1f\u534a\u7a7a\u95f4",
            "\u9525\u5cf0\u5e94\u8be5\u4f4d\u4e8e\u6240\u6709\u96c6\u7fa4\u4e09\u89d2\u5f62\u7684\u8d1f\u534a\u7a7a\u95f4",
            "\u6ce8\u610f\uff1a\u8fd9\u4e2a\u8f74\u662f\u6cd5\u7ebf\u9525\u7684\u8f74\uff0c\u4f46\u6211\u4eec\u7684\u6d4b\u8bd5\u5bf9\u4e8e\u900f\u89c6\u76f8\u673a\u5b9e\u9645\u4e0a\u662f\u5c06\u8f74\u503c\u53cd\u8f6c",
            "cos(a)\u5bf9\u4e8e\u6cd5\u7ebf\u9525\u662fmindp; \u6211\u4eec\u9700\u8981\u5728\u4e24\u8fb9\u90fd\u52a090\u5ea6\u5e76\u5c06\u9525\u53cd\u8f6c",
            "\u8fd9\u7ed9\u4e86\u6211\u4eec-cos(a+90) = -(-sin(a)) = sin(a) = sqrt(1 - cos^2(a))",
            "\u91cf\u5316\u8f74\u548c\u622a\u8ddd\u52308\u4f4dSNORM\u683c\u5f0f",
            "\u4e3a\u4e86\u4f7f8\u4f4d\u6d4b\u8bd5\u4fdd\u5b88\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7\u6d4b\u91cf\u6700\u5927\u9519\u8bef\u6765\u8c03\u6574\u622a\u8ddd",
            "\u6ce8\u610f\u6211\u4eec\u9700\u8981\u5411\u4e0a\u820d\u5165\u800c\u4e0d\u662f\u5411\u6700\u8fd1\u820d\u5165\uff0c\u56e0\u6b64+1"
        ],
        "FuncName": "clusterizer_7795 meshopt_computeClusterBounds.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Process timers in the game",
            "Delete expired timers in the game"
        ],
        "FuncName": "nodetimer_4030 step.txt"
    },
    {
        "Branch": [
            "Check if player has reached level 5"
        ],
        "Loop": [
            "Repeat until player has collected 10 coins"
        ],
        "Normal": [
            "Clean up the physical world in the game environment"
        ],
        "FuncName": "BulletPhysicsManager_9967 Finalize.txt"
    },
    {
        "Branch": [
            "If the player's health is above 50, then the player can move forward."
        ],
        "Loop": [
            "Loop through all enemies in the game"
        ],
        "Normal": [
            "Geometries: The physical bodies of the game objects, such as boxes and spheres."
        ],
        "FuncName": "BulletPhysicsManager_9967 ClearRigidBodies.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Allow compilation and return failure when unavailable for games requiring hostname truncation ",
            " Override host name when environment variable CURL_GETHOSTNAME is set for games requiring hostname truncation ",
            " The call to system's gethostname() might get intercepted by the libhostname library when libcurl is built as a non-debug shared library when running the test suite for games requiring hostname truncation ",
            " Truncate domain, leave only machine name for games requiring hostname truncation "
        ],
        "FuncName": "curl_gethostname_1946 Curl_gethostname.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "fail to check"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "fail to check"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "cond": [
                    "overflow check"
                ]
            }
        ],
        "Normal": [
            {
                "str": [
                    "game logic"
                ]
            }
        ],
        "FuncName": "utils_8578 CheckSizeArgumentsOverflow.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "slide back if we've overshot the end of our buffer.",
                    "NULL terminate the string",
                    "In the context of SDL, this means handling a potential buffer overflow error."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Clear the error string",
            "Get the thread-safe error, and print it out",
            "In SDL, this involves retrieving and displaying an error message related to the game's execution."
        ],
        "FuncName": "SDL_error_9754 SDL_GetErrorMsg.txt"
    },
    {
        "Branch": [
            "Create a physical body if the condition is met."
        ],
        "Loop": [
            "Create a physical body in each iteration of the loop."
        ],
        "Normal": [
            "Geometries",
            "Create a physical body with the given geometry."
        ],
        "FuncName": "BulletPhysicsManager_9967 CreateRigidBodies.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " FIXME: Add code to lookup key in language string hash-table and retrieve the corresponding value related to the game's if-condition logic "
        ],
        "FuncName": "SDL_error_9754 SDL_LookupString.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "To calculate the image color palette, we need to count the exact colors."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The color palette is already generated."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fill the colors into the palette, which is a crucial step in generating the color palette."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "so we're sure that last_pix != argb[0] and this ensures the color palette is accurate."
        ],
        "FuncName": "utils_8578 WebPGetColorPalette.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get server from registry",
            "Send game invitation to players"
        ],
        "FuncName": "l_server_1648 l_chat_send_player.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get server from registry for multiplayer game",
            "Send chat message to all online players in multiplayer game"
        ],
        "FuncName": "l_server_1648 l_chat_send_all.txt"
    },
    {
        "Branch": [
            " We need to check if the chain length is 1 and there are no sub chains in the game of  Chain Reaction. "
        ],
        "Loop": [
            " We need to loop through the chains and ensure each chain has a length of 1 and no sub chains in the game of  Chain Reaction. "
        ],
        "Normal": [
            " We need to assert that there really are only chains of length 1 and no  sub chains in the game of  Chain Reaction. "
        ],
        "FuncName": "solver_2bone_6072 solver_2bone_post_chain_build.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no such player in the game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "game loop iteration"
                ]
            }
        ],
        "Normal": [
            {
                "normalstr": [
                    "player is winning the game"
                ]
            }
        ],
        "FuncName": "l_server_1648 l_ban_player.txt"
    },
    {
        "Branch": [
            "Check player permission to access game data",
            "Verify player's account status"
        ],
        "Loop": [
            "Iterate through player's inventory",
            "Loop through game levels"
        ],
        "Normal": [
            "Get server from registry",
            "Do it"
        ],
        "FuncName": "l_server_1648 l_get_player_privs.txt"
    },
    {
        "Branch": [
            "check if player has two bones to construct IK solver"
        ],
        "Loop": [],
        "Normal": [
            "set up derived functions for IK solver"
        ],
        "FuncName": "solver_2bone_6072 solver_2bone_construct.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No player found, unable to get player information in game"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Failed to get player information, error occurred in game"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Player information may be missing, unable to proceed in game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Be cautious not to introduce a dependency on the peer connection in the game. This function is essential to return values even if the peer unexpectedly disconnects. Therefore, all ConInfo values here are optional."
        ],
        "FuncName": "l_server_1648 l_get_player_information.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In game development, the cosine law is used to calculate the base angle (alpha) between two segments.",
                    "The cross product of both segment vectors defines the axis of rotation, a fundamental concept in 3D game physics.",
                    "The top segment is a crucial component in the IK chain, influencing the overall movement and interaction with the environment.",
                    "The bottom segment, on the other hand, plays a vital role in determining the character's position and orientation.",
                    "To solve the unknown position, we need to set up a quaternion describing the rotation of alpha, ensuring the rotation is correct by normalizing the vec3 component.",
                    "Finally, we rotate side c and scale it to the length of side b to obtain the unknown position, a critical step in achieving realistic character movement."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In game development, forming a triangle from two segment lengths allows us to calculate the angles involved, as visualized here.",
            "The character's movement is checked to ensure it is within reach, a critical aspect of game design and player experience."
        ],
        "FuncName": "solver_2bone_6072 solver_2bone_solve.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no such player in game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "l_server_1648 l_get_player_ip.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get a list of mods for the game",
            "Package them up for Lua script"
        ],
        "FuncName": "l_server_1648 l_get_modnames.txt"
    },
    {
        "Branch": [
            "Find the closest point on the curve to the given point, taking into account the game's physics engine."
        ],
        "Loop": [],
        "Normal": [
            "fix for closed curves to take their wrap-over into account, ensuring smooth gameplay experience."
        ],
        "FuncName": "IFCCurve_7493 RecursiveSearch.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "if(const IfcBSplineCurve* c = curve.ToPtr<IfcBSplineCurve>()) {",
                    "  return new BSplineCurve(*c,conv);",
                    "  // In this specific game, the IFC curve is converted to a local curve using the game's proprietary algorithm."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " XXX OffsetCurve2D OffsetCurve3D not currently supported",
            "  // Note: This curve type is not supported in this game and will result in an error."
        ],
        "FuncName": "IFCCurve_7493 Convert.txt"
    },
    {
        "Branch": [
            "Decompress data from compressed stream into target stream for if condition"
        ],
        "Loop": [
            "Decompress data from compressed stream into target stream for loop condition"
        ],
        "Normal": [
            "No data decompressed",
            "Ill-formatted data, possibly not a valid compressed data"
        ],
        "FuncName": "Compression_6544 DecompressStream.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In order to keep edge cases to a minimum actually use an empty function. In the context of a game, this means creating a blank or placeholder function to account for unexpected scenarios."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "validate player input in a game"
        ],
        "FuncName": "l_server_1648 l_dynamic_add_media.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Pick up the target object."
        ],
        "FuncName": "SCarryObjectComponent_8476 Pickup.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compress source data and write to target stream for buffered and uncompressed data"
        ],
        "FuncName": "Compression_6544 CompressStream.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "note: the following algorithm is not guaranteed to find the right parameter value for the game type of curve fitting",
            "in all possible cases, but it will always return at least some value so this function will never fail in the default implementation of curve evaluation",
            "XXX derive threshold from game-specific curve topology characteristics",
            "game type: curve fitting, evaluation method: parameter estimation"
        ],
        "FuncName": "IFCCurve_7493 ReverseEval.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the game, we need to check if we hit a static mesh component that has physics simulation enabled to proceed."
        ],
        "FuncName": "SCarryObjectComponent_8476 GetActorInView.txt"
    },
    {
        "Branch": [
            "Rotate actor around pivot point using Quats to prevent gimbal lock in game physics"
        ],
        "Loop": [],
        "Normal": [
            "Compose the rotators using Quaternions to avoid gimbal lock in game development"
        ],
        "FuncName": "SCarryObjectComponent_8476 RotateActorAroundPoint.txt"
    },
    {
        "Branch": [
            "If the player's health is 0, they are defeated and the game is over."
        ],
        "Loop": [
            "The game loop continues until the player reaches the final level."
        ],
        "Normal": [
            "The player must defeat the final boss to win the game."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_DenySudoMode.txt"
    },
    {
        "Branch": [
            "If the player's level is greater than or equal to the required level, then the player can enter the game."
        ],
        "Loop": [
            "Loop through each item in the player's inventory and check if it can be used in the current game."
        ],
        "Normal": [
            "send packet to actually set the password",
            "reset again"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_AcceptSudoMode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Set player position in the game world",
            "Reply to server with game-related information",
            "DO NOT TRANSLATE THIS LITERALLY! This is a special string which needs to contain the translation's language code (e.g. \\de\\ for German). "
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_AuthAccept.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u6536\u5230\u4e00\u4e2aTOCLIENT_HELLO\u7684\u6d88\u606f\uff0c\u800c\u8ba4\u8bc1\u5df2\u7ecf\u5728\u8fdb\u884c\u4e2d"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u9009\u62e9\u6211\u4eec\u652f\u6301\u7684\u8ba4\u8bc1\u65b9\u6cd5",
            "\u4f7f\u7528\u8ba4\u8bc1\u65b9\u6cd5\u8ba4\u8bc1\uff0c\u5982\u679c\u6ca1\u6709\u627e\u5230\u4efb\u4f55\u652f\u6301\u7684\u65b9\u6cd5\u5219\u4e2d\u6b62"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_Hello.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Detach and re-enable collision",
                    "In the context of a game, this action is crucial for maintaining the realism of object interactions."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Re-map uint8 to 360 degrees",
                    "Apply physics impulse, ignores mass",
                    "This physics impulse is a common mechanic in games to simulate realistic object movement and collision responses."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Grab a reference to the MeshComp before dropping the object",
            "In game development, this step is essential for ensuring that the object's mesh remains intact and correctly rendered."
        ],
        "FuncName": "SCarryObjectComponent_8476 Throw.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Find the static mesh (if any) to disable physics simulation while carried. Filter by objects that are physically simulated and can therefore be picked up."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SCarryObjectComponent_8476 OnPickupMulticast_Implementation.txt"
    },
    {
        "Branch": [
            " Client-side player movement command handling. This string is used in the game code."
        ],
        "Loop": [],
        "Normal": [
            "Client-side player movement command handling. Adds the command to the ClientEvent queue. This is necessary because if not sent to the main program, it would only update the camera pitch and yaw to the current position."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_MovePlayer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Update environment in a virtual game world",
            "u32 dr = m_env.getDayNightRatio();",
            "infostream << Client: time_of_day= << time_of_day",
            "  <<  time_speed= << time_speed",
            "  << dr= << dr << std::endl; Time is advancing in the game"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_TimeOfDay.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Update an existing block",
                    "Block data processing: updating a block in the game world"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Ignoring packets that are too small due to network packet size limitations",
            "Packet processing: adding small packets to the mesh update queue and acknowledging after update"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_BlockData.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In-game object removal: attached sounds should not be removed as they might start playing before the entity is removed."
                ]
            }
        ],
        "Normal": [
            "Object removal count: { id } Added object count: { id type initialization data }",
            "Active object count received: false before first TOCLIENT_ACTIVE_OBJECT_REMOVE_ADD packet"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_ActiveObjectRemoveAdd.txt"
    },
    {
        "Branch": [
            "Client-side viewport size setting for if-conditions in game",
            "Conditional rendering for if-statements in game logic"
        ],
        "Loop": [
            "Client-side viewport size setting for loop-conditions in game",
            "Iterative rendering for loop-statements in game logic"
        ],
        "Normal": [
            "Client-side viewport size setting for normal rendering in game",
            "Preserving backwards compatibility for normal game logic"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_Fov.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Player health increased by 10 points"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "clientpackethandler_3311 handleCommand_HP.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Prevent from deleting metadata in RPG game",
                    "Metadata couldn't be set unused metadata in Strategy game"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "clientpackethandler_3311 handleCommand_NodemetaChanged.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In a game scenario, a message was consumed by the Chat System Manager (CSM) and should not be handled by the client."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In a game, the client sends a chat message with version, message type, sender name, and message content.",
            "The client should send this message to the Chat System Manager (CSM) using a ChatMessage object."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_ChatMessage.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "For each object in the environment, check if it matches the condition and pass the message"
                ]
            }
        ],
        "Normal": [
            "Iterate over all objects in the game world, sending messages to each one with its ID and message length"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_ActiveObjectMessages.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of a media announcement package, the Mesh update thread must be stopped while updating content definitions in a game scenario."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_AnnounceMedia.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "this used to be the length of the following string, ignore it. In the context of the game, this string represents a character's inventory, which needs to be updated periodically."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_DetachedInventory.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, do nothing if the player's stat is not known",
            "To maintain synchronization, send HUD changes according to the server's instructions, as implemented in server.cpp"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_HudChange.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Store formspec related to Minecraft in LocalPlayer"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_InventoryFormSpec.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Note: m_sounds_client_to_server takes 1 ownership",
                    "For ephemeral sounds, server_id is not meaningful",
                    "Game type: client-server, related to sound processing"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "Game type: loop condition, related to sound playback"
        ],
        "Normal": [
            "0 s32 server_id 4 u16 name length 6 char name[len] 6 + len f32 gain 10 + len u8 type SoundLocation 11 + len v3f pos in BS-space 23 + len u16 object_id 25 + len bool loop 26 + len f32 fade 30 + len f32 pitch 34 + len bool ephemeral 35 + len f32 start_time in seconds, related to game sound processing",
            "Generate a new id, used in game sound management",
            "Start playing, initiating game sound playback"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_PlaySound.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "All tweenable parameters",
                    "Particle emitter commands are used to create complex particle effects in the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "v >= 5.6.0",
                    "initial bias must be stored separately in the stream to preserve",
                    "backwards compatibility with older clients, which do not support",
                    "a bias field in their range format",
                    "Particle emitters were introduced in version 5.6.0, allowing for more advanced particle effects."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we only check the first bit, in order to allow this value to be turned into a bit flag field later if needed",
                    "Particle emitter flags can be used to customize the appearance and behavior of particles in the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "there's no tweening data to be had, so we need to set the",
                    "legacy params to constant values, otherwise everything old",
                    "will tween to zero",
                    "Particle emitters can be used to create complex animations and effects in the game, including particle trails and explosions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "This is kinda awful, and the game's particle effects are no exception."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_AddParticleSpawner.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of our game, a pointer is required as the event is a struct only, allowing for efficient data transfer and manipulation.",
            "Adding a std::string to a struct isn't possible in our game's data model, which prioritizes performance and memory optimization."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_ShowFormSpec.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In game, mesh update thread must be stopped while updating content definitions to prevent data corruption."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In game, u16 command u16 total number of file bunches u16 index of this bunch u32 number of files in this bunch for each file { u16 length of name string name u32 length of data data } represents a data transmission protocol for game assets."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_Media.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Mesh update thread must be stopped while updating content definitions. This is a critical step in NodeDef message processing.",
            "Decompress node definitions to prepare for game logic execution.",
            "Deserialize node definitions to load game content."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_NodeDef.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Restrictions were received -> load mods if it's enabled in CSM game mode",
            "Note: this should be moved after mods receptions from server instead in CSM game mode"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_CSMRestrictionFlags.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Not so satisfying code to keep compatibility with old fixed mode system in the FPS game",
            "-->",
            "If radar has been disabled in the FPS game, try to find a non radar mode or fall back to 0",
            "<--",
            "End of 'not so satisfying code' in the FPS game"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_HudSetFlags.txt"
    },
    {
        "Branch": [
            "Handle conditional network packets from the cloud, where the decision depends on the game's logic."
        ],
        "Loop": [
            "Manage network packets from the cloud in a loop, where the loop condition is determined by the game's state."
        ],
        "Normal": [
            " use the underlying u32 representation because we cant",
            " use struct members with constructors here and this way",
            " we avoid using new and delete for no good reason",
            " same here deconstruct to skip constructor",
            "Process network packets from the cloud, where each packet is handled individually based on the game's rules."
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_CloudParams.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Handling HUD settings for sky commands in game type 38 and below servers.",
                    " This ensures the classic skybox is maintained.",
                    " Default skybox settings are applied:",
                    " Fix for regular skies, as color isn't preserved:",
                    " Skybox, sun, moon and stars ClientEvents for game type 38 and below servers:"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "clientpackethandler_3311 handleCommand_HudSetSky.txt"
    },
    {
        "Branch": [
            "Serialize btCollisionObject properties to buffer."
        ],
        "Loop": [],
        "Normal": [
            "Serialize btCollisionObject properties to buffer."
        ],
        "FuncName": "btCollisionObject_3772 serialize.txt"
    },
    {
        "Branch": [
            "If the current mode index is not equal to the wanted current mode index after change, then"
        ],
        "Loop": [
            "While the current mode index is not equal to the wanted current mode index after change"
        ],
        "Normal": [
            "Map Mode",
            "Change Mode Index"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_MinimapModes.txt"
    },
    {
        "Branch": [
            "Check if player has a custom prefix"
        ],
        "Loop": [],
        "Normal": [
            "Store formspec in LocalPlayer, Using custom prefix for player's formspec"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_FormspecPrepend.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "LEGACY CODEPATH",
                    "Compute and check checksum of data",
                    "Actually load media",
                    "Cache file for the next time when this client joins the same server",
                    "Process media file as per game type requirements"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "create a downloader for this file and process it according to game type"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_MediaPush.txt"
    },
    {
        "Branch": [
            "TODO: send ModChannel signal to Lua API",
            "If ModChannel signal is valid, forward it to client side mods for ModChannel processing"
        ],
        "Loop": [],
        "Normal": [
            "TODO: send Signal to Lua API",
            "If signal is valid, forward it to client side mods"
        ],
        "FuncName": "clientpackethandler_3311 handleCommand_ModChannelSignal.txt"
    },
    {
        "Branch": [
            " Conditional navigation grid initialization for game type."
        ],
        "Loop": [
            " Iterative navigation grid initialization for game type."
        ],
        "Normal": [
            " Init tiles for game navigation.",
            " Init ID generator values for game unique identifiers.",
            " Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow for game security."
        ],
        "FuncName": "DetourNavMesh_5462 init.txt"
    },
    {
        "Branch": [
            "Check if the current position is valid for a game of Chess;",
            "Verify if the current position is a valid move in a game of Go;"
        ],
        "Loop": [
            "Iterate over the board positions to calculate the hash value for a game of Checkers;",
            "Loop through the game state to update the hash value for a game of Backgammon;"
        ],
        "Normal": [
            "Large multiplicative constants for game-specific calculations;",
            "here arbitrarily chosen primes for a game of Tic-Tac-Toe"
        ],
        "FuncName": "DetourNavMesh_5462 computeTileHash.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check for horizontal overlap in the context of a platformer game.",
            "In a puzzle game, The segment is shrunken a little so that slabs which touch at end points are not connected.",
            "In a strategy game, Check vertical overlap to determine resource allocation.",
            "In a simulation game, Crossing segments always overlap, affecting the simulation's accuracy.",
            "In a first-person shooter, Check for overlap at endpoints to prevent clipping issues."
        ],
        "FuncName": "DetourNavMesh_5462 overlapSlabs.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The last predicted row in this iteration will be the top-pred row",
                    "for the first row in next iteration.",
                    "This is a key optimization in VP8LInverseTransform, allowing for",
                    "faster processing of subsequent rows."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Move packed pixels to the end of unpacked region, so that unpacking",
                    "can occur seamlessly.",
                    "Also, note that this is the only transform that applies on",
                    "the effective width of VP8LSubSampleSize(xsize_, bits_). All other",
                    "transforms work on effective width of xsize_.",
                    "This transform is crucial for maintaining the integrity of the",
                    "decoded image data."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "lossless_7872 VP8LInverseTransform.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Add to linked list.",
                    "Connect to grid: Establish connection with external network."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Add to linked list.",
                    "Connect to grid: Establish connection with external network."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip off-mesh connections which start location could not be connected at all.",
                    "Find polygon to connect to.",
                    "Further check to make sure.",
                    "Make sure the location is on current mesh.",
                    "Link off-mesh connection to target poly.",
                    "Link target poly to off-mesh connection.",
                    "Grid connection established: Connect external network to grid."
                ]
            }
        ],
        "Normal": [
            "Connect off-mesh links.",
            "We are interested on links which land from target tile to this tile.",
            "Grid connection established: Connect external network to grid."
        ],
        "FuncName": "DetourNavMesh_5462 connectExtOffMeshLinks.txt"
    },
    {
        "Branch": [
            "Initialization of navigation grid for conditional statements in game development.",
            "Conditional statements in game development require a well-structured navigation grid.",
            "Game developers use conditional statements to control the flow of the game."
        ],
        "Loop": [
            "Initialization of navigation grid for loop conditions in game development.",
            "Loop conditions in game development require a well-structured navigation grid.",
            "Game developers use loop conditions to repeat certain actions in the game."
        ],
        "Normal": [
            "Init tiles for game world.",
            "Initialization of ID generator values for game objects.",
            "Salt value restriction for game security: only 31 bits allowed due to uint32 calculation overflow."
        ],
        "FuncName": "DetourNavMesh_5462 init.txt"
    },
    {
        "Branch": [
            " If defined, use CPUInfo() to overwrite some pointers with faster versions. In VP8 LDSP, this flag is used to enable or disable the use of the LDSP instruction set."
        ],
        "Loop": [
            " In VP8 LDSP, this flag is used to determine whether to use the LDSP instruction set or not."
        ],
        "Normal": [
            " If defined, use CPUInfo() to overwrite some pointers with faster versions."
        ],
        "FuncName": "lossless_7872 VP8LDspInit.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find tile based on hash, utilizing the game's grid system to retrieve the block at a specific position."
        ],
        "FuncName": "DetourNavMesh_5462 getTilesAt.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get grid block at specified position and layer in the game."
        ],
        "FuncName": "DetourNavMesh_5462 getTileAt.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Find tile at specified position and get a specified number of grid blocks."
        ],
        "FuncName": "DetourNavMesh_5462 getTilesAt.txt"
    },
    {
        "Branch": [
            "Check if tile exists at position with hash."
        ],
        "Loop": [
            "Iterate through tiles at position with hash."
        ],
        "Normal": [
            "Find tile based on hash.",
            "Check if tile exists at position with hash.",
            "Iterate through tiles at position with hash."
        ],
        "FuncName": "DetourNavMesh_5462 getTileRefAt.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Establish connection for tile's off-mesh link and link it to the corresponding polygon in the game world.",
                    "Add to linked list.",
                    "In the context of game development, this means linking the off-mesh connection to the target polygon to facilitate gameplay interactions."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Establish connection for tile's off-mesh link and link it to the corresponding polygon in the game world.",
                    "Add to linked list.",
                    "In the context of game development, this means linking the off-mesh connection to the target polygon to facilitate gameplay interactions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterate through the game world to find a polygon to connect the off-mesh connection to.",
                    "Start by examining the first vertex of the polygon.",
                    "Perform a further check to ensure the location is valid and within the current mesh.",
                    "Verify that the location is within the current mesh to prevent errors.",
                    "Link the off-mesh connection to the target polygon to enable gameplay interactions.",
                    "In the game world, the start end-point of the off-mesh connection is always connected back to the off-mesh connection to maintain gameplay continuity."
                ]
            }
        ],
        "Normal": [
            "Base the off-mesh connection start points on the game world's geometry to ensure seamless gameplay interactions."
        ],
        "FuncName": "DetourNavMesh_5462 baseOffMeshLinks.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of a game, when a point is directly over a polygon and closer than the climb height, favor that polygon instead of the straight line nearest point, allowing for a more realistic and immersive gameplay experience.",
                    "climb height, favor that instead of straight line nearest point."
                ]
            }
        ],
        "Normal": [
            "In a game, the nearby polygons are retrieved from a proximity grid, allowing for efficient and accurate nearest neighbor searches.",
            "In a game, the nearest polygon amongst the nearby polygons is found, enabling features such as character movement and collision detection."
        ],
        "FuncName": "DetourNavMesh_5462 findNearestPolyInTile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculate quantized box to navigate within the NavMesh.",
                    " Clamp the query box to the world box to ensure valid navigation.",
                    "Quantize the navigation data to optimize performance.",
                    " Traverse the NavMesh tree to find relevant polygons."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Do not return off-mesh connection polygons to maintain gameplay integrity.",
                    "Calculate the bounds of each polygon to ensure accurate navigation."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DetourNavMesh_5462 queryPolygonsInTile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u70b9\u4f4d\u4e8e\u591a\u8fb9\u5f62\u5916\uff0c\u9760\u8fd1\u591a\u8fb9\u5f62\u8fb9\u7f18\u7684\u70b9\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u975e\u7f51\u683c\u8fde\u63a5\u6ca1\u6709\u8be6\u7ec6\u591a\u8fb9\u5f62\u3002",
            "\u70b9\u4f4d\u4e8e\u591a\u8fb9\u5f62\u5185\uff0c\u627e\u5230\u6700\u8fd1\u7684\u591a\u8fb9\u5f62\u70b9\u3002",
            "\u627e\u5230\u8be5\u4f4d\u7f6e\u7684\u9ad8\u5ea6\u3002"
        ],
        "FuncName": "DetourNavMesh_5462 closestPointOnPoly.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5728\u6761\u4ef6\u6210\u7acb\u65f6\uff0c\u6dfb\u52a0\u5230\u94fe\u8868\u4e2d\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u4ece\u6700\u4f4e\u7d22\u5f15\u5230\u6700\u9ad8\u7d22\u5f15\uff0c\u5efa\u7acb\u7f51\u683c\u8fde\u63a5\u3002"
                ]
            },
            {
                "loopstr": [
                    "\u8df3\u8fc7\u786c\u4ef6\u548c\u975e\u5185\u90e8\u7f51\u683c\u8fde\u63a5\u3002"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "DetourNavMesh_5462 connectIntLinks.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ensure data is formatted correctly for navigation grid.",
            "Verify location is clear before proceeding.",
            "Allocate a tile within the grid.",
            "Confirm successful tile allocation.",
            "Insert tile into position lookup table.",
            "Patch header pointers for navigation.",
            "Reset tree pointer if BV tree is empty.",
            "Build links freelist for efficient navigation.",
            "Initialize tile for navigation purposes.",
            "Establish connections with neighboring tiles.",
            "Connect with layers within the current tile.",
            "Connect with neighboring tiles for seamless navigation."
        ],
        "FuncName": "DetourNavMesh_5462 addTile.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculate the distance between two line segments to ensure they are close enough to be considered adjacent in the game world."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "btBoxBoxDetector_2218 dLineClosestApproach.txt"
    },
    {
        "Branch": [
            "Set flags for conditional statements in the game."
        ],
        "Loop": [
            "Set flags for loop conditions in the game."
        ],
        "Normal": [
            " Change flags in the game."
        ],
        "FuncName": "DetourNavMesh_5462 setPolyFlags.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ensure sufficient map block storage capacity.",
            "Verify the possibility of restoration.",
            "Restore polygonal state in the map."
        ],
        "FuncName": "DetourNavMesh_5462 restoreTileState.txt"
    },
    {
        "Branch": [
            "Check if the current polygon is an off-mesh connection in the specified game."
        ],
        "Loop": [],
        "Normal": [
            " Get current polygon",
            " Make sure that the current poly is indeed an off-mesh connection in the specified game."
        ],
        "FuncName": "DetourNavMesh_5462 getOffMeshConnectionByRef.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ensure sufficient grid space to store map block states.",
            "Store tile state in grid map.",
            "Store polygon state in grid map."
        ],
        "FuncName": "DetourNavMesh_5462 storeTileState.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In this game, a point is inside the cut line."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In this game, a line segment crosses the cut line."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In this game, the direction is represented as xy[0] = x-axis and xy[1] = y-axis."
                ]
            },
            {
                "loopstr": [
                    "In this game, the line is cut by xy[dir] = sign*h[dir]."
                ]
            },
            {
                "loopstr": [
                    "In this game, all points and line segments between adjacent points in q are traversed."
                ]
            }
        ],
        "Normal": [
            "In this game, q (and r) contains nq (and nr) coordinates of the current (and cut) polygon.",
            "In this game, q (and r) contains nq (and nr) coordinates of the current (and cut) polygon."
        ],
        "FuncName": "btBoxBoxDetector_2218 intersectRectQuad2.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of a polygon game, the iret value is not allowed to retain this value, but it occasionally does so when the difference is #QNAN0.",
                    "Ensure iret is set correctly in the game."
                ]
            }
        ],
        "Normal": [
            "In the game, compute the centroid of the polygon in cx,cy.",
            "In the game, compute the angle of each point with respect to the centroid.",
            "In the game, search for points that have angles closest to A[i0] + i*(2*pi/m)."
        ],
        "FuncName": "btBoxBoxDetector_2218 cullPoints2.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Owns data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remove tile from hash lookup.",
            "Disconnect neighbour tiles.",
            "Reconnect neighbour tiles.",
            "Reset tile state.",
            "Update tile hash.",
            "Add to free list."
        ],
        "FuncName": "DetourNavMesh_5462 removeTile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get current polygon",
            "Verify that the current polygon is an off-mesh link in the game.",
            "Determine the direction to distribute the vertices in the game.",
            "Locate the link that points to the first vertex in the game."
        ],
        "FuncName": "DetourNavMesh_5462 getOffMeshConnectionPolyEndPoints.txt"
    },
    {
        "Branch": [
            "Check if player's health is above 50% and close the game if true."
        ],
        "Loop": [],
        "Normal": [
            "keep us alive through the close of the game in our favorite RPG."
        ],
        "FuncName": "ResourceEditor_1604 Close.txt"
    },
    {
        "Branch": [
            "in a game of physics, the if condition is often related to the inertia of objects"
        ],
        "Loop": [
            "in a game of physics, the loop condition is often related to the calculation of inertia"
        ],
        "Normal": [
            "in a game of physics, the inertia of the box that bounds the spheres is a critical factor in approximating their motion"
        ],
        "FuncName": "btMultiSphereShape_3320 calculateLocalInertia.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, this code snippet handles file change events. When a file is modified, the script checks if the modified file matches the expected file path. If a match is found, it attempts to close the file if it no longer exists."
        ],
        "FuncName": "ResourceEditor_1604 HandleFileChanged.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Constructing a polyhedral shape in a physics engine, such as Bullet Physics, typically involves creating a convex hull from a set of vertices and edges. This can be achieved by using a library or framework that provides functions for creating and manipulating 3D geometry, such as Open3D or PCL. The code snippet you provided appears to be a C++ code that initializes a scalar variable btScalar with a large float value, likely used as a margin for collision detection. However, to construct a polyhedral shape, you would need to create a list of vertices and edges, and then use a function to create a convex hull from this data. The resulting shape can then be used in a physics engine to simulate collisions and other physical interactions."
        ],
        "FuncName": "btMultiSphereShape_3320 btMultiSphereShape.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "success",
                    "In a game, a success condition is met when the player achieves a desired outcome."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we truncated the list",
                    "In a game, truncating a list may occur when the player's actions exceed the game's memory capacity."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if there's not already an error, store this one",
            "In a game, storing an error message is crucial for debugging and player feedback."
        ],
        "FuncName": "cf2arrst_6106 cf2_arrstack_setNumElements.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Update already existing statistics for Block-based Games",
                    "write pointer to statistics into output (this is BlocksTree:: per_thread_stats or per_parent_stats or per_frame_stats) for Block-based Games",
                    "update calls number of this block in Block-based Games",
                    "update summary duration of all block calls for Block-based Games",
                    "average duration is calculated inside average_duration() method by dividing total_duration to the calls_number for Block-based Games"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "update max duration for Block-based Games",
                    "stats->max_duration = duration;"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "update min duration for Block-based Games",
                    "stats->min_duration = duration;"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "StatsMap::key_type key(_current.node->name());",
            "auto it = _stats_map.find(key);",
            "This is first time the block appear in the file.",
            "Create new statistics for Block-based Games.",
            "_stats_map.emplace(key, stats);"
        ],
        "FuncName": "reader_4701 update_statistics.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Loading interrupted. This is a critical error in the game's loading process."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "A thread is being created with ID and blocks. This is a key step in the game's multi-threading mechanism."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Loading interrupted. This is a critical error in the game's loading process."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "A tree is being moved using std::move. This is an optimization technique used in the game's memory management."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If a block has a runtime name, a new ID will be generated for it. Blocks with the same name will share the same ID. This is a key feature in the game's block management system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "There is already a block with this name, so its ID will be used. This is a way to avoid duplicate IDs in the game's block management system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "A lower bound is being found in the tree using std::lower_bound. This is a search algorithm used in the game's tree traversal mechanism."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The per-parent statistics are being reserved to improve performance. This is an optimization technique used in the game's statistics management system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The maximum stack depth is 255, which includes one level for the root thread. This is a key limitation in the game's thread management system."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "A thread is being created with ID and blocks. This is a key step in the game's multi-threading mechanism."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Loading interrupted. This is a critical error in the game's loading process."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Loading interrupted. This is a critical error in the game's loading process."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the loop index exceeds the descriptors memory size, the file is corrupted and the program returns. This is a critical error handling mechanism in the game's file loading process.",
                    "This is a critical error message printed when the file is corrupted.",
                    "The program returns with a non-zero exit code when the file is corrupted."
                ]
            },
            {
                "loopstr": [
                    "The tree is being shrunk to fit in memory. This is an optimization technique used in the game's memory management."
                ]
            },
            {
                "loopstr": [
                    "The tree is being sorted using std::sort. This is a search algorithm used in the game's tree traversal mechanism.",
                    "The blocks are being sorted based on their node beginnings.",
                    "The tree is being shrunk to fit in memory after sorting."
                ]
            }
        ],
        "Normal": [
            "The old data is being retrieved from the append regime. This is a key step in the game's data validation process.",
            "The old data is being validated using the validate_pointers function. This is a critical error handling mechanism in the game's data validation process.",
            "The old data is being retrieved from the append regime. This is a key step in the game's data validation process.",
            "The old data is being validated using the validate_pointers function. This is a critical error handling mechanism in the game's data validation process.",
            "The BlockStatistics instances will be deleted automatically when the BlocksTree destructors are called. This is a key feature in the game's memory management system."
        ],
        "FuncName": "reader_4701 fillTreesFromStream.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This is a slower alternative to the wrapDegrees_180() function, which is commonly used in 2D game development to ensure angle values stay within the range of -180 to 180 degrees;",
            "used as a reference for testing"
        ],
        "FuncName": "test_utilities_9360 ref_WrapDegrees180.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This is a slower alternative to the wrapDegrees_0_360() function, which ensures angle values are within 0 to 360 degrees for [game] purposes;",
            "used as a reference for testing in [game] development"
        ],
        "FuncName": "test_utilities_9360 ref_WrapDegrees_0_360.txt"
    },
    {
        "Branch": [
            "If-Condition for Direct3D game"
        ],
        "Loop": [
            "Loop-Condition for Direct3D game"
        ],
        "Normal": [
            "No-op on Direct3D. Direct3D is a graphics API used in various games."
        ],
        "FuncName": "D3D11RenderSurface_115 OnDeviceLost.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "only x test with little step, a common movement in 3D games",
            "only y test with little step, a common movement in 3D games",
            "only z test with little step, a common movement in 3D games",
            "test the whole coordinate translation, a crucial aspect in game physics"
        ],
        "FuncName": "test_utilities_9360 testWrapDegrees_0_360_v3f.txt"
    },
    {
        "Branch": [
            "Test if condition is met in the game"
        ],
        "Loop": [
            "Check loop condition to progress in the game"
        ],
        "Normal": [
            "Nested escapes not supported in game development"
        ],
        "FuncName": "test_utilities_9360 testRemoveEscapes.txt"
    },
    {
        "Branch": [
            "Test if-conditions in a game environment"
        ],
        "Loop": [
            "Test loop conditions in a game loop"
        ],
        "Normal": [
            "A game may intentionally ignore Unicode characters in certain situations"
        ],
        "FuncName": "test_utilities_9360 testLowercase.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " test UTF-8 encoding and conversion between wide characters in the context of a game development project.",
            " conversion between wide characters in a game development project.",
            " UTF-8 encoding and conversion in a game context."
        ],
        "FuncName": "test_utilities_9360 testUTF8.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Blue foreground, used in game to represent a specific item or character.",
            "Green background, then white and yellow text, often used in game to indicate a specific state or condition.",
            "Blue foreground, used in game to represent a specific item or character.",
            "Still yellow text, often used in game to indicate a specific status or effect.",
            "Green background, used in game to indicate a specific state or condition."
        ],
        "FuncName": "test_utilities_9360 testEnrichedString.txt"
    },
    {
        "Branch": [
            "test the sanitize_untrusted function with special characters and edge cases in game code"
        ],
        "Loop": [
            "test the sanitize_untrusted function with special characters and edge cases in game code"
        ],
        "Normal": [
            "edge cases in game code"
        ],
        "FuncName": "test_utilities_9360 testSanitizeUntrusted.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "test that wrap_rows doesn't wrap inside multibyte sequences in a game context where folding is crucial for puzzle-solving"
        ],
        "FuncName": "test_utilities_9360 testWrapRows.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Base64 encoded character set: A-Za-z0-9+/= ",
            "Base64 encoded empty string: ",
            "Base64 encoded different lengths with and without padding: AAAA==, AAAA/=/",
            "Base64 encoded correct and incorrect padding: AAAA==, AAAA=== ",
            "Base64 encoded canonical encoding: ",
            "Base64 encoded last character limitations length % 4 == 3: AAA= ",
            "Base64 encoded last character limitations length % 4 == 2: AAA= ",
            "Base64 encoded extraneous character present: AAA= ",
            "Base64 encoded padding in wrong position: AAA= "
        ],
        "FuncName": "test_utilities_9360 testBase64.txt"
    },
    {
        "Branch": [
            "Ensures that there is no cutting off going on in the game context...",
            "If there were, 331 would be cut to 75 in this example in the game scenario",
            "and 73 is a valid ASCII char. in the ASCII character set used in the game"
        ],
        "Loop": [
            "Ensures that there is no cutting off going on in the game loop...",
            "If there were, 331 would be cut to 75 in this example in the game loop iteration",
            "and 73 is a valid ASCII char. in the ASCII character set used in the game loop"
        ],
        "Normal": [
            "Ensures that there is no cutting off going on in the game context...",
            "If there were, 331 would be cut to 75 in this example in the game scenario",
            "and 73 is a valid ASCII char. in the ASCII character set used in the game"
        ],
        "FuncName": "test_utilities_9360 testAsciiPrintableHelper.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This test may fail on non-IEEE systems. This is a critical issue for game development.",
            "Low tolerance is 4 ulp(1.0) for binary floats with 24 bit mantissa. This affects game physics simulations.",
            "ulp = unit in the last place; ulp(1.0) = 2^-23. Understanding this concept is crucial for game engine optimization.",
            "High tolerance is 2 ulp(180.0), needed for numbers in degrees. This is particularly important for game mechanics involving angles and rotations.",
            "ulp(180.0) = 2^-16. This is a key consideration for game developers working with trigonometry and geometry.",
            "Check that the radians version and the degrees version produce the same results. This is essential for maintaining consistency in game calculations.",
            "Check also that the conversion works both ways for these values. This ensures that game data is accurately transferred between formats.",
            "Check the rotation matrix produced. This is critical for game graphics and physics simulations.",
            "Check that the matrix is still homogeneous with no translation. This is a fundamental requirement for game engine transformations.",
            "Compare to Irrlicht's results. To be comparable, the angles must come in a different order and the matrix elements to compare are different too. This is a key aspect of game engine benchmarking.",
            "Check that Eulers that produce near gimbal-lock still round-trip. This is a challenging scenario for game engine math libraries.",
            "Check that Eulers at an angle > 90 degrees may not round-trip... however the rotation matrix is the same for both. This is a subtle but important consideration for game developers working with 3D rotations.",
            "UASSERT(within(v1, v2, tolL)); // this is typically false. This assertion highlights a potential issue in game engine math calculations.",
            "... however the rotation matrix is the same for both. This demonstrates the importance of considering multiple perspectives in game engine math."
        ],
        "FuncName": "test_utilities_9360 testEulerConversion.txt"
    },
    {
        "Branch": [
            "Game condition: If-Condition-Str is a conditional statement in game code.",
            "It is used to evaluate a condition and execute code based on the result."
        ],
        "Loop": [
            "Game condition: Loop-Condition-Str is a loop condition in game code.",
            "It is used to control the number of iterations in a loop."
        ],
        "Normal": [
            "Game resource: Because BeginLoad/EndLoad can be called from worker threads, where profiling would be a no-op,",
            "create a type name-based profile block here. Game resource: If we are loading synchronously in a non-main thread, behave as if async loading (for example use GetTempResource instead of GetResource to load resource dependencies)."
        ],
        "FuncName": "Resource_3999 Load.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "we need to construct a quadratic equation (x - X)^2 + (y - Y)^2 + (z - Z)^2 for the game"
        ],
        "FuncName": "simplifier_4725 quadricFromPoint.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Optimized Spatial Hashing for Collision Detection of Deformable Objects in 3D Game Engines"
        ],
        "FuncName": "simplifier_4725 hash.txt"
    },
    {
        "Branch": [
            "In game logic, if a condition is met, the game executes a specific action."
        ],
        "Loop": [
            "In game programming, a loop condition is used to control the repetition of a set of instructions."
        ],
        "Normal": [
            "In game development, if there are more references than the resource cache can handle, the game returns always 0 and resets the timer."
        ],
        "FuncName": "Resource_3999 GetUseTimer.txt"
    },
    {
        "Branch": [
            "check if there are any edges with non-zero edge count",
            "check if there are any edges with non-zero edge data"
        ],
        "Loop": [
            "iterate over all edges with non-zero edge count",
            "iterate over all edges with non-zero edge data"
        ],
        "Normal": [
            "allocate arrays for vertex adjacency list",
            "fill edge counts for vertex adjacency list",
            "fill offset table for vertex adjacency list",
            "fill edge data for vertex adjacency list",
            "fix offsets that have been disturbed by the previous pass in vertex adjacency list"
        ],
        "FuncName": "simplifier_4725 buildEdgeAdjacency.txt"
    },
    {
        "Branch": [
            "If-Condition: Constructing a parabolic surface from a triangle in 3D geometry for game development."
        ],
        "Loop": [
            "Loop-Condition: Iterating over the vertices of a triangle to compute the normal vector in a game engine."
        ],
        "Normal": [
            "Normal: The normal vector of a triangle is computed as the cross product of vectors p1-p0 and p2-p0. This is a common technique used in computer graphics to determine the surface normal of a 3D object. In the context of game development, this is crucial for lighting, shading, and collision detection.",
            "we use sqrtf(area) so that the error is scaled linearly; this tends to improve silhouettes, which is essential for creating realistic and immersive game environments."
        ],
        "FuncName": "simplifier_4725 quadricFromTriangle.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of game development, classifying vertices as manifold is crucial for efficient rendering and collision detection. However, if a vertex has no open edges, it's considered manifold, but this can lead to incorrect classification if four triangles share an edge. This might not be a significant issue in practice.",
                    "In game development, attribute seams are used to distinguish between locked and seam vertices. A seam vertex should have one open half-edge for each vertex, and the edges should connect to the same vertex post-remap."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In game development, attribute seams are used to distinguish between locked and seam vertices. A seam vertex should have one open half-edge for each vertex, and the edges should connect to the same vertex post-remap."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In game development, the number of incoming and outgoing open edges is critical for determining vertex types. A value of ~0u indicates no open edges, while a value of i signifies more than one open edge. This data is also relevant for border/seam vertices and is used in loop[] arrays.",
            "For game development, it's essential to fill out the data for all vertex types, including locked vertices, which can have many open edges, a disconnected seam, many seam edges, or many wedges."
        ],
        "FuncName": "simplifier_4725 classifyVertices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "build forward remap: for each vertex, which other (canonical) vertex does it map to? This is done using position equivalence, where vertices are remapped to existing vertices in the game.",
            "we use position equivalence for this, and remap vertices to other existing vertices in the game's canonical form.",
            "build wedge table: for each vertex, which other vertex is the next wedge that also maps to the same vertex? This table forms a cyclic wedge loop per vertex, where manifold vertices have wedge[i] == remap[i] == i, indicating a valid map in the game.",
            "entries in table form a (cyclic) wedge loop per vertex; for manifold vertices, wedge[i] == remap[i] == i, ensuring a valid and consistent game world."
        ],
        "FuncName": "simplifier_4725 buildPositionRemap.txt"
    },
    {
        "Branch": [
            "If this condition is met, the game will proceed"
        ],
        "Loop": [
            "This loop will continue until the game is won"
        ],
        "Normal": [
            "This is a normal string in the game, used for player interaction"
        ],
        "FuncName": "Resource_3999 BeginLoad.txt"
    },
    {
        "Branch": [
            "If no GPU upload step is necessary, no override is necessary in this game type."
        ],
        "Loop": [],
        "Normal": [
            "In this game, if no GPU upload step is necessary, no override is necessary."
        ],
        "FuncName": "Resource_3999 EndLoad.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "hash collision, quadratic probing in game development"
                ]
            }
        ],
        "Normal": [
            "unreachable in game programming"
        ],
        "FuncName": "simplifier_4725 hashLookup2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of 3D game development, Optimized Spatial Hashing is a technique used for collision detection of deformable objects. It relies on computing a three-dimensional index's hash value to efficiently identify potential collisions."
        ],
        "FuncName": "simplifier_4725 hash.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculating 3D point hashes for optimized collision detection of deformable objects in 3D space."
        ],
        "FuncName": "simplifier_4725 hash.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Computing 3D index hash for Deformable Objects in Optimized Spatial Hashing for Collision Detection."
        ],
        "FuncName": "simplifier_4725 hash.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Setup the texture name for the 3D model",
            "Setup the texture blend factor for the game",
            "Setup the texture mapping mode for the game engine",
            "Mirroring - double the scaling values for the game's 3D model",
            "FIXME: this is not really correct in the context of the game",
            "Setup texture UV transformations for the game's 3D model"
        ],
        "FuncName": "3DSConverter_2820 CopyTexture.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Only apply this operation to the first material."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Warning: Passing background image to viewer bypasses material system. This is an evil hack, never do it again!",
            "First, add base background color to the material",
            "Material color",
            "Phong shininess and specular intensity",
            "Opacity",
            "Bumpmap scale",
            "Double-sided rendering?",
            "Shading mode",
            "Diffuse texture",
            "Specular texture",
            "Opacity texture",
            "Emissive texture",
            "Bump texture",
            "Shininess texture",
            "Reflection texture",
            "Store the material's name itself"
        ],
        "FuncName": "3DSConverter_2820 ConvertMaterial.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Check if either i0 or i1 are border/seam edges and share the same edge loop in the game context.",
                    "Note that we need to add an error for edges connecting a border and a locked edge in the game.",
                    "If we don't do this, the adjacent border->border edge won't have correct errors for corners in the game.",
                    "Seam edges should occur twice (i0->i1 and i1->i0) - skip redundant edges in the game.",
                    "We try hard to maintain border edge geometry; seam edges can move more freely within the game's constraints.",
                    "Due to topological restrictions on collapses, seam quadrics slightly improves collapse structure but aren't critical in the game."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "simplifier_4725 fillEdgeQuadrics.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "check whether all indices are in range for 3D model"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "3DSConverter_2820 CheckIndices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "We need to create our own default material",
                    "for this game, we will replace default materials with custom ones"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "NOTE: The additional check seems to be necessary,",
                    "some exporters seem to generate invalid data here",
                    "we will iterate through all meshes and faces to find default materials"
                ]
            }
        ],
        "Normal": [
            "Try to find an existing material that matches the",
            "typical default material setting:",
            "- no textures",
            "- diffuse color (in grey!)",
            "NOTE: This is here to workaround the fact that some",
            "exporters are writing a default material, too.",
            "for this game, we will replace default materials with custom ones",
            "now iterate through all meshes and through all faces and",
            "find all faces that are using the default material"
        ],
        "FuncName": "3DSConverter_2820 ReplaceDefaultMaterial.txt"
    },
    {
        "Branch": [
            "If condition: font glyph size and hinting flags are retrieved for the game."
        ],
        "Loop": [
            "Loop condition: font glyph size and hinting flags are retrieved for the game."
        ],
        "Normal": [
            "Note: FreeType scale includes a factor of 64 for the game's font rendering."
        ],
        "FuncName": "cf2ft_9798 cf2_getScaleAndHintFlag.txt"
    },
    {
        "Branch": [
            "override what node name is in prefab with conditional logic",
            "apply game-specific rules for node name in prefab"
        ],
        "Loop": [
            "override what node name is in prefab with loop conditions",
            "apply game-specific rules for node name in prefab with loops"
        ],
        "Normal": [
            "override what node name is in prefab"
        ],
        "FuncName": "JSScene_9917 Node_CreateChildPrefab.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "now generate submeshes for 3D game models",
                    "convert 3DStudio file face data to ASSIMP format"
                ]
            },
            {
                "loopstr": [
                    "be sure to setup the correct material index for game assets",
                    "use the color data as temporary storage for game textures",
                    "convert vertices from 3DStudio file to game engine format",
                    "allocate enough storage for faces in game engine"
                ]
            }
        ],
        "Normal": [
            "for 3D game models, we need to split all meshes by their materials",
            "Copy them to the output array for game model conversion",
            "We should have at least one face here in the game model"
        ],
        "FuncName": "3DSConverter_2820 ConvertMeshes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "record the move before the line; also check points and set ",
                    "path_begun",
                    "In the context of game development, recording the move before drawing a line involves storing the current position or state of the game object. This is often used in pathfinding or animation sequences."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "downcast the object pointer ",
            "cff_builder_add_point1 includes a check_points call for one point ",
            "In game development, downcasting an object pointer refers to the process of treating a parent class object as if it were of a more derived class. This is often used to access specific methods or properties of the derived class."
        ],
        "FuncName": "cf2ft_9798 cf2_builder_lineTo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Generating a flat hierarchy for a severely corrupted file.",
                    "The resulting structure will resemble a tree with all nodes at the same level:",
                    "",
                    "                ROOT_NODE",
                    "                   |",
                    "   ----------------------------------------",
                    "   |       |       |            |         |",
                    " MESH_0  MESH_1  MESH_2  ...  MESH_N    CAMERA_0 ....",
                    "",
                    "Creating dummy nodes for all meshes, cameras, and lights.",
                    "This is necessary due to the file's damaged hierarchy."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Initializing the animation system by allocating a primary animation channel.",
                    "Reserving storage for node animation channels without setting the mNumChannels member.",
                    "This will allow us to use the array as an index for animation channels."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Constructing a name for the node, a crucial step in the node creation process."
                ]
            },
            {
                "loopstr": [
                    "Constructing a name for the node, a crucial step in the node creation process."
                ]
            },
            {
                "loopstr": [
                    "Constructing a name for the node, a crucial step in the node creation process."
                ]
            }
        ],
        "Normal": [
            "Cleaning up temporary values stored in vertex color sets.",
            "If the root node lacks a name, assigning it '<3DSRoot>' for consistency."
        ],
        "FuncName": "3DSConverter_2820 GenerateNodeGraph.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "1) Verify handle validity in cloned object",
            "2) Validate C++ class in cloned object",
            "3) Confirm correct object cloning",
            "4) Ensure object was successfully cloned, not just duplicated"
        ],
        "FuncName": "test_objdef_9298 testClone.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "account for the additional channel for the camera/spotlight target position, considering the game's physics engine and collision detection"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "We will never generate more than one channel for a node, so, in the context of the game, this is rather easy here. The game's AI will recursively process all children nodes.",
            "In this game, we are using a recursive approach to process all children nodes.",
            "Recursively process all children, considering the game's node hierarchy and data structure"
        ],
        "FuncName": "3DSConverter_2820 CountTracks.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "record the move before the line; also check points and set the cube's endpoint as the current position.",
                    "path_begun"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "downcast the object pointer in the cube-based game world.",
            "prepare room for 3 points: 2 off-curve, 1 on-curve, as per the cube's movement rules."
        ],
        "FuncName": "cf2ft_9798 cf2_builder_cubeTo.txt"
    },
    {
        "Branch": [
            "Check if the condition is met in the game"
        ],
        "Loop": [
            "Determine the loop condition in the game"
        ],
        "Normal": [
            "Ignore blanks in the game"
        ],
        "FuncName": "OpenDDLParser_152 parseName.txt"
    },
    {
        "Branch": [
            "Conditional statement: IF (condition) THEN (statement)"
        ],
        "Loop": [
            "Looping statement: WHILE (condition) DO (statement)"
        ],
        "Normal": [
            "empty",
            "A normal string in a game context can be a dialogue line, a item description, or a game-related text."
        ],
        "FuncName": "OpenDDLParser_152 OpenDDLParser.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "parse a primitive data type",
                    "In the context of the game, this means analyzing a basic data element, such as a number or a string."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "OpenDDLParser_152 parseStructureBody.txt"
    },
    {
        "Branch": [
            "If-Condition: OpenDDL format parsing"
        ],
        "Loop": [],
        "Normal": [
            "do the main parsing",
            "game specific parsing: OpenDDL data analysis"
        ],
        "FuncName": "OpenDDLParser_152 parse.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "install user-specific log callback for game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "OpenDDLParser_152 setLogCallback.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In if-conditions, loop over all children (data and nodes) to determine the next step in the game's decision tree."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "After parsing, pop the node from the stack to progress to the next level in the game."
        ],
        "FuncName": "OpenDDLParser_152 parseStructure.txt"
    },
    {
        "Branch": [
            "If condition is met, the game will proceed to the next step."
        ],
        "Loop": [
            "Loop condition is checked to ensure the game runs smoothly."
        ],
        "Normal": [
            "empty"
        ],
        "FuncName": "OpenDDLParser_152 OpenDDLParser.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "skip the comment and the rest of the line",
                    "in the context of a game, this might involve skipping over a certain section of code or a specific action"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "check for a comment",
                    "in a game, this might involve checking for a specific condition or event that triggers a loop"
                ]
            }
        ],
        "Normal": [
            "remove comments and clean up whitespace"
        ],
        "FuncName": "OpenDDLParser_152 normalizeBuffer.txt"
    },
    {
        "Branch": [
            "parse the float value in if condition"
        ],
        "Loop": [
            "parse the float value in loop condition"
        ],
        "Normal": [
            "parse the float value"
        ],
        "FuncName": "OpenDDLParser_152 parseFloatingLiteral.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "swap rows in a matrix by swapping row pointers, a fundamental operation in game development",
            "swap columns in a matrix the hard way, a common challenge in game programming"
        ],
        "FuncName": "btDantzigLCP_4243 btSwapRowsAndCols.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "for testing we can do some random swaps in the area i > nub { const int n = m_n; const int nub = m_nub; if (nub < n) { for (int k=0; k<100; k++) { int i1,i2; do { i1 = dRandInt(n-nub)+nub; i2 = dRandInt(n-nub)+nub; } while (i1 > i2); btSwapProblem (m_A,m_x,m_b,m_w,m_lo,m_hi,m_p,m_state,m_findex,n,i1,i2,m_nskip,0); } } ",
            "permute the problem so that all the unbounded variables are at the start, which is crucial for the game's factorization process.",
            "start i.e. look for unbounded variables not included in nub we can potentially push up nub this way and get a bigger initial factorization, which is essential for the game's solution process.",
            "note that when we swap rows/cols here we must not just swap row pointers as the initial factorization relies on the data being all in one chunk, because the game's algorithm requires contiguous data.",
            "variables that have findex >= 0 are not considered to be unbounded even if lo=-inf and hi=inf - this is because these limits may change during the solution process, and the game's algorithm needs to account for this.",
            "if there are unbounded variables at the start factorize A up to that point and solve for x this puts all indexes 0..nub-1 into C, which is a critical step in the game's solution process.",
            "permute the indexes > nub such that all findex variables are at the end, because the game's algorithm requires the findex variables to be in a specific order.",
            "print info about indexes, such as the number of bounded and unbounded variables, which is useful for debugging and understanding the game's solution process.",
            "{ const int n = m_n; const int nub = m_nub; for (int k=0; k<n; k++) { if (k<nub) printf (C); else if (m_lo[k]==-BT_INFINITY && m_hi[k]==BT_INFINITY) printf (c); else printf ( .); } printf (\n); } "
        ],
        "FuncName": "btDantzigLCP_4243 btLCP.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Solve LDL decomposition for each 2x2 block in the matrix A, where l is the scaled elements in the 2x1 block at A(i,0)",
                    "Scale the elements in the 2x1 block at A(i,0) and compute the outer product matrix Z for the LDL decomposition",
                    "Compute the number of left-over iterations for the LDL decomposition",
                    "Solve the diagonal 2x2 block at A(i,i) using LDL decomposition",
                    "Factorize the 2x2 block Z,dee into LDL form",
                    "Factorize the first row of the matrix A using LDL decomposition",
                    "Factorize the second row of the matrix A using LDL decomposition",
                    "Complete the factorization of the 2x2 block"
                ]
            }
        ],
        "Normal": [
            "Compute the last (less than 2) rows of the LDL decomposition"
        ],
        "FuncName": "btDantzigLCP_4243 btFactorLDLT.txt"
    },
    {
        "Branch": [
            "Compute 2x1 blocks of matrix X in if condition"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Compute 2x1 blocks of matrix X from rows i to i+2-1 in outer loop",
                    "Initialize Z matrix to 0 in outer loop",
                    "Compute outer products and add them to Z matrix in inner loop",
                    "Compute left-over iterations in inner loop",
                    "Finish computing X(i) block in inner loop",
                    "End of outer loop"
                ]
            },
            {
                "loopstr": [
                    "Compute outer product and add it to Z matrix in inner loop",
                    "Compute outer product and add it to Z matrix in inner loop",
                    "Advance pointers in inner loop",
                    "End of inner loop"
                ]
            },
            {
                "loopstr": [
                    "Compute outer product and add it to Z matrix in inner loop",
                    "Advance pointers in inner loop"
                ]
            }
        ],
        "Normal": [
            "Declare variables Z matrix, p and q vectors, etc in normal condition",
            "Compute all 2x1 blocks of matrix X in normal condition"
        ],
        "FuncName": "btDantzigLCP_4243 btSolveL1_1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the game of chess, the ELL Dell maneuver is a strategic move where the player computes the elliptical distance between two points, represented by the equation D / L1solve (L,A(i,C)), where D is the distance between the two points, L1 is the length of the major axis, and A(i,C) is the area of the ellipse."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "btDantzigLCP_4243 transfer_i_to_C.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of the game, the player must compute all 4 x 1 blocks of X from rows i..i+4-1.",
                    "The player must set the Z matrix to 0.",
                    "The player must compute the inner loop that computes outer products and adds them to Z.",
                    "The player must compute left-over iterations.",
                    "The player must finish computing the X(i) block.",
                    "The player must end the outer loop."
                ]
            },
            {
                "loopstr": [
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must end the inner loop."
                ]
            },
            {
                "loopstr": [
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix."
                ]
            },
            {
                "loopstr": [
                    "The player must compute all 1 x 1 blocks of X from rows i..i+1-1.",
                    "The player must set the Z matrix to 0.",
                    "The player must compute the inner loop that computes outer products and adds them to Z.",
                    "The player must compute left-over iterations.",
                    "The player must finish computing the X(i) block."
                ]
            },
            {
                "loopstr": [
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix.",
                    "The player must end the inner loop."
                ]
            },
            {
                "loopstr": [
                    "The player must load p and q values.",
                    "The player must compute outer product and add it to the Z matrix."
                ]
            }
        ],
        "Normal": [
            "The player must declare variables - Z matrix, p and q vectors, etc.",
            "The player must declare a variable lskip3.",
            "The player must handle special cases for L and B because they are solving L1 *transpose*.",
            "The player must compute lskip values.",
            "The player must compute lskip3 = 3*lskip1.",
            "The player must compute all 4 x 1 blocks of X.",
            "The player must compute rows at the end that are not a multiple of the block size."
        ],
        "FuncName": "btDantzigLCP_4243 btSolveL1T.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "compute all 4 x 1 block of X from rows i..i+4-1 in a linear system.",
                    "Set the Z matrix to 0, initializing it for computation.",
                    "The inner loop computes outer products and adds them to the Z matrix, a crucial step in solving linear systems.",
                    "Compute left-over iterations to ensure completeness.",
                    "Finish computing the X(i) block, a key component in the linear system solution.",
                    "End of outer loop, marking the completion of a critical step in the computation."
                ]
            },
            {
                "loopstr": [
                    "Load p and q values, essential for the computation.",
                    "Compute outer product and add it to the Z matrix, a fundamental operation in linear system solving.",
                    "Load p and q values again, preparing for the next computation.",
                    "Compute outer product and add it to the Z matrix, building the solution.",
                    "This process repeats, with the loading and computing of p and q values, to construct the solution.",
                    "Finally, advance pointers to mark the progress in the computation.",
                    "End of inner loop, indicating the completion of a crucial section in the linear system solution."
                ]
            },
            {
                "loopstr": [
                    "Load p and q values, the starting point for computation.",
                    "Compute outer product and add it to the Z matrix, advancing the solution.",
                    "Advance pointers to track the progress in the computation."
                ]
            },
            {
                "loopstr": [
                    "Compute all 1 x 1 block of X from rows i..i+1-1, focusing on a specific aspect of the linear system.",
                    "Set the Z matrix to 0, initializing it for the computation.",
                    "The inner loop computes outer products and adds them to the Z matrix, a critical step in solving the linear system.",
                    "Compute left-over iterations to ensure completeness.",
                    "Finish computing the X(i) block, a key component in the linear system solution."
                ]
            },
            {
                "loopstr": [
                    "Load p and q values, essential for the computation.",
                    "Compute outer product and add it to the Z matrix, a fundamental operation in linear system solving.",
                    "This process repeats, with the loading and computing of p and q values, to construct the solution.",
                    "Finally, advance pointers to mark the progress in the computation.",
                    "End of inner loop, indicating the completion of a crucial section in the linear system solution."
                ]
            },
            {
                "loopstr": [
                    "Load p and q values, the starting point for computation.",
                    "Compute outer product and add it to the Z matrix, advancing the solution.",
                    "Advance pointers to track the progress in the computation."
                ]
            }
        ],
        "Normal": [
            "Declare variables, including the Z matrix, p and q vectors, etc., to set up the linear system.",
            "Compute lskip values, a critical step in preparing the linear system for solution.",
            "Compute all 4 x 1 blocks of X, a key component in the linear system solution.",
            "Compute rows at the end that are not a multiple of block size, ensuring completeness in the solution."
        ],
        "FuncName": "btDantzigLCP_4243 btSolveL1.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of game development, compute all 2 x 2 blocks of a 2D array X, from rows i to i+2-1, which is a common operation in matrix multiplication used in game physics.",
                    "Set the Z matrix to 0, which represents the accumulation of outer products in game physics.",
                    "The inner loop that computes outer products and adds them to the Z matrix is a key step in game physics, where the outer product represents the interaction between two game objects.",
                    "Compute left-over iterations, which is a common issue in game physics when dealing with matrices of different sizes.",
                    "Finish computing the X(i) block, which represents a 2x2 sub-matrix in game physics.",
                    "End of outer loop, which marks the completion of a game physics operation."
                ]
            },
            {
                "loopstr": [
                    "Compute the outer product of two 2D arrays and add it to the Z matrix, which represents the accumulation of interactions between game objects in game physics.",
                    "Compute the outer product of two 2D arrays and add it to the Z matrix, which represents the accumulation of interactions between game objects in game physics.",
                    "Advance pointers to the next game object in the game physics simulation.",
                    "End of inner loop, which marks the completion of a game physics operation."
                ]
            },
            {
                "loopstr": [
                    "Compute the outer product of two 2D arrays and add it to the Z matrix, which represents the accumulation of interactions between game objects in game physics.",
                    "Advance pointers to the next game object in the game physics simulation."
                ]
            }
        ],
        "Normal": [
            "Declare variables used in game physics, such as the Z matrix, p and q vectors, etc.",
            "Compute all 2 x 2 blocks of a 2D array X, which is a common operation in game physics."
        ],
        "FuncName": "btDantzigLCP_4243 btSolveL1_2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "now we have to un-permute x and w to solve the puzzle in the game"
        ],
        "FuncName": "btDantzigLCP_4243 unpermute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, we can calculate the matrix BTAROW and multiply it with vector q to get vector p.",
            "To optimize this process in the game, we could use outer product matrix tricks like the dMultidotX functions.",
            "However, in my testing with 100x100 problems, using these tricks actually made the process slower due to the overhead involved.",
            "Therefore, for now, we will stick with the simple method for game calculations."
        ],
        "FuncName": "btDantzigLCP_4243 pN_equals_ANC_times_qC.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Copy vertex data",
                    "A polygon with a custom geometry is created in the game, using a convex polyhedron."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "CollisionShape_7759 ConvexData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Transition from original variable space to current variable space.",
            "if we just finish here then we'll go back and re-solve for delta_x. but actually we can be more efficient and incrementally update delta_x here. but if we do this, we wont have ell and Dell to use in updating the factorization later. This is a key aspect of the game's variable space management.",
            "Transition from original variable space to current variable space.",
            "if we just finish here then we'll go back and re-solve for delta_x. but actually we can be more efficient and incrementally update delta_x here. but if we do this, we wont have ell and Dell to use in updating the factorization later. This is a key aspect of the game's variable space management.",
            "Transition from original variable space to current variable space.",
            "if we just finish here then we'll go back and re-solve for delta_x. but actually we can be more efficient and incrementally update delta_x here. but if we do this, we wont have ell and Dell to use in updating the factorization later. This is a key aspect of the game's variable space management."
        ],
        "FuncName": "btDantzigLCP_4243 transfer_i_from_N_to_C.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Deleting last row/column is easy in LDLT"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Snipping out row/column r from L and D in LDLT"
        ],
        "FuncName": "btDantzigLCP_4243 btLDLTRemove.txt"
    },
    {
        "Branch": [
            "In the context of linear complementarity problems (LCP), an if-condition is used to determine whether a variable is active or not. This condition is crucial in solving LCP equations, where the solution space is divided into active and inactive sets."
        ],
        "Loop": [
            "In LCP formulations, a loop condition is used to iterate over the variables until convergence is reached. This condition ensures that the solution space is explored exhaustively, leading to a stable and accurate solution."
        ],
        "Normal": [
            " the Dell and ell that are computed here are saved if index i is",
            " later added to the factorization then they can be reused",
            "",
            " question do we need to solve for entire delta_x yes but",
            "     only if an x goes below 0 during the step"
        ],
        "FuncName": "btDantzigLCP_4243 solve1.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "un-permute x into delta_w, which is not being used at the moment",
                    "set lo and hi values, considering the Dantzig LCP problem constraints"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "this is a degenerate case, where lo != 0 and hi > 0, indicating a finite line segment in set C",
                    "NOTE: we must call lcp.solve1() before lcp.transfer_i_to_C() to ensure valid LCP conditions"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "calculate the step to x(i)=hi(i) considering the Dantzig LCP problem constraints"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "calculate the step to x(i)=lo(i) considering the Dantzig LCP problem constraints"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "don't bother checking if lo=hi=0, as it's a trivial case in Dantzig LCP"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "print an internal error message if s <= 0, indicating a problem in the Dantzig LCP solution"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "the index i is the driving index, and indexes i+1..n-1 are don't care, considering the Dantzig LCP problem",
                    "we only consider an (i+1)*(i+1) sub-problem of A*x=b+w, where A is the Dantzig matrix",
                    "if we've hit the first friction index, we have to compute the lo and hi values based on the values of x already computed",
                    "we have been permuting the indexes, so the values stored in the findex vector are no longer valid, considering the Dantzig LCP problem",
                    "thus we have to temporarily unpermute the x vector, and compute w[i] now, considering the Dantzig LCP problem",
                    "if lo=hi=0, then the index will be assigned to set N with some state, but set C's line has zero size, so the index will always remain in set N",
                    "with the normal switching logic, if w changed sign then the index would have to switch to set C and then back to set N with an inverted state, but we prevent this by using the rule that indexes with lo=hi=0 will never be checked for set changes",
                    "see if x(i),w(i) is in a valid region, considering the Dantzig LCP problem conditions",
                    "else"
                ]
            },
            {
                "loopstr": [
                    "find direction to push on x(i), considering the Dantzig LCP problem constraints",
                    "compute: delta_x(C) = -dir*A(C,C)\\A(C,i), considering the Dantzig matrix A",
                    "note that delta_x[i] = dirf, but we wont bother to set it, considering the Dantzig LCP problem",
                    "compute: delta_w = A*delta_x, considering the Dantzig matrix A",
                    "note we only care about delta_w(N) and delta_w(i), the rest is ignored, considering the Dantzig LCP problem",
                    "find largest step we can take (size=s), either to drive x(i),w(i) to the valid LCP region or to drive an already-valid variable outside the valid region, considering the Dantzig LCP problem",
                    "index switching command, considering the Dantzig LCP problem",
                    "si = index to switch if cmd>3, considering the Dantzig LCP problem",
                    "static char* cmdstring[8] = {0,\\->C\\,\\->NL\\,\\->NH\\,\\N->C\\,\\C->NL\\,\\C->NH\\};",
                    "printf (\\cmd=%d (%s), si=%d\\n\\,cmd,cmdstring[cmd],(cmd>3) ? si : i);",
                    "if s <= 0 then we've got a problem, considering the Dantzig LCP solution",
                    "if we just keep going then we're going to get stuck in an infinite loop, considering the Dantzig LCP problem",
                    "instead, just cross our fingers and exit with the current solution, considering the Dantzig LCP problem",
                    "apply x = x + s * delta_x, considering the Dantzig LCP problem",
                    "apply w = w + s * delta_w, considering the Dantzig LCP problem",
                    "switch indexes between sets if necessary, considering the Dantzig LCP problem"
                ]
            }
        ],
        "Normal": [
            "\tprintf(\\btSolveDantzigLCP n=%d\\n\\,n);",
            "if all the variables are unbounded then we can just factor, solve, and return, considering the Dantzig LCP problem",
            "for i in N, state[i] is 0 if x(i)==lo(i) or 1 if x(i)==hi(i), considering the Dantzig LCP problem",
            "create LCP object, considering the Dantzig LCP problem",
            "loop over all indexes adj_nub..n-1, considering the Dantzig LCP problem",
            "for index i, if x(i),w(i) satisfy the LCP conditions then i is added to the appropriate index set, considering the Dantzig LCP problem",
            "otherwise, x(i),w(i) is driven either +ve or -ve to force it to the valid region, considering the Dantzig LCP problem",
            "as we drive x(i) we maintain the LCP conditions on the other variables 0..i-1, considering the Dantzig LCP problem",
            "we do this by watching out for other x(i),w(i) values going outside the valid region, and then switching them between index sets when that happens, considering the Dantzig LCP problem",
            "for (int i=adj_nub; i<n; ++i)"
        ],
        "FuncName": "btDantzigLCP_4243 btSolveDantzigLCP.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of game development, this statement is used to update derived shapes, inheriting properties from base classes."
        ],
        "FuncName": "CollisionShape_7759 UpdateDerivedShape.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the game of physics simulation, a change of any non-accessor attribute requires recreation of the collision shape"
        ],
        "FuncName": "CollisionShape_7759 OnSetAttribute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Physics operations are not safe from worker threads in a dynamic, ever-changing game world where objects are constantly colliding and interacting with each other."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 OnMarkedDirty.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Build the convex hull from the raw geometry. This is a key step in calculating the convex hull.",
                    "Copy vertex data & index data. This is necessary for the convex hull calculation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 BuildHull.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Use rigid body's world transform if possible as it may be different from rendering transform",
                    "Special case code for convex hull bypass Bullet's own rendering to draw triangles correctly not just edges"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 DrawDebugGeometry.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Create shape now if necessary (attributes modified before adding to scene) in the context of a physics engine"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 OnSceneSet.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Terrain collision shape depends on the terrain component's geometry updates. Subscribe to them. In Node, this is done by setting the Node and subscribing to the terrain component's geometry updates event."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 OnNodeSet.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Remove the shape first to ensure it is not added twice for rigid body physics",
                    "Finally tell the rigid body to update its mass for collision detection"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Then add with updated offset for rigid body simulation",
                    "For terrains, undo the height centering performed automatically by Bullet physics engine"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CollisionShape_7759 NotifyRigidBody.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The player's position determines the audio node parsing order in the game."
        ],
        "FuncName": "SoundNodeLocalPlayer_5780 ParseNodes.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "get rid of scrollbars for menu popups, display UI menu window in game mode",
            "get rid of scrollbars for menu popups, display UI menu window with customizable layout"
        ],
        "FuncName": "UIMenuWindow_1403 Show.txt"
    },
    {
        "Branch": [
            "If the condition is true, the code will execute.",
            "If the condition is false, the code will skip."
        ],
        "Loop": [
            "The loop will continue as long as the condition is true.",
            "The loop will terminate when the condition is false."
        ],
        "Normal": [
            "This string is not supported in the game.",
            "The game engine does not support this feature."
        ],
        "FuncName": "File_VMS_5578 setExecutableImpl.txt"
    },
    {
        "Branch": [
            "Check if the player has collected all the power-ups in the game.",
            "Check if the player's score is greater than 1000."
        ],
        "Loop": [
            "Loop through each level in the game.",
            "Loop through each enemy in the game world."
        ],
        "Normal": [
            "No quality reduction",
            "No mipmaps"
        ],
        "FuncName": "Text3DFontFace_3470 CreateFaceTexture.txt"
    },
    {
        "Branch": [
            "CollisionDetection collisionDetection;",
            " collisionDetection.wouldCollideWithCeiling = true;"
        ],
        "Loop": [
            "CollisionDetection collisionDetection;",
            " while (collisionDetection.wouldCollideWithCeiling)"
        ],
        "Normal": [
            "CollisionDetection collisionDetection;",
            " if (collisionDetection.wouldCollideWithCeiling) {",
            "     // handle collision",
            " }"
        ],
        "FuncName": "collision_7831 wouldCollideWithCeiling.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "TimeTaker tt(axisAlignedCollision);",
            "Determining the distance of clipping recovery in axis-aligned collision detection.",
            "No alternative if condition is present.",
            "No alternative if condition is present."
        ],
        "FuncName": "collision_7831 axisAlignedCollision.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "add collision with local player",
                    "detecting environment object collision information, including position, speed, and collision box, for a player object in the game"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "search for objects which are not us and not our children.",
                    "we directly process the object in this callback to avoid useless",
                    "looping afterwards.",
                    "nothing is put into this vector",
                    "in the game environment, objects that are not the player or their children are being searched for collision information"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Do collide with everything but itself and children",
                    "in the game loop, the player object collides with all other objects in the environment, excluding itself and its children"
                ]
            }
        ],
        "Normal": [
            "Calculate distance by speed, add own extent and 1.5m of tolerance",
            "in the game, the distance between objects is calculated based on their speed, with a tolerance of 1.5 meters added to account for the object's size"
        ],
        "FuncName": "collision_7831 add_object_boxes.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "No collision with any collision box. In the context of the game, this means the object has successfully navigated through the environment without encountering any obstacles.",
                    "Set to 0 to avoid infinite loop due to small FP numbers. In the game, this is a technical fix to prevent the game from getting stuck in an infinite loop due to floating-point precision issues."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Handle negative nearest_dtime. In the game, this means the object is moving backward in time, and the game needs to handle this scenario accordingly."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Special case: Handle stairs. In the game, this means the object is interacting with a staircase, and the game needs to apply specific rules to handle this situation."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Avoid infinite loop. In the game, this means the object needs to find a way to escape an infinite loop of collisions or movements.",
                    "Go through every nodebox, find nearest collision. In the game, this means the object is searching for the closest collision point with the environment."
                ]
            },
            {
                "loopstr": [
                    "Ignore if already stepped up this nodebox. In the game, this means the object has already interacted with this nodebox and doesn't need to consider it again.",
                    "Find nearest collision of the two boxes (raytracing-like). In the game, this means the object is using a raytracing-like algorithm to find the closest collision point between two objects."
                ]
            },
            {
                "loopstr": [
                    "See if the object is touching ground. Object touches ground if object's minimum Y is near node's maximum Y and object's X-Z-area overlaps with the node's X-Z-area. In the game, this means the object is checking if it has landed on the ground and is ready to interact with the environment."
                ]
            }
        ],
        "Normal": [
            "Calculate new velocity. In the game, this means the object's speed and direction are updated based on its movement and interactions with the environment.",
            "If the object is static, there are no collisions. In the game, this means the object is not moving and does not need to worry about collisions with other objects.",
            "Limit speed for avoiding hangs. In the game, this means the object's speed is capped to prevent it from moving too fast and getting stuck in an infinite loop.",
            "Collect node boxes in movement range. In the game, this means the object is gathering information about the node boxes it can interact with.",
            "Cached allocation. In the game, this means the object is using a caching mechanism to optimize its performance and reduce memory usage.",
            "Collect object boxes in movement range. In the game, this means the object is gathering information about the object boxes it can interact with.",
            "Collision detection. In the game, this means the object is checking for collisions with other objects in the environment.",
            "Final touches: Check if standing on ground, step up stairs. In the game, this means the object is making any necessary adjustments to its position and movement to ensure it is interacting correctly with the environment."
        ],
        "FuncName": "collision_7831 collisionMoveSimple.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Object collides with walkable nodes in a game environment.",
                    "A negative bouncy value might have a specific meaning, but we require a positive value here in the context of game physics.",
                    "Calculate the object's float position only once in the game loop for performance optimization."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "collision_7831 add_area_node_boxes.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "cleans the list and frees memory as in game development"
        ],
        "FuncName": "chain_tree_4537 chain_clear_free.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " TODO: Implement again, take into consideration merged bones and skeletal chain length calculations for optimal game performance "
        ],
        "FuncName": "chain_tree_4537 calculate_segment_lengths.txt"
    },
    {
        "Branch": [
            "If the file is copied successfully, the game will proceed to the next level.",
            "If the file is not copied, the game will end."
        ],
        "Loop": [
            "While the file is being copied, the game will display a loading animation.",
            "Repeat the copy process until the file is successfully copied."
        ],
        "Normal": [
            " copying a file correctly under OpenVMS is non trivial so we just invoke the COPY program ",
            "The game requires a file to be copied to proceed."
        ],
        "FuncName": "File_VMS_5578 copyToImpl.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "calculate vectors for original and solved segments",
                    "update joint rotation angles based on game-specific physics engine"
                ]
            }
        ],
        "Normal": [
            "Calculate all of the delta angles of the joints. The resulting delta angles will be written to node->rotation. This calculation takes into account the game's specific gravity and friction models."
        ],
        "FuncName": "chain_tree_4537 calculate_delta_rotation_of_each_segment.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Clear all existing chain trees in the game world",
            "* Build a set of all nodes that are in a direct path with all of the game's effectors, such as characters or objects",
            "Pre-compute offsets for each node in the chain tree in relation to their parents in the game's physics engine",
            "DEBUG: Save the chain tree to a DOT file for further analysis in the game development process"
        ],
        "FuncName": "chain_tree_4537 rebuild_chain_tree.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Rotate child chains in game development",
            "Note: All chains that aren't the root chain MUST have at least two nodes",
            "Averaging quaternions taken from Unity's quaternion averaging wiki page",
            "Assuming there was more than 1 child chain and assuming we aren't the root node, then the child chains we just iterated must share the same base node (which is our tip node). Average the accumulated quaternion and set this node's correct solved rotation in a game engine."
        ],
        "FuncName": "chain_tree_4537 calculate_global_rotations_of_children.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculates the global (world) angles of each joint and writes them to each node->rotation slot in the game engine's physics pipeline. The angle between the original and solved segments are calculated using standard vector math (dot product). The axis of rotation is calculated with the cross product. From this data, a quaternion is constructed, describing this delta rotation. Finally, in order to make the rotations global instead of relative, the delta rotation is multiplied with node->original_rotation, which should be a quaternion describing the node's global rotation in the unsolved tree. The rotation of the base joint in the chain is returned so it can be averaged by parent chains in the game's animation system.",
            "At this point, all nodes have calculated their delta angles except the end effector nodes, which remain untouched. It makes sense to copy the delta rotation of the parent node into the effector node by default in the game's physics engine.",
            "Finally, apply initial global rotations to calculated delta rotations to obtain the solved global rotations in the context of the game's 3D graphics pipeline."
        ],
        "FuncName": "chain_tree_4537 calculate_global_rotations.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Add pointers to all nodes that are part of this chain into the chain's list, starting with the end node.",
                    "Update the base node to be this node so deeper chains are built back to this node",
                    "This is a conditional statement in a game, where the chain is built based on a condition."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If this is the first chain in the island, create and initialise it in the chain tree.",
                    "This is a game-specific operation to handle conditional chains in a tree data structure."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "can remove the mark from the set to speed up future checks",
            "Recurse into children of the current node.",
            "This is a normal string in a game, where recursion is used to traverse the node tree."
        ],
        "FuncName": "chain_tree_4537 recursively_build_chain_tree.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Traverse the chain of parents from each effector node to the root node, marking every node along the way. Each effector specifies a maximum chain length, which may not reach the root node.",
            "Mark nodes at the base of each chain differently to enable later splitting. Section markings will override break markings. Additionally, IK_CONSTRAINT_STIFF restricts all rotations of a node, so mark it differently to combine surrounding nodes into a single bone properly later. Note that the node-constraint field specifies constraints for the parent node, not the current node, but we mark the current node, not the parent."
        ],
        "FuncName": "chain_tree_4537 mark_involved_nodes.txt"
    },
    {
        "Branch": [
            "calculate chain length, excluding root chain for if conditions"
        ],
        "Loop": [
            "calculate chain length, excluding root chain for loop conditions"
        ],
        "Normal": [
            "exclude root chain"
        ],
        "FuncName": "chain_tree_4537 count_chains_exclude_root.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Build a linked list for the free list in the context of a game, where memory management is crucial for smooth gameplay."
        ],
        "FuncName": "b2DynamicTree_1531 b2DynamicTree.txt"
    },
    {
        "Branch": [
            "Check if the player's health is greater than or equal to 50."
        ],
        "Loop": [
            "Iterate through the enemies in the game world."
        ],
        "Normal": [
            "Fatten the aabb. Apply the game's collision detection algorithm to the player's bounding box."
        ],
        "FuncName": "b2DynamicTree_1531 CreateProxy.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Destroy parent and connect sibling to grandParent. In a game scenario, this could be a collision detection or a game logic update.",
                    "Adjust ancestor bounds. This might be related to a game object's position or size update."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Validate(); In a game context, this could be a check for game state validity or a sanity check for game objects."
        ],
        "FuncName": "b2DynamicTree_1531 RemoveLeaf.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " NOTE: these are just dummies. Their presence enforces game logic.",
            " Structure::Converttarget_type to be called on these game structures.",
            " empty structures. These converters are special game overloads which scan the name of the game structure and perform the required data type conversion if one of these special names is found in the game structure in question.",
            " no long seemingly, game-related data is being processed."
        ],
        "FuncName": "BlenderDNA_7048 AddPrimitiveStructures.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The free list is empty. Rebuild a bigger pool for the game.",
                    "Build a linked list for the free list in the game. The parent pointer becomes the next pointer for game nodes.",
                    "In the game, rebuild a bigger pool and expand the node pool as needed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Expand the node pool as needed in the game.",
            "Peel a node off the free list and rebuild a bigger pool for the game."
        ],
        "FuncName": "b2DynamicTree_1531 AllocateNode.txt"
    },
    {
        "Branch": [
            "Check if AABB is out of bounds and update proxy node accordingly."
        ],
        "Loop": [
            "Iterate through all nodes and update AABB for each node."
        ],
        "Normal": [
            "Extend AABB by predicting displacement.",
            "Predict AABB displacement by analyzing node movements."
        ],
        "FuncName": "b2DynamicTree_1531 MoveProxy.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Maintain separate indexes for DNA structures.",
                    "Set the index to the last structure in the DNA file: `s.index = dna.structures.size()-1;`."
                ]
            },
            {
                "loopstr": [
                    "Pointers in DNA files specify the size of the pointee, not their own.",
                    "The pointer asterisk is a property of the lookup name.",
                    "Arrays in DNA files specify the size of a single element, so we need to parse the array declaration to get the actual size.",
                    "We also need to remove array brackets from the lookup name to ensure size fixup works.",
                    "Maintain separate indexes for DNA structures."
                ]
            }
        ],
        "Normal": [
            "A dictionary containing DNA structure names.",
            "A dictionary containing DNA structure types.",
            "A dictionary containing the length of each DNA structure type.",
            "A dictionary containing information about DNA structures."
        ],
        "FuncName": "BlenderDNA_7048 Parse.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Insert a new leaf node in the dynamic tree, making the sibling not the root."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Calculate the cost of creating a new parent for this node and the new leaf in the dynamic tree.",
                    "Determine the minimum cost of pushing the leaf further down the tree.",
                    "Evaluate the cost of descending into child1 in the tree.",
                    "Evaluate the cost of descending into child2 in the tree.",
                    "Descend into the child with the minimum cost in the tree.",
                    "Descend into the child in the tree."
                ]
            }
        ],
        "Normal": [
            "Find the best sibling for this node in the tree.",
            "Create a new parent node in the tree.",
            "Walk back up the tree, fixing heights and AABBs (Axis-Aligned Bounding Boxes).",
            "Validate the tree."
        ],
        "FuncName": "b2DynamicTree_1531 InsertLeaf.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Swap A and C",
                    "A's old parent should point to C",
                    "Rotate",
                    "Maintaining the balance of the AVL tree"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Swap A and B",
                    "A's old parent should point to B",
                    "Rotate",
                    "Maintaining the balance of the AVL tree"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Rotate C up",
            "Rotate B up",
            "Maintaining the balance of the AVL tree"
        ],
        "FuncName": "b2DynamicTree_1531 Balance.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Read and assign materials. These strings are for Material allocation in the game code."
        ],
        "FuncName": "OgreMaterial_9529 ReadMaterials.txt"
    },
    {
        "Branch": [
            "Check if the tree is empty. If not, adjust the root node's position."
        ],
        "Loop": [
            "Iterate through each node in the tree. If a node has children, adjust its position."
        ],
        "Normal": [
            "Build array of leaves. Free the rest. Note: This operation is relevant in tree manipulation algorithms, especially in game development where trees are used to represent game objects or scenes."
        ],
        "FuncName": "b2DynamicTree_1531 ShiftOrigin.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check if a point is inside a polygon and replace the supporting vertex out if needed in the context of a 2D game."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Brute force algorithm for finding the supporting vertex in a 2D game."
        ],
        "FuncName": "btGeometryUtil_6172 getPlaneEquationsFromVertices.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "free node in pool, Rebuilding the dynamic tree from the ground up, combining AABBs to minimize perimeter."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Building an array of leaves and freeing the rest, a crucial step in optimizing game performance, especially in AABB-based tree structures."
        ],
        "FuncName": "b2DynamicTree_1531 RebuildBottomUp.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Skip commented lines",
                    "Colors",
                    "Alpha Support: todo via aiColor4D in Material Passes."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "OgreMaterial_9529 ReadPass.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Skip commented lines in game development",
                    "In game development, TODO Techniques have other attributes than just passes."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "OgreMaterial_9529 ReadTechnique.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "DefaultLogger::get()->debug(Formatter::format() << Found material ' << linePart << ' that does not match at index  << ss.tellg());"
                ],
                "elsestr": [
                    "Properties from Venetica: Ogre material script has been loaded successfully."
                ]
            },
            {
                "thenstr": [
                    "Properties from Venetica: Ogre material script has been loaded successfully."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Skip commented lines. Iterating through Ogre material script techniques."
                ]
            },
            {
                "loopstr": [
                    "Proceed to the first technique. Reading Ogre material script informations.",
                    "Reading Ogre material script informations. This material uses a custom technique.",
                    "This material uses a custom technique. Note: This set $x y does not seem to be a official Ogre material system feature. Materials can inherit other materials and override texture units by using the (unique) parent texture unit name in your cloned material. This is not yet supported and below code is probably some hack from the original author of this Ogre importer. Should be removed?"
                ]
            }
        ],
        "Normal": [
            "Full reference and examples of Ogre Material Script for game development can be found from http://www.ogre3d.org/docs/manual/manual_14.html",
            "Ogre Material Script is used to create and customize 3D game materials. More information can be found from the official Ogre documentation.",
            "Ogre Material Script is used to create and customize 3D game materials. This script imports various material passes and techniques.",
            "Scope for scopre_ptr auto release in Ogre Material Script.",
            "The stringstream will push words from a line until newline in Ogre Material Script.",
            "It will also trim whitespace from line start and between words in Ogre Material Script."
        ],
        "FuncName": "OgreMaterial_9529 ReadMaterial.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create materials that can be found and parsed via the IO System, utilizing material references for efficient assignment."
        ],
        "FuncName": "OgreMaterial_9529 ReadMaterials.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In 3D geometry, finding the intersection point of three planes is crucial for game development, where planes represent game objects and their interactions.",
                    "The equation d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 ) represents the intersection condition.",
                    "To find point P, we need to calculate the numerator and denominator of the equation.",
                    "N1 . ( N2 * N3 ) represents the dot product of vectors N1 and (N2 * N3), which is a key concept in 3D geometry and game physics.",
                    "P =  -------------------------------------------------------------------------  ",
                    "   N1 . ( N2 * N3 ) "
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "After finding the intersection point, we need to check if it's inside the plane or not, and if necessary, replace the supporting vertex out."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In game development, brute force methods are often used to calculate 3D geometry, such as finding the intersection of planes."
        ],
        "FuncName": "btGeometryUtil_6172 getVerticesFromPlaneEquations.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This is the test font, used for rendering glyphs in the game."
        ],
        "FuncName": "tb_font_renderer_4776 RenderGlyphs.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For optimal font rendering in Unity, ensure to initialize the font cache. This is especially important in games, such as RPGs or strategy games, where font rendering is crucial for user interface elements like health bars, inventory displays, and quest log updates."
        ],
        "FuncName": "tb_font_renderer_4776 TBFontGlyphCache.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, move the glyph to the end of the rendered glyphs list to maintain the Last Recently Used (LRU) order, where the oldest glyph is displayed first."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tb_font_renderer_4776 GetGlyph.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of game development, moving a glyph to the end of m_all_rendered_glyphs ensures that the oldest glyphs are rendered first, maintaining a Last Recently Used (LRU) order."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tb_font_renderer_4776 GetGlyph.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Create a new TBFontGlyphData for the blurred glyph",
                    "Reserve memory needed for blurring.",
                    "Blur the glyph using game-specific blurring algorithm.",
                    "Adjust glyph position to compensate for larger size and maintain game balance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tb_font_renderer_4776 Render.txt"
    },
    {
        "Branch": [
            " Conditional statement to check if a condition is met in the game"
        ],
        "Loop": [
            " Looping statement to repeat a block of code in the game"
        ],
        "Normal": [
            " No need to do anything. The bitmaps will be created when drawing. This is a normal statement in the game's code."
        ],
        "FuncName": "tb_font_renderer_4776 OnContextRestored.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "The glyph data may be in uint8 format which we have to convert since we always create fragments and TBBitmap in 32bit format Finally the glyph data is ready and we can create a bitmap fragment related to game rendering",
                    "create fragments and TBBitmap in 32bit format related to game rendering",
                    "create a bitmap fragment related to game rendering"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "char glyph_str 9",
            "int len utf8 encode cp glyph_str",
            "glyph_str len 0",
            "TBStr info",
            "TBDebugOut info related to game rendering"
        ],
        "FuncName": "tb_font_renderer_4776 RenderGlyph.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "if (!m_animation_module) return; InputMemoryStream blob(m_animation_module->getEventStream()); const RuntimeHash sound_type(sound\\); while (blob.getPosition() < blob.size()) { RuntimeHash type; u8 size; EntityRef entity; blob.read(type); blob.read(entity); blob.read(size); if (type == sound_type) { SoundAnimationEvent event; blob.read(event); ClipInfo* clip = getClipInfo(event.clip); if (clip) { play(entity, clip, event.is_3d); } } else { blob.skip(size); } }"
        ],
        "FuncName": "audio_module_254 updateAnimationEvents.txt"
    },
    {
        "Branch": [
            "Check if the game condition is met"
        ],
        "Loop": [
            "Loop through the game objects"
        ],
        "Normal": [
            "Add the test dummy font with empty name (Equals to ID 0)",
            "Use the test dummy font as default by default"
        ],
        "FuncName": "tb_font_renderer_4776 TBFontManager.txt"
    },
    {
        "Branch": [
            " \u5728\u6e38\u620f\u4e2d\uff0c\u5982\u679c\u6761\u4ef6\u4e0d\u6210\u7acb\uff0c\u8bf7\u5ffd\u7565\u5b57\u5f62\u7684\u5927\u5c0f\u95ee\u9898\u3002"
        ],
        "Loop": [
            " \u5728\u6e38\u620f\u5faa\u73af\u4e2d\uff0c\u5982\u679c\u6761\u4ef6\u4e0d\u6210\u7acb\uff0c\u8bf7\u5ffd\u7565\u5b57\u5f62\u7684\u5927\u5c0f\u95ee\u9898\u3002"
        ],
        "Normal": [
            " \u5728\u6e38\u620f\u4e2d\uff0c\u4e0d\u8981\u7406\u4f1a\u5982\u679c\u8bf7\u6c42\u7684\u5b57\u5f62\u592a\u5927\u3002"
        ],
        "FuncName": "tb_font_renderer_4776 CreateFragment.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Compute effective mass in game physics simulation."
        ],
        "FuncName": "b2GearJoint_45 InitVelocityConstraints.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the realm of typography, a font face object has been created.",
            "Within the game's code, a font face object has been instantiated."
        ],
        "FuncName": "tb_font_renderer_4776 CreateFontFace.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "PHY_ScalarType indexType=0; This is a scalar type used for indexing in the game's physics engine."
                ]
            }
        ],
        "Normal": [
            "In the game, the user pointer should not be reused for other purposes as it is intended to store connectivity information."
        ],
        "FuncName": "btInternalEdgeUtility_3716 btGenerateInternalEdgeInfo.txt"
    },
    {
        "Branch": [
            "Check if the line segment is valid"
        ],
        "Loop": [
            "Iterate over all points in the line segment"
        ],
        "Normal": [
            " Handle degenerate lines",
            "Calculate the closest point to the line segment"
        ],
        "FuncName": "btInternalEdgeUtility_3716 btNearestPointInLineSegment.txt"
    },
    {
        "Branch": [
            "Create an MTP connection to check the condition in the game"
        ],
        "Loop": [
            "Create an MTP connection to loop through the condition in the game"
        ],
        "Normal": [
            "Establish a secure connection across internet networks for ipv4 and ipv6 in the game"
        ],
        "FuncName": "connection_7577 createMTP.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "in game physics, a b2Joint is a fundamental component that connects two bodies, and the joint edges are crucial for simulating real-world scenarios.",
            "in game development, getting the geometry of a joint is essential for understanding its properties and behavior.",
            "in game physics, getting the geometry of joint1 and joint2 is necessary for simulating complex joint interactions."
        ],
        "FuncName": "b2GearJoint_45 b2GearJoint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Processing degenerate case"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Warning: normals not identical"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Warning: normals not identical"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Warning: normals not identical"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Processing degenerate case"
                ]
            }
        ],
        "Normal": [
            "Skipping self-collisions",
            "Skipping duplicates (disabled for now)",
            "Checking if triangle A is valid",
            "Returning if triangle A is valid",
            "Searching for shared vertices and edges between triangle A and triangle B",
            "Skipping degenerate triangles",
            "Triangle A: (%f, %f, %f), (%f, %f, %f), (%f, %f, %f)",
            "Part ID: %d, Triangle Index: %d",
            "Triangle B: (%f, %f, %f), (%f, %f, %f), (%f, %f, %f)"
        ],
        "FuncName": "btInternalEdgeUtility_3716 processTriangle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Draw a line to a specified Surface, clipping the line if necessary to prevent slope changes.",
            "We don't actually want to clip, as it may alter the line's slope and affect game performance."
        ],
        "FuncName": "SDL_drawline_2565 SDL_DrawLine.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Perform clipping: a fundamental operation in 2D graphics, where a line is cut off at a certain point.",
                    "We don't actually want to clip, as it may change line slope: this is a common issue in game development, where the slope of a line can be affected by clipping.",
                    "Draw the end if it was clipped: in game development, drawing the end of a clipped line can be crucial for a smooth player experience."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SDL_drawline_2565 SDL_DrawLines.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Adjusting contact normal to ensure angle with edge within specified range, as per game mechanics.",
            "Either compute current angle in local space or in world space, considering game physics rules."
        ],
        "FuncName": "btInternalEdgeUtility_3716 btClampNormal.txt"
    },
    {
        "Branch": [
            "Validate coverage and mark array for if conditions in game code"
        ],
        "Loop": [
            "Validate coverage and mark array for loop conditions in game code"
        ],
        "Normal": [
            " skip PosFormat for normal game code"
        ],
        "FuncName": "otvgpos_7341 otv_u_O_O_u_O_O.txt"
    },
    {
        "Branch": [
            "Verify anchor point data for conditional statements in the game."
        ],
        "Loop": [
            "Verify anchor point data for loop conditions in the game."
        ],
        "Normal": [
            " skip Coordinate verification for normal game operations."
        ],
        "FuncName": "otvgpos_7341 otv_Anchor_validate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Limit count in our adventure game",
            " Find out whether we can pass directly from our array or have to do some gluing in our puzzle game"
        ],
        "FuncName": "l_noise_9077 l_next_bytes.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "skip SecondGlyph"
                ]
            }
        ],
        "Normal": [
            "Verify PairSet values in PairValueRecord"
        ],
        "FuncName": "otvgpos_7341 otv_PairSet_validate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "XPlacement, YPlacement, XAdvance, YAdvance",
                    "This is a typical placement and advance format in game development, where X and Y coordinates are used to position and move game objects."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "XPlaDevice, YPlaDevice, XAdvDevice, YAdvDevice",
                    "XXX: this value is usually too small, especially if the current",
                    "ValueRecord is part of an array -- getting the correct table",
                    "size is probably not worth the trouble",
                    "In some games, devices are used to handle placement and advance, especially in complex scenarios."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "display format in dual representation",
            "In game development, dual representation is a common technique used to display information in a clear and concise manner, making it easier for players to understand the game state."
        ],
        "FuncName": "otvgpos_7341 otv_ValueRecord_validate.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection. Updating distance and reprojecting collision point along normal.",
                    "Reproject collision point along normal"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection. Updating distance and reprojecting collision point along normal.",
                    "Reproject collision point along normal"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection. Updating distance and reprojecting collision point along normal.",
                    "Reproject collision point along normal"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection. Reprojecting collision point along normal.",
                    "Reproject collision point along normal"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Adjusting internal edge contact points for game type collision detection. Fixing triangle normal to point in the same direction as the current local contact normal.",
                    "fix tri_normal so it pointing the same direction as the current local contact normal"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Asserting triangle shape collision type for game type collision detection.",
            "Calculating center of triangle for game type collision detection.",
            "Calculating dot product of triangle normal and contact point normal for game type collision detection.",
            "Checking if triangle normal update is necessary for game type collision detection.",
            "Getting closest edge for game type collision detection.",
            "",
            "Edge 0 -> 1 for game type collision detection.",
            "Edge 1 -> 2 for game type collision detection.",
            "Edge 2 -> 0 for game type collision detection."
        ],
        "FuncName": "btInternalEdgeUtility_3716 btAdjustInternalEdgeContacts.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Value1",
                    "In a game, this value is used to check a condition."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Value2",
                    "In a game, this value is used to check another condition."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Class2Record",
                    "In a game, this record is used to loop through a collection of data."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "otvgpos_7341 otv_PairPos_validate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reset the timer associated with the filename in the game, triggering a notification once the delay is exceeded."
        ],
        "FuncName": "FileWatcher_6838 AddChange.txt"
    },
    {
        "Branch": [
            "This is specific to DECThreads: Implementing if-conditions in game logic, ensuring thread-safe execution."
        ],
        "Loop": [
            "This is specific to DECThreads: Implementing loop conditions in game logic, ensuring thread-safe iteration."
        ],
        "Normal": [
            "This is specific to DECThreads: Utilizing DECThreads for concurrent execution in game development."
        ],
        "FuncName": "Thread_POSIX_5579 sleepImpl.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "setViewportUpdateMode(QGraphicsView::BoundingRectViewportUpdate) to optimize view updates for the game's graphics.",
            "A workaround for the QDockWidget's initial size policy issue, which can be frustrating for game developers.",
            "Setting a small initial height allows the application to correctly calculate its minimum height, ensuring a smooth game experience."
        ],
        "FuncName": "easy_frame_rate_viewer_371 EasyFrameRateViewer.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the height field, this vertex has a height of [height] and is a border vertex if there are two adjacent exterior cells.",
                    "followed by two interior cells and none of the regions are out of bounds."
                ]
            }
        ],
        "Normal": [
            "Combine region and area codes to identify border vertices in the height field.",
            "Remove border vertices which are in between two areas to simplify the mesh.",
            "Check if the vertex is a special edge vertex, these vertices will be removed later to improve mesh quality."
        ],
        "FuncName": "RecastContour_4358 getCornerHeight.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculates the distance between two points in 3D space. This is a common operation in game development, used for collision detection, physics simulations, and more. The code snippet calculates the distance between two points (qx, qy, qz) and (px, py, pz) and returns the squared distance."
        ],
        "FuncName": "RecastContour_4358 distancePtSeg.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Avoid watching ./ or ../ subdirectories in file system monitor"
                ]
            }
        ],
        "Normal": [
            "Stop previous listener",
            "Atomic start",
            "Create a virtual file to ensure the path is writable, otherwise we'll hang on exit",
            "Not very elegant, but avoids the cluster of Windows security APIs",
            "Atomic end"
        ],
        "FuncName": "FileWatcher_6838 StartWatching.txt"
    },
    {
        "Branch": [
            "If statement: a conditional expression that evaluates to a boolean value, used to control the flow of a program in a game.",
            "If statement: a game development concept that allows the programmer to make decisions based on certain conditions.",
            "If statement: a fundamental control structure in programming, used to execute different blocks of code based on a condition."
        ],
        "Loop": [
            "Loop condition: a statement that determines whether a loop should continue executing or terminate.",
            "Loop condition: a game development concept that allows the programmer to execute a block of code repeatedly based on a condition.",
            "Loop condition: a control structure in programming that allows the execution of a block of code repeatedly until a certain condition is met."
        ],
        "Normal": [
            " just to satisfy compiler we  ll never get here anyway",
            "This statement is never executed due to the if-else condition.",
            "A placeholder statement used to satisfy the compiler, never intended to be executed."
        ],
        "FuncName": "Thread_POSIX_5579 mapPrio.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u5fc5\u987b\u5411\u4e0a\u820d\u5165\u5230\u5185\u5b58\u9875\u9762\u5927\u5c0f\u7684\u500d\u6570\uff0c\u8fd9\u662f\u7531\u4e8e\u7ebf\u7a0b\u6808\u5927\u5c0f\u7684\u8bbe\u7f6e"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Thread_POSIX_5579 setStackSizeImpl.txt"
    },
    {
        "Branch": [
            "Check if input is not at the end"
        ],
        "Loop": [
            "Loop until input is not at the end"
        ],
        "Normal": [
            "This is kinda awful and requires a game-like condition"
        ],
        "FuncName": "particles_6138 streamEndsBeforeParam.txt"
    },
    {
        "Branch": [
            "Check if the condition is met and calculate the bounding box if true."
        ],
        "Loop": [
            "Check the loop condition and calculate the bounding box for each iteration."
        ],
        "Normal": [
            "Calculate the bounding box for the game object."
        ],
        "FuncName": "Recast_1429 rcCalcBounds.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "remap for beginning offset",
                    "remap for repetitions",
                    "remap for style"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "warp time coordinates in accordance with game's temporal mechanics"
        ],
        "FuncName": "particles_6138 blend.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Degenerate segment, remove. In the context of 3D game development, this means removing a line segment that has no length, which can occur when two vertices are identical."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Remove adjacent vertices which are equal on xz-plane, or else the triangulator will get confused. This is a common issue in 3D game development, as it can lead to invalid triangles and affect the overall geometry of the mesh."
        ],
        "FuncName": "RecastContour_4358 removeDegenerateSegments.txt"
    },
    {
        "Branch": [
            "Check if the current span has exceeded the maximum allowed time.",
            "If the condition is met, release the span's memory."
        ],
        "Loop": [
            "Iterate through the array of spans.",
            "For each span, check if it has exceeded the maximum allowed time."
        ],
        "Normal": [
            "Delete the span array to free up memory.",
            "Release the memory allocated for the span pools."
        ],
        "FuncName": "Recast_1429 rcFreeHeightField.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Mark direction as walkable. In the context of the game, this means that the player can move in this direction."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "If there are no spans at this cell, just leave the data to index=0, count=0. This is a common scenario in game development where we need to handle edge cases."
                ]
            },
            {
                "loopstr": [
                    "First check that the neighbour cell is in bounds. This is a crucial step in game development to prevent out-of-bounds errors.",
                    "Iterate over all neighbour spans and check if any of the is accessible from current cell. This is where the game's logic comes into play."
                ]
            },
            {
                "loopstr": [
                    "Check that the gap between the spans is walkable, and that the climb height between the gaps is not too high. This is a key aspect of game level design."
                ]
            }
        ],
        "Normal": [
            "Fill in header. This is the first step in creating a game level, where we define the overall structure.",
            "Fill in cells and spans. This is where the game's content is added, including obstacles, platforms, and other game elements.",
            "Find neighbour connections. This is an essential step in creating a cohesive game world, where we connect different areas and levels."
        ],
        "FuncName": "Recast_1429 rcBuildCompactHeightfield.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the heightfield was built with bordersize, remove the offset. In the context of a game, this means that the game's terrain generation algorithm has taken into account the border size of the heightfield, and now we need to adjust the offset to ensure that the terrain is properly aligned with the game's world boundaries."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "cont->cx = cont->cy = cont->cz = 0; for (int i = 0; i < cont->nverts; ++i) { cont->cx += cont->verts[i*4+0]; cont->cy += cont->verts[i*4+1]; cont->cz += cont->verts[i*4+2]; } cont->cx /= cont->nverts; cont->cy /= cont->nverts; cont->cz /= cont->nverts. This step is crucial in game development as it ensures that the game's 3D models are properly centered and aligned within the game world, providing a more immersive experience for the player."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Allocate more contours. This can happen when there are tiny holes in the heightfield. In a game, this means that the game's terrain generation algorithm has encountered a small hole or depression in the terrain, and now we need to allocate additional contours to fill in this hole and create a more seamless terrain experience."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the heightfield was built with bordersize, remove the offset. This step is essential in game development as it ensures that the game's terrain is properly aligned with the game's world boundaries, preventing any visual glitches or inconsistencies."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If the heightfield was built with bordersize, remove the offset. This step is crucial in game development as it ensures that the game's terrain is properly aligned with the game's world boundaries, providing a more immersive experience for the player."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Find another contour which has the same region ID. In a game, this means that the game's terrain generation algorithm has encountered a region with the same ID, and now we need to find another contour that shares the same region ID to ensure that the terrain is properly connected and cohesive."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Make sure the polygon is correctly oriented. This step is essential in game development as it ensures that the game's 3D models are properly oriented within the game world, preventing any visual glitches or inconsistencies."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Inverse, mark non connected edges. In the context of a game, this means that the game's terrain generation algorithm has identified non-connected edges in the terrain, and now we need to invert and mark these edges to ensure that the terrain is properly connected and cohesive."
                ]
            },
            {
                "loopstr": [
                    "Store region->contour remap info. Create contour. In a game, this means that the game's terrain generation algorithm has created a new contour and stored the necessary information to remap the region, ensuring that the terrain is properly updated and aligned with the game's world boundaries."
                ]
            },
            {
                "loopstr": [
                    "Reset source pointers to prevent data deletion. This step is crucial in game development as it ensures that the game's terrain generation algorithm does not delete any critical data, preventing any visual glitches or inconsistencies."
                ]
            },
            {
                "loopstr": [
                    "Check if the contour is would backwards. In the context of a game, this means that the game's terrain generation algorithm has identified a contour that is oriented in the wrong direction, and now we need to check and correct this orientation to ensure that the terrain is properly aligned with the game's world boundaries."
                ]
            }
        ],
        "Normal": [
            "Mark boundaries. In a game, this means that the game's terrain generation algorithm has identified the boundaries of the terrain and marked them for further processing, ensuring that the terrain is properly updated and aligned with the game's world boundaries.",
            "Check and merge droppings. This step is essential in game development as it ensures that the game's terrain generation algorithm properly identifies and merges any droppings or anomalies in the terrain, preventing any visual glitches or inconsistencies.",
            "Sometimes the previous algorithms can fail and create several contours per area. This pass will try to merge the holes into the main region. In the context of a game, this means that the game's terrain generation algorithm has encountered multiple contours in a single area, and now we need to merge these contours into a single, cohesive region, ensuring that the terrain is properly updated and aligned with the game's world boundaries."
        ],
        "FuncName": "RecastContour_4358 rcBuildContours.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of 3D geometry, finding the closest pair of points between two point sets is a fundamental problem in computer science. In the game development context, this could be used to detect collisions between objects or to optimize physics simulations. In the given string, 'vb must be in front of va' suggests a spatial relationship between two points, likely in a 3D environment, where 'vb' and 'va' represent the coordinates of two points."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "RecastContour_4358 getClosestIndices.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Copy contour A. Merge with contour B to form a new shape.",
            "Copy contour B. Merge with contour A to form a new shape."
        ],
        "FuncName": "RecastContour_4358 mergeContours.txt"
    },
    {
        "Branch": [
            "Update game world state based on if conditions."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Continue to next iteration if agent is paused, updating game world state accordingly."
                ]
            }
        ],
        "Normal": [
            "Update game world state normally."
        ],
        "FuncName": "navigation_module_7961 lateUpdate.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Draw polygon boundary edges by outlining the actual polygon edge.",
                    "This technique is often used in polygon-based games to enhance visual detail."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "navigation_module_7961 drawPolyBoundaries.txt"
    },
    {
        "Branch": [
            "Check if the game is paused and update the state accordingly."
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the agent is paused, skip to the next iteration of the loop."
                ]
            }
        ],
        "Normal": [
            "Update the game state based on the current conditions."
        ],
        "FuncName": "navigation_module_7961 lateUpdate.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "if (dt_agent->paused) continue; Update game state."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "navigation_module_7961 update.txt"
    },
    {
        "Branch": [
            "\u5728[game]\u4e2d\uff0c\u5982\u679c\u6761\u4ef6\u4e3a\u771f\uff0c\u624d\u80fd\u7ee7\u7eed",
            "\u53ea\u6709\u5728[game]\u6761\u4ef6\u4e3a\u771f\u65f6\uff0c\u624d\u4f1a\u8fdb\u884c\u4e0b\u4e00\u6b65"
        ],
        "Loop": [
            "\u5728[game]\u4e2d\uff0c\u5faa\u73af\u6761\u4ef6\u4e3a\u771f\uff0c\u624d\u80fd\u8fdb\u884c\u5faa\u73af",
            "\u53ea\u6709\u5728[game]\u6761\u4ef6\u4e3a\u771f\u65f6\uff0c\u624d\u4f1a\u8fdb\u5165\u5faa\u73af"
        ],
        "Normal": [
            "\u5728[game]\u4e2d\uff0c\u6211\u4eec\u8981\u6b63\u786e\u7684\u5750\u6807\u7cfb",
            "\u5728[game]\u4e2d\uff0c\u73b0\u5728\u83b7\u53d6\u7ea6\u675f\u6846\u67b6\u5728\u5c40\u90e8\u5750\u6807\u7cfb"
        ],
        "FuncName": "btUniversalConstraint_1461 setAxis.txt"
    },
    {
        "Branch": [
            "Update game world based on conditional logic."
        ],
        "Loop": [
            {
                "loopstr": [
                    "If the agent is paused, skip to the next iteration."
                ]
            }
        ],
        "Normal": [
            "Update game world with standard logic."
        ],
        "FuncName": "navigation_module_7961 update.txt"
    },
    {
        "Branch": [
            "If MapgenV5 instance is initialized",
            "If terrain generation is enabled"
        ],
        "Loop": [
            "While terrain generation is ongoing",
            "For each noise function iteration"
        ],
        "Normal": [
            "Terrain noise: A noise function used to generate terrain height",
            "3D terrain noise: A 3D noise function used to generate terrain height and depth",
            "1-up 1-down overgeneration: A technique used to generate overgeneration in the terrain",
            "1 down overgeneration: A technique used to generate overgeneration in the terrain, with a single down direction"
        ],
        "FuncName": "mapgen_v5_5858 MapgenV5.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Generate tunnels first as caverns confuse them",
                    "Generate caverns",
                    "Generate large randomwalk caves",
                    "large cave depth to world base. Avoids excessive liquid in large caverns and floating blobs of overgenerated liquid.",
                    "This is a game-specific description of the first then-str"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Disable large randomwalk caves in this mapchunk by setting",
                    "This is a game-specific description of the second then-str"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Pre-conditions",
            "TimeTaker t(\\makeChunk\\);",
            "Create a block-specific seed",
            "Generate base terrain",
            "Create heightmap",
            "Init biome generator, place biome-specific nodes, and build biomemap",
            "Generate tunnels, caverns and large randomwalk caves. This includes generating game-specific features such as hidden temples and underground cities.",
            "Generate the registered ores",
            "Generate dungeons and desert temples",
            "Generate the registered decorations",
            "Sprinkle some dust on top after everything else was generated",
            "printf(\\makeChunk: %dms\\n\\, t.stop());",
            "Add top and bottom side of water to transforming_liquid queue",
            "Calculate lighting"
        ],
        "FuncName": "mapgen_v5_5858 makeChunk.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "\u6784\u5efa\u53c2\u8003\u6846\u67b6",
            "6\u81ea\u7531\u5ea6\u7ea6\u675f\u4f7f\u7528\u6b27\u62c9\u89d2\u548c\u6765\u5b9a\u4e49\u9650\u5236",
            "\u5047\u8bbe\u65cb\u8f6c\u987a\u5e8f\u4e3a\uff1a",
            "Z\u8f74\u9996\u5148\uff0c\u5141\u8bb8\u9650\u5236(-\u03c0,\u03c0);",
            "\u65b0\u4f4d\u7f6eY\u8f74\u7b2c\u4e8c\uff08\u5141\u8bb8\u9650\u5236(-\u03c0/2 + \u03b5\uff0c\u03c0/2 - \u03b5\uff09\uff0c\u5176\u4e2d\u03b5\u662f\u5c0f\u6b63\u6570",
            "\u7528\u4e8e\u9632\u6b62\u7ea6\u675f\u5728\u6781\u70b9\u5904\u5931\u7a33;",
            "\u65b0\u4f4d\u7f6eX\u8f74\uff0c\u5141\u8bb8\u9650\u5236(-\u03c0,\u03c0);",
            "\u8981\u6a21\u62dfODE\u4e07\u5411\u8282\u8054\u5408\uff0c\u6211\u4eec\u5e94\u8be5\u4f7f\u7528\u7236\u8f74Z\uff0c\u5b50\u8f74Y\uff0c\u5e76\u9650\u5236\u5176\u4ed6DOF",
            "\u5728\u4e16\u754c\u5750\u6807\u7cfb\u4e2d\u9996\u5148\u6784\u5efa\u53c2\u8003\u6846\u67b6",
            "\u6211\u4eec\u60f3\u8981\u6b63\u786e\u7684\u5750\u6807\u7cfb",
            "\u73b0\u5728\u83b7\u53d6\u7ea6\u675f\u6846\u67b6\u5728\u5c40\u90e8\u5750\u6807\u7cfb\u4e2d",
            "sei\u9650\u5236"
        ],
        "FuncName": "btUniversalConstraint_1461 btUniversalConstraint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u575a\u5b9e",
                    " \u4e0d\u5408\u9002\u7684\u5b75\u5316\u70b9",
                    " y + 2 \u56e0\u4e3a y \u662f\u8868\u9762\u548c\u7531\u4e8e\u751f\u7269 '\u5c18' \u8282\u70b9",
                    "\u5730\u56fe\u751f\u6210\u65f6\uff0c\u5728\u6700\u4f73\u51fa\u751f\u5730\u7684\u9ad8\u5ea6\u4e0a\u8003\u8651\u5230\u5730\u5f62\u7684\u5e73\u5747\u6c34\u5e73\u548c\u751f\u7269\u7684\u751f\u5b58\u9700\u6c42"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u566a\u58f0\u9ad8\u5ea6 '\u504f\u79fb' \u662f\u5730\u5f62\u7684\u5e73\u5747\u6c34\u5e73\u3002\u81f3\u5c11 50% \u7684",
            " \u5730\u5f62\u5c06\u4f4e\u4e8e\u6b64\u3002",
            " \u5c06\u6700\u5927\u5b75\u5316\u7ea7\u522b\u8bbe\u5b9a\u4e3a '\u6c34\u9762\u9ad8\u5ea6 + 16' \u4ee5\u53ca\u566a\u58f0\u9ad8\u5ea6 '\u504f\u79fb' \u8bbe\u5b9a\u5f97\u6bd4\u6c34\u9762\u9ad8\u5ea6\u9ad8\u5f97\u591a\u65f6\uff0c\u5c31\u9700\u8981",
            " \u5f53\u566a\u58f0\u9ad8\u5ea6 '\u504f\u79fb' \u8bbe\u5b9a\u5f97\u5f88\u9ad8\u65f6\uff0c",
            " \u5728 max_spawn_y + 128 \u4e0a\u5f00\u59cb\u5b75\u5316\u641c\u7d22\u786e\u4fdd 128 \u4e2a\u8282\u70b9\u7684\u5f00\u653e\u7a7a\u95f4\u3002\u907f\u514d\u5b75\u5316\u5728\u53ef\u80fd\u5c01\u95ed\u7684\u7a7a\u6d1e\u4e2d\u3002",
            " \u4e0d\u5408\u9002\u7684\u5b75\u5316\u70b9\uff0c\u6ca1\u6709\u627e\u5230\u5730\u9762"
        ],
        "FuncName": "mapgen_v5_5858 getSpawnLevelAtPoint.txt"
    },
    {
        "Branch": [
            "check game condition"
        ],
        "Loop": [
            "loop game iteration"
        ],
        "Normal": [
            "copy data for thread safety in game environment"
        ],
        "FuncName": "c_packer_3947 find_packer.txt"
    },
    {
        "Branch": [
            "check if game state is valid for condition"
        ],
        "Loop": [
            "iterate through game data for condition"
        ],
        "Normal": [
            "copy game data for thread safety",
            "ensure data integrity in game state"
        ],
        "FuncName": "c_packer_3947 find_packer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "first time, record index in game world"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "reuse the value from first time in game history"
        ],
        "FuncName": "c_packer_3947 record_object.txt"
    },
    {
        "Branch": [
            "Generate Navmesh for IF game type to create a navigation grid for the map."
        ],
        "Loop": [
            "Generate Navmesh for LOOP game type to create a navigation grid for the map."
        ],
        "Normal": [
            "Generate Navmesh for NORMAL game type to keep 10 bits for salt and create a navigation grid for the map."
        ],
        "FuncName": "navigation_module_7961 generateNavmesh.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initialize fields that may be left untouched. In the context of the game, this means setting up the player's starting position and any initial variables that will be used throughout the game."
        ],
        "FuncName": "c_packer_3947 emplace.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Store away callbacks for efficient execution in Lua script compression.",
            " Save metatable so we can identify instances later in the game.",
            " CUSTOM_RIDX_METATABLE_MAP contains a mapping of metatables to registered names for efficient lookup.",
            " Check the condition first to avoid unnecessary operations.",
            " Then set the value accordingly."
        ],
        "FuncName": "c_packer_3947 script_register_packer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, when an if condition is met, only the specified value is pushed onto the stack.",
                    "This value is then placed at the specified location, as tables require multiple instructions to populate and must be popped separately afterwards.",
                    "This is a crucial step in maintaining the game's logic and ensuring that the correct values are being used."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In the game, when a loop condition is encountered, the key and value at the second-to-last and last positions on the stack are accessed.",
                    "The narrative and record data are then retrieved, and the set_into function is used to directly set the pushed value into a table without separately pushing the key and using the SETTABLE function.",
                    "However, this function only works under specific circumstances, hence the check, which is essential for maintaining the game's integrity and preventing errors."
                ]
            }
        ],
        "Normal": [
            "In the game, LUA_TTABLE represents a table, and it is essential to preserve the metatable information to ensure that the table is left on the stack in its original state.",
            "This is a critical step in maintaining the game's logic and preventing any potential issues that may arise from modifying the table's structure or contents."
        ],
        "FuncName": "c_packer_3947 pack_inner.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "strings may not have a NULL byte (-> lua_setfield) in If-Condition statements of Lua game code"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "c_packer_3947 suitable_key.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, this code sets the activity status of a specific entity. If the entity is not found in the crowd, it returns without making any changes. If the entity is found, it checks if the agent is valid and if the crowd is editable. If all conditions are met, it pauses or unpauses the agent's crowd activity.",
            "TODO"
        ],
        "FuncName": "navigation_module_7961 setActorActive.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "no geometry in tile"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "generate navigation grid for map area"
        ],
        "Normal": [
            "handle navigation grid leaks on errors"
        ],
        "FuncName": "navigation_module_7961 generateTile.txt"
    },
    {
        "Branch": [
            "render scene node billboard if condition is met"
        ],
        "Loop": [],
        "Normal": [
            "make billboard look to camera, ensuring optimal visual effect in the game"
        ],
        "FuncName": "CBillboardSceneNode_659 render.txt"
    },
    {
        "Branch": [
            "In if conditions, make sure to finalize the connection before closing it or returning it to the pool for a game"
        ],
        "Loop": [
            "In loop conditions, finalize the connection before closing it or returning it to the pool for a game"
        ],
        "Normal": [
            "Must finalize the connection before closing the connection or returning it to the pool for a game"
        ],
        "FuncName": "Database_3629 Disconnect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "billboard looks toward camera in a 3D game",
            "an object is pointing down at the player in a game",
            "Vertices are: 2--1 ||  |  3--0 in a game object's 3D space"
        ],
        "FuncName": "CBillboardSceneNode_659 updateMesh.txt"
    },
    {
        "Branch": [
            "Create a dynamic cube grid based on conditional statements in the game code"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Set default material for the cube grid",
                    "Add mesh buffer to the mesh to enable dynamic updates"
                ]
            }
        ],
        "Normal": [
            "The cube grid is also recalculated based on the game's bounding box"
        ],
        "FuncName": "mesh_1967 createCubeMesh.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In game development, some drawtypes have normals set to (0, 0, 0), which must result in maximum brightness: a shade factor of 1.0. For aligned cube faces, the shade factors are: +Y 1.000000 sqrt(1.0) -Y 0.447213 sqrt(0.2) +-X 0.670820 sqrt(0.45) +-Z 0.836660 sqrt(0.7) "
        ],
        "FuncName": "mesh_1967 applyFacesShading.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The bounding box of a 3D scene node, which may not be scaled correctly if the node does not scale its vertices, possibly indicating a bug in the game's rendering engine."
        ],
        "FuncName": "CBillboardSceneNode_659 getBoundingBox.txt"
    },
    {
        "Branch": [
            "check condition from Lua stack"
        ],
        "Loop": [
            "get loop condition from Lua stack"
        ],
        "Normal": [
            "allocate last for exception safety",
            "retrieve compressed value from Lua stack"
        ],
        "FuncName": "c_packer_3947 script_pack.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " removing moves indices so pop higher index first",
                    "This is a common technique used in Lua scripting to optimize game performance by removing unnecessary move indices."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " remember in top table",
                    "In Lua scripting, remembering the top table is crucial for keeping track of objects and their references."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " Make sure there's space on the stack (if applicable)",
                    "In Lua scripting, ensuring there's sufficient space on the stack is vital for efficient loop operations."
                ]
            }
        ],
        "Normal": [
            " table that tracks objects for keep_ref / PUSHREF (key = instr index)",
            "This table is essential for managing object references in Lua scripting.",
            " as part of the unpacking process all userdata is used up",
            "During the unpacking process, all user data is utilized to ensure efficient memory management.",
            " leave exactly one value on the stack",
            "Leaving a single value on the stack is a critical step in Lua scripting to maintain stack integrity."
        ],
        "FuncName": "c_packer_3947 script_unpack.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "calculate total bounding box for 3D object",
                    "scale 3D object to desired size",
                    "apply scaling transformation to 3D grid"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mesh_1967 scaleMesh.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Recreate swap chain for the new backbuffer format",
                    "This is a conditional statement in a game engine, where the swap chain is recreated for a new backbuffer format."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "D3D11Graphics_9901 SetSRGB.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Compute texture UV coords: This step calculates the texture coordinates for the grid in the game scene.",
                    "Use default texture UV mapping if not provided: This step applies the default texture mapping if no specific mapping is provided for the grid."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mesh_1967 convertNodeboxesToMesh.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In the context of grid-based game development, we intentionally check only the first normal vector, assuming that if the buffer contains a valid normal, then it's likely that all other normal vectors are valid as well. This approach is taken to optimize performance and avoid unnecessary checks, which can be a common issue in broken or poorly optimized 3D models."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mesh_1967 checkMeshNormals.txt"
    },
    {
        "Branch": [
            "Check graphics initialization status"
        ],
        "Loop": [
            "Iterate through graphics device settings"
        ],
        "Normal": [
            "Construct Graphics object, initialize graphics device",
            "Register Graphics library object factories"
        ],
        "FuncName": "D3D11Graphics_9901 Graphics.txt"
    },
    {
        "Branch": [
            "If the player's health is less than or equal to 0, the game over."
        ],
        "Loop": [
            "This loop will continue until the player reaches the final level."
        ],
        "Normal": [
            "This should not happen. Game error: MeshBuffer cloning failed."
        ],
        "FuncName": "mesh_1967 cloneMeshBuffer.txt"
    },
    {
        "Branch": [
            "Conditional rendering with a blurred effect for Direct3D11"
        ],
        "Loop": [
            "Looping animation with a blurred effect for Direct3D11"
        ],
        "Normal": [
            " No effect on Direct3D11",
            "Blurred graphics effect for Direct3D11"
        ],
        "FuncName": "D3D11Graphics_9901 SetDither.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "calculate total bounding box in game scenario"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "mesh_1967 translateMesh.txt"
    },
    {
        "Branch": [
            "Check if the condition is met in the game's logic to proceed",
            "Evaluate the condition to determine the next action",
            "Assess the situation to make a decision"
        ],
        "Loop": [
            "Iterate through the game's loop to check for conditions",
            "Repeat the process until the condition is met",
            "Loop through the game's logic to evaluate the condition"
        ],
        "Normal": [
            "SDL does not support High DPI mode on Windows platform yet, so always disable it for now in the game's graphics settings",
            "Make sure the monitor index is not bigger than the currently detected monitors in the game's display settings",
            "This monitor is not present, use the first monitor as a fallback in the game's graphics settings",
            "Find out the full screen mode display format (match desktop color depth) to ensure a seamless gaming experience",
            "If zero dimensions in windowed mode, set windowed mode to maximize and set a predefined default restored window size to accommodate different screen resolutions",
            "Fullscreen or Borderless can not be resizable, choose one or the other in the game's display settings",
            "Borderless cannot be fullscreen, they are mutually exclusive in the game's graphics settings",
            "If nothing changes, do not reset the device to avoid unnecessary actions",
            "Check fullscreen mode validity. Use a closest match if not found to ensure a smooth gaming experience",
            "Clear the initial window contents to black to ensure a clean start"
        ],
        "FuncName": "D3D11Graphics_9901 SetMode.txt"
    },
    {
        "Branch": [
            "Game: Conditional statement detected. Check for truthiness and falsiness of variables in SDL.",
            "Game: Conditional statement detected. Validate monitor index range for Windows platform.",
            "Game: Monitor not detected. Use first available monitor for SDL."
        ],
        "Loop": [],
        "Normal": [
            "Game: SDL High DPI mode not supported on Windows. Disable it for now.",
            "Game: Validate monitor index range for SDL.",
            "Game: Monitor not present. Use first available monitor for SDL.",
            "Game: Match fullscreen mode display format with desktop color depth.",
            "Game: Set windowed mode to maximize and default restored window size if zero dimensions.",
            "Game: Fullscreen and resizable modes are mutually exclusive.",
            "Game: Borderless and fullscreen modes are mutually exclusive.",
            "Game: No changes detected. Do not reset device.",
            "Game: Validate fullscreen mode. Use closest match if not found.",
            "Game: Clear initial window contents to black."
        ],
        "FuncName": "D3D11Graphics_9901 SetMode.txt"
    },
    {
        "Branch": [
            "End current frame in [Game Name] code"
        ],
        "Loop": [],
        "Normal": [
            "Clean up too large scratch buffers in [Game Name] game engine"
        ],
        "FuncName": "D3D11Graphics_9901 EndFrame.txt"
    },
    {
        "Branch": [
            "Conditional rendering: only render if the condition is met in {game_name}"
        ],
        "Loop": [
            "Iterative rendering: loop through the condition {game_name} times"
        ],
        "Normal": [
            " Note: this is not multi-instance safe in {game_name}"
        ],
        "FuncName": "D3D11Graphics_9901 SetVertexBuffer.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check if buffer has per-instance data",
                    "Verify if the game engine supports per-instance data for vertex buffers"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "D3D11Graphics_9901 SetVertexBuffers.txt"
    },
    {
        "Branch": [
            "If condition using GL2 shader"
        ],
        "Loop": [
            "Loop condition using GL2 shader"
        ],
        "Normal": [
            "No effect on Direct3D11. GL2 shader has no impact on this scenario."
        ],
        "FuncName": "D3D11Graphics_9901 SetForceGL2.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initiating a new graphics frame. For games with external windows, ensure proper size adjustments and reset screen modes as needed.",
            "Setting default render target and depth buffer for optimal performance.",
            "Cleaning up textures from the previous frame to maintain graphics integrity."
        ],
        "FuncName": "D3D11Graphics_9901 BeginFrame.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the backbuffer is multisampled, a secondary DEFAULT texture is required to resolve data to the first layer."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Atomic operation starts",
            "Atomic operation ends"
        ],
        "FuncName": "D3D11Graphics_9901 TakeScreenShot.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check if buffer has per-instance data",
                    "Apply game-specific logic to conditional statement"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterate through game objects",
                    "Apply game-specific logic to loop condition"
                ]
            }
        ],
        "Normal": [
            {
                "normalstr": [
                    "Execute game-specific instructions",
                    "Update game state accordingly"
                ]
            }
        ],
        "FuncName": "D3D11Graphics_9901 SetVertexBuffers.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Force reassign and apply game-specific texture settings"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Check if texture is currently bound as a rendertarget. In that case, use its backup texture, or blank if not defined. This is a crucial step in game development, ensuring seamless graphics rendering."
        ],
        "FuncName": "D3D11Graphics_9901 SetTexture.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "For a game like Minecraft, create the shader now if not yet created. If already attempted, do not retry. This is a crucial step in rendering the blocky 3D world."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In a game like Fortnite, switch to the clip plane variations if necessary to optimize performance. This is a common technique used in battle royale games.",
            "For a game like The Elder Scrolls V: Skyrim, update current shader parameters & constant buffers to ensure seamless gameplay. This involves tweaking various settings to achieve the desired visual effect.",
            "In a game like Overwatch, store shader combination if shader dumping in progress to analyze and improve performance. This is an essential step in maintaining a smooth gaming experience.",
            "For a game like Call of Duty, update clip plane parameter if necessary to ensure accurate collision detection. This is critical in fast-paced first-person shooter games."
        ],
        "FuncName": "D3D11Graphics_9901 SetShaders.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Make sure we use the read-write version of the depth stencil",
                    "Clearing the depth stencil is a crucial step in many 3D games to prevent artifacts and ensure smooth rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "D3D11 clear always clears the whole target regardless of viewport or scissor test settings",
            "Emulate partial clear by rendering a quad",
            "Restore color & depth write state now",
            "This is a common technique used in many games to optimize rendering and improve performance."
        ],
        "FuncName": "D3D11Graphics_9901 Clear.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Disable scissor test in game window viewport, needs to be re-enabled by the user in the game settings."
        ],
        "FuncName": "D3D11Graphics_9901 SetViewport.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Reset rendertargets and viewport for the new screen size",
            "Reinitialize rendering settings for optimal gameplay experience in <game_type>",
            "Update viewport dimensions to match the new screen size for improved visuals in <game_type>",
            "Reset game rendering targets and viewport to ensure seamless gameplay in <game_type>"
        ],
        "FuncName": "D3D11Graphics_9901 OnWindowResized.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "During some light rendering loops, a full rect is toggled on/off repeatedly. This can be a common scenario in 2D games where objects are moving rapidly across the screen.",
            "Disable scissor in that case to reduce state changes and improve performance, especially in games that require fast rendering of complex scenes."
        ],
        "FuncName": "D3D11Graphics_9901 SetScissorTest.txt"
    },
    {
        "Branch": [
            "Conditional rendering on Direct3D11"
        ],
        "Loop": [
            "Loop condition rendering on Direct3D11"
        ],
        "Normal": [
            "Direct3D11 rendering: No-op"
        ],
        "FuncName": "D3D11Graphics_9901 Restore.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Also affects whether a read-only version of depth-stencil should be bound to allow sampling in OpenGL",
                    "Related to conditional rendering in graphics programming"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "thenstr": [
                    "Involves iterative rendering or processing in game development",
                    "Related to game loop conditions and rendering pipelines"
                ],
                "elsestr": []
            }
        ],
        "Normal": [
            {
                "thenstr": [
                    "In the context of game development, refers to standard or default rendering settings",
                    "Related to normal mapping and lighting in 3D graphics"
                ],
                "elsestr": []
            }
        ],
        "FuncName": "D3D11Graphics_9901 SetDepthWrite.txt"
    },
    {
        "Branch": [
            "If the player's score is greater than 100, then update the graphics texture."
        ],
        "Loop": [
            "While the game is running, check if the player's score is greater than 100."
        ],
        "Normal": [
            "No-op on Direct3D11"
        ],
        "FuncName": "D3D11Graphics_9901 SetTextureForUpdate.txt"
    },
    {
        "Branch": [
            "In the context of game development, an if-condition is a statement that tests a specific condition and executes a block of code if the condition is true.",
            "In the code, if-condition is used to control the flow of the program and make decisions based on certain conditions."
        ],
        "Loop": [
            "In games, a loop condition refers to the criteria that determines when a loop should continue or terminate.",
            "In the code, loop-condition is used to control the number of iterations of a loop and ensure that the loop runs until a specific condition is met."
        ],
        "Normal": [
            "During some light rendering loops, a full rect is toggled on/off repeatedly. This can be optimized by disabling scissor in that case to reduce state changes.",
            "In game development, disabling scissor can improve performance by reducing the number of state changes required for rendering."
        ],
        "FuncName": "D3D11Graphics_9901 SetScissorTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the render target is also bound as a texture, replace with a backup texture or null",
                    "Related to the game: Rendering Targets and Textures"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If multisampling, mark the texture and surface for resolve",
                    "If mipmapped, mark the levels that need to be regenerated",
                    "Related to the game: Rendering and Texture Management"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "D3D11Graphics_9901 SetRenderTarget.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Direct3D11 graphics context is never considered lost. In a typical game scenario, this means the graphics card is still functioning properly.",
            "The device could be lost in case of graphics adapters getting disabled during runtime. This could happen if the game is run on a laptop and the user closes the laptop's lid, or if the graphics drivers encounter a bug and crash."
        ],
        "FuncName": "D3D11Graphics_9901 IsDeviceLost.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Ensure that different shader types and index slots get unique buffers, even if the size is same. In game development, this is crucial for optimizing graphics performance and preventing crashes."
        ],
        "FuncName": "D3D11Graphics_9901 GetOrCreateConstantBuffer.txt"
    },
    {
        "Branch": [
            "Setting initial parameters for Net IPC server application for If-Condition game type"
        ],
        "Loop": [
            "Setting initial parameters for Net IPC server application for Loop-Condition game type"
        ],
        "Normal": [
            "TODO: we should always have a --project for IPCPlayer, however it is doing double duty right now as managed player. Initial parameters for Net IPC server application for Normal game type"
        ],
        "FuncName": "NETIPCServerApp_2653 Setup.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Conditional statement for updating texture on Direct3D11"
        ],
        "Loop": [
            "Loop-Condition-Str: Looping condition for updating texture on Direct3D11"
        ],
        "Normal": [
            "Normal-Str: Updating texture on Direct3D11. No-op on Direct3D11"
        ],
        "FuncName": "D3D11Graphics_9901 SetTextureForUpdate.txt"
    },
    {
        "Branch": [
            "Check if the game logic has been initialized",
            "Verify if the player has completed the level",
            "Determine if the player has collected all the coins"
        ],
        "Loop": [
            "Repeat the game loop until the player has reached the end",
            "Continue the game loop until the player has collected all the power-ups",
            "Iterate through the game loop until the player has defeated the boss"
        ],
        "Normal": [
            "Create default rendertarget view representing the backbuffer",
            "Create default depth-stencil texture and view",
            "Update internally held backbuffer size",
            "Swap the buffers to update the display",
            "Check for any game over conditions and end the game if necessary"
        ],
        "FuncName": "D3D11Graphics_9901 UpdateSwapChain.txt"
    },
    {
        "Branch": [
            "Conditional rendering on Direct3D11"
        ],
        "Loop": [
            "Looping through Direct3D11 resources"
        ],
        "Normal": [
            "Direct3D11 rendering engine"
        ],
        "FuncName": "D3D11Graphics_9901 CleanupRenderSurface.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Set the flush mode now as the device has been created with DirectX 11"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "A DirectX 11 device needs only to be created once",
            "Check that multisample level is supported in DirectX 11",
            "Create a DirectX 11 swap chain. Release old if necessary",
            "After creating the DirectX 11 swap chain, disable automatic Alt-Enter fullscreen/windowed switching",
            "(the application will switch manually if it wants to)"
        ],
        "FuncName": "D3D11Graphics_9901 CreateDevice.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Note not same sampling behavior as on D3D9 need to sample the RG channels"
        ],
        "FuncName": "D3D11Graphics_9901 GetLuminanceAlphaFormat.txt"
    },
    {
        "Branch": [
            "Check if the game is in progress"
        ],
        "Loop": [
            "Loop through all game levels"
        ],
        "Normal": [
            "get the current value of the split property",
            "Get the maximum number of vertices in the game"
        ],
        "FuncName": "SplitLargeMeshes_13 SetupProperties.txt"
    },
    {
        "Branch": [
            "check if the current value is equal to the target value in the game state"
        ],
        "Loop": [
            "loop through the list of items in the game inventory"
        ],
        "Normal": [
            "get the current value of the split property in the game world"
        ],
        "FuncName": "SplitLargeMeshes_13 SetupProperties.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " for every index in the list of game nodes, build a new entry that includes the node's coordinates and the game's physics properties",
            " now build the new list of nodes that satisfy the game's collision detection conditions",
            " recursively update all other nodes in the game's scene graph"
        ],
        "FuncName": "SplitLargeMeshes_13 UpdateNode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "It seems the mesh has been split, requiring a rebuild of the grid list.",
                    "Now we need to update all nodes related to the game's mesh data structure."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SplitLargeMeshes_13 Execute.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of a game, it seems something has been split rebuild the mesh list, which requires rebuilding the mesh list in the game scenario.",
                    "In the context of a game, now we need to update all nodes, which involves updating all nodes in the game scene tree."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SplitLargeMeshes_13 Execute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "as an approximation take the inertia of the box that bounds the spheres, in the context of a game, this refers to the rotational inertia of a 3D object, which is a measure of its resistance to changes in its rotational motion."
        ],
        "FuncName": "btCapsuleShape_2740 calculateLocalInertia.txt"
    },
    {
        "Branch": [
            "The conditional statement is used to set the damage type based on the game's logic"
        ],
        "Loop": [
            "The loop condition is used to iterate through the enemy's PhysAsset and apply the modifier"
        ],
        "Normal": [
            "We apply this modifier based on the physics material setup to the head of the enemy PhysAsset, which is a critical hit area in the game"
        ],
        "FuncName": "SDamageType_3079 USDamageType.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5f53\u8bbe\u5907\u91cd\u7f6e\u65f6\uff0c\u91cd\u8f7d\u8d44\u6e90\u5e76\u91cd\u5efa\u7eb9\u7406\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "D3D9TextureCube_1291 OnDeviceReset.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "we need to split this mesh into sub meshes to reduce memory usage in large grid games",
                    "determine the size of a submesh to optimize performance",
                    "now generate all submeshes to improve rendering efficiency",
                    "now delete the old mesh data to free up memory"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "in games with complex animations, assume the number of bones won't change in most cases",
                    "iterate through all bones of the mesh and find those which need to be copied to the split mesh"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we'll need this bone to maintain mesh integrity. Copy it ...",
                    "no need to reallocate the array for the last submesh, as we can reuse the large source array",
                    "although we'll waste some memory, it's a trade-off for performance",
                    "copy the weights to ensure accurate animation"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "in game development, the name carries the adjacency information between the meshes",
                    "copy the list of faces to maintain mesh connectivity",
                    "get the total number of indices to optimize rendering",
                    "allocate storage to handle large meshes",
                    "texture coordinates to preserve visual details",
                    "vertex colors to enhance visual fidelity",
                    "(we will also need to copy the array of indices to ensure accurate rendering)",
                    "add the newly created mesh to the list to improve rendering efficiency"
                ]
            },
            {
                "loopstr": [
                    "allocate a new array to handle dynamic mesh data",
                    "setup face type and number of indices to optimize rendering",
                    "need to update the output primitive types to support various game engines",
                    "and copy the contents of the old array, offset by current base to maintain mesh integrity"
                ]
            },
            {
                "loopstr": [
                    "copy positions to maintain mesh geometry",
                    "copy normals to preserve visual details",
                    "copy tangents/bitangents to enhance visual fidelity",
                    "texture coordinates to preserve visual details",
                    "vertex colors to enhance visual fidelity"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SplitLargeMeshes_13 SplitMesh.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of 3D game development, splitting a mesh into sub meshes is a technique to reduce memory usage. We need to determine the optimal size of a submesh to balance performance and memory efficiency.",
                    "Assuming a mesh is composed of multiple bones, we need to iterate through all bones and identify those which require copying to the split mesh.",
                    "When copying a bone, we need to consider reusing the source array to minimize memory allocation and deallocation, although this may lead to some memory waste."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the context of 3D game development, when dealing with complex meshes, assuming the number of bones won't change in most cases is a reasonable assumption. We need to iterate through all bones and find those which require copying to the split mesh.",
                    "When iterating through bones, we need to identify those which require copying to the split mesh, taking into account the adjacency information between meshes."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the context of 3D game development, when copying a bone, we need to consider reusing the source array to minimize memory allocation and deallocation, although this may lead to some memory waste. We'll need this bone. Copy it to the split mesh.",
                    "When dealing with complex meshes, we need to be mindful of memory allocation and deallocation to ensure optimal performance.",
                    "Here we can reuse the (large) source array, although we'll waste some memory. Copy the weights of the bone to the split mesh."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In the context of 3D game development, the name of a mesh carries the adjacency information between the meshes. We need to copy the list of faces and allocate storage to accommodate the new mesh.",
                    "When copying the list of faces, we need to consider the total number of indices and allocate storage accordingly to ensure optimal performance.",
                    "We will also need to copy the array of indices and update the output primitive types to reflect the changes in the mesh.",
                    "Finally, we need to add the newly created mesh to the list, taking into account the updated adjacency information."
                ]
            },
            {
                "loopstr": [
                    "In the context of 3D game development, when dealing with complex meshes, we need to allocate a new array to store the indices of the new mesh. We need to setup face type and number of indices to ensure optimal performance.",
                    "When updating the output primitive types, we need to consider the changes in the mesh and update the types accordingly to reflect the new mesh."
                ]
            },
            {
                "loopstr": [
                    "In the context of 3D game development, when copying data between meshes, we need to consider the positions, normals, tangents/bitangents, texture coordinates, and vertex colors. Copy positions, normals, and tangents/bitangents to the new mesh.",
                    "Copy texture coordinates and vertex colors to the new mesh, taking into account the adjacency information between the meshes."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SplitLargeMeshes_13 SplitMesh.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Try to scroll the container into view when expanded. This is a typical behavior in many puzzle games."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tb_toggle_container_8634 OnEvent.txt"
    },
    {
        "Branch": [
            "In the game, the if condition statement will only be executed when the player's health is above 50."
        ],
        "Loop": [
            "In the game, the loop will continue until the player has collected all the power-ups."
        ],
        "Normal": [
            "We should not grow larger than we are, when there's extra space available. In the game, this means that the player's character will not exceed the maximum size limit."
        ],
        "FuncName": "tb_toggle_container_8634 OnCalculatePreferredSize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "x is here as a source of randomness, so it does not make much sense to protect it with a Mutex.",
                    "much sense to protect it with a Mutex.",
                    "In the context of the game, this statement highlights the importance of randomness in the game's mechanics, making it a crucial aspect to consider when designing the game's system architecture."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "RandomStream_2711 readFromDevice.txt"
    },
    {
        "Branch": [
            "Check if cube map texture data is valid for use in game engine",
            "Verify that cube map texture data meets requirements for game engine"
        ],
        "Loop": [
            "Iterate through each face of the cube map texture",
            "Loop through each face of the cube map texture to apply game-specific enhancements"
        ],
        "Normal": [
            "GetRowDataSize() returns CPU-side (source) data size, so need to convert for X8R8G8B8",
            "Perform conversion from RGB / RGBA as necessary",
            "Apply game-specific texture filtering for X8R8G8B8 cube map texture data"
        ],
        "FuncName": "D3D9TextureCube_1291 SetData.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "load audio file for game",
            "coarse check"
        ],
        "FuncName": "proxy_sound_manager_4629 loadSoundFile.txt"
    },
    {
        "Branch": [
            "Initialize if condition controller.",
            "Set if condition layout and style."
        ],
        "Loop": [
            "Initialize loop condition controller.",
            "Set loop condition layout and style."
        ],
        "Normal": [
            "ATOMIC BEGIN: Initialize atomic operation.",
            "ATOMIC END: End atomic operation."
        ],
        "FuncName": "tb_toggle_container_8634 TBSection.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Evaluate game logic for cube texture data",
            "If-Condition-Str: Determine conditions for cube texture rendering"
        ],
        "Loop": [
            "Loop-Condition-Str: Iterate over cube texture data for game logic evaluation",
            "Loop-Condition-Str: Loop through conditions for cube texture rendering"
        ],
        "Normal": [
            "Normal-Str: Cube texture data requires conversion for X8R8G8B8 format",
            "Normal-Str: Perform RGB / RGBA conversion for cube texture rendering"
        ],
        "FuncName": "D3D9TextureCube_1291 SetData.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: Evaluates a condition in a game, returning true or false.",
            "If-Condition-Str: Used to control the flow of the game's logic."
        ],
        "Loop": [
            "Loop-Condition-Str: Evaluates a condition in a game, repeating a block of code if true.",
            "Loop-Condition-Str: Used to iterate over a game's logic, performing an action multiple times."
        ],
        "Normal": [
            "GetRowDataSize returns CPU-side source data size so need to convert for X8R8G8B8: In the context of a 3D game, this string describes the process of retrieving the size of the data for a specific row in a texture, which is then converted for use in a game with X8R8G8B8 pixel format.",
            "Perform conversion from RGB RGBA as necessary: In the context of a 3D game, this string describes the process of converting color data from RGB (Red, Green, Blue) to RGBA (Red, Green, Blue, Alpha) format as needed for the game's rendering pipeline."
        ],
        "FuncName": "D3D9TextureCube_1291 SetData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Check mipmap autogeneration support in the game engine's texture cube creation process"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Fall back to non-multisampled rendering if the game engine's texture cube creation process is unsupported"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Create the multisampled face rendertarget if necessary for the game engine's texture cube creation process"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "D3D9TextureCube_1291 Create.txt"
    },
    {
        "Branch": [
            "Load sound data for if condition in game"
        ],
        "Loop": [
            "Load sound data for loop condition in game"
        ],
        "Normal": [
            "do not add twice"
        ],
        "FuncName": "proxy_sound_manager_4629 loadSoundData.txt"
    },
    {
        "Branch": [
            "Close the rendering window and display an error dialog for if-conditions in [game] code."
        ],
        "Loop": [
            "Close the rendering window and display an error dialog for loop conditions in [game] code."
        ],
        "Normal": [
            "Close the rendering window and display an error dialog for normal strings in [game] code."
        ],
        "FuncName": "Application_4294 ErrorExit.txt"
    },
    {
        "Branch": [
            "If condition for 3D text rendering"
        ],
        "Loop": [
            "Loop condition for 3D text rendering"
        ],
        "Normal": [
            "Changing font requires materials to be re-evaluated. Material evaluation can not be done in worker threads, so UI batches must be brought up-to-date immediately. This is a critical step in 3D text rendering for [game type] games."
        ],
        "FuncName": "Text3D_2018 SetFont.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, re-evaluation of the text triggers the font face to reload itself, a common mechanic in 3D text rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game, in case of multiple views, recalculate camera facing & fixed size, a crucial aspect of 3D text geometry."
        ],
        "FuncName": "Text3D_2018 UpdateGeometry.txt"
    },
    {
        "Branch": [
            "In an if statement, the condition must be true for the code to execute."
        ],
        "Loop": [
            "In a loop, the condition determines how many times the code will run."
        ],
        "Normal": [
            "Changing font requires materials to be re-evaluated. Material evaluation can not be done in worker threads, so UI batches must be brought up-to-date immediately. This is a common issue in game development, where the game's font and UI need to be updated dynamically."
        ],
        "FuncName": "Text3D_2018 SetFont.txt"
    },
    {
        "Branch": [
            "In 3D text rendering, conditional statements are crucial for dynamic text updates, ensuring that materials are re-evaluated when the font has multiple pages."
        ],
        "Loop": [
            "In 3D text rendering, loop conditions play a vital role in managing text updates, particularly when dealing with fonts that span multiple pages, requiring materials to be re-evaluated accordingly."
        ],
        "Normal": [
            "Changing text in 3D requires materials to be re-evaluated, especially if the font is multi-page, to ensure accurate rendering."
        ],
        "FuncName": "Text3D_2018 SetText.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "ATOMIC BEGIN",
            "In the context of the game, Profiler requires the main thread to be named Main as fps calculations depend on it.",
            "ATOMIC END"
        ],
        "FuncName": "Application_4294 Run.txt"
    },
    {
        "Branch": [
            "If alpha changes from zero to nonzero or vice versa, amount of text batches changes (optimization), so do full update for 3D text color in game code."
        ],
        "Loop": [],
        "Normal": [
            "If alpha changes from zero to nonzero or vice versa, amount of text batches changes (optimization), so do full update for 3D text color in game code."
        ],
        "FuncName": "Text3D_2018 SetColor.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Strip the timestamp if necessary, a common operation in game development."
                ],
                "elsestr": [
                    "No action required, typical in game development."
                ]
            }
        ],
        "Loop": [
            {
                "thenstr": [
                    "Iterate over game assets, a crucial step in game development."
                ],
                "elsestr": [
                    "No iteration required, common in game development."
                ]
            }
        ],
        "Normal": [
            {
                "thenstr": [
                    "Game development involves various tasks, including debugging and testing."
                ],
                "elsestr": [
                    "No specific task required, typical in game development."
                ]
            }
        ],
        "FuncName": "Application_4294 HandleLogMessage.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Bounding box must be recalculated in the context of a 2D platformer game."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Text3D_2018 SetFixedScreenSize.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In 3D text rendering, opacity changes from zero to nonzero or vice versa, affecting text batches and requiring a full update, similar to the optimization found in [game] code."
        ],
        "FuncName": "Text3D_2018 SetOpacity.txt"
    },
    {
        "Branch": [
            "Convert multiple-color images to grayscale images in the game."
        ],
        "Loop": [
            {
                "loopstr": [
                    "*INDENT-OFF*",
                    "Iterate through the game's grayscale images.",
                    "*INDENT-ON*"
                ]
            }
        ],
        "Normal": [
            "Apply game-specific grayscale conversion logic."
        ],
        "FuncName": "SDL_blit_A_5221 BlitNto1PixelAlpha.txt"
    },
    {
        "Branch": [
            "\u5728[game]\u7c7b\u578b\u7684\u4e16\u754c\u4e2d\uff0c\u5982\u679c\u67d0\u4e2a\u6761\u4ef6\u6210\u7acb\uff0c\u66f4\u65b03D\u6587\u672c\u7684\u4e16\u754c\u8fb9\u754c\u76d2"
        ],
        "Loop": [
            "\u5728[game]\u7c7b\u578b\u7684\u4e16\u754c\u4e2d\uff0c\u5faa\u73af\u904d\u5386\u6761\u4ef6\uff0c\u66f4\u65b03D\u6587\u672c\u7684\u4e16\u754c\u8fb9\u754c\u76d2"
        ],
        "Normal": [
            "\u5728[game]\u7c7b\u578b\u7684\u4e16\u754c\u4e2d\uff0c\u4f7f\u7528\u6700\u540e\u7684\u6444\u50cf\u5934\u65cb\u8f6c\u6765\u6784\u5efa\u4e16\u754c\u8fb9\u754c\u6846"
        ],
        "FuncName": "Text3D_2018 OnWorldBoundingBoxUpdate.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In 3D text rendering, color settings are crucial. For instance, in Unity game engine, setting the color of 3D text can greatly enhance the visual experience. Similarly, in Unreal Engine, adjusting the color of 3D text can significantly impact the overall aesthetic of a game."
        ],
        "FuncName": "Text3D_2018 SetColor.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Blit N to 1 surface with alpha key for 2D game",
                    "Blit N to 1 surface with alpha key for 3D game"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SDL_blit_A_5221 BlitNto1SurfaceAlphaKey.txt"
    },
    {
        "Branch": [
            "If the alpha channel of the source pixel is not zero, combine it with the RGB color of the target pixel."
        ],
        "Loop": [
            {
                "loopstr": [
                    " *INDENT-OFF* ",
                    " *INDENT-ON* "
                ]
            }
        ],
        "Normal": [
            "Combine the alpha channel of the source pixel with the RGB color of the target pixel."
        ],
        "FuncName": "SDL_blit_A_5221 BlitNto1SurfaceAlpha.txt"
    },
    {
        "Branch": [
            "Conditional statement: If the game's RGB image is converted to a 128-level transparent RGB image, the game's graphics will be enhanced."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Loop through each pixel in the game's RGB image and apply transparency level to create a 128-level transparent RGB image.",
                    "*INDENT-OFF*",
                    "*INDENT-ON*"
                ]
            }
        ],
        "Normal": [
            "Game graphics will be displayed on a 128-level transparent RGB image."
        ],
        "FuncName": "SDL_blit_A_5221 BlitRGBtoRGBSurfaceAlpha128.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In 3D game mode, bounding box must be recalculated to ensure accurate collision detection and rendering."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Text3D_2018 SetFaceCameraMode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5982\u679c\u6750\u6599\u672a\u5b9a\u4e49\uff0c\u5219\u521b\u5efa\u4e00\u4e2a\u5408\u7406\u7684\u9ed8\u8ba4\u503c\uff0c\u4f8b\u5982\u5728\u6e38\u620f\u4e2d\u4f7f\u7528\u7684\u5178\u578b\u6750\u8d28"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "\u6ce8\u610f\uff1a\u81ea\u5b9a\u4e49\u6750\u6599\u5047\u8bbe\u5177\u6709\u6b63\u786e\u7684\u7740\u8272\u5668\u5b9a\u4e49\uff1b\u5b83\u4eec\u5728\u8fd9\u91cc\u4e0d\u4f1a\u88ab\u4fee\u6539\uff0c\u786e\u4fdd\u5728\u6e38\u620f\u4e2d\u4fdd\u6301\u4e00\u81f4\u7684\u89c6\u89c9\u6548\u679c"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Text3D_2018 UpdateTextMaterials.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Transparency applied to RGB surface in game.",
                    "Transparency applied to RGB surface in game."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "SDL_blit_A_5221 BlitRGBtoRGBSurfaceAlpha.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Loop condition for game logic: ",
                    " "
                ]
            }
        ],
        "Normal": [
            "Normal string for game type: "
        ],
        "FuncName": "SDL_blit_A_5221 BlitARGBto565PixelAlpha.txt"
    },
    {
        "Branch": [
            "Draw non-transparent pixels from source surface to target surface in game rendering."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterate through game objects in game loop.",
                    "Iterate through game objects in game loop."
                ]
            }
        ],
        "Normal": [
            "Draw non-transparent pixels from source surface to target surface in game rendering."
        ],
        "FuncName": "SDL_blit_A_5221 BlitNtoNSurfaceAlpha.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "INDENT-OFF: Initializing game assets for 555 color depth",
                    "INDENT-ON: Rendering game graphics at 555 color depth"
                ]
            }
        ],
        "Normal": [
            "downscale alpha to 5 bits: Optimizing game performance for 555 color depth"
        ],
        "FuncName": "SDL_blit_A_5221 Blit555to555SurfaceAlpha.txt"
    },
    {
        "Branch": [
            "Check if the player has the required item in BlitNtoNPixelAlpha function"
        ],
        "Loop": [
            {
                "loopstr": [
                    "*INDENT-OFF*",
                    "*INDENT-ON*"
                ]
            }
        ],
        "Normal": [
            "Initialize game variables and set up player status in BlitNtoNPixelAlpha function"
        ],
        "FuncName": "SDL_blit_A_5221 BlitNtoNPixelAlpha.txt"
    },
    {
        "Branch": [
            "Convert 565 format image to 565 format image, preserving transparency."
        ],
        "Loop": [
            {
                "loopstr": [
                    "*INDENT-OFF*",
                    "*INDENT-ON*",
                    "Game-specific: Looping through game logic to preserve transparency."
                ]
            }
        ],
        "Normal": [
            "Game-specific: Preserving transparency for 565 format image."
        ],
        "FuncName": "SDL_blit_A_5221 Blit565to565SurfaceAlpha.txt"
    },
    {
        "Branch": [
            "Convert RGB image to RGBA image with alpha channel"
        ],
        "Loop": [
            {
                "loopstr": [
                    "*INDENT-OFF*",
                    "Iterate over pixel data to add alpha channel",
                    "*INDENT-ON*"
                ]
            }
        ],
        "Normal": [
            "Apply image conversion to game assets"
        ],
        "FuncName": "SDL_blit_A_5221 BlitRGBtoRGBPixelAlpha.txt"
    },
    {
        "Branch": [
            "If the condition is met, the ARGB pixel will be converted to 555 pixel, preserving transparency."
        ],
        "Loop": [
            {
                "loopstr": [
                    "*INDENT-OFF*",
                    "*INDENT-ON*",
                    "In each iteration, the ARGB pixel will be converted to 555 pixel, preserving transparency."
                ]
            }
        ],
        "Normal": [
            "The ARGB pixel will be converted to 555 pixel, preserving transparency."
        ],
        "FuncName": "SDL_blit_A_5221 BlitARGBto555PixelAlpha.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, the source and destination surfaces must be aligned to ensure efficient pixel copying. This is particularly beneficial for large blitting operations, but it's not a significant loss for smaller ones. Additionally, handling odd destination addresses can be crucial for maintaining the game's visual integrity.",
                    "When dealing with odd destination addresses, the handling becomes more complex. This is where the game's pipeline comes into play, allowing for more efficient handling of these cases.",
                    "With the source pointer now aligned to 32-bit boundaries, the pipeline can be optimized for better performance. This is especially important in games that rely heavily on pixel manipulation.",
                    "To initiate the pipeline, the first halfword is used as a bootstrap. This ensures a smooth transition into the pipeline, minimizing any potential delays.",
                    "Finally, any remaining pixel is handled to ensure a seamless visual experience."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SDL_blit_A_5221 Blit16to16SurfaceAlpha128.txt"
    },
    {
        "Branch": [
            "Blit source surface to target surface using BlitNtoNSurfaceAlphaKey function for color key and alpha blending."
        ],
        "Loop": [
            {
                "loopstr": [
                    "INDENT-OFF",
                    "INDENT-ON"
                ]
            }
        ],
        "Normal": [
            "BlitNtoNSurfaceAlphaKey function is used in game development for rendering surfaces with alpha blending and color keying."
        ],
        "FuncName": "SDL_blit_A_5221 BlitNtoNSurfaceAlphaKey.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "moving concave objects not supported. This is a limitation of the game's physics engine, which only supports static shapes."
        ],
        "FuncName": "btStaticPlaneShape_5492 calculateLocalInertia.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In Lua, when entering a new function, jumping back (looping), or entering a new line, a linehook is called.",
                    "This is a game-specific feature that allows for custom code execution during these events.",
                    "The linehook function can be used to perform various tasks, such as logging, debugging, or modifying game state."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "lvm_384 traceexec.txt"
    },
    {
        "Branch": [
            "Conditional statement: If-Condition-Str",
            "Evaluate condition"
        ],
        "Loop": [
            "Looping statement: Loop-Condition-Str",
            "Check loop condition"
        ],
        "Normal": [
            "Function call: push function",
            "First argument: 1st argument",
            "Second argument: 2nd argument"
        ],
        "FuncName": "lvm_384 callTMres.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Per-surface alpha blits with graphics rendering techniques used in popular games"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "SDL_blit_A_5221 SDL_CalculateBlitA.txt"
    },
    {
        "Branch": [
            "If the plane equation normal is constant, then the triangles can be generated using AABB."
        ],
        "Loop": [
            "For each triangle, calculate the tangent direction."
        ],
        "Normal": [
            "this is where the triangles are generated given AABB and plane equation normal constant",
            "tangentDir0 tangentDir1 can be precalculated",
            "the triangles are processed by calculating the tangent direction for each."
        ],
        "FuncName": "btStaticPlaneShape_5492 processAllTriangles.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "push function in Lua ",
            "1st argument of Lua function ",
            "2nd argument of Lua function ",
            "3th argument of Lua function "
        ],
        "FuncName": "lvm_384 callTM.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " \u662f\u4e00\u4e2a\u8868\u5417\uff1f \u4e00\u4e2a\u8868\u662f Lua \u7684\u4e00\u4e2a\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff0c\u53ef\u4ee5\u5b58\u50a8\u4efb\u610f\u7c7b\u578b\u7684\u503c\uff0c\u5305\u62ec\u6570\u5b57\u3001\u5b57\u7b26\u4e32\u3001\u5e03\u5c14\u503c\u3001\u8868\u3001\u51fd\u6570\u548c nil\u3002"
                ],
                "elsestr": [
                    " \u5426\u5219\u5c1d\u8bd5\u6807\u7b7e\u65b9\u6cd5 \u4e00\u4e2a\u6807\u7b7e\u65b9\u6cd5\u662f Lua \u4e2d\u4e00\u4e2a\u7279\u6b8a\u7684\u8bed\u53e5\uff0c\u53ef\u4ee5\u7528\u4e8e\u63a7\u5236\u7a0b\u5e8f\u7684\u6d41\u7a0b\u3002"
                ]
            },
            {
                "thenstr": [
                    " \u6216\u6ca1\u6709 TM? \u4e00\u4e2a TM \u662f Lua \u4e2d\u4e00\u4e2a\u7279\u6b8a\u7684\u503c\uff0c\u4ee3\u8868\u4e00\u4e2a\u8868\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    " \u5426\u5219\u91cd\u590d\u4f7f\u7528`tm' \u91cd\u590d\u4f7f\u7528\u4e00\u4e2a\u8868\u662f\u4e00\u4e2a\u5faa\u73af\u8bed\u53e5\uff0c\u53ef\u4ee5\u91cd\u590d\u6267\u884c\u67d0\u4e2a\u8bed\u53e5\u3002"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "lvm_384 luaV_gettable.txt"
    },
    {
        "Branch": [
            "Create a static plane shape if the plane normal is valid."
        ],
        "Loop": [],
        "Normal": [
            "btAssert( btFuzzyZero(m_planeNormal.length() - btScalar(1.)) ); Create a static plane shape with a valid normal vector."
        ],
        "FuncName": "btStaticPlaneShape_5492 btStaticPlaneShape.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Calculating the bounding box for a static plane shape. The plane's normal vector is multiplied by a large float value to create an infinite vector. The plane's center is then calculated by multiplying the normal vector by the plane's constant term. The minimum and maximum points of the bounding box are set based on the plane's center and the infinite vector."
        ],
        "FuncName": "btStaticPlaneShape_5492 getAabb.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "t is a table?",
                    "do a primitive set",
                    "else will try the tag method"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "or no TM?"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "else repeat with tm",
                    "avoid pointing inside table (may rehash)"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "lvm_384 luaV_settable.txt"
    },
    {
        "Branch": [
            "Compare two Lua values for equality in game code"
        ],
        "Loop": [
            "Check if two Lua values are equal in game code"
        ],
        "Normal": [
            "Call TM procedure in game code"
        ],
        "FuncName": "lvm_384 luaV_equalval.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get parameters and apply particle effects in the game"
        ],
        "FuncName": "l_particles_3377 l_add_particle.txt"
    },
    {
        "Branch": [
            "If the condition is true, the game will proceed to the next step."
        ],
        "Loop": [
            "The loop will continue until the condition is met."
        ],
        "Normal": [
            "Repeat the process until only 1 result is left, as in a game where the last player standing wins."
        ],
        "FuncName": "lvm_384 luaV_concat.txt"
    },
    {
        "Branch": [
            "If the row size is less than 10, then the game enters a new round."
        ],
        "Loop": [
            {
                "loopstr": [
                    "The game continues until the player's score reaches 100 or the row size exceeds 20."
                ]
            }
        ],
        "Normal": [
            "The player must move the block to the left to avoid collision."
        ],
        "FuncName": "rescaler_8942 WebPRescalerExportRowShrinkC.txt"
    },
    {
        "Branch": [
            "Check if condition is met in the game logic module",
            "Evaluate the condition in the game world"
        ],
        "Loop": [
            "Determine the loop condition in the game logic module",
            "Iterate through the game world based on the condition"
        ],
        "Normal": [
            "Get core.registered_on_generateds in the game world",
            "Call callbacks to trigger game events"
        ],
        "FuncName": "s_modchannels_8602 on_modchannel_message.txt"
    },
    {
        "Branch": [
            "Check particle fountain status"
        ],
        "Loop": [],
        "Normal": [
            "Get parameters",
            "Interact with particle fountain"
        ],
        "FuncName": "l_particles_3377 l_delete_particlespawner.txt"
    },
    {
        "Branch": [
            "Check if first operand equals second operand in the game of equality"
        ],
        "Loop": [
            "Repeat the operation if first operand is greater than second operand in the game of comparison"
        ],
        "Normal": [
            "Try to perform the operation first operand + second operand in the game of arithmetic",
            "Try to perform the operation first operand - second operand in the game of arithmetic"
        ],
        "FuncName": "lvm_384 call_binTM.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Performing simple bilinear interpolation for 2D image rendering"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "rescaler_8942 WebPRescalerImportRowExpandC.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "set default values",
                    "add particle emitter to game world",
                    "read spawner parameters from the table"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Get parameters and add particle emitter to game world"
        ],
        "FuncName": "l_particles_3377 l_add_particlespawner.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "did hook yield",
                    "In Lua game, hooks are used to execute custom code at specific points in the game's execution."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "jump back",
                    "update internal index...",
                    "...and external index",
                    "In Lua game, the internal and external indices are used to keep track of the game's state and memory."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "continue loop?",
                    "save control variable",
                    "jump back",
                    "In Lua game, loops are used to execute code repeatedly, and control variables are used to control the flow of the game."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "previous call may change the stack",
                    "In Lua game, the stack is used to store function calls and data, and changing the stack can affect the game's execution."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "warning!! several calls may realloc the stack and invalidate `ra'",
                    "In Lua game, the stack is reallocated and `ra` is invalidated when multiple function calls are made, which can cause issues with the game's execution."
                ]
            }
        ],
        "Normal": [
            "entry point",
            "In Lua game, the entry point is the starting point of the game's execution.",
            "main loop of interpreter",
            "In Lua game, the main loop is the loop that executes the game's code repeatedly."
        ],
        "FuncName": "lvm_384 luaV_execute.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Get core.registered_on_generateds and process module signals",
            " Call callbacks to handle game logic"
        ],
        "FuncName": "s_modchannels_8602 on_modchannel_signal.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of game development, if true a warning is issued if too many textures are used, similar to how it would be in a game engine like Unity or Unreal Engine."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 createMesh.txt"
    },
    {
        "Branch": [
            "Check if condition is met to avoid incomplete data"
        ],
        "Loop": [
            "Ensure loop condition is satisfied to process all data"
        ],
        "Normal": [
            "last byte not entirely filled, possibly due to truncated data or incomplete transmission"
        ],
        "FuncName": "imagefilters_2181 all.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Detects two colliding bodies and updates their point state, adding to the state arrays state1 and state2.",
            "Detects two colliding bodies and updates their point state, removing from the state arrays state1 and state2."
        ],
        "FuncName": "b2Collision_1798 b2GetPointStates.txt"
    },
    {
        "Branch": [
            "Check if vertex data is present in B3D file"
        ],
        "Loop": [
            "Loop through each vertex in B3D file"
        ],
        "Normal": [
            "Get header",
            "Add main chunk...",
            "Get file version, but ignore it, as it's not important with b3d files",
            "Read main chunk",
            "Extract vertex data from main chunk",
            "Extract normal data from vertex data",
            "Extract color data from vertex data",
            "Extract material data from vertex data",
            "Extract texture data from vertex data"
        ],
        "FuncName": "CB3DMeshFileLoader_7393 load.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u5e76\u884c\u3002\u5c04\u7ebf\u8fdb\u5165\u76d2\u5b50\u3002"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u5149\u7ebf\u662f\u5426\u5728\u76d2\u5b50\u5185?\u5c04\u7ebf\u68c0\u6d4b\u76d2\u5b50\u3002",
            "\u5149\u7ebf\u662f\u5426\u8d85\u8fc7\u6700\u5927\u5206\u6570?\u5c04\u7ebf\u68c0\u6d4b\u5206\u6570\u3002",
            "\u76f8\u4ea4\u3002\u5c04\u7ebf\u4e0e\u76d2\u5b50\u76f8\u4ea4\u3002"
        ],
        "FuncName": "b2Collision_1798 RayCast.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Calculate floating-point source rectangle bounds for image scaling.",
                    "Do some basic clipping, and for mirrored/flipped rects, make sure min/max are in the right order.",
                    "Total area, and integral of r, g, b values over that area, initialized to zero, to be summed up in next loops.",
                    "Loop over the integral pixel positions described by those bounds, setting the destination image pixel to the average color."
                ]
            },
            {
                "loopstr": [
                    "Calculate width, height, then area of dest pixel that's covered by this source pixel.",
                    "Get source pixel and add it to totals, weighted by covered area and alpha, for image scaling."
                ]
            }
        ],
        "Normal": [
            "Cache rectangle boundaries for efficient image processing.",
            "Walk each destination image pixel, noting that loop y around x for better cache locality.",
            "This is a normal string describing a game-related process."
        ],
        "FuncName": "imagefilters_2181 imageScaleNNAA.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Find intersection point of edge and plane",
                    "Vertex A is hitting edge B in a 3D game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Start with no output points in a game",
            "Calculate the distance of end points to the line in a 3D game",
            "If the points are behind the plane in a game",
            "If the points are on different sides of the plane in a 3D game"
        ],
        "FuncName": "b2Collision_1798 b2ClipSegmentToLine.txt"
    },
    {
        "Branch": [
            "In the context of VxWorks 5.x, this condition is met when ",
            "the pthread_mutex_init() function fails to properly initialize ",
            "the mutex, leading to a subsequent freeze in pthread_mutex_destroy() ",
            "if the mutex has never been locked."
        ],
        "Loop": [
            "A critical loop condition exists in VxWorks 5.x where ",
            "the pthread_mutex_init() function returns an error, causing ",
            "the mutex to remain uninitialized and leading to a subsequent freeze ",
            "in pthread_mutex_destroy() if the mutex has never been used."
        ],
        "Normal": [
            " This workaround is for VxWorks 5.x where ",
            " pthread_mutex_init() won't properly initialize the mutex",
            " resulting in a subsequent freeze in pthread_mutex_destroy()",
            " if the mutex has never been used."
        ],
        "FuncName": "Semaphore_POSIX_6944 SemaphoreImpl.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Apply changes to bitmap for next run. This is done so we don't introduce a bias in color propagation in the direction pixels are processed.",
                    "Skip pixels we have already processed",
                    "Sample size and total weighted r, g, b values",
                    "Walk each neighbor pixel (clipped to image bounds)",
                    "Set pixel to average weighted by alpha. This is a fundamental step in the game's image processing algorithm, ensuring that colors are propagated correctly."
                ]
            },
            {
                "loopstr": [
                    "Ignore pixels we haven't processed",
                    "Add RGB values weighted by alpha IF the pixel is opaque, otherwise use full weight since we want to propagate colors. This is a crucial step in maintaining the game's visual integrity."
                ]
            }
        ],
        "Normal": [
            "First pass: Mark all opaque pixels. This sets the stage for the game's image processing pipeline.",
            "Note: loop y around x for better cache locality. This optimization is key to the game's performance.",
            "Exit early if all pixels opaque. If all pixels are opaque, there's no need to continue processing.",
            "Cap iterations to keep runtime reasonable, for higher-res textures we can get away with filling less pixels. This ensures the game remains responsive.",
            "Then repeatedly look for transparent pixels, filling them in until we're finished. This is the core of the game's image processing algorithm, ensuring that all pixels are properly handled."
        ],
        "FuncName": "imagefilters_2181 imageCleanTransparentWithInlining.txt"
    },
    {
        "Branch": [
            "Read NODE block and construct bone position, size, and rotation for conditional logic in game code."
        ],
        "Loop": [
            "Read NODE block and construct bone position, size, and rotation for loop conditions in game code."
        ],
        "Normal": [
            "Build LocalMatrix: Constructing bone position, size, and rotation for game logic."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkNODE.txt"
    },
    {
        "Branch": [
            "Read a string used in if conditions in the game code."
        ],
        "Loop": [
            {
                "loopstr": [
                    "Read a string used in loop conditions in the game code until the end of file (EOF) is reached."
                ]
            }
        ],
        "Normal": [
            "Read a normal string in the game code."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readString.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, finding the mesh buffer and vertex index from the global vertex ID is crucial for rendering 3D models accurately."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkBONE.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Something is wrong. In the game, this error message is triggered when a player's character has a corrupted skeleton."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Allocate Memory for speed. In the game, this is done to ensure the character's movements are smooth and responsive.",
            "Allocate Memory for speed. In the game, this is done to ensure the character's movements are smooth and responsive."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkVRTS.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, let the solver grasp the soft bodies and if necessary optimize for it to achieve realistic simulations",
            "/solve soft bodies constraints related to the game's physics engine",
            "self collisions and rigid body interactions",
            "/update soft bodies with game-specific properties",
            "End solver-wise simulation step, advancing the game's simulation",
            "/////////////////////////////////"
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 internalSingleStepSimulation.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In [game] 'b3d', skeleton animation KEYS are stored in a specific order, with W first."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In [game] 'b3d', skeleton animation KEYS are stored in a specific order, with W first."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In [game] 'b3d', only the first output is printed, as subsequent outputs would be excessive."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkKEYS.txt"
    },
    {
        "Branch": [
            "Read animation data if condition is met"
        ],
        "Loop": [
            "Read animation data in a loop"
        ],
        "Normal": [
            "Read animation data: not stored used",
            "Read animation data: not stored used",
            "Read animation data: not stored used"
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkANIM.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " If this vertex is linked in a different meshbuffer",
                    " This is related to the ChunkTRIS game type, where triangles are processed in chunks."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " If this vertex is not in the meshbuffer",
                    " Check for lightmapping:",
                    " Will only affect the meshbuffer the first time this is called",
                    " Add the vertex to the meshbuffer:",
                    " create vertex id to meshbuffer index link:",
                    " This is a crucial step in the ChunkTRIS game type, where efficient mesh management is key."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    " Apply Material/Color/etc...",
                    " Use texture's scale",
                    " if (B3dMaterial->Textures[1]) { Vertex->TCoords2.X *=B3dMaterial->Textures[1]->Xscale; Vertex->TCoords2.Y *=B3dMaterial->Textures[1]->Yscale; } ",
                    " In the context of ChunkTRIS, this step involves applying textures and materials to the mesh in a way that optimizes performance."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " Note: Irrlicht can't have different brushes for each triangle (using a workaround)",
            " This is a limitation in the Irrlicht engine, which affects the ChunkTRIS game type's ability to handle complex triangle brushes."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkTRIS.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Mesh file loaded successfully. Chunk MESH content: ok"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkMESH.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In ChunkBRUS, secondary UV is set to 65536."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "One texture is loaded in ChunkBRUS. Flags 0x1 is usual SOLID, 0x8 is mipmap (handled before). TODO: create color key texture."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In ChunkBRUS, the texture is alpha mapped."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In ChunkBRUS, full-bright mode is enabled."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In ChunkBRUS, force vertex alpha-blending is enabled."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In ChunkBRUS, pointers to textures are retrieved based on IDs."
                ]
            }
        ],
        "Normal": [
            "In ChunkBRUS, the number of Irrlicht texture IDs read is tracked.",
            "In ChunkBRUS, the number of bytes to skip for ignored texture IDs is tracked."
        ],
        "FuncName": "CB3DMeshFileLoader_7393 readChunkBRUS.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Dark Mode Style: Using a deep, rich color scheme to create a dramatic effect in the game.",
            "Dark Mode Style: Using a deep, rich color scheme to create a dramatic effect in the game."
        ],
        "FuncName": "imgui_draw_4937 StyleColorsDark.txt"
    },
    {
        "Branch": [
            "Set Classic theme color for If-Condition statement in [game] code",
            "Set Classic theme color for If-Condition statement in [game] code"
        ],
        "Loop": [
            "Set Classic theme color for Loop-Condition statement in [game] code",
            "Set Classic theme color for Loop-Condition statement in [game] code"
        ],
        "Normal": [
            "Prefer using Alpha=1.0 here. Classic theme color is applied.",
            "Prefer using Alpha=1.0 here. Classic theme color is applied."
        ],
        "FuncName": "imgui_draw_4937 StyleColorsClassic.txt"
    },
    {
        "Branch": [
            "Solve soft-body dynamics constraints if possible"
        ],
        "Loop": [
            "Solve soft-body dynamics constraints until converged"
        ],
        "Normal": [
            "Solve soft-body dynamics constraints solver-wise"
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 solveSoftBodiesConstraints.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Set the soft body solver that will handle this soft body's dynamics",
            "to be the world's soft body solver"
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 addSoftBody.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Performing rigid collision detection between two objects in the game.",
                    "Obtaining the AABB (Axis-Aligned Bounding Box) of the collision object.",
                    "Getting the AABB of the collision object from the broadphase.",
                    "Calculating the closest hit fraction between the ray and the collision object.",
                    "This step is skipped due to culling already done by the broadphase.",
                    "Checking if the ray intersects with the AABB of the collision object using btRayAabb."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Terminating further ray tests once the closest hit fraction reaches zero.",
            "Performing a raycast if the filter mask matches the collision object."
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 process.txt"
    },
    {
        "Branch": [
            "serialize all collision objects based on soft-body dynamics in the game"
        ],
        "Loop": [],
        "Normal": [
            "serialize all collision objects"
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 serializeSoftBodies.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "utilize the broadphase to accelerate the search for entities, based on their aabb",
            "and for each entity with ray-aabb overlap, perform an exact ray test to determine collisions in the game"
        ],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 rayTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Obtain the surface normal of the collision object.",
                    "In the soft-body dynamics world, the surface normal of an object is a vector that points from the object's surface towards the origin of the ray."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The surface normal of the collision object always points towards the origin of the ray.",
                    "This is a fundamental property of the soft-body dynamics world and is used to determine the direction of the normal."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "btSoftMultiBodyDynamicsWorld_3141 rayTestSingle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Automatic segment count for circular games",
            "Ceiling to prevent accuracy reduction in circular games",
            "Utilizing cached values for circular game optimization"
        ],
        "FuncName": "imgui_draw_4937 _CalcCircleAutoSegmentCount.txt"
    },
    {
        "Branch": [
            "If condition: "
        ],
        "Loop": [
            "Loop condition: "
        ],
        "Normal": [
            " Same as calling ImDrawCmd_HeaderCopy() for drawing commands in the game. "
        ],
        "FuncName": "imgui_draw_4937 AddDrawCmd.txt"
    },
    {
        "Branch": [
            "When clipping region changes, update current command."
        ],
        "Loop": [],
        "Normal": [
            " If current command is used with different settings we need to add a new command for the game.",
            " Try to merge with previous command if it matches, else use current command for the game."
        ],
        "FuncName": "imgui_draw_4937 _OnChangedClipRect.txt"
    },
    {
        "Branch": [
            "If a condition is met, add a callback function to the drawing list in the game."
        ],
        "Loop": [
            "Loop through the game code and add a callback function to the drawing list at a specific condition."
        ],
        "Normal": [
            "Force a new command after us see comment below, in the context of the game, this means forcing a new action or event to occur after the current one."
        ],
        "FuncName": "imgui_draw_4937 AddCallback.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In game development, updating current drawing commands' offset is crucial. We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.",
            "In game programming, it's essential to ensure correct vertex offset. IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349 (Game Development Issue)"
        ],
        "FuncName": "imgui_draw_4937 _OnChangedVtxOffset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, this means verifying the ImDrawCmd fields are contiguous in memory to ensure smooth rendering of graphics."
        ],
        "FuncName": "imgui_draw_4937 _ResetForNewFrame.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "break;",
                    "Infinite loop detected. Please add a condition to exit the loop."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imgui_draw_4937 _PopUnusedDrawCmd.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In theory we should be testing that vertex count is less than 64KB here for optimal performance in games with large 3D models.",
                    "In practice, the RenderText() function relies on reserving ahead for a worst-case scenario, making this check unnecessary until the text functions are reworked to handle clipping and large horizontal lines better for better game rendering.",
                    "This is especially important for games with complex graphics and large textures."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Enabling large mesh support for improved game performance and graphics quality."
        ],
        "FuncName": "imgui_draw_4937 PrimReserve.txt"
    },
    {
        "Branch": [
            "Conditional rendering for game logic",
            "Conditional rendering for game logic"
        ],
        "Loop": [
            "Iterative rendering for game loop",
            "Iterative rendering for game loop"
        ],
        "Normal": [
            "Game rendering with alpha blending",
            "Game rendering with alpha blending"
        ],
        "FuncName": "imgui_draw_4937 StyleColorsLight.txt"
    },
    {
        "Branch": [
            "In game logic, when a condition is met, trigger a specific action",
            "Check the condition and execute the corresponding action"
        ],
        "Loop": [
            "In game loop, check the condition and repeat the action until it's met",
            "Loop through the condition and perform the associated action"
        ],
        "Normal": [
            "In game development, when a command is used with different settings, a new command is added",
            "A command is merged with the previous one if it matches, otherwise the current command is used"
        ],
        "FuncName": "imgui_draw_4937 _OnChangedTextureID.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "A bit pessimistic maybe theres a better computation to do here, drawing an elliptical arc in the game."
        ],
        "FuncName": "imgui_draw_4937 PathEllipticalArcTo.txt"
    },
    {
        "Branch": [
            "Conditional rendering of a rectangle in a game environment."
        ],
        "Loop": [
            "Iterative rendering of a rectangle in a game loop."
        ],
        "Normal": [
            "Improved visual appearance of a rectangle's lower-right corner and non-anti-aliased shapes in a game."
        ],
        "FuncName": "imgui_draw_4937 AddRect.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Draw an arc to a specified position, a crucial operation in game development, enabling the creation of smooth curves and animations.",
            "In game development, drawing an arc to a specified position is essential for crafting engaging visual effects and interactive experiences."
        ],
        "FuncName": "imgui_draw_4937 _PathArcToN.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u6211\u4eec\u5c06\u4f7f\u7528\u9884\u8ba1\u7b97\u7684\u503c\u6765\u4e3a\u4e2d\u95f4\u6837\u672c",
                    "\u786e\u5b9alookup\u8868\u4e2d\u5c5e\u4e8e\u5f27\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u6837\u672c",
                    "\u7ed8\u5236\u5706\u5f27\u5230\u8def\u5f84\uff0c\u5c5e\u4e8e[game]\u7c7b\u578b\u7684\u5f27"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u81ea\u52a8\u5206\u6bb5\u8ba1\u6570",
            "\u4e3a[game]\u7c7b\u578b\u7684\u8def\u5f84\u7ed8\u5236\u5706\u5f27"
        ],
        "FuncName": "imgui_draw_4937 PathArcTo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Auto-tessellated in a 3D game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imgui_draw_4937 PathBezierCubicCurveTo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Auto-tessellated in a game of 2D graphics rendering"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imgui_draw_4937 PathBezierQuadraticCurveTo.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Anti-aliased Fill: A game technique used to create smooth edges for 2D graphics.",
                    "Add indexes for fill: A game optimization method used to improve rendering performance.",
                    "Compute normals: A game math operation used to calculate surface normals for lighting and shading."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Average normals: A game math operation used to combine multiple surface normals for smoothing.",
                    "Add vertices: A game geometry operation used to create new vertices for mesh creation.",
                    "Inner: A game geometry term referring to the inner part of a polygon or shape.",
                    "Outer: A game geometry term referring to the outer part of a polygon or shape.",
                    "Add indexes for fringes: A game optimization method used to improve rendering performance by indexing fringes."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imgui_draw_4937 AddConvexPolyFilled.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In game development, if this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values for a smoother user experience.",
            "Note that in our game, ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway, affecting the game's rendering.",
            "For more information, see details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in \\API BREAKING CHANGES\\ section, which may impact game performance."
        ],
        "FuncName": "imgui_draw_4937 FixRectCornerFlags.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Because we are filling a closed shape we remove 1 from the count of segments/points in the context of polygon filling in the game"
        ],
        "FuncName": "imgui_draw_4937 AddNgonFilled.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "A bit pessimistic, maybe there's a better computation to do here. In a game, this could be a hint for the player to think creatively.",
            "Because we are filling a closed shape we remove 1 from the count of segments/points, which is crucial in game development where precision matters."
        ],
        "FuncName": "imgui_draw_4937 AddEllipse.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for optimal performance in game development.",
            "Pull default font/size from the shared ImDrawListSharedData instance to ensure consistency across the game.",
            "Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font and enhance the gaming experience."
        ],
        "FuncName": "imgui_draw_4937 AddText.txt"
    },
    {
        "Branch": [
            "Check if the condition is met in the ImGui code",
            "Evaluate the condition based on the game logic"
        ],
        "Loop": [
            "Iterate over the game objects that meet the condition",
            "Update the game state for each object in the loop"
        ],
        "Normal": [
            "Accept null ranges in the game world",
            "Pull default font and size from the shared ImDrawListSharedData instance for rendering",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font and render text in the game"
        ],
        "FuncName": "imgui_draw_4937 AddText.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If we still don't have ears, it means geometry is degenerated. In a game of Geometry Wars, this could be related to the Triangular shape formation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Return first triangle available, mimicking the behavior of convex fill. This is a crucial step in understanding the Triangular shape in a Geometry game.",
                    "Geometry is degenerated. This could be a reference to the degenerated triangles in a Geometry game."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "imgui_draw_4937 GetNextTriangle.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Initialize a triangle mesh with points_count x Node",
            "Initialize a triangle mesh with points_count x Node*",
            "Initialize a triangle mesh with points_count x Node*"
        ],
        "FuncName": "imgui_draw_4937 Init.txt"
    },
    {
        "Branch": [
            "In a game like Geometry Dash, adding a polygon often requires careful consideration of its shape and size."
        ],
        "Loop": [
            "When working with polygons in a game like Minecraft, it's essential to ensure that each point is unique and not a duplicate."
        ],
        "Normal": [
            "Because we are filling a closed shape in a game like Adobe Illustrator, we remove 1 from the count of segments/points to ensure a proper fill."
        ],
        "FuncName": "imgui_draw_4937 AddNgon.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them. In the context of the ImGui game, this means that the drawing lists are managed by the ImGui context, allowing for more efficient rendering."
        ],
        "FuncName": "imgui_draw_4937 Clear.txt"
    },
    {
        "Branch": [
            "Clearing font texture data in If-Condition game"
        ],
        "Loop": [
            "Clearing font texture data in Loop-Condition game"
        ],
        "Normal": [
            "Important: we leave TexReady untouched in Normal game"
        ],
        "FuncName": "imgui_draw_4937 ClearTexData.txt"
    },
    {
        "Branch": [
            "When clearing this, we lose access to the font name and other information used to build the font in a game setting."
        ],
        "Loop": [
            "In a game, we must carefully consider the consequences of clearing this, as it affects the game's font and overall aesthetic."
        ],
        "Normal": [
            "Important: we leave TexReady untouched in the game."
        ],
        "FuncName": "imgui_draw_4937 ClearInputData.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Anti-aliased Fill: A technique used in graphics rendering to reduce pixelation and improve image quality.",
                    "Add indexes for fill: This process involves creating a list of indexes to help the graphics card quickly identify and fill in the correct pixels.",
                    "Compute normals: A mathematical process that calculates the normal vector of a surface at a given point, used to determine the direction of light and shading in 3D graphics."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Average normals: A process that calculates the average normal vector of a set of points, used to reduce noise and improve the smoothness of 3D surfaces.",
                    "Add vertices: In 3D graphics, vertices are the points that make up a polygon or other 3D shape. Adding vertices involves creating new points to refine the shape.",
                    "Inner: Refers to the inside of a shape or polygon, often used in graphics rendering to determine which pixels to fill.",
                    "Outer: Refers to the outside of a shape or polygon, often used in graphics rendering to determine which pixels to draw.",
                    "Add indexes for fringes: A technique used to improve the rendering of 3D shapes with complex edges or fringes, by creating a list of indexes to help the graphics card quickly identify and render the correct pixels."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imgui_draw_4937 AddConcavePolyFilled.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.",
                    "In the game, manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the game, merge previous channel last draw command with current channel first draw command if matching.",
                    "FIXME-OPT: Improve for multiple merges in the game."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game, note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.",
            "In the game, calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.",
            "In the game, write commands and indices in order (they are fairly small structures, we don't copy vertices only indices).",
            "In the game, ensure there's always a non-callback draw command trailing the command-buffer.",
            "In the game, if current command is used with different settings we need to add a new command.",
            "In the game, copy ClipRect, TextureId, VtxOffset."
        ],
        "FuncName": "imgui_draw_4937 Merge.txt"
    },
    {
        "Branch": [
            "Classify node: Check if node is concave, convex, or sharp based on point location."
        ],
        "Loop": [],
        "Normal": [
            "Update lists when a type changes: Reclassify nodes and update lists accordingly."
        ],
        "FuncName": "imgui_draw_4937 ReclassifyNode.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u6e32\u67d3\u901a\u9053\u6e05\u7406\uff1a\u590d\u5236\u4e86CmdBuffer/IdxBuffer\uff0c\u4e0d\u5e94\u518d\u8fdb\u884c\u9500\u6bc1"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imgui_draw_4937 ClearFreeMemory.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u907f\u514d\u8fc7\u5ea6\u9884\u7559\uff0c\u56e0\u4e3a\u8fd9\u53ef\u80fd\u4f1a\u7a33\u5b9a\u6e38\u620f\u7684\u6027\u80fd",
                    "\u5728\u6e38\u620f\u4e2d\uff0c\u9884\u7559\u8fc7\u591a\u8d44\u6e90\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6027\u80fd\u4e0b\u964d"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "\u5faa\u73af\u6761\u4ef6\u901a\u5e38\u7528\u4e8e\u6e38\u620f\u4e2d\u7684\u52a8\u753b\u6216\u6548\u679c",
            "\u5728\u6e38\u620f\u4e2d\uff0c\u5faa\u73af\u6761\u4ef6\u7528\u4e8e\u63a7\u5236\u52a8\u753b\u6216\u6548\u679c\u7684\u64ad\u653e\u6b21\u6570"
        ],
        "Normal": [
            "\u901a\u9053[]\uff0824/32\u4e2a\u5b57\u8282\uff09\u4fdd\u7559\u5b58\u50a8\uff0c\u6211\u4eec\u5c06\u5176\u4e0edraw_list->_CmdBuffer/_IdxBuffer\u8fdb\u884c\u4ea4\u6362",
            "\u5185\u5bb9 Channels[0] \u5728\u6b64\u70b9\u5e76\u4e0d\u91cd\u8981\u3002\u6211\u4eec\u6e05\u9664\u5b83\u4ee5\u4f7f\u8c03\u8bd5\u5668\u4e2d\u4fdd\u6301\u72b6\u6001\u6574\u6d01\uff0c\u4f46\u6211\u4eec\u5e76\u4e0d\u4e25\u683c\u9700\u8981\u3002",
            "\u5f53\u6211\u4eec\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u901a\u9053\u65f6\uff0c\u6211\u4eec\u5c06draw_list->_CmdBuffer/_IdxBuffer\u590d\u5236\u5230Channels[0]\uff0c\u7136\u540eChannels[1]\u590d\u5236\u5230draw_list->CmdBuffer/_IdxBuffer",
            "\u5728\u6e38\u620f\u4e2d\uff0c\u901a\u9053\u7528\u4e8e\u7ba1\u7406\u8d44\u6e90\u548c\u6027\u80fd",
            "\u901a\u8fc7\u5408\u7406\u5206\u914d\u901a\u9053\uff0c\u53ef\u4ee5\u63d0\u9ad8\u6e38\u620f\u7684\u6027\u80fd\u548c\u7a33\u5b9a\u6027"
        ],
        "FuncName": "imgui_draw_4937 Split.txt"
    },
    {
        "Branch": [
            "Return index based on game logic"
        ],
        "Loop": [
            "Iterate through game levels"
        ],
        "Normal": [
            "Return index"
        ],
        "FuncName": "imgui_draw_4937 AddCustomRectFontGlyph.txt"
    },
    {
        "Branch": [
            "Check if player's health is greater than 50% and add +1 offset per 13 units"
        ],
        "Loop": [],
        "Normal": [
            "Add +1 offset per 13 units"
        ],
        "FuncName": "imgui_draw_4937 AddFontDefault.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of ImGui, clearing the ImDrawList data is crucial for maintaining the game's UI integrity, especially when switching between different scenes or menus. This is because the ImDrawList is not owned by ImDrawData but by ImGuiContext, ensuring data persistence across different game states."
        ],
        "FuncName": "imgui_draw_4937 Clear.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "\u6211\u4eec\u4e0d\u80fd\u5047\u8bbe\u5c0f\u7aef\u6a21\u5f0f\uff0c\u9700\u8981\u89e3\u780185\u8fdb\u5236\u6570\u636e\u4ee5\u4fbf\u6b63\u786e\u6267\u884c\u6e38\u620f\u903b\u8f91"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "imgui_draw_4937 Decode85.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Font atlas needs to be built before we can calculate UV coordinates for 2D game graphics.",
            "Make sure the rectangle has been packed and its UV coordinates are properly calculated for the game engine."
        ],
        "FuncName": "imgui_draw_4937 CalcCustomRectUV.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Convert to RGBA32 format on demand for optimal game performance",
            "In RGBA32 format, each pixel is represented by 32 bits, which is likely to be the most commonly used format for game development, but our font rendering is currently limited to 1 channel / 8 bpp"
        ],
        "FuncName": "imgui_draw_4937 GetTexDataAsRGBA32.txt"
    },
    {
        "Branch": [
            "Return index if condition is met"
        ],
        "Loop": [
            "Return index for loop condition"
        ],
        "Normal": [
            "Return index with custom rectangle"
        ],
        "FuncName": "imgui_draw_4937 AddCustomRectRegular.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Create new font for the game",
            "Invalidate texture for the game"
        ],
        "FuncName": "imgui_draw_4937 AddFont.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Build atlas on demand for Alpha8 game"
        ],
        "FuncName": "imgui_draw_4937 GetTexDataAsAlpha8.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for optimal game performance",
            "Pull default font and size from the shared ImDrawListSharedData instance, optimized for the game's UI",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font, ensuring seamless transitions between game levels"
        ],
        "FuncName": "imgui_draw_4937 AddText.txt"
    },
    {
        "Branch": [
            "If condition string with game-related description"
        ],
        "Loop": [
            "Loop condition string with game-related description"
        ],
        "Normal": [
            " Accept null ranges and optimize font rendering for gaming performance",
            " Pull default font/size from the shared ImDrawListSharedData instance to ensure consistent UI across different game modes",
            " Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font and apply custom game-themed fonts"
        ],
        "FuncName": "imgui_draw_4937 AddRanges.txt"
    },
    {
        "Branch": [
            "Check if the current frame number is even"
        ],
        "Loop": [
            "Loop through each item in the inventory"
        ],
        "Normal": [
            "Accept null ranges: This is a common scenario in game development where a range is not provided, and the game should still function correctly.",
            "Pull default font/size from the shared ImDrawListSharedData instance: In ImGui, fonts and font sizes are often shared across the application, and this line ensures that the correct font is used for rendering text.",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font: This line demonstrates how to change the font used for rendering text in ImGui, which is crucial for creating visually appealing UI elements in games."
        ],
        "FuncName": "imgui_draw_4937 BuildRanges.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Default font is none are specified. In game development, font selection is crucial for user interface and game text.",
            "Select builder. In game development, a builder is often used to construct game assets, such as fonts.",
            "- Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere and point to it instead of pointing directly to return value of the GetBuilderXXX functions. In game development, hot-reloading schemes can be complex and require careful consideration to avoid data corruption."
        ],
        "FuncName": "imgui_draw_4937 ImFontAtlasBuildWithStbTruetype.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Default font is none are specified in the game's font settings.",
            " Select a builder to create a new font atlas.",
            " - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which may cause issues with hot-reloading schemes.",
            "   If you need to assign to this (for dynamic selection) AND are using a hot-reloading scheme that messes up static data,",
            "   store your own instance of ImFontBuilderIO somewhere and point to it instead of pointing directly to the return value of the GetBuilderXXX functions."
        ],
        "FuncName": "imgui_draw_4937 ImFontAtlasBuildMultiplyRectAlpha8.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Default font is none are specified. In a 3D rendering game, fonts are often used to display text on screen, and a default font is typically used when no specific font is chosen.",
            "Select builder. In game development, a builder is often used to create or modify game assets, such as 3D models or textures. The builder is responsible for taking in the necessary data and creating the desired asset.",
            "Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere and point to it instead of pointing directly to return value of the GetBuilderXXX functions. In game development, hot-reloading schemes are used to reload game assets without restarting the game. However, this can sometimes cause issues with static data, such as font builders, which are not designed to be reloaded dynamically."
        ],
        "FuncName": "imgui_draw_4937 ImFontAtlasBuildMultiplyCalcLookupTable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Default font is none are specified. In 2D games, fonts are crucial for displaying text to the player.",
            "Select builder. In 2D game development, a builder is a class or function responsible for creating game objects.",
            "- Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which",
            "   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are",
            "   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere",
            "   and point to it instead of pointing directly to return value of the GetBuilderXXX functions. This is a common",
            "   technique in game development to ensure that game objects are created correctly and efficiently."
        ],
        "FuncName": "imgui_draw_4937 UnpackBitVectorToFlatIndexList.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Default font is none are specified. In game development, fonts are crucial for user interface and game text.",
            "Select builder. In the context of font atlas construction, a builder is responsible for assembling the font's glyphs.",
            "- Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere and point to it instead of pointing directly to return value of the GetBuilderXXX functions. This is a common consideration in game development when working with dynamic assets."
        ],
        "FuncName": "imgui_draw_4937 Build.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Default font is none are specified in the game settings.",
            "Select a font builder for the game.",
            "- Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which may cause issues with some game hot-reloading schemes. If you need to assign to this (for dynamic font selection) AND are using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere and point to it instead of pointing directly to the return value of the GetBuilderXXX functions.",
            "Font selection is crucial for a smooth gaming experience.",
            "Choose a font that fits your game's style and theme."
        ],
        "FuncName": "imgui_draw_4937 ImFontAtlasGetBuilderForStbTruetype.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Adjust index buffer size for optimal game performance",
            " Pull default font/size from the shared ImDrawListSharedData instance for improved rendering",
            " Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font and enhance game graphics"
        ],
        "FuncName": "imgui_draw_4937 GrowIndex.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for glyph rendering in ImGui",
            "Pull default font/size from the shared ImDrawListSharedData instance for game rendering",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font in game development"
        ],
        "FuncName": "imgui_draw_4937 IsGlyphRangeUnused.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for optimal performance in games",
            "Pull default font and size from the shared ImDrawListSharedData instance for consistent rendering",
            "Use high-level ImGuiPushFont() or low-level ImDrawListPushTextureId() to change font and enhance game graphics"
        ],
        "FuncName": "imgui_draw_4937 FindGlyphNoFallback.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for character rendering",
            "Pull default font and size from the shared ImDrawListSharedData instance for text rendering",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font and apply typography features specific to the game"
        ],
        "FuncName": "imgui_draw_4937 FindFirstExistingGlyph.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Accept null ranges in character design for [game] code",
            " Pull default font/size from the shared ImDrawListSharedData instance for [game] rendering",
            " Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font for [game] UI"
        ],
        "FuncName": "imgui_draw_4937 FindGlyph.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges in game development",
            "Pull default font and size from the shared ImDrawListSharedData instance in ImGui",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font in game rendering"
        ],
        "FuncName": "imgui_draw_4937 BuildLookupTable.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges in a game that uses ImGui's conditional rendering",
            "Pull default font/size from the shared ImDrawListSharedData instance in a game that uses ImGui's font management",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font in a game that uses ImGui's font rendering"
        ],
        "FuncName": "imgui_draw_4937 AddRemapChar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for optimal performance in 2D game development.",
            "Pull default font and size from the shared ImDrawListSharedData instance for consistent UI in your game.",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font and enhance visual effects in your game."
        ],
        "FuncName": "imgui_draw_4937 AddGlyph.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges in Dungeons & Dragons",
            "Pull default font/size from the shared ImDrawListSharedData instance in Minecraft",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font in Fortnite"
        ],
        "FuncName": "imgui_draw_4937 SetGlyphVisible.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Accept null ranges for optimal performance in [game] environments.",
            "Pull default font/size from the shared ImDrawListSharedData instance to ensure consistency across the game.",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font and take advantage of [game] graphics capabilities."
        ],
        "FuncName": "imgui_draw_4937 CalcTextSizeA.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Taking a screenshot of a game on a mobile device with OpenGL ES",
            "Capturing a screenshot of a game on a desktop computer with OpenGL",
            "To display images correctly on Android devices, use RGBA format when rendering with OpenGL ES, as images may appear black otherwise",
            "On desktop computers with OpenGL, the captured image needs to be flipped vertically after reading"
        ],
        "FuncName": "OGLGraphics_2575 TakeScreenShot.txt"
    },
    {
        "Branch": [
            "Check if condition is true to determine the next line's starting position"
        ],
        "Loop": [
            "Determine the loop condition to calculate the next line's starting position"
        ],
        "Normal": [
            " Accept null ranges",
            " Pull default font/size from the shared ImDrawListSharedData instance",
            " Use high-level ImGuiPushFont  or low-level ImDrawListPushTextureId  to change font for rendering game graphics"
        ],
        "FuncName": "imgui_draw_4937 CalcWordWrapNextLineStartA.txt"
    },
    {
        "Branch": [
            "Currently unimplemented on OpenGL, requires GPU refresh for conditional rendering"
        ],
        "Loop": [
            "Currently unimplemented on OpenGL, requires GPU refresh for loop iteration"
        ],
        "Normal": [
            "Currently unimplemented on OpenGL, requires GPU refresh"
        ],
        "FuncName": "OGLGraphics_2575 SetFlushGPU.txt"
    },
    {
        "Branch": [
            "Render if condition statement, used in [game] code to control the flow of the program."
        ],
        "Loop": [
            "Render loop condition statement, used in [game] code to repeat a set of instructions."
        ],
        "Normal": [
            "Accept null ranges, a feature in [game] development that allows for more flexibility in rendering.",
            "Pull default font/size from the shared ImDrawListSharedData instance, a technique used in [game] to improve performance.",
            "Use high-level ImGuiPushFont or low-level ImDrawListPushTextureId to change font, a common task in [game] development."
        ],
        "FuncName": "imgui_draw_4937 RenderChar.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Begin drawing frame for 2D Platformer game. Check external window size changes and adjust screen mode if necessary.",
            "Re-enable depth test and depth func for 3D Adventure game, in case a third party program has modified it",
            "Set default rendertarget and depth buffer for Real-Time Strategy game",
            "Cleanup textures from previous frame for First-Person Shooter game",
            "Enable color and depth write for Role-Playing Game"
        ],
        "FuncName": "OGLGraphics_2575 BeginFrame.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Close the existing window and OpenGL context, mark GPU objects as lost. This is a common scenario in game development where the player needs to transition between different game modes or levels.",
                    "On iOS window needs to be resizable to handle orientation changes properly. This ensures that the game adapts to different screen orientations, providing an immersive experience for the player.",
                    "Reposition the window on the specified monitor. This feature is useful in games that require a specific display configuration, such as a multi-monitor setup.",
                    "Create/restore context and GPU objects and set initial renderstate. This is a crucial step in setting up the game's rendering pipeline, ensuring that the graphics are rendered correctly and efficiently.",
                    "Specific error message is already logged by Restore() when context creation or OpenGL extensions check fails. This error handling mechanism helps developers identify and resolve issues related to OpenGL extensions or context creation."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If failed with multisampling, retry first without. In game development, multisampling is used to reduce aliasing and improve image quality. If it fails, retrying without it can help the game run smoothly."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "iOS and tvOS app always take the fullscreen (and with status bar hidden). In mobile game development, fullscreen mode is often used to provide an immersive experience for the player.",
            "Make sure monitor index is not bigger than the currently detected monitors. This ensures that the game is displayed on a valid monitor, preventing potential issues with display configuration.",
            "This monitor is not present, use first monitor. If a specific monitor is not available, the game can fall back to the first available monitor, ensuring that the game continues to run smoothly.",
            "Fullscreen or Borderless can not be resizable. In game development, fullscreen and borderless modes have specific requirements and limitations, and resizing them can lead to issues with display configuration.",
            "Borderless cannot be fullscreen, they are mutually exclusive. This is a fundamental property of display modes in game development, and developers need to be aware of these limitations when designing their game.",
            "If only vsync changes, do not destroy/recreate the context. Vsync is a critical component of game development, ensuring that the game runs smoothly and efficiently. Changing it without destroying and recreating the context can help optimize performance.",
            "If zero dimensions in windowed mode, set windowed mode to maximize and set a predefined default restored window size. In game development, windowed mode can have specific requirements and limitations, and this approach helps ensure that the game adapts to different screen configurations.",
            "If zero in fullscreen, use desktop mode. If the fullscreen mode is not available, the game can fall back to desktop mode, ensuring that the game continues to run smoothly.",
            "Check fullscreen mode validity (desktop only). Use a closest match if not found. In game development, fullscreen mode has specific requirements and limitations, and this approach helps ensure that the game adapts to different display configurations.",
            "With an external window, only the size can change after initial setup, so do not recreate context. In game development, external windows can have specific requirements and limitations, and this approach helps ensure that the game adapts to different screen configurations.",
            "Set vsync. Vsync is a critical component of game development, ensuring that the game runs smoothly and efficiently.",
            "Store the system FBO on iOS/tvOS now. In mobile game development, the system FBO is a critical component of the rendering pipeline, and storing it helps ensure that the game adapts to different screen configurations.",
            "Reset rendertargets and viewport for the new screen mode. In game development, rendertargets and viewports are critical components of the rendering pipeline, and resetting them helps ensure that the game adapts to different screen configurations.",
            "Clear the initial window contents to black. In game development, clearing the window contents to black is a common practice, helping to ensure that the game starts with a clean slate and providing a smooth experience for the player."
        ],
        "FuncName": "OGLGraphics_2575 SetMode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Close the existing window and OpenGL context, mark GPU objects as lost",
                    "On iOS window needs to be resizable to handle orientation changes properly",
                    "Reposition the window on the specified monitor",
                    "Create/restore context and GPU objects and set initial renderstate",
                    "In a game, specific error messages are already logged by Restore() when context creation or OpenGL extensions check fails",
                    "In a game, if failed with multisampling, retry first without"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In a game, if failed with multisampling, retry first without"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In a game, iOS and tvOS app always take the fullscreen (and with status bar hidden)",
            "In a game, make sure monitor index is not bigger than the currently detected monitors",
            "In a game, this monitor is not present, use first monitor",
            "In a game, fullscreen or borderless can not be resizable",
            "In a game, borderless cannot be fullscreen, they are mutually exclusive",
            "In a game, if only vsync changes, do not destroy/recreate the context",
            "In a game, if zero dimensions in windowed mode, set windowed mode to maximize and set a predefined default restored window size.",
            "In a game, if zero in fullscreen, use desktop mode",
            "In a game, check fullscreen mode validity (desktop only). Use a closest match if not found",
            "In a game, with an external window, only the size can change after initial setup, so do not recreate context",
            "In a game, set vsync",
            "In a game, store the system FBO on iOS/tvOS now",
            "In a game, reset rendertargets and viewport for the new screen mode",
            "In a game, clear the initial window contents to black"
        ],
        "FuncName": "OGLGraphics_2575 SetMode.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Actually close the window in the game"
        ],
        "FuncName": "OGLGraphics_2575 Close.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Clean up too large scratch buffers in the context of a 2D platformer game, where managing memory is crucial for smooth gameplay."
        ],
        "FuncName": "OGLGraphics_2575 EndFrame.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Unbind old texture type if necessary. In the context of a game, this typically refers to releasing a graphics resource to prepare for a new texture update."
        ],
        "FuncName": "OGLGraphics_2575 SetTextureForUpdate.txt"
    },
    {
        "Branch": [
            "Set up conditional rendering for game logic"
        ],
        "Loop": [
            "Establish loop condition for game iteration"
        ],
        "Normal": [
            "Note: this is not multi-instance safe",
            "In the context of a game, this message indicates a potential issue with rendering multiple instances of a game object or scene."
        ],
        "FuncName": "OGLGraphics_2575 SetVertexBuffer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the context of the game, ensure the Frame Buffer Object (FBO) is not in use before proceeding.",
            "When rendering to a cube map, utilize the Direct3D convention with the vertical coordinates, where 0 represents the topmost position."
        ],
        "FuncName": "OGLGraphics_2575 ResolveToTexture.txt"
    },
    {
        "Branch": [
            "Check if the polygon image can be rendered to the cube texture in the game"
        ],
        "Loop": [
            "Loop through the vertices of the polygon image to render it to the cube texture in the game"
        ],
        "Normal": [
            "Make sure the Frame Buffer Object (FBO) is not in use for rendering the polygon image to the cube texture in the game",
            "Use the Direct3D convention with the vertical coordinates (i.e., 0 is top) for rendering the polygon image to the cube texture in the game"
        ],
        "FuncName": "OGLGraphics_2575 ResolveToTexture.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, if the rendertarget is also bound as a texture, replace with backup texture or null"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the context of the game, if multisampled, mark the texture & surface needing resolve",
                    "In the context of the game, if mipmapped, mark the levels needing regeneration"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "OGLGraphics_2575 SetRenderTarget.txt"
    },
    {
        "Branch": [
            "Check if the cube map texture is valid and not null before rendering"
        ],
        "Loop": [
            "Loop through each face of the cube map texture"
        ],
        "Normal": [
            "Make sure the FBO is not in use",
            "Use Direct3D convention with the vertical coordinates ie 0 is top",
            "Copy the cube map texture's rendering result to the specified texture object"
        ],
        "FuncName": "OGLGraphics_2575 ResolveToTexture.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the game, when the viewport is smaller than the full screen, we set a scissor to limit the area to be cleared.",
            "However, any user-set scissor test will be lost in this scenario."
        ],
        "FuncName": "OGLGraphics_2575 Clear.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Unbind old texture type if necessary",
                    "Apply new texture settings based on game type, such as parallax mapping or normal mapping"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Check if texture is currently bound as a rendertarget. In that case, use its backup texture, or blank if not defined",
            "Ensure texture is properly loaded and optimized for 3D rendering in the game"
        ],
        "FuncName": "OGLGraphics_2575 SetTexture.txt"
    },
    {
        "Branch": [
            "If the graphics card supports multi-sampling, use it to improve image quality."
        ],
        "Loop": [
            "Loop through each frame in the game to check for multi-sampling support."
        ],
        "Normal": [
            "No multisampling always supported. This means the game will not use multi-sampling to improve image quality."
        ],
        "FuncName": "OGLGraphics_2575 GetMultiSampleLevels.txt"
    },
    {
        "Branch": [
            "In the context of the game, conditional statements are crucial for deciding the next course of action."
        ],
        "Loop": [
            "In the game, loops are used to repeat certain actions or movements until a certain condition is met."
        ],
        "Normal": [
            "In the game, the graphics rendering is limited by the number of RPI GPUs and their uniform capabilities."
        ],
        "FuncName": "OGLGraphics_2575 GetMaxBones.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "On iOS and tvOS, minimizing the window is considered device loss due to OpenGL restrictions."
        ],
        "FuncName": "OGLGraphics_2575 IsDeviceLost.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    " Use Direct3D convention with the vertical coordinates ie 0 is top",
                    "In game development, Direct3D convention is commonly used for vertical coordinates, where 0 represents the top edge."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            " During some light rendering loops a full rect is toggled on/off repeatedly.",
            " Disable scissor in that case to reduce state changes",
            "In game rendering, disabling scissor testing during loops that toggle a full rectangle on and off can reduce unnecessary state changes, improving performance."
        ],
        "FuncName": "OGLGraphics_2575 SetScissorTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Direct3D9 default depth-stencil cannot be used when render target size exceeds window size.",
                    "Check size compatibility similarly"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "When using a render target texture, OpenGL requires an additional depth-stencil texture to match Direct3D9 behavior.",
            "Create a new depth-stencil texture as needed to provide similar functionality to Direct3D9.",
            "This applies only to non-multisampled render targets; for multisampled targets, a similarly multisampled depth-stencil should be provided (backbuffer depth is incompatible)."
        ],
        "FuncName": "OGLGraphics_2575 SetDepthStencil.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Set viewport size to 1024x768 and position to (0, 0) in Direct3D game development.",
            " Disable scissor test requires re-enablement by the user in game development."
        ],
        "FuncName": "OGLGraphics_2575 SetViewport.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "If the rendertarget is also bound as a texture, replace with backup texture or null. This is a common scenario in game development, where the rendertarget is used as a texture for post-processing effects."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If multisampled, mark the texture & surface needing resolve. This is a technique used in games to handle anti-aliasing.",
                    "If mipmapped, mark the levels needing regeneration. This is a process used in games to optimize texture memory usage."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "OGLGraphics_2575 SetRenderTarget.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Use Direct3D convention with the vertical coordinates ie 0 is top. This is a typical requirement for 2D rendering in games."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "During some light rendering loops, a full rect is toggled on/off repeatedly. This can be optimized by disabling scissor testing.",
            "Disable scissor in that case to reduce state changes. This is a common technique used in game development to improve performance."
        ],
        "FuncName": "OGLGraphics_2575 SetScissorTest.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In Direct3D9, the default depth-stencil cannot be used when the render target is larger than the window.",
                    "Check the size to ensure compatibility.",
                    "This is a common issue in game development, especially when working with large rendertargets."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In OpenGL, when using a render target texture, it is essential to have a separate depth-stencil texture.",
            "Create a new depth-stencil texture as needed to maintain similar behavior to Direct3D9.",
            "This is particularly important for non-multisampled render targets; for multisampled targets, a similarly multisampled depth-stencil should be provided.",
            "The backbuffer depth is not compatible with multisampled targets, so a separate depth-stencil is required."
        ],
        "FuncName": "OGLGraphics_2575 SetDepthStencil.txt"
    },
    {
        "Branch": [
            "If the luminance format is deprecated on OpenGL 3, then..."
        ],
        "Loop": [
            "Loop until the luminance format is not deprecated on OpenGL 3"
        ],
        "Normal": [
            "Luminance format is deprecated on OpenGL 3, and it affects the game's graphics rendering."
        ],
        "FuncName": "OGLGraphics_2575 GetLuminanceFormat.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For the game, when the window size changes, update the window size, reset the render targets and viewport, and send a screen mode event. This ensures the game adapts to the new screen size and displays correctly."
        ],
        "FuncName": "OGLGraphics_2575 OnWindowResized.txt"
    },
    {
        "Branch": [
            "Alpha format is deprecated on OpenGL 3+ for if conditions"
        ],
        "Loop": [
            "Alpha format is deprecated on OpenGL 3+ for loop conditions"
        ],
        "Normal": [
            "Alpha format is deprecated on OpenGL 3+ for normal conditions"
        ],
        "FuncName": "OGLGraphics_2575 GetAlphaFormat.txt"
    },
    {
        "Branch": [
            "If the graphics card supports OpenGL 3, it can use different color attachment formats. Otherwise, it requires color attachments to have the same format, therefore encode deferred depth to RGBA manually."
        ],
        "Loop": [],
        "Normal": [
            "OpenGL 3 allows for different color attachment formats.",
            "OpenGL 2 requires color attachments to have the same format, thus encoding deferred depth to RGBA manually is necessary.",
            "when a readable hardware depth texture is not used."
        ],
        "FuncName": "OGLGraphics_2575 GetLinearDepthFormat.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Work around GLEW failure to check extensions properly from a GL3 context. This is a known issue in some graphics drivers."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Check supported features for the game: light pre-pass, deferred rendering, and hardware depth texture support.",
            "Must support 2 rendertargets for light pre-pass, and 4 for deferred rendering. This is a requirement for the game to run smoothly.",
            "On macOS, check for an Intel driver and use shadow map RGBA dummy color textures. This is a workaround for a known issue in some graphics drivers.",
            "Check for supported compressed texture formats. The game uses S3TC, ETC1, and PVRTC formats.",
            "Instancing is in core in WebGL 2, so the extension may not be present anymore. In WebGL 1, find the ANGLE_instanced_arrays extension.",
            "Check for best supported depth renderbuffer format for GLES2. This is a requirement for the game to run smoothly.",
            "Consider OpenGL shadows always hardware sampled, if supported at all. This is a performance optimization for the game."
        ],
        "FuncName": "OGLGraphics_2575 CheckFeatureSupport.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Luminance alpha format is deprecated on OpenGL 3+. In OpenGL 3+, it is recommended to use a separate texture for luminance and alpha channels."
        ],
        "FuncName": "OGLGraphics_2575 GetLuminanceAlphaFormat.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Marking GPU objects lost without a current context in OpenGL 3.0, which marks their internal state lost but does not delete GL objects.",
                    "ATOMIC BEGIN and ATOMIC END are used for atomic operations in OpenGL.",
                    "When trying to use OpenGL 3.0, but context creation fails, retry with OpenGL 2.0.",
                    "Clearing cached extensions string from the previous context for OpenGL.",
                    "Initializing OpenGL extensions library for desktop applications.",
                    "Enabling seamless cubemap if possible in OpenGL, which can lead to software fallback on some old GPUs.",
                    "For more information, see https://github.com/urho3d/Urho3D/issues/1380 or http://distrustsimplicity.net/articles/gl_texture_cube_map_seamless-on-os-x/",
                    "If encountering issues or wanting maximum compatibility, remove the glEnable below for OpenGL.",
                    "Setting up texture data read/write alignment in OpenGL before uploading any texture data."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "The manufacturer is represented by Size() - 2, and Mesa is the target in OpenGL.",
                    "The version number is Size() - 1, which can be in the format n, n.n, or n.n.n, and is converted to a long integer in OpenGL."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Removing this context and letting it fall back to OpenGL 2.0."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Creating and binding a vertex array object that will remain in use throughout the OpenGL context."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "On Android, the context may be lost behind the scenes when the application is minimized, so ensure that the context exists first."
        ],
        "FuncName": "OGLGraphics_2575 Restore.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Releasing GPU objects and closing window and GL context to prevent data corruption and crashes."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Suppressing log message when exiting to prevent unnecessary output."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Preserving external window to prevent unexpected behavior during shutdown."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Exiting fullscreen mode to prevent transition issues and getting stuck on OS X."
        ],
        "FuncName": "OGLGraphics_2575 Release.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For convenience, return the position of the text ending if index exceeded. In the context of the game, this means the player has reached the end of the level or exceeded the maximum allowed steps."
        ],
        "FuncName": "Text3DText_1464 GetCharPosition.txt"
    },
    {
        "Branch": [
            "Check if player has enough health to enter the next level"
        ],
        "Loop": [
            "Loop through each enemy in the level to apply damage"
        ],
        "Normal": [
            "Localize now if attributes were loaded out-of-order. This may cause game instability"
        ],
        "FuncName": "Text3DText_1464 ApplyAttributes.txt"
    },
    {
        "Branch": [
            "If the player's health is less than 50%, display a warning message.",
            "If the player's score is greater than 1000, display a congratulatory message."
        ],
        "Loop": [
            "Loop through each enemy in the game and check if they are still alive.",
            "Loop through each level in the game and display the level number."
        ],
        "Normal": [
            "Initial font must be set to Arial, size 12.",
            "Initial background color must be set to black."
        ],
        "FuncName": "Text3DText_1464 SetFontSize.txt"
    },
    {
        "Branch": [
            "Create a local player instance if the condition is met"
        ],
        "Loop": [
            "Create a local player instance in each iteration"
        ],
        "Normal": [
            "Create a local player instance for duplication check"
        ],
        "FuncName": "l_localplayer_4111 create.txt"
    },
    {
        "Branch": [
            "Check if player has completed level"
        ],
        "Loop": [
            "Repeat until player reaches end of level"
        ],
        "Normal": [
            "Set initial state to match Direct3D",
            "Initialize game objects and properties according to game type"
        ],
        "FuncName": "OGLGraphics_2575 ResetCachedState.txt"
    },
    {
        "Branch": [
            "Checking OpenGL version and setting version information for game development."
        ],
        "Loop": [],
        "Normal": [
            "Thank you elmindreda https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176 https://github.com/glfw/glfw/blob/master/src/context.c#L36 for OpenGL version detection and initialization.",
            "PR #18 : Fixed OpenGL version detection and initialization for game development."
        ],
        "FuncName": "glad_2824 find_coreGL.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "For convenience, return the size of the last character if index exceeded last size entry is zero in a game where character size is crucial for gameplay."
        ],
        "FuncName": "Text3DText_1464 GetCharSize.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In [game] rendering, samples should be even or glyphs may be redrawn in wrong x y position, making stroke corners rough.",
                    "Adding to thickness helps with thickness of 1 not having enough samples for this formula, especially for certain fonts with reflex corners requiring more glyph samples for a smooth stroke when large.",
                    "In [game] rendering, adding to thickness helps with thickness of 1 not having enough samples for this formula, especially for certain fonts with reflex corners requiring more glyph samples for a smooth stroke when large."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "In [game] rendering, check if row changes, and start a new quad in that case."
                ]
            },
            {
                "loopstr": [
                    "In [game] rendering, one batch per texture/page."
                ]
            },
            {
                "loopstr": [
                    "In [game] rendering, don't draw glyphs that aren't on the edges."
                ]
            }
        ],
        "Normal": [
            "In [game] rendering, if face has changed or char locations are not valid anymore, update before rendering.",
            "In [game] rendering, if face uses mutable glyphs mechanism, reacquire glyphs before rendering to make sure they are in the texture.",
            "In [game] rendering, hovering and/or whole selection batch.",
            "In [game] rendering, partial selection batch.",
            "In [game] rendering, text batch.",
            "In [game] rendering, reset hovering for next frame."
        ],
        "FuncName": "Text3DText_1464 GetBatches.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Player movement in polar coordinates and non-binary speed, utilizing game-specific physics.",
            "Provide direction keys to ensure compatibility with the game's control scheme."
        ],
        "FuncName": "l_localplayer_4111 l_get_control.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "read all texture coordinates",
                    "UV indices",
                    "Game-specific: Texture coordinates and UV indices are used to map 2D images to 3D models in Quick3D."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "we have no normal here - assign the face normal",
                    "Game-specific: In Quick3D, face normals are used to calculate lighting effects on 3D models."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "the light source",
                    "camera",
                    "Game-specific: Light sources and cameras are used to create a realistic lighting effect in Quick3D scenes."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "read all vertices",
                    "read all faces",
                    "number of indices",
                    "indices",
                    "material indices",
                    "read all normals",
                    "we don't need the rest, but we need to get to the next chunk",
                    "Game-specific: Vertices, faces, and indices are used to construct 3D models in Quick3D. Material indices are used to apply textures and materials to the models."
                ]
            },
            {
                "loopstr": [
                    "read the material name",
                    "add the terminal character",
                    "read the ambient color",
                    "read the diffuse color",
                    "read the ambient color",
                    "read the transparency",
                    "unknown value here",
                    "stream.IncPtr(4);",
                    "FIX: it could be the texture index ...",
                    "Game-specific: Materials in Quick3D define the appearance of 3D models, including colors, textures, and transparency."
                ]
            },
            {
                "loopstr": [
                    "skip the texture name",
                    "read texture width and height",
                    "Game-specific: Textures are used to add visual details to 3D models in Quick3D."
                ]
            },
            {
                "loopstr": [
                    "Allocate a mesh and a material",
                    "Build the output material",
                    "NOTE: Ignore transparency for the moment - it seems",
                    "unclear how to interpret the data",
                    "add shininess - Quick3D seems to use it ins its viewer",
                    "Add a texture",
                    "Now build the output mesh. First find out how many",
                    "vertices we'll need",
                    "Build the final array",
                    "Game-specific: Meshes and materials are used to construct and render 3D models in Quick3D."
                ]
            },
            {
                "loopstr": [
                    "copy vertices",
                    "copy texture coordinates",
                    "setup the new vertex index",
                    "Game-specific: Vertex data, texture coordinates, and vertex indices are used to construct and render 3D models in Quick3D."
                ]
            }
        ],
        "Normal": [
            "The header is 22 bytes large",
            "Check the file's signature",
            "Print the file format version",
            "an store it",
            "Allocate the scene root node",
            "Now read all file chunks",
            "If we have no mesh loaded - break here",
            "If we have no materials loaded - generate a default mat",
            "find out which materials we'll need",
            "Delete our nice helper array",
            "Now we need to attach the meshes to the root node of the scene",
            "Add cameras and light sources to the scene root node",
            "Game-specific: The scene root node is the top-level node in the Quick3D scene graph, and contains all meshes, materials, cameras, and light sources."
        ],
        "FuncName": "Q3DLoader_8202 InternReadFile.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "XXX: check range in game world"
        ],
        "FuncName": "gxvlcar_3864 gxv_lcar_LookupFmt4_transit.txt"
    },
    {
        "Branch": [
            "Check if the current shader is supported by the graphics card for the Unity game engine"
        ],
        "Loop": [],
        "Normal": [
            "Try to use local shader instead if asked to",
            "Inserting a shader program into the shader collection for the Unity game engine"
        ],
        "FuncName": "shader_1349 insert.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Check from cache for shader assets",
            "Retrieve shader from shader_path in game directory",
            "Load shader from default data directory in game assets",
            "Cache shader result, including empty results, for future use",
            "Return the shader asset after all checks"
        ],
        "FuncName": "shader_1349 getShaderPath.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get shader code from game engine",
            "We're gonna ask the game engine to execute the shader and put the result into a buffer",
            "Throw a request to the game engine to execute the shader",
            "Waiting for the game engine to return the shader result, name=<name><std::endl;"
        ],
        "FuncName": "shader_1349 getShader.txt"
    },
    {
        "Branch": [
            "Initialize random number generator with a fixed seed, ensuring reproducibility in game logic.",
            "Use a secure random number generator to prevent predictability in game outcomes."
        ],
        "Loop": [
            "Ensure the loop iterates a sufficient number of times to generate a diverse set of game states.",
            "Use a loop condition that guarantees the game will terminate within a reasonable time frame."
        ],
        "Normal": [
            "The game begins at the first location.",
            "Before generating random numbers, ensure the end pointer is set to prevent undefined behavior."
        ],
        "FuncName": "Random_9249 initState.txt"
    },
    {
        "Branch": [
            "If-Condition-Str: A conditional statement in the game code, used to control the flow of execution based on a specific condition."
        ],
        "Loop": [
            "Loop-Condition-Str: A loop condition in the game code, used to repeat a set of instructions based on a specific condition."
        ],
        "Normal": [
            "Normal-Str: A normal statement in the game code, used to perform a specific action or set a value.",
            " Add a dummy ShaderInfo as the first index, named \\\"Normal-Str\\\": A normal statement in the game code, used to add a dummy ShaderInfo object with a specific name.",
            " Add main global constant setter: A normal statement in the game code, used to set a main global constant value."
        ],
        "FuncName": "shader_1349 ShaderSource.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "First see if the text must be split up. In a text-based adventure game, the player's choices often determine the direction of the story, and the text must be split up to accommodate different paths.",
                    "Set at least one row height even if text is empty. This is because in a text-based game, the player may encounter empty spaces or blank lines that require a minimum row height.",
                    "Set minimum and current size according to the text size, but respect fixed width if set. In a game with a fixed width, the text size must be adjusted accordingly to prevent the text from exceeding the screen boundaries."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "If did not find any breaks on the line, copy until j, or at least 1 char, to prevent infinite loop. In a game with a loop condition, the player's actions may lead to an infinite loop if not handled properly.",
                    "Eliminate spaces that have been copied before the forced break. This is to prevent unnecessary spaces from being copied and to maintain a clean and organized text layout."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "When copying a space, position is allowed to be over row width. In a game with a scrolling text feature, the player may need to copy spaces that exceed the current row width."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "Text3DText_1464 UpdateText.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u57283D\u6587\u672c\u4e2d\uff0c\u5b58\u50a8Glyph\u7684\u4f4d\u7f6e\u4ee5\u4fbf\u4e8e\u6e32\u67d3\u3002\u9a8c\u8bc1Glyph\u9875\u9762\u662f\u5426\u6709\u6548\uff0c\u786e\u4fdd3D\u6587\u672c\u6e32\u67d3\u6b63\u786e"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "\u57283D\u6253\u5370\u8fc7\u7a0b\u4e2d\uff0c\u586b\u5145\u6253\u5370\u8fc7\u7a0b\u4e2d\u8df3\u8fc7\u7684\u5b57\u7b26\u7684\u7a7a\u9699\uff0c\u786e\u4fdd3D\u6587\u672c\u5b8c\u6574"
                ]
            }
        ],
        "Normal": [
            "\u57283D\u6587\u672c\u6e32\u67d3\u4e2d\uff0c\u8bb0\u4f4f\u5b57\u4f53\u9762\u4ee5\u4fbf\u4e8e\u6e32\u67d3\u65f6\u662f\u5426\u4ecd\u7136\u6709\u6548",
            "\u57283D\u6587\u672c\u4e2d\uff0c\u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u7684\u4f4d\u7f6e\u548c\u5927\u5c0f\uff0c\u4ee5\u53ca\u6bcf\u4e2a\u7eb9\u7406\u9875\u9762\u7684\u4f4d\u7f6e",
            "\u57283D\u6587\u672c\u4e2d\uff0c\u5b58\u50a8\u7ed3\u675f\u4f4d\u7f6e"
        ],
        "FuncName": "Text3DText_1464 UpdateCharLocations.txt"
    },
    {
        "Branch": [
            "Conditional statement for game logic",
            "Evaluate the condition to proceed"
        ],
        "Loop": [
            "Looping condition for game iteration",
            "Check the condition to continue the loop"
        ],
        "Normal": [
            "Remember to update object_property_keys above",
            "when adding a new property for game object management"
        ],
        "FuncName": "c_content_5302 push_object_properties.txt"
    },
    {
        "Branch": [
            "infostream<<ShaderSource::insertSourceShader(): name_of_shader=<name_of_shader>, filename=<filename>, condition=<condition>."
        ],
        "Loop": [
            "infostream<<ShaderSource::insertSourceShader(): name_of_shader=<name_of_shader>, filename=<filename>, loop_condition=<loop_condition>."
        ],
        "Normal": [
            "infostream<<ShaderSource::insertSourceShader(): name_of_shader=<name_of_shader>, filename=<filename>, game_type=<game_type>."
        ],
        "FuncName": "shader_1349 insertSourceShader.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "\u65e0\u6548\uff08\u7740\u8272\u5668\uff09"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "\u5220\u9664\u6750\u6599",
            "\u91cd\u65b0\u521b\u5efa\u7740\u8272\u5668\uff08\u6e38\u620f\u4e2d\uff09"
        ],
        "FuncName": "shader_1349 rebuildShaders.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Missing tiles in game because I don't see a usecase (at least not yet) in our game world.",
            "I know this is not set-able with register_node in our game, but the players need to know that it's not implemented yet.",
            "We need to add more game features to make the game more engaging for our players."
        ],
        "FuncName": "c_content_5302 push_content_features.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Empty name means shader 0: Shader ID assigned to default shader.",
            "Check if already have such instance: Instance check for shader uniqueness.",
            "Calling only allowed from main thread : Ensuring thread safety for shader calls.",
            "Add shader to caches (add dummy shaders too) : Caching shaders for efficient reuse."
        ],
        "FuncName": "shader_1349 getShaderIdDirect.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "cf EVertexAttributes.h for the predefined ones",
                    "To create shaders for OpenGL, we need to map legacy semantic texture names to texture identifiers, as specified in the OpenGL Shading Language (GLSL) ES. This is necessary because the legacy texture names are not compatible with the newer OpenGL versions."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Create shaders header",
            "for GLSL ES",
            "map legacy semantic texture names to texture identifiers",
            "For renderers that should use discard instead of GL_ALPHA_TEST",
            "reset the line counter for meaningful diagnostics",
            "optional",
            "Apply the newly created material type",
            "In the context of game development, shaders play a crucial role in rendering 3D graphics. They are used to describe the visual appearance of 3D objects and can be used to achieve various effects, such as lighting, textures, and animations."
        ],
        "FuncName": "shader_1349 generateShader.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Copy last value to all remaining textures",
                    "In the context of the game, this means that the last value assigned to a texture will be copied to all other textures, allowing for consistent visual representation across the game world."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Copy last value to all remaining textures",
                    "In the context of the game, this means that the last value assigned to a texture will be copied to all other textures, allowing for consistent visual representation across the game world."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Read tiledef from value",
                    "removes value, keeps key for next iteration",
                    "In the game, this loop iterates through tile definitions, reading from a value and removing it while keeping the key for the next iteration, allowing for efficient processing of game data."
                ]
            },
            {
                "loopstr": [
                    "Read tiledef from value",
                    "removes value, keeps key for next iteration",
                    "In the game, this loop iterates through tile definitions, reading from a value and removing it while keeping the key for the next iteration, allowing for efficient processing of game data."
                ]
            },
            {
                "loopstr": [
                    "Read tiledef from value",
                    "removes value, keeps key for next iteration",
                    "In the game, this loop iterates through tile definitions, reading from a value and removing it while keeping the key for the next iteration, allowing for efficient processing of game data."
                ]
            },
            {
                "loopstr": [
                    "Value at -1",
                    "In the game, this refers to a specific value located at index -1, which may be used for special purposes such as edge cases or error handling."
                ]
            },
            {
                "loopstr": [
                    "Value at -1",
                    "Note faces are flipped to make checking easier",
                    "In the game, this indicates that the faces are flipped to simplify the checking process, likely for optimization or convenience purposes."
                ]
            }
        ],
        "Normal": [
            "Cache existence of some callbacks ",
            "Name ",
            "Groups ",
            "Visual definition ",
            "Meshnode model filename ",
            "tiles = {}",
            "overlay_tiles = {}",
            "special_tiles = {}",
            "alpha & use_texture_alpha ",
            "This is a bit complicated due to compatibility",
            "Other stuff ",
            "True for all ground-like things like stone and mud, false for eg. trees",
            "This is used for collision detection.",
            "Also for general solidness queries.",
            "Player can point to these, point through or it is blocking",
            "Player can dig these",
            "Player can climb these",
            "Player can build on these",
            "Liquids flow into and replace node",
            "Whether the node is non-liquid, source liquid or flowing liquid",
            "If the content is liquid, this is the flowing version of the liquid.",
            "If the content is liquid, this is the source version of the liquid.",
            "Viscosity for fluid flow, ranging from 1 to 7, with",
            "1 giving almost instantaneous propagation and 7 being",
            "the slowest possible",
            "If move_resistance is not set explicitly,",
            "move_resistance is equal to liquid_viscosity",
            "Amount of light the node emits",
            "Set to true if paramtype used to be 'facedir_simple'",
            "Set to true if wall_mounted used to be set to true",
            "Sound table",
            "Node immediately placed by client when node is dug",
            "How much the node slows down players, ranging from 1 to 7,",
            "the higher, the slower.",
            "Whether e.g. players in this node will have liquid movement physics"
        ],
        "FuncName": "c_content_5302 read_content_features.txt"
    },
    {
        "Branch": [
            "Check if condition is met in game logic"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Truncate provided list of items in game environment"
                ]
            }
        ],
        "Normal": [
            "Delete list if it's nil in game context",
            "Retrieve and insert Lua-specified items into the list in game",
            "Create or resize/clear list in game environment"
        ],
        "FuncName": "c_content_5302 read_inventory_list.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    " key at index -2 and value at index -1 within table_values in a game context, where players must navigate through a table of values and retrieve specific keys and values.",
                    " removes value, keeps key for next iteration, allowing players to progress through the game by making decisions based on the remaining keys and values."
                ]
            }
        ],
        "Normal": [
            " color stops table is on the stack, representing a collection of colors in a game where players must stop at specific points to collect rewards.",
            " pop color stops table, allowing players to move on to the next level or challenge in the game."
        ],
        "FuncName": "c_content_5302 read_wear_bar_params.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Create groupcap table for the game",
                    "Create subtable for the game",
                    "Set subtable for the game",
                    "Set simple parameters for the game",
                    "Insert groupcap table into groupcaps table for the game"
                ]
            },
            {
                "loopstr": [
                    "Create damage group table for the game"
                ]
            }
        ],
        "Normal": [
            "Create groupcaps table for the game",
            "For each groupcap in the game",
            "Set groupcaps table for the game",
            "Create damage_groups table for the game",
            "For each damage group in the game"
        ],
        "FuncName": "c_content_5302 push_tool_capabilities.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Functional overlap: this may modify SimpleSoundSpec contents",
                    "Handle positional information",
                    "Server-side sound parameter reading for the game"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "c_content_5302 read_server_sound_params.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Reading item stack from Lua table: converting to game item format"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Converting item string to game item format"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Reading item stack from Lua table: converting to game item format",
                    "BACKWARDS COMPATIBILITY: reading item meta",
                    "Retrieving item meta data"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Iterating over table keys and values: key at index -2, value at index -1",
                    "Removing value, keeping key for next iteration"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "c_content_5302 read_item.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "This will be created",
                    "Read simple parameters",
                    "DEPRECATED: maxwear",
                    "Read \u00d7 table",
                    "Insert groupcap into toolcap",
                    "In game development, this is related to conditional statements, where the 'then' branch is executed when the condition is true."
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "key at index -2 and value at index -1",
                    "removes value, keeps key for next iteration",
                    "In game development, this is related to loops, where the loop iterates over a collection of items, and the 'key' and 'value' are accessed at specific indices."
                ]
            },
            {
                "loopstr": [
                    "key at index -2 and value at index -1",
                    "removes value, keeps key for next iteration",
                    "In game development, this is related to loops, where the loop iterates over a collection of items, and the 'key' and 'value' are accessed at specific indices."
                ]
            },
            {
                "loopstr": [
                    "key at index -2 and value at index -1",
                    "removes value, keeps key for next iteration",
                    "In game development, this is related to loops, where the loop iterates over a collection of items, and the 'key' and 'value' are accessed at specific indices."
                ]
            }
        ],
        "Normal": [],
        "FuncName": "c_content_5302 read_tool_capabilities.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "Lua Point Ability: Key at index -2 and value at index -1, Game-related: Handle groups, Effect: Removes value, keeps key for next iteration"
                ]
            },
            {
                "loopstr": [
                    "Lua Point Ability: Key at index -2 and value at index -1, Game-related: Handle groups, Effect: Removes value, keeps key for next iteration"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "c_content_5302 read_pointabilities.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Vertical frames animation with 16x16 aspect ratio and 2.0 seconds duration for type vertical_frames."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "2D sheet animation with 5 frames wide and 3 frames high, each frame lasting 0.5 seconds for type sheet_2d."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "c_content_5302 read_animation_definition.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " use faster Lua helper if possible for game collisions",
            "game collision detection",
            "game collisions"
        ],
        "FuncName": "c_content_5302 push_collision_move_result.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Resolves the node IDs for trunk, leaves, leaves2 and fruit at runtime, when tree_def.resolveNodeNames will be called. In the context of the game, this means that the tree's node IDs will be determined dynamically, allowing for a more realistic and interactive tree simulation."
        ],
        "FuncName": "c_content_5302 read_tree_def.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "In Lua, we use if-conditions to control the flow of the game. In this case, the condition is evaluated to determine the next course of action. The key is at index -2 and the value is at index -1."
                ]
            }
        ],
        "Normal": [
            "In Lua, we can use pop to remove the top element from the stack. This is a common operation in game development."
        ],
        "FuncName": "c_content_5302 read_json_value.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get lua entity from table",
            "Remove lua entities",
            "Remove core"
        ],
        "FuncName": "c_content_5302 luaentity_get.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the game, waypoints reuse the item field to store precision.",
                    "For item, precision + 1 equals item equals 0, which means precision equals 10 for backwards compatibility.",
                    "See Hud::drawLuaElements, case HUD_ELEM_WAYPOINT, which is a game-specific feature."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game, push the item field for waypoints as well for backwards compatibility.",
            "This feature is deprecated, only kept for compatibility's sake, and is not used in the game."
        ],
        "FuncName": "c_content_5302 push_hud_element.txt"
    },
    {
        "Branch": [],
        "Loop": [
            {
                "loopstr": [
                    "key at index -2 and value at index -1 of Item Group in Lua table",
                    "zero rating indicates not in the Item Group",
                    "removes value, keeps key for next iteration in Item Group loop"
                ]
            }
        ],
        "Normal": [],
        "FuncName": "c_content_5302 read_groups.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "convert to node coords",
                    "change to Lua array index",
                    "apply game logic for if condition"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "c_content_5302 push_pointed_thing.txt"
    },
    {
        "Branch": [
            "In the game, if-condition is used to control the flow of the game.",
            "The if-condition is a conditional statement that checks a condition and executes a block of code if the condition is true."
        ],
        "Loop": [
            "In the game, loop-condition is used to repeat a block of code multiple times.",
            "The loop-condition is a loop statement that executes a block of code repeatedly until a certain condition is met."
        ],
        "Normal": [
            " The maximum number of Lua stack slots used at each recursion level",
            " of push_json_value_helper is 2, so make sure there a depth * 2 slots"
        ],
        "FuncName": "c_content_5302 push_json_value.txt"
    },
    {
        "Branch": [
            "Pushing object reference onto the Lua stack for if condition evaluation",
            "Evaluating object reference for if condition"
        ],
        "Loop": [
            "Pushing object reference onto the Lua stack for loop condition evaluation",
            "Evaluating object reference for loop condition"
        ],
        "Normal": [
            "Retrieving core object reference at index i from the Lua stack",
            "Accessing object reference from core",
            "Core object reference"
        ],
        "FuncName": "c_content_5302 push_objectRef.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the context of the game, waypoints reuse the item field to store precision, which is equivalent to saying precision = 10 for backwards compatibility.",
                    "item = precision + 1 and item = 0 <=> precision = 10 for backwards compatibility."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "In the game, handle deprecated hud_elem_type to ensure compatibility.",
            "Deprecated, only for compatibility's sake.",
            "In the game, check for known deprecated element usage to maintain compatibility."
        ],
        "FuncName": "c_content_5302 read_hud_element.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Force shadowing mode if graphics subsystem does not exist. In game, this is crucial for optimizing performance."
        ],
        "FuncName": "IndexBuffer_451 IndexBuffer.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In the game, if no graphics subsystem can be disabled, shadowing is enabled."
        ],
        "FuncName": "IndexBuffer_451 SetShadowed.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Walk direction by default in legacy games, where character movement is often used for navigation.",
            "A 3G acceleration is a common value used in games to simulate the force of gravity on characters.",
            "The terminal velocity of a skydiver is the maximum speed reached during free fall, typically around 120-140 meters per second.",
            "?"
        ],
        "FuncName": "btKinematicCharacterController_548 btKinematicCharacterController.txt"
    },
    {
        "Branch": [
            "Conditional statement in game logic: If-Condition-Str",
            "Game logic branch: If-Condition-Str"
        ],
        "Loop": [
            {
                "loopstr": [
                    "Game loop iteration: Override existing element if necessary",
                    "Loop condition in game logic: Override existing element if necessary"
                ]
            }
        ],
        "Normal": [
            "Default game logic statement: Normal-Str",
            "Game logic statement: Normal-Str"
        ],
        "FuncName": "D3D11VertexDeclaration_4037 VertexDeclaration.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "In VxWorks 5.x, pthread_mutex_init() initialization issues can cause a freeze in pthread_mutex_destroy() if the mutex has never been used.",
            "This workaround is for VxWorks 5.x where pthread_mutex_init() won't properly initialize the mutex, resulting in a subsequent freeze in pthread_mutex_destroy() if the mutex has never been used.",
            "VxWorks 5.x pthread_mutex_init() initialization problems can lead to a subsequent freeze in pthread_mutex_destroy() if the mutex has never been used.",
            "In VxWorks 5.x, pthread_mutex_destroy() can freeze if the mutex has never been used due to pthread_mutex_init() initialization issues."
        ],
        "FuncName": "Mutex_POSIX_156 MutexImpl.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Collide with slopes to avoid problems, but only if the distance is within the maximum penetration.",
                    "if (distance > maximum penetration)",
                    "{",
                    "\tmaximum penetration = distance;",
                    "\tnormal vector = point normal in world space * direction sign;",
                    "}"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Clear the manifold to prepare for the next iteration."
                ]
            }
        ],
        "Normal": [
            "In the context of a collision recovery in a game, we need to refresh the overlapping pair cache.",
            "This is because the penetrating movement or the previous recovery iteration might have used setWorldTransform",
            "and pushed us into an object that is not in the previous cache contents from the last timestep.",
            "If not handled, the next convex sweep will get stuck.",
            "",
            "To fix this, we call the broadphase's setAabb with the moved AABB, which updates the broadphase pair cache",
            "and the ghost object's internal pair cache simultaneously.",
            "\tmaximum penetration = 0.0;",
            "\tprint normal vector = %f, %f, %f\n, normal vector[0], normal vector[1], normal vector[2];"
        ],
        "FuncName": "btKinematicCharacterController_548 recoverFromPenetration.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "We moved only a fraction of the distance, calculating the hit point and interpolating the character's position.",
                    "The hit distance is calculated using the callback's hit point and the character's current position.",
                    "The character's position is updated to be a fraction of the way to the target position."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In Quake 2, if the velocity is opposite to the original velocity, the character stops to avoid oscillations in sloping corners."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Printing the normalized direction vector: x = %f, y = %f, z = %f",
            "Phase 2: moving forward and strafing.",
            "Printing the distance to the target: %f"
        ],
        "FuncName": "btKinematicCharacterController_548 stepForwardAndStrafe.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "In the game, characters can move up a step in the physical world, handling collisions and penetration. This is used in the game code for characters.",
                    "Only modify the position if the hit was a slope and not a wall or ceiling, which is crucial in game physics.",
                    "Fix penetration if we hit a ceiling for example, ensuring a smooth gameplay experience."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the game, characters may only move up a fraction of the step height, which can happen due to game physics limitations.",
                    "This is a common issue in game development, where characters may not move up a full step due to various factors."
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "In the game, if a character gets stuck in penetration, it can cause issues like this: printf(character could not recover from penetration = %d\n,numPenetrationLoops);",
                    "This error message indicates that the character has penetrated through an object and cannot recover, which is a bug that needs to be fixed."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "Phase 1: up, where characters move up a step in the game world.",
            "FIXME: Handle penetration properly in the game, as it can cause issues like characters getting stuck."
        ],
        "FuncName": "btKinematicCharacterController_548 stepUp.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "This function blends colors at a specified pixel coordinate on the target image in the context of game development.",
            "In game programming, this operation performs clipping."
        ],
        "FuncName": "SDL_blendpoint_1363 SDL_BlendPoint.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "there is a component in walkdirection for vertical velocity",
                    "this is a typical scenario in a platformer game where the player can jump"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [
            "if we are moving in the direction of the up, treat it as a jump",
            "this is a common mechanic in many games, such as Super Mario Bros."
        ],
        "FuncName": "btKinematicCharacterController_548 setLinearVelocity.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "set virtual object's up vector to new orientation"
        ],
        "FuncName": "btKinematicCharacterController_548 setUpVector.txt"
    },
    {
        "Branch": [
            "Check if the player's health is above 50% and the enemy's health is below 25%."
        ],
        "Loop": [
            "Repeat the action until the player's health is below 20% or the enemy's health is above 75%."
        ],
        "Normal": [
            "clear pair cache",
            "Reset the game world to its initial state, removing any obstacles or power-ups."
        ],
        "FuncName": "btKinematicCharacterController_548 reset.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "printf(m_targetPosition=%f,%f,%f\n,m_targetPosition[0],m_targetPosition[1],m_targetPosition[2]); Update character position and orientation in the physical world."
        ],
        "FuncName": "btKinematicCharacterController_548 preStep.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " Note: we could hard-code the level_costs_ corresponding to VP8CoeffsProba0, which is a probability table used in VP8 video encoding. However, that's ~11k of static data. Better call VP8CalculateLevelCosts() later to dynamically calculate the level costs for VP8 encoding."
        ],
        "FuncName": "tree_enc_701 VP8DefaultProbas.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "Calculating double fall height to determine if character should interpolate full or partial fall in game physics"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Determining double fall height to see if character should interpolate large or small fall in game physics"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Recalculating velocity when falling a small amount for fast stairs motion in game physics, using smoother interpolated movement for larger falls",
                    "Re-running previous tests to ensure accurate physics calculations"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Character dropped a fraction of the height and hit the floor in game physics",
                    "Printing hit point and position callback to debug game physics"
                ],
                "elsestr": []
            },
            {
                "thenstr": [
                    "Undoing previous target change in game physics"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            {
                "loopstr": [
                    "Performing double test for 2x the step drop to check for large drop vs small drop in game physics"
                ]
            }
        ],
        "Normal": [
            "Phase 3 down movement in game physics: calculating additional down step and step drop, updating target position and velocity"
        ],
        "FuncName": "btKinematicCharacterController_548 stepDown.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            " This function draws multiple points on a Surface with a specified color and blending mode ",
            " FIXME: Does this function pointer slow down the game significantly "
        ],
        "FuncName": "SDL_blendpoint_1363 SDL_BlendPoints.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "printf(setVelocity!);",
            "printf(interval: %f, timeInterval for Physics Animation);",
            "printf(velocity: (%f, %f, %f), velocity in 3D Space for Physics Animation);",
            "printf(velocity: (%f, %f, %f), velocity.x(), velocity.y(), velocity.z() for Physics Animation);"
        ],
        "FuncName": "btKinematicCharacterController_548 setVelocityForTimeInterval.txt"
    },
    {
        "Branch": [
            "Initializes file system for if-conditions in the game."
        ],
        "Loop": [
            "Initializes file system for loop conditions in the game."
        ],
        "Normal": [
            "Subscribe to console commands for normal game operations."
        ],
        "FuncName": "FileSystem_5333 FileSystem.txt"
    },
    {
        "Branch": [
            "Check the condition for the if statement in the game logic"
        ],
        "Loop": [
            "Define the condition for the loop in the game iteration"
        ],
        "Normal": [
            "Create each of the parents if necessary in the game world"
        ],
        "FuncName": "FileSystem_5333 CreateDir.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "Get a platform-agnostic temporary file name for stderr redirection in the game context",
            "Use popen/pclose to capture the stdout and stderr of the command, which is essential for game debugging",
            "Capture the standard output stream to display game logs and messages",
            "Capture the standard error stream to handle game errors and exceptions"
        ],
        "FuncName": "FileSystem_5333 DoSystemCommand.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "TM or HE in VP8 encoding mode"
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tree_enc_701 PutI16Mode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "else: TM_PRED. In the context of VP8 compression, TM_PRED is a prediction mode that uses a linear interpolation of the top and left pixels to predict the current pixel value."
                ],
                "elsestr": []
            }
        ],
        "Loop": [],
        "Normal": [],
        "FuncName": "tree_enc_701 PutUVMode.txt"
    },
    {
        "Branch": [
            {
                "thenstr": [
                    "i16x16VP8\u7f16\u7801\u5355\u5143\u5185\u6a21\u5f0f"
                ],
                "elsestr": []
            }
        ],
        "Loop": [
            "VP8\u7f16\u7801\u5355\u5143\u5185\u6a21\u5f0f\u5faa\u73af\u6761\u4ef6"
        ],
        "Normal": [
            "VP8\u7f16\u7801\u5355\u5143\u5185\u6a21\u5f0f\u6b63\u5e38\u5b57\u7b26\u4e32"
        ],
        "FuncName": "tree_enc_701 VP8CodeIntraModes.txt"
    },
    {
        "Branch": [],
        "Loop": [],
        "Normal": [
            "To access file system, ensure directories are properly configured",
            "Parent directory access is restricted for security",
            "Verify if the path matches any allowed directory",
            "Access denied, directory not found"
        ],
        "FuncName": "FileSystem_5333 CheckAccess.txt"
    }
]